
(function(l, r) { if (l.getElementById('livereloadscript')) return; r = l.createElement('script'); r.async = 1; r.src = '//' + (window.location.host || 'localhost').split(':')[0] + ':35729/livereload.js?snipver=1'; r.id = 'livereloadscript'; l.getElementsByTagName('head')[0].appendChild(r) })(window.document);
var app = (function () {
  'use strict';

  /**
   * Template7 1.4.2
   * Mobile-first HTML template engine
   * 
   * http://www.idangero.us/template7/
   * 
   * Copyright 2019, Vladimir Kharlampidi
   * The iDangero.us
   * http://www.idangero.us/
   * 
   * Licensed under MIT
   * 
   * Released on: June 14, 2019
   */

  let t7ctx;
  if (typeof window !== 'undefined') {
    t7ctx = window;
  } else if (typeof global !== 'undefined') {
    t7ctx = global;
  } else {
    t7ctx = undefined;
  }

  const Template7Context = t7ctx;

  const Template7Utils = {
    quoteSingleRexExp: new RegExp('\'', 'g'),
    quoteDoubleRexExp: new RegExp('"', 'g'),
    isFunction(func) {
      return typeof func === 'function';
    },
    escape(string = '') {
      return string
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    },
    helperToSlices(string) {
      const { quoteDoubleRexExp, quoteSingleRexExp } = Template7Utils;
      const helperParts = string.replace(/[{}#}]/g, '').trim().split(' ');
      const slices = [];
      let shiftIndex;
      let i;
      let j;
      for (i = 0; i < helperParts.length; i += 1) {
        let part = helperParts[i];
        let blockQuoteRegExp;
        let openingQuote;
        if (i === 0) slices.push(part);
        else if (part.indexOf('"') === 0 || part.indexOf('\'') === 0) {
          blockQuoteRegExp = part.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
          openingQuote = part.indexOf('"') === 0 ? '"' : '\'';
          // Plain String
          if (part.match(blockQuoteRegExp).length === 2) {
            // One word string
            slices.push(part);
          } else {
            // Find closed Index
            shiftIndex = 0;
            for (j = i + 1; j < helperParts.length; j += 1) {
              part += ` ${helperParts[j]}`;
              if (helperParts[j].indexOf(openingQuote) >= 0) {
                shiftIndex = j;
                slices.push(part);
                break;
              }
            }
            if (shiftIndex) i = shiftIndex;
          }
        } else if (part.indexOf('=') > 0) {
          // Hash
          const hashParts = part.split('=');
          const hashName = hashParts[0];
          let hashContent = hashParts[1];
          if (!blockQuoteRegExp) {
            blockQuoteRegExp = hashContent.indexOf('"') === 0 ? quoteDoubleRexExp : quoteSingleRexExp;
            openingQuote = hashContent.indexOf('"') === 0 ? '"' : '\'';
          }
          if (hashContent.match(blockQuoteRegExp).length !== 2) {
            shiftIndex = 0;
            for (j = i + 1; j < helperParts.length; j += 1) {
              hashContent += ` ${helperParts[j]}`;
              if (helperParts[j].indexOf(openingQuote) >= 0) {
                shiftIndex = j;
                break;
              }
            }
            if (shiftIndex) i = shiftIndex;
          }
          const hash = [hashName, hashContent.replace(blockQuoteRegExp, '')];
          slices.push(hash);
        } else {
          // Plain variable
          slices.push(part);
        }
      }
      return slices;
    },
    stringToBlocks(string) {
      const blocks = [];
      let i;
      let j;
      if (!string) return [];
      const stringBlocks = string.split(/({{[^{^}]*}})/);
      for (i = 0; i < stringBlocks.length; i += 1) {
        let block = stringBlocks[i];
        if (block === '') continue;
        if (block.indexOf('{{') < 0) {
          blocks.push({
            type: 'plain',
            content: block,
          });
        } else {
          if (block.indexOf('{/') >= 0) {
            continue;
          }
          block = block
            .replace(/{{([#/])*([ ])*/, '{{$1')
            .replace(/([ ])*}}/, '}}');
          if (block.indexOf('{#') < 0 && block.indexOf(' ') < 0 && block.indexOf('else') < 0) {
            // Simple variable
            blocks.push({
              type: 'variable',
              contextName: block.replace(/[{}]/g, ''),
            });
            continue;
          }
          // Helpers
          const helperSlices = Template7Utils.helperToSlices(block);
          let helperName = helperSlices[0];
          const isPartial = helperName === '>';
          const helperContext = [];
          const helperHash = {};
          for (j = 1; j < helperSlices.length; j += 1) {
            const slice = helperSlices[j];
            if (Array.isArray(slice)) {
              // Hash
              helperHash[slice[0]] = slice[1] === 'false' ? false : slice[1];
            } else {
              helperContext.push(slice);
            }
          }

          if (block.indexOf('{#') >= 0) {
            // Condition/Helper
            let helperContent = '';
            let elseContent = '';
            let toSkip = 0;
            let shiftIndex;
            let foundClosed = false;
            let foundElse = false;
            let depth = 0;
            for (j = i + 1; j < stringBlocks.length; j += 1) {
              if (stringBlocks[j].indexOf('{{#') >= 0) {
                depth += 1;
              }
              if (stringBlocks[j].indexOf('{{/') >= 0) {
                depth -= 1;
              }
              if (stringBlocks[j].indexOf(`{{#${helperName}`) >= 0) {
                helperContent += stringBlocks[j];
                if (foundElse) elseContent += stringBlocks[j];
                toSkip += 1;
              } else if (stringBlocks[j].indexOf(`{{/${helperName}`) >= 0) {
                if (toSkip > 0) {
                  toSkip -= 1;
                  helperContent += stringBlocks[j];
                  if (foundElse) elseContent += stringBlocks[j];
                } else {
                  shiftIndex = j;
                  foundClosed = true;
                  break;
                }
              } else if (stringBlocks[j].indexOf('else') >= 0 && depth === 0) {
                foundElse = true;
              } else {
                if (!foundElse) helperContent += stringBlocks[j];
                if (foundElse) elseContent += stringBlocks[j];
              }
            }
            if (foundClosed) {
              if (shiftIndex) i = shiftIndex;
              if (helperName === 'raw') {
                blocks.push({
                  type: 'plain',
                  content: helperContent,
                });
              } else {
                blocks.push({
                  type: 'helper',
                  helperName,
                  contextName: helperContext,
                  content: helperContent,
                  inverseContent: elseContent,
                  hash: helperHash,
                });
              }
            }
          } else if (block.indexOf(' ') > 0) {
            if (isPartial) {
              helperName = '_partial';
              if (helperContext[0]) {
                if (helperContext[0].indexOf('[') === 0) helperContext[0] = helperContext[0].replace(/[[\]]/g, '');
                else helperContext[0] = `"${helperContext[0].replace(/"|'/g, '')}"`;
              }
            }
            blocks.push({
              type: 'helper',
              helperName,
              contextName: helperContext,
              hash: helperHash,
            });
          }
        }
      }
      return blocks;
    },
    parseJsVariable(expression, replace, object) {
      return expression.split(/([+ \-*/^()&=|<>!%:?])/g).reduce((arr, part) => {
        if (!part) {
          return arr;
        }
        if (part.indexOf(replace) < 0) {
          arr.push(part);
          return arr;
        }
        if (!object) {
          arr.push(JSON.stringify(''));
          return arr;
        }

        let variable = object;
        if (part.indexOf(`${replace}.`) >= 0) {
          part.split(`${replace}.`)[1].split('.').forEach((partName) => {
            if (partName in variable) variable = variable[partName];
            else variable = undefined;
          });
        }
        if (
          (typeof variable === 'string')
          || Array.isArray(variable)
          || (variable.constructor && variable.constructor === Object)
        ) {
          variable = JSON.stringify(variable);
        }
        if (variable === undefined) variable = 'undefined';

        arr.push(variable);
        return arr;
      }, []).join('');

    },
    parseJsParents(expression, parents) {
      return expression.split(/([+ \-*^()&=|<>!%:?])/g).reduce((arr, part) => {
        if (!part) {
          return arr;
        }

        if (part.indexOf('../') < 0) {
          arr.push(part);
          return arr;
        }

        if (!parents || parents.length === 0) {
          arr.push(JSON.stringify(''));
          return arr;
        }

        const levelsUp = part.split('../').length - 1;
        const parentData = levelsUp > parents.length ? parents[parents.length - 1] : parents[levelsUp - 1];

        let variable = parentData;
        const parentPart = part.replace(/..\//g, '');
        parentPart.split('.').forEach((partName) => {
          if (typeof variable[partName] !== 'undefined') variable = variable[partName];
          else variable = 'undefined';
        });
        if (variable === false || variable === true) {
          arr.push(JSON.stringify(variable));
          return arr;
        }
        if (variable === null || variable === 'undefined') {
          arr.push(JSON.stringify(''));
          return arr;
        }
        arr.push(JSON.stringify(variable));
        return arr;
      }, []).join('');
    },
    getCompileVar(name, ctx, data = 'data_1') {
      let variable = ctx;
      let parts;
      let levelsUp = 0;
      let newDepth;
      if (name.indexOf('../') === 0) {
        levelsUp = name.split('../').length - 1;
        newDepth = variable.split('_')[1] - levelsUp;
        variable = `ctx_${newDepth >= 1 ? newDepth : 1}`;
        parts = name.split('../')[levelsUp].split('.');
      } else if (name.indexOf('@global') === 0) {
        variable = 'Template7.global';
        parts = name.split('@global.')[1].split('.');
      } else if (name.indexOf('@root') === 0) {
        variable = 'root';
        parts = name.split('@root.')[1].split('.');
      } else {
        parts = name.split('.');
      }
      for (let i = 0; i < parts.length; i += 1) {
        const part = parts[i];
        if (part.indexOf('@') === 0) {
          let dataLevel = data.split('_')[1];
          if (levelsUp > 0) {
            dataLevel = newDepth;
          }
          if (i > 0) {
            variable += `[(data_${dataLevel} && data_${dataLevel}.${part.replace('@', '')})]`;
          } else {
            variable = `(data_${dataLevel} && data_${dataLevel}.${part.replace('@', '')})`;
          }
        } else if (Number.isFinite ? Number.isFinite(part) : Template7Context.isFinite(part)) {
          variable += `[${part}]`;
        } else if (part === 'this' || part.indexOf('this.') >= 0 || part.indexOf('this[') >= 0 || part.indexOf('this(') >= 0) {
          variable = part.replace('this', ctx);
        } else {
          variable += `.${part}`;
        }
      }
      return variable;
    },
    getCompiledArguments(contextArray, ctx, data) {
      const arr = [];
      for (let i = 0; i < contextArray.length; i += 1) {
        if (/^['"]/.test(contextArray[i])) arr.push(contextArray[i]);
        else if (/^(true|false|\d+)$/.test(contextArray[i])) arr.push(contextArray[i]);
        else {
          arr.push(Template7Utils.getCompileVar(contextArray[i], ctx, data));
        }
      }

      return arr.join(', ');
    },
  };

  /* eslint no-eval: "off" */

  const Template7Helpers = {
    _partial(partialName, options) {
      const ctx = this;
      const p = Template7Class.partials[partialName];
      if (!p || (p && !p.template)) return '';
      if (!p.compiled) {
        p.compiled = new Template7Class(p.template).compile();
      }
      Object.keys(options.hash).forEach((hashName) => {
        ctx[hashName] = options.hash[hashName];
      });
      return p.compiled(ctx, options.data, options.root);
    },
    escape(context) {
      if (typeof context === 'undefined' || context === null) return '';
      if (typeof context !== 'string') {
        throw new Error('Template7: Passed context to "escape" helper should be a string');
      }
      return Template7Utils.escape(context);
    },
    if(context, options) {
      let ctx = context;
      if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
      if (ctx) {
        return options.fn(this, options.data);
      }

      return options.inverse(this, options.data);
    },
    unless(context, options) {
      let ctx = context;
      if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
      if (!ctx) {
        return options.fn(this, options.data);
      }

      return options.inverse(this, options.data);
    },
    each(context, options) {
      let ctx = context;
      let ret = '';
      let i = 0;
      if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
      if (Array.isArray(ctx)) {
        if (options.hash.reverse) {
          ctx = ctx.reverse();
        }
        for (i = 0; i < ctx.length; i += 1) {
          ret += options.fn(ctx[i], { first: i === 0, last: i === ctx.length - 1, index: i });
        }
        if (options.hash.reverse) {
          ctx = ctx.reverse();
        }
      } else {
        // eslint-disable-next-line
        for (const key in ctx) {
          i += 1;
          ret += options.fn(ctx[key], { key });
        }
      }
      if (i > 0) return ret;
      return options.inverse(this);
    },
    with(context, options) {
      let ctx = context;
      if (Template7Utils.isFunction(ctx)) { ctx = context.call(this); }
      return options.fn(ctx);
    },
    join(context, options) {
      let ctx = context;
      if (Template7Utils.isFunction(ctx)) { ctx = ctx.call(this); }
      return ctx.join(options.hash.delimiter || options.hash.delimeter);
    },
    js(expression, options) {
      const data = options.data;
      let func;
      let execute = expression;
      ('index first last key').split(' ').forEach((prop) => {
        if (typeof data[prop] !== 'undefined') {
          const re1 = new RegExp(`this.@${prop}`, 'g');
          const re2 = new RegExp(`@${prop}`, 'g');
          execute = execute
            .replace(re1, JSON.stringify(data[prop]))
            .replace(re2, JSON.stringify(data[prop]));
        }
      });
      if (options.root && execute.indexOf('@root') >= 0) {
        execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
      }
      if (execute.indexOf('@global') >= 0) {
        execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
      }
      if (execute.indexOf('../') >= 0) {
        execute = Template7Utils.parseJsParents(execute, options.parents);
      }
      if (execute.indexOf('return') >= 0) {
        func = `(function(){${execute}})`;
      } else {
        func = `(function(){return (${execute})})`;
      }
      return eval(func).call(this);
    },
    js_if(expression, options) {
      const data = options.data;
      let func;
      let execute = expression;
      ('index first last key').split(' ').forEach((prop) => {
        if (typeof data[prop] !== 'undefined') {
          const re1 = new RegExp(`this.@${prop}`, 'g');
          const re2 = new RegExp(`@${prop}`, 'g');
          execute = execute
            .replace(re1, JSON.stringify(data[prop]))
            .replace(re2, JSON.stringify(data[prop]));
        }
      });
      if (options.root && execute.indexOf('@root') >= 0) {
        execute = Template7Utils.parseJsVariable(execute, '@root', options.root);
      }
      if (execute.indexOf('@global') >= 0) {
        execute = Template7Utils.parseJsVariable(execute, '@global', Template7Context.Template7.global);
      }
      if (execute.indexOf('../') >= 0) {
        execute = Template7Utils.parseJsParents(execute, options.parents);
      }
      if (execute.indexOf('return') >= 0) {
        func = `(function(){${execute}})`;
      } else {
        func = `(function(){return (${execute})})`;
      }
      const condition = eval(func).call(this);
      if (condition) {
        return options.fn(this, options.data);
      }

      return options.inverse(this, options.data);
    },
  };
  Template7Helpers.js_compare = Template7Helpers.js_if;

  const Template7Options = {};
  const Template7Partials = {};

  class Template7Class {
    constructor(template) {
      const t = this;
      t.template = template;
    }
    compile(template = this.template, depth = 1) {
      const t = this;
      if (t.compiled) return t.compiled;

      if (typeof template !== 'string') {
        throw new Error('Template7: Template must be a string');
      }
      const { stringToBlocks, getCompileVar, getCompiledArguments } = Template7Utils;

      const blocks = stringToBlocks(template);
      const ctx = `ctx_${depth}`;
      const data = `data_${depth}`;
      if (blocks.length === 0) {
        return function empty() { return ''; };
      }

      function getCompileFn(block, newDepth) {
        if (block.content) return t.compile(block.content, newDepth);
        return function empty() { return ''; };
      }
      function getCompileInverse(block, newDepth) {
        if (block.inverseContent) return t.compile(block.inverseContent, newDepth);
        return function empty() { return ''; };
      }

      let resultString = '';
      if (depth === 1) {
        resultString += `(function (${ctx}, ${data}, root) {\n`;
      } else {
        resultString += `(function (${ctx}, ${data}) {\n`;
      }
      if (depth === 1) {
        resultString += 'function isArray(arr){return Array.isArray(arr);}\n';
        resultString += 'function isFunction(func){return (typeof func === \'function\');}\n';
        resultString += 'function c(val, ctx) {if (typeof val !== "undefined" && val !== null) {if (isFunction(val)) {return val.call(ctx);} else return val;} else return "";}\n';
        resultString += 'root = root || ctx_1 || {};\n';
      }
      resultString += 'var r = \'\';\n';
      let i;
      for (i = 0; i < blocks.length; i += 1) {
        const block = blocks[i];
        // Plain block
        if (block.type === 'plain') {
          // eslint-disable-next-line
          resultString += `r +='${(block.content).replace(/\r/g, '\\r').replace(/\n/g, '\\n').replace(/'/g, '\\' + '\'')}';`;
          continue;
        }
        let variable;
        let compiledArguments;
        // Variable block
        if (block.type === 'variable') {
          variable = getCompileVar(block.contextName, ctx, data);
          resultString += `r += c(${variable}, ${ctx});`;
        }
        // Helpers block
        if (block.type === 'helper') {
          let parents;
          if (ctx !== 'ctx_1') {
            const level = ctx.split('_')[1];
            let parentsString = `ctx_${level - 1}`;
            for (let j = level - 2; j >= 1; j -= 1) {
              parentsString += `, ctx_${j}`;
            }
            parents = `[${parentsString}]`;
          } else {
            parents = `[${ctx}]`;
          }
          let dynamicHelper;
          if (block.helperName.indexOf('[') === 0) {
            block.helperName = getCompileVar(block.helperName.replace(/[[\]]/g, ''), ctx, data);
            dynamicHelper = true;
          }
          if (dynamicHelper || block.helperName in Template7Helpers) {
            compiledArguments = getCompiledArguments(block.contextName, ctx, data);
            resultString += `r += (Template7Helpers${dynamicHelper ? `[${block.helperName}]` : `.${block.helperName}`}).call(${ctx}, ${compiledArguments && (`${compiledArguments}, `)}{hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
          } else if (block.contextName.length > 0) {
            throw new Error(`Template7: Missing helper: "${block.helperName}"`);
          } else {
            variable = getCompileVar(block.helperName, ctx, data);
            resultString += `if (${variable}) {`;
            resultString += `if (isArray(${variable})) {`;
            resultString += `r += (Template7Helpers.each).call(${ctx}, ${variable}, {hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
            resultString += '}else {';
            resultString += `r += (Template7Helpers.with).call(${ctx}, ${variable}, {hash:${JSON.stringify(block.hash)}, data: ${data} || {}, fn: ${getCompileFn(block, depth + 1)}, inverse: ${getCompileInverse(block, depth + 1)}, root: root, parents: ${parents}});`;
            resultString += '}}';
          }
        }
      }
      resultString += '\nreturn r;})';

      if (depth === 1) {
        // eslint-disable-next-line
        t.compiled = eval(resultString);
        return t.compiled;
      }
      return resultString;
    }
    static get options() {
      return Template7Options;
    }
    static get partials() {
      return Template7Partials;
    }
    static get helpers() {
      return Template7Helpers;
    }
  }

  function Template7(...args) {
    const [template, data] = args;
    if (args.length === 2) {
      let instance = new Template7Class(template);
      const rendered = instance.compile()(data);
      instance = null;
      return (rendered);
    }
    return new Template7Class(template);
  }
  Template7.registerHelper = function registerHelper(name, fn) {
    Template7Class.helpers[name] = fn;
  };
  Template7.unregisterHelper = function unregisterHelper(name) {
    Template7Class.helpers[name] = undefined;
    delete Template7Class.helpers[name];
  };
  Template7.registerPartial = function registerPartial(name, template) {
    Template7Class.partials[name] = { template };
  };
  Template7.unregisterPartial = function unregisterPartial(name) {
    if (Template7Class.partials[name]) {
      Template7Class.partials[name] = undefined;
      delete Template7Class.partials[name];
    }
  };
  Template7.compile = function compile(template, options) {
    const instance = new Template7Class(template, options);
    return instance.compile();
  };

  Template7.options = Template7Class.options;
  Template7.helpers = Template7Class.helpers;
  Template7.partials = Template7Class.partials;

  /**
   * SSR Window 1.0.1
   * Better handling for window object in SSR environment
   * https://github.com/nolimits4web/ssr-window
   *
   * Copyright 2018, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: July 18, 2018
   */
  var doc = (typeof document === 'undefined') ? {
    body: {},
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    activeElement: {
      blur: function blur() {},
      nodeName: '',
    },
    querySelector: function querySelector() {
      return null;
    },
    querySelectorAll: function querySelectorAll() {
      return [];
    },
    getElementById: function getElementById() {
      return null;
    },
    createEvent: function createEvent() {
      return {
        initEvent: function initEvent() {},
      };
    },
    createElement: function createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute: function setAttribute() {},
        getElementsByTagName: function getElementsByTagName() {
          return [];
        },
      };
    },
    location: { hash: '' },
  } : document; // eslint-disable-line

  var win = (typeof window === 'undefined') ? {
    document: doc,
    navigator: {
      userAgent: '',
    },
    location: {},
    history: {},
    CustomEvent: function CustomEvent() {
      return this;
    },
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    getComputedStyle: function getComputedStyle() {
      return {
        getPropertyValue: function getPropertyValue() {
          return '';
        },
      };
    },
    Image: function Image() {},
    Date: function Date() {},
    screen: {},
    setTimeout: function setTimeout() {},
    clearTimeout: function clearTimeout() {},
  } : window; // eslint-disable-line

  /**
   * Dom7 2.1.3
   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
   * http://framework7.io/docs/dom.html
   *
   * Copyright 2019, Vladimir Kharlampidi
   * The iDangero.us
   * http://www.idangero.us/
   *
   * Licensed under MIT
   *
   * Released on: February 11, 2019
   */

  class Dom7 {
    constructor(arr) {
      const self = this;
      // Create array-like object
      for (let i = 0; i < arr.length; i += 1) {
        self[i] = arr[i];
      }
      self.length = arr.length;
      // Return collection with methods
      return this;
    }
  }

  function $(selector, context) {
    const arr = [];
    let i = 0;
    if (selector && !context) {
      if (selector instanceof Dom7) {
        return selector;
      }
    }
    if (selector) {
        // String
      if (typeof selector === 'string') {
        let els;
        let tempParent;
        const html = selector.trim();
        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          let toCreate = 'div';
          if (html.indexOf('<li') === 0) toCreate = 'ul';
          if (html.indexOf('<tr') === 0) toCreate = 'tbody';
          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) toCreate = 'tr';
          if (html.indexOf('<tbody') === 0) toCreate = 'table';
          if (html.indexOf('<option') === 0) toCreate = 'select';
          tempParent = doc.createElement(toCreate);
          tempParent.innerHTML = html;
          for (i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
            // Pure ID selector
            els = [doc.getElementById(selector.trim().split('#')[1])];
          } else {
            // Other selectors
            els = (context || doc).querySelectorAll(selector.trim());
          }
          for (i = 0; i < els.length; i += 1) {
            if (els[i]) arr.push(els[i]);
          }
        }
      } else if (selector.nodeType || selector === win || selector === doc) {
        // Node/element
        arr.push(selector);
      } else if (selector.length > 0 && selector[0].nodeType) {
        // Array of elements or instance of Dom
        for (i = 0; i < selector.length; i += 1) {
          arr.push(selector[i]);
        }
      }
    }
    return new Dom7(arr);
  }

  $.fn = Dom7.prototype;
  $.Class = Dom7;
  $.Dom7 = Dom7;

  function unique(arr) {
    const uniqueArray = [];
    for (let i = 0; i < arr.length; i += 1) {
      if (uniqueArray.indexOf(arr[i]) === -1) uniqueArray.push(arr[i]);
    }
    return uniqueArray;
  }
  function toCamelCase(string) {
    return string.toLowerCase().replace(/-(.)/g, (match, group1) => group1.toUpperCase());
  }

  function requestAnimationFrame(callback) {
    if (win.requestAnimationFrame) return win.requestAnimationFrame(callback);
    else if (win.webkitRequestAnimationFrame) return win.webkitRequestAnimationFrame(callback);
    return win.setTimeout(callback, 1000 / 60);
  }
  function cancelAnimationFrame(id) {
    if (win.cancelAnimationFrame) return win.cancelAnimationFrame(id);
    else if (win.webkitCancelAnimationFrame) return win.webkitCancelAnimationFrame(id);
    return win.clearTimeout(id);
  }

  // Classes and attributes
  function addClass(className) {
    if (typeof className === 'undefined') {
      return this;
    }
    const classes = className.split(' ');
    for (let i = 0; i < classes.length; i += 1) {
      for (let j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.add(classes[i]);
      }
    }
    return this;
  }
  function removeClass(className) {
    const classes = className.split(' ');
    for (let i = 0; i < classes.length; i += 1) {
      for (let j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.remove(classes[i]);
      }
    }
    return this;
  }
  function hasClass(className) {
    if (!this[0]) return false;
    return this[0].classList.contains(className);
  }
  function toggleClass(className) {
    const classes = className.split(' ');
    for (let i = 0; i < classes.length; i += 1) {
      for (let j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') this[j].classList.toggle(classes[i]);
      }
    }
    return this;
  }
  function attr(attrs, value) {
    if (arguments.length === 1 && typeof attrs === 'string') {
      // Get attr
      if (this[0]) return this[0].getAttribute(attrs);
      return undefined;
    }

    // Set attrs
    for (let i = 0; i < this.length; i += 1) {
      if (arguments.length === 2) {
        // String
        this[i].setAttribute(attrs, value);
      } else {
        // Object
        // eslint-disable-next-line
        for (const attrName in attrs) {
          this[i][attrName] = attrs[attrName];
          this[i].setAttribute(attrName, attrs[attrName]);
        }
      }
    }
    return this;
  }
  // eslint-disable-next-line
  function removeAttr(attr) {
    for (let i = 0; i < this.length; i += 1) {
      this[i].removeAttribute(attr);
    }
    return this;
  }
  // eslint-disable-next-line
  function prop(props, value) {
    if (arguments.length === 1 && typeof props === 'string') {
      // Get prop
      if (this[0]) return this[0][props];
    } else {
      // Set props
      for (let i = 0; i < this.length; i += 1) {
        if (arguments.length === 2) {
          // String
          this[i][props] = value;
        } else {
          // Object
          // eslint-disable-next-line
          for (const propName in props) {
            this[i][propName] = props[propName];
          }
        }
      }
      return this;
    }
  }
  function data(key, value) {
    let el;
    if (typeof value === 'undefined') {
      el = this[0];
      // Get value
      if (el) {
        if (el.dom7ElementDataStorage && (key in el.dom7ElementDataStorage)) {
          return el.dom7ElementDataStorage[key];
        }

        const dataKey = el.getAttribute(`data-${key}`);
        if (dataKey) {
          return dataKey;
        }
        return undefined;
      }
      return undefined;
    }

    // Set value
    for (let i = 0; i < this.length; i += 1) {
      el = this[i];
      if (!el.dom7ElementDataStorage) el.dom7ElementDataStorage = {};
      el.dom7ElementDataStorage[key] = value;
    }
    return this;
  }
  function removeData(key) {
    for (let i = 0; i < this.length; i += 1) {
      const el = this[i];
      if (el.dom7ElementDataStorage && el.dom7ElementDataStorage[key]) {
        el.dom7ElementDataStorage[key] = null;
        delete el.dom7ElementDataStorage[key];
      }
    }
  }
  function dataset() {
    const el = this[0];
    if (!el) return undefined;
    const dataset = {}; // eslint-disable-line
    if (el.dataset) {
      // eslint-disable-next-line
      for (const dataKey in el.dataset) {
        dataset[dataKey] = el.dataset[dataKey];
      }
    } else {
      for (let i = 0; i < el.attributes.length; i += 1) {
        // eslint-disable-next-line
        const attr = el.attributes[i];
        if (attr.name.indexOf('data-') >= 0) {
          dataset[toCamelCase(attr.name.split('data-')[1])] = attr.value;
        }
      }
    }
    // eslint-disable-next-line
    for (const key in dataset) {
      if (dataset[key] === 'false') dataset[key] = false;
      else if (dataset[key] === 'true') dataset[key] = true;
      else if (parseFloat(dataset[key]) === dataset[key] * 1) dataset[key] *= 1;
    }
    return dataset;
  }
  function val(value) {
    const dom = this;
    if (typeof value === 'undefined') {
      if (dom[0]) {
        if (dom[0].multiple && dom[0].nodeName.toLowerCase() === 'select') {
          const values = [];
          for (let i = 0; i < dom[0].selectedOptions.length; i += 1) {
            values.push(dom[0].selectedOptions[i].value);
          }
          return values;
        }
        return dom[0].value;
      }
      return undefined;
    }

    for (let i = 0; i < dom.length; i += 1) {
      const el = dom[i];
      if (Array.isArray(value) && el.multiple && el.nodeName.toLowerCase() === 'select') {
        for (let j = 0; j < el.options.length; j += 1) {
          el.options[j].selected = value.indexOf(el.options[j].value) >= 0;
        }
      } else {
        el.value = value;
      }
    }
    return dom;
  }
  // Transforms
  // eslint-disable-next-line
  function transform(transform) {
    for (let i = 0; i < this.length; i += 1) {
      const elStyle = this[i].style;
      elStyle.webkitTransform = transform;
      elStyle.transform = transform;
    }
    return this;
  }
  function transition(duration) {
    if (typeof duration !== 'string') {
      duration = `${duration}ms`; // eslint-disable-line
    }
    for (let i = 0; i < this.length; i += 1) {
      const elStyle = this[i].style;
      elStyle.webkitTransitionDuration = duration;
      elStyle.transitionDuration = duration;
    }
    return this;
  }
  // Events
  function on(...args) {
    let [eventType, targetSelector, listener, capture] = args;
    if (typeof args[1] === 'function') {
      [eventType, listener, capture] = args;
      targetSelector = undefined;
    }
    if (!capture) capture = false;

    function handleLiveEvent(e) {
      const target = e.target;
      if (!target) return;
      const eventData = e.target.dom7EventData || [];
      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }
      if ($(target).is(targetSelector)) listener.apply(target, eventData);
      else {
        const parents = $(target).parents(); // eslint-disable-line
        for (let k = 0; k < parents.length; k += 1) {
          if ($(parents[k]).is(targetSelector)) listener.apply(parents[k], eventData);
        }
      }
    }
    function handleEvent(e) {
      const eventData = e && e.target ? e.target.dom7EventData || [] : [];
      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }
      listener.apply(this, eventData);
    }
    const events = eventType.split(' ');
    let j;
    for (let i = 0; i < this.length; i += 1) {
      const el = this[i];
      if (!targetSelector) {
        for (j = 0; j < events.length; j += 1) {
          const event = events[j];
          if (!el.dom7Listeners) el.dom7Listeners = {};
          if (!el.dom7Listeners[event]) el.dom7Listeners[event] = [];
          el.dom7Listeners[event].push({
            listener,
            proxyListener: handleEvent,
          });
          el.addEventListener(event, handleEvent, capture);
        }
      } else {
        // Live events
        for (j = 0; j < events.length; j += 1) {
          const event = events[j];
          if (!el.dom7LiveListeners) el.dom7LiveListeners = {};
          if (!el.dom7LiveListeners[event]) el.dom7LiveListeners[event] = [];
          el.dom7LiveListeners[event].push({
            listener,
            proxyListener: handleLiveEvent,
          });
          el.addEventListener(event, handleLiveEvent, capture);
        }
      }
    }
    return this;
  }
  function off(...args) {
    let [eventType, targetSelector, listener, capture] = args;
    if (typeof args[1] === 'function') {
      [eventType, listener, capture] = args;
      targetSelector = undefined;
    }
    if (!capture) capture = false;

    const events = eventType.split(' ');
    for (let i = 0; i < events.length; i += 1) {
      const event = events[i];
      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];
        let handlers;
        if (!targetSelector && el.dom7Listeners) {
          handlers = el.dom7Listeners[event];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers = el.dom7LiveListeners[event];
        }
        if (handlers && handlers.length) {
          for (let k = handlers.length - 1; k >= 0; k -= 1) {
            const handler = handlers[k];
            if (listener && handler.listener === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (!listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            }
          }
        }
      }
    }
    return this;
  }
  function once(...args) {
    const dom = this;
    let [eventName, targetSelector, listener, capture] = args;
    if (typeof args[1] === 'function') {
      [eventName, listener, capture] = args;
      targetSelector = undefined;
    }
    function onceHandler(...eventArgs) {
      listener.apply(this, eventArgs);
      dom.off(eventName, targetSelector, onceHandler, capture);
      if (onceHandler.dom7proxy) {
        delete onceHandler.dom7proxy;
      }
    }
    onceHandler.dom7proxy = listener;
    return dom.on(eventName, targetSelector, onceHandler, capture);
  }
  function trigger(...args) {
    const events = args[0].split(' ');
    const eventData = args[1];
    for (let i = 0; i < events.length; i += 1) {
      const event = events[i];
      for (let j = 0; j < this.length; j += 1) {
        const el = this[j];
        let evt;
        try {
          evt = new win.CustomEvent(event, {
            detail: eventData,
            bubbles: true,
            cancelable: true,
          });
        } catch (e) {
          evt = doc.createEvent('Event');
          evt.initEvent(event, true, true);
          evt.detail = eventData;
        }
        // eslint-disable-next-line
        el.dom7EventData = args.filter((data, dataIndex) => dataIndex > 0);
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }
    return this;
  }
  function transitionEnd(callback) {
    const events = ['webkitTransitionEnd', 'transitionend'];
    const dom = this;
    let i;
    function fireCallBack(e) {
      /* jshint validthis:true */
      if (e.target !== this) return;
      callback.call(this, e);
      for (i = 0; i < events.length; i += 1) {
        dom.off(events[i], fireCallBack);
      }
    }
    if (callback) {
      for (i = 0; i < events.length; i += 1) {
        dom.on(events[i], fireCallBack);
      }
    }
    return this;
  }
  function animationEnd(callback) {
    const events = ['webkitAnimationEnd', 'animationend'];
    const dom = this;
    let i;
    function fireCallBack(e) {
      if (e.target !== this) return;
      callback.call(this, e);
      for (i = 0; i < events.length; i += 1) {
        dom.off(events[i], fireCallBack);
      }
    }
    if (callback) {
      for (i = 0; i < events.length; i += 1) {
        dom.on(events[i], fireCallBack);
      }
    }
    return this;
  }
  // Sizing/Styles
  function width() {
    if (this[0] === win) {
      return win.innerWidth;
    }

    if (this.length > 0) {
      return parseFloat(this.css('width'));
    }

    return null;
  }
  function outerWidth(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        // eslint-disable-next-line
        const styles = this.styles();
        return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
      }
      return this[0].offsetWidth;
    }
    return null;
  }
  function height() {
    if (this[0] === win) {
      return win.innerHeight;
    }

    if (this.length > 0) {
      return parseFloat(this.css('height'));
    }

    return null;
  }
  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        // eslint-disable-next-line
        const styles = this.styles();
        return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
      }
      return this[0].offsetHeight;
    }
    return null;
  }
  function offset() {
    if (this.length > 0) {
      const el = this[0];
      const box = el.getBoundingClientRect();
      const body = doc.body;
      const clientTop = el.clientTop || body.clientTop || 0;
      const clientLeft = el.clientLeft || body.clientLeft || 0;
      const scrollTop = el === win ? win.scrollY : el.scrollTop;
      const scrollLeft = el === win ? win.scrollX : el.scrollLeft;
      return {
        top: (box.top + scrollTop) - clientTop,
        left: (box.left + scrollLeft) - clientLeft,
      };
    }

    return null;
  }
  function hide() {
    for (let i = 0; i < this.length; i += 1) {
      this[i].style.display = 'none';
    }
    return this;
  }
  function show() {
    for (let i = 0; i < this.length; i += 1) {
      const el = this[i];
      if (el.style.display === 'none') {
        el.style.display = '';
      }
      if (win.getComputedStyle(el, null).getPropertyValue('display') === 'none') {
        // Still not visible
        el.style.display = 'block';
      }
    }
    return this;
  }
  function styles() {
    if (this[0]) return win.getComputedStyle(this[0], null);
    return {};
  }
  function css(props, value) {
    let i;
    if (arguments.length === 1) {
      if (typeof props === 'string') {
        if (this[0]) return win.getComputedStyle(this[0], null).getPropertyValue(props);
      } else {
        for (i = 0; i < this.length; i += 1) {
          // eslint-disable-next-line
          for (let prop in props) {
            this[i].style[prop] = props[prop];
          }
        }
        return this;
      }
    }
    if (arguments.length === 2 && typeof props === 'string') {
      for (i = 0; i < this.length; i += 1) {
        this[i].style[props] = value;
      }
      return this;
    }
    return this;
  }

  // Dom manipulation
  function toArray() {
    const arr = [];
    for (let i = 0; i < this.length; i += 1) {
      arr.push(this[i]);
    }
    return arr;
  }
  // Iterate over the collection passing elements to `callback`
  function each(callback) {
    // Don't bother continuing without a callback
    if (!callback) return this;
    // Iterate over the current collection
    for (let i = 0; i < this.length; i += 1) {
      // If the callback returns false
      if (callback.call(this[i], i, this[i]) === false) {
        // End the loop early
        return this;
      }
    }
    // Return `this` to allow chained DOM operations
    return this;
  }
  function forEach(callback) {
    // Don't bother continuing without a callback
    if (!callback) return this;
    // Iterate over the current collection
    for (let i = 0; i < this.length; i += 1) {
      // If the callback returns false
      if (callback.call(this[i], this[i], i) === false) {
        // End the loop early
        return this;
      }
    }
    // Return `this` to allow chained DOM operations
    return this;
  }
  function filter(callback) {
    const matchedItems = [];
    const dom = this;
    for (let i = 0; i < dom.length; i += 1) {
      if (callback.call(dom[i], i, dom[i])) matchedItems.push(dom[i]);
    }
    return new Dom7(matchedItems);
  }
  function map(callback) {
    const modifiedItems = [];
    const dom = this;
    for (let i = 0; i < dom.length; i += 1) {
      modifiedItems.push(callback.call(dom[i], i, dom[i]));
    }
    return new Dom7(modifiedItems);
  }
  // eslint-disable-next-line
  function html(html) {
    if (typeof html === 'undefined') {
      return this[0] ? this[0].innerHTML : undefined;
    }

    for (let i = 0; i < this.length; i += 1) {
      this[i].innerHTML = html;
    }
    return this;
  }
  // eslint-disable-next-line
  function text(text) {
    if (typeof text === 'undefined') {
      if (this[0]) {
        return this[0].textContent.trim();
      }
      return null;
    }

    for (let i = 0; i < this.length; i += 1) {
      this[i].textContent = text;
    }
    return this;
  }
  function is(selector) {
    const el = this[0];
    let compareWith;
    let i;
    if (!el || typeof selector === 'undefined') return false;
    if (typeof selector === 'string') {
      if (el.matches) return el.matches(selector);
      else if (el.webkitMatchesSelector) return el.webkitMatchesSelector(selector);
      else if (el.msMatchesSelector) return el.msMatchesSelector(selector);

      compareWith = $(selector);
      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }
      return false;
    } else if (selector === doc) return el === doc;
    else if (selector === win) return el === win;

    if (selector.nodeType || selector instanceof Dom7) {
      compareWith = selector.nodeType ? [selector] : selector;
      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) return true;
      }
      return false;
    }
    return false;
  }
  function indexOf(el) {
    for (let i = 0; i < this.length; i += 1) {
      if (this[i] === el) return i;
    }
    return -1;
  }
  function index() {
    let child = this[0];
    let i;
    if (child) {
      i = 0;
      // eslint-disable-next-line
      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) i += 1;
      }
      return i;
    }
    return undefined;
  }
  // eslint-disable-next-line
  function eq(index) {
    if (typeof index === 'undefined') return this;
    const length = this.length;
    let returnIndex;
    if (index > length - 1) {
      return new Dom7([]);
    }
    if (index < 0) {
      returnIndex = length + index;
      if (returnIndex < 0) return new Dom7([]);
      return new Dom7([this[returnIndex]]);
    }
    return new Dom7([this[index]]);
  }
  function append(...args) {
    let newChild;

    for (let k = 0; k < args.length; k += 1) {
      newChild = args[k];
      for (let i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          const tempDiv = doc.createElement('div');
          tempDiv.innerHTML = newChild;
          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (let j = 0; j < newChild.length; j += 1) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }
    }

    return this;
  }
  // eslint-disable-next-line
  function appendTo(parent) {
    $(parent).append(this);
    return this;
  }
  function prepend(newChild) {
    let i;
    let j;
    for (i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        const tempDiv = doc.createElement('div');
        tempDiv.innerHTML = newChild;
        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j = 0; j < newChild.length; j += 1) {
          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
        }
      } else {
        this[i].insertBefore(newChild, this[i].childNodes[0]);
      }
    }
    return this;
  }
  // eslint-disable-next-line
  function prependTo(parent) {
    $(parent).prepend(this);
    return this;
  }
  function insertBefore(selector) {
    const before = $(selector);
    for (let i = 0; i < this.length; i += 1) {
      if (before.length === 1) {
        before[0].parentNode.insertBefore(this[i], before[0]);
      } else if (before.length > 1) {
        for (let j = 0; j < before.length; j += 1) {
          before[j].parentNode.insertBefore(this[i].cloneNode(true), before[j]);
        }
      }
    }
  }
  function insertAfter(selector) {
    const after = $(selector);
    for (let i = 0; i < this.length; i += 1) {
      if (after.length === 1) {
        after[0].parentNode.insertBefore(this[i], after[0].nextSibling);
      } else if (after.length > 1) {
        for (let j = 0; j < after.length; j += 1) {
          after[j].parentNode.insertBefore(this[i].cloneNode(true), after[j].nextSibling);
        }
      }
    }
  }
  function next(selector) {
    if (this.length > 0) {
      if (selector) {
        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
          return new Dom7([this[0].nextElementSibling]);
        }
        return new Dom7([]);
      }

      if (this[0].nextElementSibling) return new Dom7([this[0].nextElementSibling]);
      return new Dom7([]);
    }
    return new Dom7([]);
  }
  function nextAll(selector) {
    const nextEls = [];
    let el = this[0];
    if (!el) return new Dom7([]);
    while (el.nextElementSibling) {
      const next = el.nextElementSibling; // eslint-disable-line
      if (selector) {
        if ($(next).is(selector)) nextEls.push(next);
      } else nextEls.push(next);
      el = next;
    }
    return new Dom7(nextEls);
  }
  function prev(selector) {
    if (this.length > 0) {
      const el = this[0];
      if (selector) {
        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
          return new Dom7([el.previousElementSibling]);
        }
        return new Dom7([]);
      }

      if (el.previousElementSibling) return new Dom7([el.previousElementSibling]);
      return new Dom7([]);
    }
    return new Dom7([]);
  }
  function prevAll(selector) {
    const prevEls = [];
    let el = this[0];
    if (!el) return new Dom7([]);
    while (el.previousElementSibling) {
      const prev = el.previousElementSibling; // eslint-disable-line
      if (selector) {
        if ($(prev).is(selector)) prevEls.push(prev);
      } else prevEls.push(prev);
      el = prev;
    }
    return new Dom7(prevEls);
  }
  function siblings(selector) {
    return this.nextAll(selector).add(this.prevAll(selector));
  }
  function parent(selector) {
    const parents = []; // eslint-disable-line
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if ($(this[i].parentNode).is(selector)) parents.push(this[i].parentNode);
        } else {
          parents.push(this[i].parentNode);
        }
      }
    }
    return $(unique(parents));
  }
  function parents(selector) {
    const parents = []; // eslint-disable-line
    for (let i = 0; i < this.length; i += 1) {
      let parent = this[i].parentNode; // eslint-disable-line
      while (parent) {
        if (selector) {
          if ($(parent).is(selector)) parents.push(parent);
        } else {
          parents.push(parent);
        }
        parent = parent.parentNode;
      }
    }
    return $(unique(parents));
  }
  function closest(selector) {
    let closest = this; // eslint-disable-line
    if (typeof selector === 'undefined') {
      return new Dom7([]);
    }
    if (!closest.is(selector)) {
      closest = closest.parents(selector).eq(0);
    }
    return closest;
  }
  function find(selector) {
    const foundElements = [];
    for (let i = 0; i < this.length; i += 1) {
      const found = this[i].querySelectorAll(selector);
      for (let j = 0; j < found.length; j += 1) {
        foundElements.push(found[j]);
      }
    }
    return new Dom7(foundElements);
  }
  function children(selector) {
    const children = []; // eslint-disable-line
    for (let i = 0; i < this.length; i += 1) {
      const childNodes = this[i].childNodes;

      for (let j = 0; j < childNodes.length; j += 1) {
        if (!selector) {
          if (childNodes[j].nodeType === 1) children.push(childNodes[j]);
        } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
          children.push(childNodes[j]);
        }
      }
    }
    return new Dom7(unique(children));
  }
  function remove() {
    for (let i = 0; i < this.length; i += 1) {
      if (this[i].parentNode) this[i].parentNode.removeChild(this[i]);
    }
    return this;
  }
  function detach() {
    return this.remove();
  }
  function add(...args) {
    const dom = this;
    let i;
    let j;
    for (i = 0; i < args.length; i += 1) {
      const toAdd = $(args[i]);
      for (j = 0; j < toAdd.length; j += 1) {
        dom[dom.length] = toAdd[j];
        dom.length += 1;
      }
    }
    return dom;
  }
  function empty() {
    for (let i = 0; i < this.length; i += 1) {
      const el = this[i];
      if (el.nodeType === 1) {
        for (let j = 0; j < el.childNodes.length; j += 1) {
          if (el.childNodes[j].parentNode) {
            el.childNodes[j].parentNode.removeChild(el.childNodes[j]);
          }
        }
        el.textContent = '';
      }
    }
    return this;
  }

  var Methods = /*#__PURE__*/Object.freeze({
    addClass: addClass,
    removeClass: removeClass,
    hasClass: hasClass,
    toggleClass: toggleClass,
    attr: attr,
    removeAttr: removeAttr,
    prop: prop,
    data: data,
    removeData: removeData,
    dataset: dataset,
    val: val,
    transform: transform,
    transition: transition,
    on: on,
    off: off,
    once: once,
    trigger: trigger,
    transitionEnd: transitionEnd,
    animationEnd: animationEnd,
    width: width,
    outerWidth: outerWidth,
    height: height,
    outerHeight: outerHeight,
    offset: offset,
    hide: hide,
    show: show,
    styles: styles,
    css: css,
    toArray: toArray,
    each: each,
    forEach: forEach,
    filter: filter,
    map: map,
    html: html,
    text: text,
    is: is,
    indexOf: indexOf,
    index: index,
    eq: eq,
    append: append,
    appendTo: appendTo,
    prepend: prepend,
    prependTo: prependTo,
    insertBefore: insertBefore,
    insertAfter: insertAfter,
    next: next,
    nextAll: nextAll,
    prev: prev,
    prevAll: prevAll,
    siblings: siblings,
    parent: parent,
    parents: parents,
    closest: closest,
    find: find,
    children: children,
    remove: remove,
    detach: detach,
    add: add,
    empty: empty
  });

  function scrollTo(...args) {
    let [left, top, duration, easing, callback] = args;
    if (args.length === 4 && typeof easing === 'function') {
      callback = easing;
      [left, top, duration, callback, easing] = args;
    }
    if (typeof easing === 'undefined') easing = 'swing';

    return this.each(function animate() {
      const el = this;
      let currentTop;
      let currentLeft;
      let maxTop;
      let maxLeft;
      let newTop;
      let newLeft;
      let scrollTop; // eslint-disable-line
      let scrollLeft; // eslint-disable-line
      let animateTop = top > 0 || top === 0;
      let animateLeft = left > 0 || left === 0;
      if (typeof easing === 'undefined') {
        easing = 'swing';
      }
      if (animateTop) {
        currentTop = el.scrollTop;
        if (!duration) {
          el.scrollTop = top;
        }
      }
      if (animateLeft) {
        currentLeft = el.scrollLeft;
        if (!duration) {
          el.scrollLeft = left;
        }
      }
      if (!duration) return;
      if (animateTop) {
        maxTop = el.scrollHeight - el.offsetHeight;
        newTop = Math.max(Math.min(top, maxTop), 0);
      }
      if (animateLeft) {
        maxLeft = el.scrollWidth - el.offsetWidth;
        newLeft = Math.max(Math.min(left, maxLeft), 0);
      }
      let startTime = null;
      if (animateTop && newTop === currentTop) animateTop = false;
      if (animateLeft && newLeft === currentLeft) animateLeft = false;
      function render(time = new Date().getTime()) {
        if (startTime === null) {
          startTime = time;
        }
        const progress = Math.max(Math.min((time - startTime) / duration, 1), 0);
        const easeProgress = easing === 'linear' ? progress : (0.5 - (Math.cos(progress * Math.PI) / 2));
        let done;
        if (animateTop) scrollTop = currentTop + (easeProgress * (newTop - currentTop));
        if (animateLeft) scrollLeft = currentLeft + (easeProgress * (newLeft - currentLeft));
        if (animateTop && newTop > currentTop && scrollTop >= newTop) {
          el.scrollTop = newTop;
          done = true;
        }
        if (animateTop && newTop < currentTop && scrollTop <= newTop) {
          el.scrollTop = newTop;
          done = true;
        }
        if (animateLeft && newLeft > currentLeft && scrollLeft >= newLeft) {
          el.scrollLeft = newLeft;
          done = true;
        }
        if (animateLeft && newLeft < currentLeft && scrollLeft <= newLeft) {
          el.scrollLeft = newLeft;
          done = true;
        }

        if (done) {
          if (callback) callback();
          return;
        }
        if (animateTop) el.scrollTop = scrollTop;
        if (animateLeft) el.scrollLeft = scrollLeft;
        requestAnimationFrame(render);
      }
      requestAnimationFrame(render);
    });
  }
  // scrollTop(top, duration, easing, callback) {
  function scrollTop(...args) {
    let [top, duration, easing, callback] = args;
    if (args.length === 3 && typeof easing === 'function') {
      [top, duration, callback, easing] = args;
    }
    const dom = this;
    if (typeof top === 'undefined') {
      if (dom.length > 0) return dom[0].scrollTop;
      return null;
    }
    return dom.scrollTo(undefined, top, duration, easing, callback);
  }
  function scrollLeft(...args) {
    let [left, duration, easing, callback] = args;
    if (args.length === 3 && typeof easing === 'function') {
      [left, duration, callback, easing] = args;
    }
    const dom = this;
    if (typeof left === 'undefined') {
      if (dom.length > 0) return dom[0].scrollLeft;
      return null;
    }
    return dom.scrollTo(left, undefined, duration, easing, callback);
  }

  var Scroll = /*#__PURE__*/Object.freeze({
    scrollTo: scrollTo,
    scrollTop: scrollTop,
    scrollLeft: scrollLeft
  });

  function animate(initialProps, initialParams) {
    const els = this;
    const a = {
      props: Object.assign({}, initialProps),
      params: Object.assign({
        duration: 300,
        easing: 'swing', // or 'linear'
        /* Callbacks
        begin(elements)
        complete(elements)
        progress(elements, complete, remaining, start, tweenValue)
        */
      }, initialParams),

      elements: els,
      animating: false,
      que: [],

      easingProgress(easing, progress) {
        if (easing === 'swing') {
          return 0.5 - (Math.cos(progress * Math.PI) / 2);
        }
        if (typeof easing === 'function') {
          return easing(progress);
        }
        return progress;
      },
      stop() {
        if (a.frameId) {
          cancelAnimationFrame(a.frameId);
        }
        a.animating = false;
        a.elements.each((index, el) => {
          const element = el;
          delete element.dom7AnimateInstance;
        });
        a.que = [];
      },
      done(complete) {
        a.animating = false;
        a.elements.each((index, el) => {
          const element = el;
          delete element.dom7AnimateInstance;
        });
        if (complete) complete(els);
        if (a.que.length > 0) {
          const que = a.que.shift();
          a.animate(que[0], que[1]);
        }
      },
      animate(props, params) {
        if (a.animating) {
          a.que.push([props, params]);
          return a;
        }
        const elements = [];

        // Define & Cache Initials & Units
        a.elements.each((index, el) => {
          let initialFullValue;
          let initialValue;
          let unit;
          let finalValue;
          let finalFullValue;

          if (!el.dom7AnimateInstance) a.elements[index].dom7AnimateInstance = a;

          elements[index] = {
            container: el,
          };
          Object.keys(props).forEach((prop) => {
            initialFullValue = win.getComputedStyle(el, null).getPropertyValue(prop).replace(',', '.');
            initialValue = parseFloat(initialFullValue);
            unit = initialFullValue.replace(initialValue, '');
            finalValue = parseFloat(props[prop]);
            finalFullValue = props[prop] + unit;
            elements[index][prop] = {
              initialFullValue,
              initialValue,
              unit,
              finalValue,
              finalFullValue,
              currentValue: initialValue,
            };
          });
        });

        let startTime = null;
        let time;
        let elementsDone = 0;
        let propsDone = 0;
        let done;
        let began = false;

        a.animating = true;

        function render() {
          time = new Date().getTime();
          let progress;
          let easeProgress;
          // let el;
          if (!began) {
            began = true;
            if (params.begin) params.begin(els);
          }
          if (startTime === null) {
            startTime = time;
          }
          if (params.progress) {
            // eslint-disable-next-line
            params.progress(els, Math.max(Math.min((time - startTime) / params.duration, 1), 0), ((startTime + params.duration) - time < 0 ? 0 : (startTime + params.duration) - time), startTime);
          }

          elements.forEach((element) => {
            const el = element;
            if (done || el.done) return;
            Object.keys(props).forEach((prop) => {
              if (done || el.done) return;
              progress = Math.max(Math.min((time - startTime) / params.duration, 1), 0);
              easeProgress = a.easingProgress(params.easing, progress);
              const { initialValue, finalValue, unit } = el[prop];
              el[prop].currentValue = initialValue + (easeProgress * (finalValue - initialValue));
              const currentValue = el[prop].currentValue;

              if (
                (finalValue > initialValue && currentValue >= finalValue) ||
                (finalValue < initialValue && currentValue <= finalValue)) {
                el.container.style[prop] = finalValue + unit;
                propsDone += 1;
                if (propsDone === Object.keys(props).length) {
                  el.done = true;
                  elementsDone += 1;
                }
                if (elementsDone === elements.length) {
                  done = true;
                }
              }
              if (done) {
                a.done(params.complete);
                return;
              }
              el.container.style[prop] = currentValue + unit;
            });
          });
          if (done) return;
          // Then call
          a.frameId = requestAnimationFrame(render);
        }
        a.frameId = requestAnimationFrame(render);
        return a;
      },
    };

    if (a.elements.length === 0) {
      return els;
    }

    let animateInstance;
    for (let i = 0; i < a.elements.length; i += 1) {
      if (a.elements[i].dom7AnimateInstance) {
        animateInstance = a.elements[i].dom7AnimateInstance;
      } else a.elements[i].dom7AnimateInstance = a;
    }
    if (!animateInstance) {
      animateInstance = a;
    }

    if (initialProps === 'stop') {
      animateInstance.stop();
    } else {
      animateInstance.animate(a.props, a.params);
    }

    return els;
  }

  function stop() {
    const els = this;
    for (let i = 0; i < els.length; i += 1) {
      if (els[i].dom7AnimateInstance) {
        els[i].dom7AnimateInstance.stop();
      }
    }
  }

  var Animate = /*#__PURE__*/Object.freeze({
    animate: animate,
    stop: stop
  });

  const noTrigger = ('resize scroll').split(' ');
  function eventShortcut(name, ...args) {
    if (typeof args[0] === 'undefined') {
      for (let i = 0; i < this.length; i += 1) {
        if (noTrigger.indexOf(name) < 0) {
          if (name in this[i]) this[i][name]();
          else {
            $(this[i]).trigger(name);
          }
        }
      }
      return this;
    }
    return this.on(name, ...args);
  }

  function click(...args) {
    return eventShortcut.bind(this)('click', ...args);
  }
  function blur(...args) {
    return eventShortcut.bind(this)('blur', ...args);
  }
  function focus(...args) {
    return eventShortcut.bind(this)('focus', ...args);
  }
  function focusin(...args) {
    return eventShortcut.bind(this)('focusin', ...args);
  }
  function focusout(...args) {
    return eventShortcut.bind(this)('focusout', ...args);
  }
  function keyup(...args) {
    return eventShortcut.bind(this)('keyup', ...args);
  }
  function keydown(...args) {
    return eventShortcut.bind(this)('keydown', ...args);
  }
  function keypress(...args) {
    return eventShortcut.bind(this)('keypress', ...args);
  }
  function submit(...args) {
    return eventShortcut.bind(this)('submit', ...args);
  }
  function change(...args) {
    return eventShortcut.bind(this)('change', ...args);
  }
  function mousedown(...args) {
    return eventShortcut.bind(this)('mousedown', ...args);
  }
  function mousemove(...args) {
    return eventShortcut.bind(this)('mousemove', ...args);
  }
  function mouseup(...args) {
    return eventShortcut.bind(this)('mouseup', ...args);
  }
  function mouseenter(...args) {
    return eventShortcut.bind(this)('mouseenter', ...args);
  }
  function mouseleave(...args) {
    return eventShortcut.bind(this)('mouseleave', ...args);
  }
  function mouseout(...args) {
    return eventShortcut.bind(this)('mouseout', ...args);
  }
  function mouseover(...args) {
    return eventShortcut.bind(this)('mouseover', ...args);
  }
  function touchstart(...args) {
    return eventShortcut.bind(this)('touchstart', ...args);
  }
  function touchend(...args) {
    return eventShortcut.bind(this)('touchend', ...args);
  }
  function touchmove(...args) {
    return eventShortcut.bind(this)('touchmove', ...args);
  }
  function resize(...args) {
    return eventShortcut.bind(this)('resize', ...args);
  }
  function scroll(...args) {
    return eventShortcut.bind(this)('scroll', ...args);
  }

  var eventShortcuts = /*#__PURE__*/Object.freeze({
    click: click,
    blur: blur,
    focus: focus,
    focusin: focusin,
    focusout: focusout,
    keyup: keyup,
    keydown: keydown,
    keypress: keypress,
    submit: submit,
    change: change,
    mousedown: mousedown,
    mousemove: mousemove,
    mouseup: mouseup,
    mouseenter: mouseenter,
    mouseleave: mouseleave,
    mouseout: mouseout,
    mouseover: mouseover,
    touchstart: touchstart,
    touchend: touchend,
    touchmove: touchmove,
    resize: resize,
    scroll: scroll
  });

  [Methods, Scroll, Animate, eventShortcuts].forEach((group) => {
    Object.keys(group).forEach((methodName) => {
      $.fn[methodName] = group[methodName];
    });
  });

  /* eslint no-control-regex: "off" */

  // Remove Diacritics
  const defaultDiacriticsRemovalap = [
    { base: 'A', letters: '\u0041\u24B6\uFF21\u00C0\u00C1\u00C2\u1EA6\u1EA4\u1EAA\u1EA8\u00C3\u0100\u0102\u1EB0\u1EAE\u1EB4\u1EB2\u0226\u01E0\u00C4\u01DE\u1EA2\u00C5\u01FA\u01CD\u0200\u0202\u1EA0\u1EAC\u1EB6\u1E00\u0104\u023A\u2C6F' },
    { base: 'AA', letters: '\uA732' },
    { base: 'AE', letters: '\u00C6\u01FC\u01E2' },
    { base: 'AO', letters: '\uA734' },
    { base: 'AU', letters: '\uA736' },
    { base: 'AV', letters: '\uA738\uA73A' },
    { base: 'AY', letters: '\uA73C' },
    { base: 'B', letters: '\u0042\u24B7\uFF22\u1E02\u1E04\u1E06\u0243\u0182\u0181' },
    { base: 'C', letters: '\u0043\u24B8\uFF23\u0106\u0108\u010A\u010C\u00C7\u1E08\u0187\u023B\uA73E' },
    { base: 'D', letters: '\u0044\u24B9\uFF24\u1E0A\u010E\u1E0C\u1E10\u1E12\u1E0E\u0110\u018B\u018A\u0189\uA779' },
    { base: 'DZ', letters: '\u01F1\u01C4' },
    { base: 'Dz', letters: '\u01F2\u01C5' },
    { base: 'E', letters: '\u0045\u24BA\uFF25\u00C8\u00C9\u00CA\u1EC0\u1EBE\u1EC4\u1EC2\u1EBC\u0112\u1E14\u1E16\u0114\u0116\u00CB\u1EBA\u011A\u0204\u0206\u1EB8\u1EC6\u0228\u1E1C\u0118\u1E18\u1E1A\u0190\u018E' },
    { base: 'F', letters: '\u0046\u24BB\uFF26\u1E1E\u0191\uA77B' },
    { base: 'G', letters: '\u0047\u24BC\uFF27\u01F4\u011C\u1E20\u011E\u0120\u01E6\u0122\u01E4\u0193\uA7A0\uA77D\uA77E' },
    { base: 'H', letters: '\u0048\u24BD\uFF28\u0124\u1E22\u1E26\u021E\u1E24\u1E28\u1E2A\u0126\u2C67\u2C75\uA78D' },
    { base: 'I', letters: '\u0049\u24BE\uFF29\u00CC\u00CD\u00CE\u0128\u012A\u012C\u0130\u00CF\u1E2E\u1EC8\u01CF\u0208\u020A\u1ECA\u012E\u1E2C\u0197' },
    { base: 'J', letters: '\u004A\u24BF\uFF2A\u0134\u0248' },
    { base: 'K', letters: '\u004B\u24C0\uFF2B\u1E30\u01E8\u1E32\u0136\u1E34\u0198\u2C69\uA740\uA742\uA744\uA7A2' },
    { base: 'L', letters: '\u004C\u24C1\uFF2C\u013F\u0139\u013D\u1E36\u1E38\u013B\u1E3C\u1E3A\u0141\u023D\u2C62\u2C60\uA748\uA746\uA780' },
    { base: 'LJ', letters: '\u01C7' },
    { base: 'Lj', letters: '\u01C8' },
    { base: 'M', letters: '\u004D\u24C2\uFF2D\u1E3E\u1E40\u1E42\u2C6E\u019C' },
    { base: 'N', letters: '\u004E\u24C3\uFF2E\u01F8\u0143\u00D1\u1E44\u0147\u1E46\u0145\u1E4A\u1E48\u0220\u019D\uA790\uA7A4' },
    { base: 'NJ', letters: '\u01CA' },
    { base: 'Nj', letters: '\u01CB' },
    { base: 'O', letters: '\u004F\u24C4\uFF2F\u00D2\u00D3\u00D4\u1ED2\u1ED0\u1ED6\u1ED4\u00D5\u1E4C\u022C\u1E4E\u014C\u1E50\u1E52\u014E\u022E\u0230\u00D6\u022A\u1ECE\u0150\u01D1\u020C\u020E\u01A0\u1EDC\u1EDA\u1EE0\u1EDE\u1EE2\u1ECC\u1ED8\u01EA\u01EC\u00D8\u01FE\u0186\u019F\uA74A\uA74C' },
    { base: 'OI', letters: '\u01A2' },
    { base: 'OO', letters: '\uA74E' },
    { base: 'OU', letters: '\u0222' },
    { base: 'OE', letters: '\u008C\u0152' },
    { base: 'oe', letters: '\u009C\u0153' },
    { base: 'P', letters: '\u0050\u24C5\uFF30\u1E54\u1E56\u01A4\u2C63\uA750\uA752\uA754' },
    { base: 'Q', letters: '\u0051\u24C6\uFF31\uA756\uA758\u024A' },
    { base: 'R', letters: '\u0052\u24C7\uFF32\u0154\u1E58\u0158\u0210\u0212\u1E5A\u1E5C\u0156\u1E5E\u024C\u2C64\uA75A\uA7A6\uA782' },
    { base: 'S', letters: '\u0053\u24C8\uFF33\u1E9E\u015A\u1E64\u015C\u1E60\u0160\u1E66\u1E62\u1E68\u0218\u015E\u2C7E\uA7A8\uA784' },
    { base: 'T', letters: '\u0054\u24C9\uFF34\u1E6A\u0164\u1E6C\u021A\u0162\u1E70\u1E6E\u0166\u01AC\u01AE\u023E\uA786' },
    { base: 'TZ', letters: '\uA728' },
    { base: 'U', letters: '\u0055\u24CA\uFF35\u00D9\u00DA\u00DB\u0168\u1E78\u016A\u1E7A\u016C\u00DC\u01DB\u01D7\u01D5\u01D9\u1EE6\u016E\u0170\u01D3\u0214\u0216\u01AF\u1EEA\u1EE8\u1EEE\u1EEC\u1EF0\u1EE4\u1E72\u0172\u1E76\u1E74\u0244' },
    { base: 'V', letters: '\u0056\u24CB\uFF36\u1E7C\u1E7E\u01B2\uA75E\u0245' },
    { base: 'VY', letters: '\uA760' },
    { base: 'W', letters: '\u0057\u24CC\uFF37\u1E80\u1E82\u0174\u1E86\u1E84\u1E88\u2C72' },
    { base: 'X', letters: '\u0058\u24CD\uFF38\u1E8A\u1E8C' },
    { base: 'Y', letters: '\u0059\u24CE\uFF39\u1EF2\u00DD\u0176\u1EF8\u0232\u1E8E\u0178\u1EF6\u1EF4\u01B3\u024E\u1EFE' },
    { base: 'Z', letters: '\u005A\u24CF\uFF3A\u0179\u1E90\u017B\u017D\u1E92\u1E94\u01B5\u0224\u2C7F\u2C6B\uA762' },
    { base: 'a', letters: '\u0061\u24D0\uFF41\u1E9A\u00E0\u00E1\u00E2\u1EA7\u1EA5\u1EAB\u1EA9\u00E3\u0101\u0103\u1EB1\u1EAF\u1EB5\u1EB3\u0227\u01E1\u00E4\u01DF\u1EA3\u00E5\u01FB\u01CE\u0201\u0203\u1EA1\u1EAD\u1EB7\u1E01\u0105\u2C65\u0250' },
    { base: 'aa', letters: '\uA733' },
    { base: 'ae', letters: '\u00E6\u01FD\u01E3' },
    { base: 'ao', letters: '\uA735' },
    { base: 'au', letters: '\uA737' },
    { base: 'av', letters: '\uA739\uA73B' },
    { base: 'ay', letters: '\uA73D' },
    { base: 'b', letters: '\u0062\u24D1\uFF42\u1E03\u1E05\u1E07\u0180\u0183\u0253' },
    { base: 'c', letters: '\u0063\u24D2\uFF43\u0107\u0109\u010B\u010D\u00E7\u1E09\u0188\u023C\uA73F\u2184' },
    { base: 'd', letters: '\u0064\u24D3\uFF44\u1E0B\u010F\u1E0D\u1E11\u1E13\u1E0F\u0111\u018C\u0256\u0257\uA77A' },
    { base: 'dz', letters: '\u01F3\u01C6' },
    { base: 'e', letters: '\u0065\u24D4\uFF45\u00E8\u00E9\u00EA\u1EC1\u1EBF\u1EC5\u1EC3\u1EBD\u0113\u1E15\u1E17\u0115\u0117\u00EB\u1EBB\u011B\u0205\u0207\u1EB9\u1EC7\u0229\u1E1D\u0119\u1E19\u1E1B\u0247\u025B\u01DD' },
    { base: 'f', letters: '\u0066\u24D5\uFF46\u1E1F\u0192\uA77C' },
    { base: 'g', letters: '\u0067\u24D6\uFF47\u01F5\u011D\u1E21\u011F\u0121\u01E7\u0123\u01E5\u0260\uA7A1\u1D79\uA77F' },
    { base: 'h', letters: '\u0068\u24D7\uFF48\u0125\u1E23\u1E27\u021F\u1E25\u1E29\u1E2B\u1E96\u0127\u2C68\u2C76\u0265' },
    { base: 'hv', letters: '\u0195' },
    { base: 'i', letters: '\u0069\u24D8\uFF49\u00EC\u00ED\u00EE\u0129\u012B\u012D\u00EF\u1E2F\u1EC9\u01D0\u0209\u020B\u1ECB\u012F\u1E2D\u0268\u0131' },
    { base: 'j', letters: '\u006A\u24D9\uFF4A\u0135\u01F0\u0249' },
    { base: 'k', letters: '\u006B\u24DA\uFF4B\u1E31\u01E9\u1E33\u0137\u1E35\u0199\u2C6A\uA741\uA743\uA745\uA7A3' },
    { base: 'l', letters: '\u006C\u24DB\uFF4C\u0140\u013A\u013E\u1E37\u1E39\u013C\u1E3D\u1E3B\u017F\u0142\u019A\u026B\u2C61\uA749\uA781\uA747' },
    { base: 'lj', letters: '\u01C9' },
    { base: 'm', letters: '\u006D\u24DC\uFF4D\u1E3F\u1E41\u1E43\u0271\u026F' },
    { base: 'n', letters: '\u006E\u24DD\uFF4E\u01F9\u0144\u00F1\u1E45\u0148\u1E47\u0146\u1E4B\u1E49\u019E\u0272\u0149\uA791\uA7A5' },
    { base: 'nj', letters: '\u01CC' },
    { base: 'o', letters: '\u006F\u24DE\uFF4F\u00F2\u00F3\u00F4\u1ED3\u1ED1\u1ED7\u1ED5\u00F5\u1E4D\u022D\u1E4F\u014D\u1E51\u1E53\u014F\u022F\u0231\u00F6\u022B\u1ECF\u0151\u01D2\u020D\u020F\u01A1\u1EDD\u1EDB\u1EE1\u1EDF\u1EE3\u1ECD\u1ED9\u01EB\u01ED\u00F8\u01FF\u0254\uA74B\uA74D\u0275' },
    { base: 'oi', letters: '\u01A3' },
    { base: 'ou', letters: '\u0223' },
    { base: 'oo', letters: '\uA74F' },
    { base: 'p', letters: '\u0070\u24DF\uFF50\u1E55\u1E57\u01A5\u1D7D\uA751\uA753\uA755' },
    { base: 'q', letters: '\u0071\u24E0\uFF51\u024B\uA757\uA759' },
    { base: 'r', letters: '\u0072\u24E1\uFF52\u0155\u1E59\u0159\u0211\u0213\u1E5B\u1E5D\u0157\u1E5F\u024D\u027D\uA75B\uA7A7\uA783' },
    { base: 's', letters: '\u0073\u24E2\uFF53\u00DF\u015B\u1E65\u015D\u1E61\u0161\u1E67\u1E63\u1E69\u0219\u015F\u023F\uA7A9\uA785\u1E9B' },
    { base: 't', letters: '\u0074\u24E3\uFF54\u1E6B\u1E97\u0165\u1E6D\u021B\u0163\u1E71\u1E6F\u0167\u01AD\u0288\u2C66\uA787' },
    { base: 'tz', letters: '\uA729' },
    { base: 'u', letters: '\u0075\u24E4\uFF55\u00F9\u00FA\u00FB\u0169\u1E79\u016B\u1E7B\u016D\u00FC\u01DC\u01D8\u01D6\u01DA\u1EE7\u016F\u0171\u01D4\u0215\u0217\u01B0\u1EEB\u1EE9\u1EEF\u1EED\u1EF1\u1EE5\u1E73\u0173\u1E77\u1E75\u0289' },
    { base: 'v', letters: '\u0076\u24E5\uFF56\u1E7D\u1E7F\u028B\uA75F\u028C' },
    { base: 'vy', letters: '\uA761' },
    { base: 'w', letters: '\u0077\u24E6\uFF57\u1E81\u1E83\u0175\u1E87\u1E85\u1E98\u1E89\u2C73' },
    { base: 'x', letters: '\u0078\u24E7\uFF58\u1E8B\u1E8D' },
    { base: 'y', letters: '\u0079\u24E8\uFF59\u1EF3\u00FD\u0177\u1EF9\u0233\u1E8F\u00FF\u1EF7\u1E99\u1EF5\u01B4\u024F\u1EFF' },
    { base: 'z', letters: '\u007A\u24E9\uFF5A\u017A\u1E91\u017C\u017E\u1E93\u1E95\u01B6\u0225\u0240\u2C6C\uA763' },
  ];

  const diacriticsMap = {};
  for (let i = 0; i < defaultDiacriticsRemovalap.length; i += 1) {
    const letters = defaultDiacriticsRemovalap[i].letters;
    for (let j = 0; j < letters.length; j += 1) {
      diacriticsMap[letters[j]] = defaultDiacriticsRemovalap[i].base;
    }
  }

  let uniqueNumber = 1;

  const Utils = {
    uniqueNumber() {
      uniqueNumber += 1;
      return uniqueNumber;
    },
    id(mask = 'xxxxxxxxxx', map = '0123456789abcdef') {
      const length = map.length;
      return mask.replace(/x/g, () => map[Math.floor((Math.random() * length))]);
    },
    mdPreloaderContent: `
    <span class="preloader-inner">
      <span class="preloader-inner-gap"></span>
      <span class="preloader-inner-left">
          <span class="preloader-inner-half-circle"></span>
      </span>
      <span class="preloader-inner-right">
          <span class="preloader-inner-half-circle"></span>
      </span>
    </span>
  `.trim(),
    iosPreloaderContent: `
    <span class="preloader-inner">
      ${[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11].map(() => '<span class="preloader-inner-line"></span>').join('')}
    </span>
  `.trim(),
    auroraPreloaderContent: `
    <span class="preloader-inner">
      <span class="preloader-inner-circle"></span>
    </span>
  `,
    eventNameToColonCase(eventName) {
      let hasColon;
      return eventName.split('').map((char, index) => {
        if (char.match(/[A-Z]/) && index !== 0 && !hasColon) {
          hasColon = true;
          return `:${char.toLowerCase()}`;
        }
        return char.toLowerCase();
      }).join('');
    },
    deleteProps(obj) {
      const object = obj;
      Object.keys(object).forEach((key) => {
        try {
          object[key] = null;
        } catch (e) {
          // no setter for object
        }
        try {
          delete object[key];
        } catch (e) {
          // something got wrong
        }
      });
    },
    nextTick(callback, delay = 0) {
      return setTimeout(callback, delay);
    },
    nextFrame(callback) {
      return Utils.requestAnimationFrame(() => {
        Utils.requestAnimationFrame(callback);
      });
    },
    now() {
      return Date.now();
    },
    requestAnimationFrame(callback) {
      return win.requestAnimationFrame(callback);
    },
    cancelAnimationFrame(id) {
      return win.cancelAnimationFrame(id);
    },
    removeDiacritics(str) {
      return str.replace(/[^\u0000-\u007E]/g, a => diacriticsMap[a] || a);
    },
    parseUrlQuery(url) {
      const query = {};
      let urlToParse = url || win.location.href;
      let i;
      let params;
      let param;
      let length;
      if (typeof urlToParse === 'string' && urlToParse.length) {
        urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
        params = urlToParse.split('&').filter(paramsPart => paramsPart !== '');
        length = params.length;

        for (i = 0; i < length; i += 1) {
          param = params[i].replace(/#\S+/g, '').split('=');
          query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param.slice(1).join('=')) || '';
        }
      }
      return query;
    },
    getTranslate(el, axis = 'x') {
      let matrix;
      let curTransform;
      let transformMatrix;

      const curStyle = win.getComputedStyle(el, null);

      if (win.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;
        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(a => a.replace(',', '.')).join(', ');
        }
        // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case
        transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (win.WebKitCSSMatrix) curTransform = transformMatrix.m41;
        // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[12]);
        // Normal Browsers
        else curTransform = parseFloat(matrix[4]);
      }
      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (win.WebKitCSSMatrix) curTransform = transformMatrix.m42;
        // Crazy IE10 Matrix
        else if (matrix.length === 16) curTransform = parseFloat(matrix[13]);
        // Normal Browsers
        else curTransform = parseFloat(matrix[5]);
      }
      return curTransform || 0;
    },
    serializeObject(obj, parents = []) {
      if (typeof obj === 'string') return obj;
      const resultArray = [];
      const separator = '&';
      let newParents;
      function varName(name) {
        if (parents.length > 0) {
          let parentParts = '';
          for (let j = 0; j < parents.length; j += 1) {
            if (j === 0) parentParts += parents[j];
            else parentParts += `[${encodeURIComponent(parents[j])}]`;
          }
          return `${parentParts}[${encodeURIComponent(name)}]`;
        }
        return encodeURIComponent(name);
      }
      function varValue(value) {
        return encodeURIComponent(value);
      }
      Object.keys(obj).forEach((prop) => {
        let toPush;
        if (Array.isArray(obj[prop])) {
          toPush = [];
          for (let i = 0; i < obj[prop].length; i += 1) {
            if (!Array.isArray(obj[prop][i]) && typeof obj[prop][i] === 'object') {
              newParents = parents.slice();
              newParents.push(prop);
              newParents.push(String(i));
              toPush.push(Utils.serializeObject(obj[prop][i], newParents));
            } else {
              toPush.push(`${varName(prop)}[]=${varValue(obj[prop][i])}`);
            }
          }
          if (toPush.length > 0) resultArray.push(toPush.join(separator));
        } else if (obj[prop] === null || obj[prop] === '') {
          resultArray.push(`${varName(prop)}=`);
        } else if (typeof obj[prop] === 'object') {
          // Object, convert to named array
          newParents = parents.slice();
          newParents.push(prop);
          toPush = Utils.serializeObject(obj[prop], newParents);
          if (toPush !== '') resultArray.push(toPush);
        } else if (typeof obj[prop] !== 'undefined' && obj[prop] !== '') {
          // Should be string or plain value
          resultArray.push(`${varName(prop)}=${varValue(obj[prop])}`);
        } else if (obj[prop] === '') resultArray.push(varName(prop));
      });
      return resultArray.join(separator);
    },
    isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
    },
    merge(...args) {
      const to = args[0];
      args.splice(0, 1);
      const from = args;

      for (let i = 0; i < from.length; i += 1) {
        const nextSource = args[i];
        if (nextSource !== undefined && nextSource !== null) {
          const keysArray = Object.keys(Object(nextSource));
          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) {
              to[nextKey] = nextSource[nextKey];
            }
          }
        }
      }
      return to;
    },
    extend(...args) {
      let deep = true;
      let to;
      let from;
      if (typeof args[0] === 'boolean') {
        deep = args[0];
        to = args[1];
        args.splice(0, 2);
        from = args;
      } else {
        to = args[0];
        args.splice(0, 1);
        from = args;
      }
      for (let i = 0; i < from.length; i += 1) {
        const nextSource = args[i];
        if (nextSource !== undefined && nextSource !== null) {
          const keysArray = Object.keys(Object(nextSource));
          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) {
              if (!deep) {
                to[nextKey] = nextSource[nextKey];
              } else if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                Utils.extend(to[nextKey], nextSource[nextKey]);
              } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                to[nextKey] = {};
                Utils.extend(to[nextKey], nextSource[nextKey]);
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }
      return to;
    },
    colorHexToRgb(hex) {
      const h = hex.replace(/^#?([a-f\d])([a-f\d])([a-f\d])$/i, (m, r, g, b) => r + r + g + g + b + b);
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(h);
      return result
        ? result.slice(1).map(n => parseInt(n, 16))
        : null;
    },
    colorRgbToHex(r, g, b) {
      const result = [r, g, b].map((n) => {
        const hex = n.toString(16);
        return hex.length === 1 ? `0${hex}` : hex;
      }).join('');
      return `#${result}`;
    },
    colorRgbToHsl(r, g, b) {
      r /= 255; // eslint-disable-line
      g /= 255; // eslint-disable-line
      b /= 255; // eslint-disable-line
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      const d = max - min;
      let h;
      if (d === 0) h = 0;
      else if (max === r) h = ((g - b) / d) % 6;
      else if (max === g) h = (b - r) / d + 2;
      else if (max === b) h = (r - g) / d + 4;
      const l = (min + max) / 2;
      const s = d === 0 ? 0 : d / (1 - Math.abs(2 * l - 1));
      if (h < 0) h = 360 / 60 + h;
      return [h * 60, s, l];
    },
    colorHslToRgb(h, s, l) {
      const c = (1 - Math.abs(2 * l - 1)) * s;
      const hp = h / 60;
      const x = c * (1 - Math.abs((hp % 2) - 1));
      let rgb1;
      if (Number.isNaN(h) || typeof h === 'undefined') {
        rgb1 = [0, 0, 0];
      } else if (hp <= 1) rgb1 = [c, x, 0];
      else if (hp <= 2) rgb1 = [x, c, 0];
      else if (hp <= 3) rgb1 = [0, c, x];
      else if (hp <= 4) rgb1 = [0, x, c];
      else if (hp <= 5) rgb1 = [x, 0, c];
      else if (hp <= 6) rgb1 = [c, 0, x];
      const m = l - (c / 2);
      return rgb1.map(n => Math.max(0, Math.min(255, Math.round(255 * (n + m)))));
    },
    colorHsbToHsl(h, s, b) {
      const HSL = {
        h,
        s: 0,
        l: 0,
      };
      const HSB = { h, s, b };

      HSL.l = (2 - HSB.s) * HSB.b / 2;
      HSL.s = HSL.l && HSL.l < 1 ? HSB.s * HSB.b / (HSL.l < 0.5 ? HSL.l * 2 : 2 - HSL.l * 2) : HSL.s;

      return [HSL.h, HSL.s, HSL.l];
    },
    colorHslToHsb(h, s, l) {
      const HSB = {
        h,
        s: 0,
        b: 0,
      };
      const HSL = { h, s, l };

      const t = HSL.s * (HSL.l < 0.5 ? HSL.l : 1 - HSL.l);
      HSB.b = HSL.l + t;
      HSB.s = HSL.l > 0 ? 2 * t / HSB.b : HSB.s;

      return [HSB.h, HSB.s, HSB.b];
    },
    colorThemeCSSProperties(...args) {
      let hex;
      let rgb;
      if (args.length === 1) {
        hex = args[0];
        rgb = Utils.colorHexToRgb(hex);
      } else if (args.length === 3) {
        rgb = args;
        hex = Utils.colorRgbToHex(...rgb);
      }
      if (!rgb) return {};
      const hsl = Utils.colorRgbToHsl(...rgb);
      const hslShade = [hsl[0], hsl[1], Math.max(0, (hsl[2] - 0.08))];
      const hslTint = [hsl[0], hsl[1], Math.max(0, (hsl[2] + 0.08))];
      const shade = Utils.colorRgbToHex(...Utils.colorHslToRgb(...hslShade));
      const tint = Utils.colorRgbToHex(...Utils.colorHslToRgb(...hslTint));
      return {
        '--f7-theme-color': hex,
        '--f7-theme-color-rgb': rgb.join(', '),
        '--f7-theme-color-shade': shade,
        '--f7-theme-color-tint': tint,
      };
    },
  };

  const Support = (function Support() {
    return {
      touch: (function checkTouch() {
        return !!((win.navigator.maxTouchPoints > 0) || ('ontouchstart' in win) || (win.DocumentTouch && doc instanceof win.DocumentTouch));
      }()),

      pointerEvents: !!win.PointerEvent,

      observer: (function checkObserver() {
        return ('MutationObserver' in win || 'WebkitMutationObserver' in win);
      }()),

      passiveListener: (function checkPassiveListener() {
        let supportsPassive = false;
        try {
          const opts = Object.defineProperty({}, 'passive', {
            // eslint-disable-next-line
            get() {
              supportsPassive = true;
            },
          });
          win.addEventListener('testPassiveListener', null, opts);
        } catch (e) {
          // No support
        }
        return supportsPassive;
      }()),

      gestures: (function checkGestures() {
        return 'ongesturestart' in win;
      }()),

      intersectionObserver: (function checkObserver() {
        return ('IntersectionObserver' in win);
      }()),
    };
  }());

  const Device = (function Device() {
    const platform = win.navigator.platform;
    const ua = win.navigator.userAgent;

    const device = {
      ios: false,
      android: false,
      androidChrome: false,
      desktop: false,
      iphone: false,
      ipod: false,
      ipad: false,
      edge: false,
      ie: false,
      firefox: false,
      macos: false,
      windows: false,
      cordova: !!(win.cordova || win.phonegap),
      phonegap: !!(win.cordova || win.phonegap),
      electron: false,
      nwjs: false,
    };

    const screenWidth = win.screen.width;
    const screenHeight = win.screen.height;

    const android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line
    let ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    const ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    const iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    const ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
    const edge = ua.indexOf('Edge/') >= 0;
    const firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
    const windows = platform === 'Win32';
    const electron = ua.toLowerCase().indexOf('electron') >= 0;
    const nwjs = typeof nw !== 'undefined' && typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.nw !== 'undefined';
    let macos = platform === 'MacIntel';

    // iPadOs 13 fix
    if (!ipad
      && macos
      && Support.touch
      && (
        (screenWidth === 1024 && screenHeight === 1366) // Pro 12.9
        || (screenWidth === 834 && screenHeight === 1194) // Pro 11
        || (screenWidth === 834 && screenHeight === 1112) // Pro 10.5
        || (screenWidth === 768 && screenHeight === 1024) // other
      )
    ) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      macos = false;
    }

    device.ie = ie;
    device.edge = edge;
    device.firefox = firefox;

    // Android
    if (android && !windows) {
      device.os = 'android';
      device.osVersion = android[2];
      device.android = true;
      device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
    }
    if (ipad || iphone || ipod) {
      device.os = 'ios';
      device.ios = true;
    }
    // iOS
    if (iphone && !ipod) {
      device.osVersion = iphone[2].replace(/_/g, '.');
      device.iphone = true;
    }
    if (ipad) {
      device.osVersion = ipad[2].replace(/_/g, '.');
      device.ipad = true;
    }
    if (ipod) {
      device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
      device.ipod = true;
    }
    // iOS 8+ changed UA
    if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
      if (device.osVersion.split('.')[0] === '10') {
        device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
      }
    }

    // Webview
    device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone))
      || (win.matchMedia && win.matchMedia('(display-mode: standalone)').matches);
    device.webview = device.webView;
    device.standalone = device.webView;

    // Desktop
    device.desktop = !(device.ios || device.android) || electron || nwjs;
    if (device.desktop) {
      device.electron = electron;
      device.nwjs = nwjs;
      device.macos = macos;
      device.windows = windows;
      if (device.macos) {
        device.os = 'macos';
      }
      if (device.windows) {
        device.os = 'windows';
      }
    }

    // Pixel Ratio
    device.pixelRatio = win.devicePixelRatio || 1;

    // Color Scheme
    const DARK = '(prefers-color-scheme: dark)';
    const LIGHT = '(prefers-color-scheme: light)';
    device.prefersColorScheme = function prefersColorTheme() {
      let theme;
      if (win.matchMedia && win.matchMedia(LIGHT).matches) {
        theme = 'light';
      }
      if (win.matchMedia && win.matchMedia(DARK).matches) {
        theme = 'dark';
      }
      return theme;
    };

    // Export object
    return device;
  }());

  class EventsClass {
    constructor(parents = []) {
      const self = this;
      self.eventsParents = parents;
      self.eventsListeners = {};
    }

    on(events, handler, priority) {
      const self = this;
      if (typeof handler !== 'function') return self;
      const method = priority ? 'unshift' : 'push';
      events.split(' ').forEach((event) => {
        if (!self.eventsListeners[event]) self.eventsListeners[event] = [];
        self.eventsListeners[event][method](handler);
      });
      return self;
    }

    once(events, handler, priority) {
      const self = this;
      if (typeof handler !== 'function') return self;
      function onceHandler(...args) {
        self.off(events, onceHandler);
        if (onceHandler.f7proxy) {
          delete onceHandler.f7proxy;
        }
        handler.apply(self, args);
      }
      onceHandler.f7proxy = handler;
      return self.on(events, onceHandler, priority);
    }

    off(events, handler) {
      const self = this;
      if (!self.eventsListeners) return self;
      events.split(' ').forEach((event) => {
        if (typeof handler === 'undefined') {
          self.eventsListeners[event] = [];
        } else if (self.eventsListeners[event]) {
          self.eventsListeners[event].forEach((eventHandler, index) => {
            if (eventHandler === handler || (eventHandler.f7proxy && eventHandler.f7proxy === handler)) {
              self.eventsListeners[event].splice(index, 1);
            }
          });
        }
      });
      return self;
    }

    emit(...args) {
      const self = this;
      if (!self.eventsListeners) return self;
      let events;
      let data;
      let context;
      let eventsParents;
      if (typeof args[0] === 'string' || Array.isArray(args[0])) {
        events = args[0];
        data = args.slice(1, args.length);
        context = self;
        eventsParents = self.eventsParents;
      } else {
        events = args[0].events;
        data = args[0].data;
        context = args[0].context || self;
        eventsParents = args[0].local ? [] : args[0].parents || self.eventsParents;
      }
      const eventsArray = Array.isArray(events) ? events : events.split(' ');
      const localEvents = eventsArray.map(eventName => eventName.replace('local::', ''));
      const parentEvents = eventsArray.filter(eventName => eventName.indexOf('local::') < 0);

      localEvents.forEach((event) => {
        if (self.eventsListeners && self.eventsListeners[event]) {
          const handlers = [];
          self.eventsListeners[event].forEach((eventHandler) => {
            handlers.push(eventHandler);
          });
          handlers.forEach((eventHandler) => {
            eventHandler.apply(context, data);
          });
        }
      });
      if (eventsParents && eventsParents.length > 0) {
        eventsParents.forEach((eventsParent) => {
          eventsParent.emit(parentEvents, ...data);
        });
      }
      return self;
    }
  }

  class Framework7Class extends EventsClass {
    constructor(params = {}, parents = []) {
      super(parents);
      const self = this;
      self.params = params;

      if (self.params && self.params.on) {
        Object.keys(self.params.on).forEach((eventName) => {
          self.on(eventName, self.params.on[eventName]);
        });
      }
    }

    // eslint-disable-next-line
    useModuleParams(module, instanceParams) {
      if (module.params) {
        const originalParams = {};
        Object.keys(module.params).forEach((paramKey) => {
          if (typeof instanceParams[paramKey] === 'undefined') return;
          originalParams[paramKey] = Utils.extend({}, instanceParams[paramKey]);
        });
        Utils.extend(instanceParams, module.params);
        Object.keys(originalParams).forEach((paramKey) => {
          Utils.extend(instanceParams[paramKey], originalParams[paramKey]);
        });
      }
    }

    useModulesParams(instanceParams) {
      const instance = this;
      if (!instance.modules) return;
      Object.keys(instance.modules).forEach((moduleName) => {
        const module = instance.modules[moduleName];
        // Extend params
        if (module.params) {
          Utils.extend(instanceParams, module.params);
        }
      });
    }

    useModule(moduleName = '', moduleParams = {}) {
      const instance = this;
      if (!instance.modules) return;
      const module = typeof moduleName === 'string' ? instance.modules[moduleName] : moduleName;
      if (!module) return;

      // Extend instance methods and props
      if (module.instance) {
        Object.keys(module.instance).forEach((modulePropName) => {
          const moduleProp = module.instance[modulePropName];
          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      }
      // Add event listeners
      if (module.on && instance.on) {
        Object.keys(module.on).forEach((moduleEventName) => {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      }
      // Add vnode hooks
      if (module.vnode) {
        if (!instance.vnodeHooks) instance.vnodeHooks = {};
        Object.keys(module.vnode).forEach((vnodeId) => {
          Object.keys(module.vnode[vnodeId]).forEach((hookName) => {
            const handler = module.vnode[vnodeId][hookName];
            if (!instance.vnodeHooks[hookName]) instance.vnodeHooks[hookName] = {};
            if (!instance.vnodeHooks[hookName][vnodeId]) instance.vnodeHooks[hookName][vnodeId] = [];
            instance.vnodeHooks[hookName][vnodeId].push(handler.bind(instance));
          });
        });
      }
      // Module create callback
      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    }

    useModules(modulesParams = {}) {
      const instance = this;
      if (!instance.modules) return;
      Object.keys(instance.modules).forEach((moduleName) => {
        const moduleParams = modulesParams[moduleName] || {};
        instance.useModule(moduleName, moduleParams);
      });
    }

    static set components(components) {
      const Class = this;
      if (!Class.use) return;
      Class.use(components);
    }

    static installModule(module, ...params) {
      const Class = this;
      if (!Class.prototype.modules) Class.prototype.modules = {};
      const name = module.name || (`${Object.keys(Class.prototype.modules).length}_${Utils.now()}`);
      Class.prototype.modules[name] = module;
      // Prototype
      if (module.proto) {
        Object.keys(module.proto).forEach((key) => {
          Class.prototype[key] = module.proto[key];
        });
      }
      // Class
      if (module.static) {
        Object.keys(module.static).forEach((key) => {
          Class[key] = module.static[key];
        });
      }
      // Callback
      if (module.install) {
        module.install.apply(Class, params);
      }
      return Class;
    }

    static use(module, ...params) {
      const Class = this;
      if (Array.isArray(module)) {
        module.forEach(m => Class.installModule(m));
        return Class;
      }
      return Class.installModule(module, ...params);
    }
  }

  function ConstructorMethods (parameters = {}) {
    const {
      defaultSelector,
      constructor: Constructor,
      domProp,
      app,
      addMethods,
    } = parameters;
    const methods = {
      create(...args) {
        if (app) return new Constructor(app, ...args);
        return new Constructor(...args);
      },
      get(el = defaultSelector) {
        if (el instanceof Constructor) return el;
        const $el = $(el);
        if ($el.length === 0) return undefined;
        return $el[0][domProp];
      },
      destroy(el) {
        const instance = methods.get(el);
        if (instance && instance.destroy) return instance.destroy();
        return undefined;
      },
    };
    if (addMethods && Array.isArray(addMethods)) {
      addMethods.forEach((methodName) => {
        methods[methodName] = (el = defaultSelector, ...args) => {
          const instance = methods.get(el);
          if (instance && instance[methodName]) return instance[methodName](...args);
          return undefined;
        };
      });
    }
    return methods;
  }

  function ModalMethods (parameters = {}) {
    const { defaultSelector, constructor: Constructor, app } = parameters;
    const methods = Utils.extend(
      ConstructorMethods({
        defaultSelector,
        constructor: Constructor,
        app,
        domProp: 'f7Modal',
      }),
      {
        open(el, animate, targetEl) {
          let $el = $(el);
          if ($el.length > 1 && targetEl) {
            // check if same modal in other page
            const $targetPage = $(targetEl).parents('.page');
            if ($targetPage.length) {
              $el.each((index, modalEl) => {
                const $modalEl = $(modalEl);
                if ($modalEl.parents($targetPage)[0] === $targetPage[0]) {
                  $el = $modalEl;
                }
              });
            }
          }
          if ($el.length > 1) {
            $el = $el.eq($el.length - 1);
          }
          if (!$el.length) return undefined;
          let instance = $el[0].f7Modal;
          if (!instance) {
            const params = $el.dataset();
            instance = new Constructor(app, { el: $el, ...params });
          }
          return instance.open(animate);
        },
        close(el = defaultSelector, animate, targetEl) {
          let $el = $(el);
          if (!$el.length) return undefined;
          if ($el.length > 1) {
            // check if close link (targetEl) in this modal
            let $parentEl;
            if (targetEl) {
              const $targetEl = $(targetEl);
              if ($targetEl.length) {
                $parentEl = $targetEl.parents($el);
              }
            }
            if ($parentEl && $parentEl.length > 0) {
              $el = $parentEl;
            } else {
              $el = $el.eq($el.length - 1);
            }
          }
          let instance = $el[0].f7Modal;
          if (!instance) {
            const params = $el.dataset();
            instance = new Constructor(app, { el: $el, ...params });
          }
          return instance.close(animate);
        },
      }
    );
    return methods;
  }

  const fetchedModules = [];
  function loadModule(moduleToLoad) {
    const Framework7 = this;
    return new Promise((resolve, reject) => {
      const app = Framework7.instance;
      let modulePath;
      let moduleObj;
      let moduleFunc;
      if (!moduleToLoad) {
        reject(new Error('Framework7: Lazy module must be specified'));
        return;
      }

      function install(module) {
        Framework7.use(module);

        if (app) {
          app.useModuleParams(module, app.params);
          app.useModule(module);
        }
      }

      if (typeof moduleToLoad === 'string') {
        const matchNamePattern = moduleToLoad.match(/([a-z0-9-]*)/i);
        if (moduleToLoad.indexOf('.') < 0 && matchNamePattern && matchNamePattern[0].length === moduleToLoad.length) {
          if (!app || (app && !app.params.lazyModulesPath)) {
            reject(new Error('Framework7: "lazyModulesPath" app parameter must be specified to fetch module by name'));
            return;
          }
          modulePath = `${app.params.lazyModulesPath}/${moduleToLoad}.js`;
        } else {
          modulePath = moduleToLoad;
        }
      } else if (typeof moduleToLoad === 'function') {
        moduleFunc = moduleToLoad;
      } else {
        // considering F7-Plugin object
        moduleObj = moduleToLoad;
      }

      if (moduleFunc) {
        const module = moduleFunc(Framework7, false);
        if (!module) {
          reject(new Error('Framework7: Can\'t find Framework7 component in specified component function'));
          return;
        }
        // Check if it was added
        if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
          resolve();
          return;
        }
        // Install It
        install(module);

        resolve();
      }
      if (moduleObj) {
        const module = moduleObj;
        if (!module) {
          reject(new Error('Framework7: Can\'t find Framework7 component in specified component'));
          return;
        }
        // Check if it was added
        if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
          resolve();
          return;
        }
        // Install It
        install(module);

        resolve();
      }
      if (modulePath) {
        if (fetchedModules.indexOf(modulePath) >= 0) {
          resolve();
          return;
        }
        fetchedModules.push(modulePath);
        const scriptLoad = new Promise((resolveScript, rejectScript) => {
          Framework7.request.get(
            modulePath,
            (scriptContent) => {
              const id = Utils.id();
              const callbackLoadName = `f7_component_loader_callback_${id}`;

              const scriptEl = doc.createElement('script');
              scriptEl.innerHTML = `window.${callbackLoadName} = function (Framework7, Framework7AutoInstallComponent) {return ${scriptContent.trim()}}`;
              $('head').append(scriptEl);

              const componentLoader = win[callbackLoadName];
              delete win[callbackLoadName];
              $(scriptEl).remove();

              const module = componentLoader(Framework7, false);

              if (!module) {
                rejectScript(new Error(`Framework7: Can't find Framework7 component in ${modulePath} file`));
                return;
              }

              // Check if it was added
              if (Framework7.prototype.modules && Framework7.prototype.modules[module.name]) {
                resolveScript();
                return;
              }

              // Install It
              install(module);

              resolveScript();
            },
            (xhr, status) => {
              rejectScript(xhr, status);
            }
          );
        });
        const styleLoad = new Promise((resolveStyle) => {
          Framework7.request.get(
            modulePath.replace('.js', app.rtl ? '.rtl.css' : '.css'),
            (styleContent) => {
              const styleEl = doc.createElement('style');
              styleEl.innerHTML = styleContent;
              $('head').append(styleEl);

              resolveStyle();
            },
            () => {
              resolveStyle();
            }
          );
        });

        Promise.all([scriptLoad, styleLoad]).then(() => {
          resolve();
        }).catch((err) => {
          reject(err);
        });
      }
    });
  }

  class Framework7 extends Framework7Class {
    constructor(params) {
      super(params);
      if (Framework7.instance) {
        throw new Error('Framework7 is already initialized and can\'t be initialized more than once');
      }

      const passedParams = Utils.extend({}, params);

      // App Instance
      const app = this;

      Framework7.instance = app;

      // Default
      const defaults = {
        version: '1.0.0',
        id: 'io.framework7.testapp',
        root: 'body',
        theme: 'auto',
        language: win.navigator.language,
        routes: [],
        name: 'Framework7',
        lazyModulesPath: null,
        initOnDeviceReady: true,
        init: true,
        autoDarkTheme: false,
        iosTranslucentBars: true,
        iosTranslucentModals: true,
        component: undefined,
        componentUrl: undefined,
      };

      // Extend defaults with modules params
      app.useModulesParams(defaults);

      // Extend defaults with passed params
      app.params = Utils.extend(defaults, params);

      const $rootEl = $(app.params.root);

      Utils.extend(app, {
        // App Id
        id: app.params.id,
        // App Name
        name: app.params.name,
        // App version
        version: app.params.version,
        // Routes
        routes: app.params.routes,
        // Lang
        language: app.params.language,
        // Root
        root: $rootEl,
        // RTL
        rtl: $rootEl.css('direction') === 'rtl',
        // Theme
        theme: (function getTheme() {
          if (app.params.theme === 'auto') {
            if (Device.ios) return 'ios';
            if (Device.desktop && Device.electron) return 'aurora';
            return 'md';
          }
          return app.params.theme;
        }()),
        // Initially passed parameters
        passedParams,
        online: win.navigator.onLine,
      });

      // Save Root
      if (app.root && app.root[0]) {
        app.root[0].f7 = app;
      }

      // Install Modules
      app.useModules();

      // Init Data & Methods
      app.initData();

      // Auto Dark Theme
      const DARK = '(prefers-color-scheme: dark)';
      const LIGHT = '(prefers-color-scheme: light)';
      app.mq = {};
      if (win.matchMedia) {
        app.mq.dark = win.matchMedia(DARK);
        app.mq.light = win.matchMedia(LIGHT);
      }
      app.colorSchemeListener = function colorSchemeListener({ matches, media }) {
        if (!matches) {
          return;
        }
        const html = doc.querySelector('html');
        if (media === DARK) {
          html.classList.add('theme-dark');
          app.darkTheme = true;
          app.emit('darkThemeChange', true);
        } else if (media === LIGHT) {
          html.classList.remove('theme-dark');
          app.darkTheme = false;
          app.emit('darkThemeChange', false);
        }
      };

      // Init
      if (app.params.init) {
        if (Device.cordova && app.params.initOnDeviceReady) {
          $(doc).on('deviceready', () => {
            app.init();
          });
        } else {
          app.init();
        }
      }

      // Return app instance
      return app;
    }

    initData() {
      const app = this;

      // Data
      app.data = {};
      if (app.params.data && typeof app.params.data === 'function') {
        Utils.extend(app.data, app.params.data.bind(app)());
      } else if (app.params.data) {
        Utils.extend(app.data, app.params.data);
      }
      // Methods
      app.methods = {};
      if (app.params.methods) {
        Object.keys(app.params.methods).forEach((methodName) => {
          if (typeof app.params.methods[methodName] === 'function') {
            app.methods[methodName] = app.params.methods[methodName].bind(app);
          } else {
            app.methods[methodName] = app.params.methods[methodName];
          }
        });
      }
    }

    enableAutoDarkTheme() {
      if (!win.matchMedia) return;
      const app = this;
      const html = doc.querySelector('html');
      if (app.mq.dark && app.mq.light) {
        app.mq.dark.addListener(app.colorSchemeListener);
        app.mq.light.addListener(app.colorSchemeListener);
      }
      if (app.mq.dark && app.mq.dark.matches) {
        html.classList.add('theme-dark');
        app.darkTheme = true;
        app.emit('darkThemeChange', true);
      } else if (app.mq.light && app.mq.light.matches) {
        html.classList.remove('theme-dark');
        app.darkTheme = false;
        app.emit('darkThemeChange', false);
      }
    }

    disableAutoDarkTheme() {
      if (!win.matchMedia) return;
      const app = this;
      if (app.mq.dark) app.mq.dark.removeListener(app.colorSchemeListener);
      if (app.mq.light) app.mq.light.removeListener(app.colorSchemeListener);
    }

    initAppComponent(callback) {
      const app = this;
      app.router.componentLoader(
        app.params.component,
        app.params.componentUrl,
        { componentOptions: { el: app.root[0], root: true } },
        (el) => {
          app.root = $(el);
          app.root[0].f7 = app;
          app.rootComponent = el.f7Component;
          if (callback) callback();
        },
        () => {}
      );
    }

    // eslint-disable-next-line
    _init() {
      const app = this;
      if (app.initialized) return app;

      app.root.addClass('framework7-initializing');

      // RTL attr
      if (app.rtl) {
        $('html').attr('dir', 'rtl');
      }

      // Auto Dark Theme
      if (app.params.autoDarkTheme) {
        app.enableAutoDarkTheme();
      }

      // Watch for online/offline state
      win.addEventListener('offline', () => {
        app.online = false;
        app.emit('offline');
        app.emit('connection', false);
      });
      win.addEventListener('online', () => {
        app.online = true;
        app.emit('online');
        app.emit('connection', true);
      });

      // Root class
      app.root.addClass('framework7-root');

      // Theme class
      $('html').removeClass('ios md aurora').addClass(app.theme);

      // iOS Translucent
      if (app.params.iosTranslucentBars && app.theme === 'ios' && Device.ios) {
        $('html').addClass('ios-translucent-bars');
      }
      if (app.params.iosTranslucentModals && app.theme === 'ios' && Device.ios) {
        $('html').addClass('ios-translucent-modals');
      }

      // Init class
      Utils.nextFrame(() => {
        app.root.removeClass('framework7-initializing');
      });
      // Emit, init other modules
      app.initialized = true;
      app.emit('init');

      return app;
    }

    init() {
      const app = this;
      if (app.params.component || app.params.componentUrl) {
        app.initAppComponent(() => {
          app._init(); // eslint-disable-line
        });
      } else {
        app._init(); // eslint-disable-line
      }
    }

    // eslint-disable-next-line
    loadModule(...args) {
      return Framework7.loadModule(...args);
    }

    // eslint-disable-next-line
    loadModules(...args) {
      return Framework7.loadModules(...args);
    }

    getVnodeHooks(hook, id) {
      const app = this;
      if (!app.vnodeHooks || !app.vnodeHooks[hook]) return [];
      return app.vnodeHooks[hook][id] || [];
    }

    // eslint-disable-next-line
    get $() {
      return $;
    }
    // eslint-disable-next-line
    get t7() {
      return Template7;
    }

    static get Dom7() {
      return $;
    }

    static get $() {
      return $;
    }

    static get Template7() {
      return Template7;
    }

    static get Class() {
      return Framework7Class;
    }

    static get Events() {
      return EventsClass;
    }
  }

  Framework7.ModalMethods = ModalMethods;
  Framework7.ConstructorMethods = ConstructorMethods;

  Framework7.loadModule = loadModule;
  Framework7.loadModules = function loadModules(modules) {
    return Promise.all(modules.map(module => Framework7.loadModule(module)));
  };

  const globals = {};
  let jsonpRequests = 0;

  function Request(requestOptions) {
    const globalsNoCallbacks = Utils.extend({}, globals);
    ('beforeCreate beforeOpen beforeSend error complete success statusCode').split(' ').forEach((callbackName) => {
      delete globalsNoCallbacks[callbackName];
    });
    const defaults = Utils.extend({
      url: win.location.toString(),
      method: 'GET',
      data: false,
      async: true,
      cache: true,
      user: '',
      password: '',
      headers: {},
      xhrFields: {},
      statusCode: {},
      processData: true,
      dataType: 'text',
      contentType: 'application/x-www-form-urlencoded',
      timeout: 0,
    }, globalsNoCallbacks);

    const options = Utils.extend({}, defaults, requestOptions);
    let proceedRequest;

    // Function to run XHR callbacks and events
    function fireCallback(callbackName, ...data) {
      /*
        Callbacks:
        beforeCreate (options),
        beforeOpen (xhr, options),
        beforeSend (xhr, options),
        error (xhr, status, message),
        complete (xhr, stautus),
        success (response, status, xhr),
        statusCode ()
      */
      let globalCallbackValue;
      let optionCallbackValue;
      if (globals[callbackName]) {
        globalCallbackValue = globals[callbackName](...data);
      }
      if (options[callbackName]) {
        optionCallbackValue = options[callbackName](...data);
      }
      if (typeof globalCallbackValue !== 'boolean') globalCallbackValue = true;
      if (typeof optionCallbackValue !== 'boolean') optionCallbackValue = true;
      return (globalCallbackValue && optionCallbackValue);
    }

    // Before create callback
    proceedRequest = fireCallback('beforeCreate', options);
    if (proceedRequest === false) return undefined;

    // For jQuery guys
    if (options.type) options.method = options.type;

    // Parameters Prefix
    let paramsPrefix = options.url.indexOf('?') >= 0 ? '&' : '?';

    // UC method
    const method = options.method.toUpperCase();

    // Data to modify GET URL
    if ((method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') && options.data) {
      let stringData;
      if (typeof options.data === 'string') {
        // Should be key=value string
        if (options.data.indexOf('?') >= 0) stringData = options.data.split('?')[1];
        else stringData = options.data;
      } else {
        // Should be key=value object
        stringData = Utils.serializeObject(options.data);
      }
      if (stringData.length) {
        options.url += paramsPrefix + stringData;
        if (paramsPrefix === '?') paramsPrefix = '&';
      }
    }

    // JSONP
    if (options.dataType === 'json' && options.url.indexOf('callback=') >= 0) {
      const callbackName = `f7jsonp_${Date.now() + ((jsonpRequests += 1))}`;
      let abortTimeout;
      const callbackSplit = options.url.split('callback=');
      let requestUrl = `${callbackSplit[0]}callback=${callbackName}`;
      if (callbackSplit[1].indexOf('&') >= 0) {
        const addVars = callbackSplit[1].split('&').filter(el => el.indexOf('=') > 0).join('&');
        if (addVars.length > 0) requestUrl += `&${addVars}`;
      }

      // Create script
      let script = doc.createElement('script');
      script.type = 'text/javascript';
      script.onerror = function onerror() {
        clearTimeout(abortTimeout);
        fireCallback('error', null, 'scripterror', 'scripterror');
        fireCallback('complete', null, 'scripterror');
      };
      script.src = requestUrl;

      // Handler
      win[callbackName] = function jsonpCallback(data) {
        clearTimeout(abortTimeout);
        fireCallback('success', data);
        script.parentNode.removeChild(script);
        script = null;
        delete win[callbackName];
      };
      doc.querySelector('head').appendChild(script);

      if (options.timeout > 0) {
        abortTimeout = setTimeout(() => {
          script.parentNode.removeChild(script);
          script = null;
          fireCallback('error', null, 'timeout', 'timeout');
        }, options.timeout);
      }

      return undefined;
    }

    // Cache for GET/HEAD requests
    if (method === 'GET' || method === 'HEAD' || method === 'OPTIONS' || method === 'DELETE') {
      if (options.cache === false) {
        options.url += `${paramsPrefix}_nocache${Date.now()}`;
      }
    }

    // Create XHR
    const xhr = new XMLHttpRequest();

    // Save Request URL
    xhr.requestUrl = options.url;
    xhr.requestParameters = options;

    // Before open callback
    proceedRequest = fireCallback('beforeOpen', xhr, options);
    if (proceedRequest === false) return xhr;

    // Open XHR
    xhr.open(method, options.url, options.async, options.user, options.password);

    // Create POST Data
    let postData = null;

    if ((method === 'POST' || method === 'PUT' || method === 'PATCH') && options.data) {
      if (options.processData) {
        const postDataInstances = [ArrayBuffer, Blob, Document, FormData];
        // Post Data
        if (postDataInstances.indexOf(options.data.constructor) >= 0) {
          postData = options.data;
        } else {
          // POST Headers
          const boundary = `---------------------------${Date.now().toString(16)}`;

          if (options.contentType === 'multipart/form-data') {
            xhr.setRequestHeader('Content-Type', `multipart/form-data; boundary=${boundary}`);
          } else {
            xhr.setRequestHeader('Content-Type', options.contentType);
          }
          postData = '';
          let data = Utils.serializeObject(options.data);
          if (options.contentType === 'multipart/form-data') {
            data = data.split('&');
            const newData = [];
            for (let i = 0; i < data.length; i += 1) {
              newData.push(`Content-Disposition: form-data; name="${data[i].split('=')[0]}"\r\n\r\n${data[i].split('=')[1]}\r\n`);
            }
            postData = `--${boundary}\r\n${newData.join(`--${boundary}\r\n`)}--${boundary}--\r\n`;
          } else if (options.contentType === 'application/json') {
            postData = JSON.stringify(options.data);
          } else {
            postData = data;
          }
        }
      } else {
        postData = options.data;
        xhr.setRequestHeader('Content-Type', options.contentType);
      }
    }
    if (options.dataType === 'json' && (!options.headers || !options.headers.Accept)) {
      xhr.setRequestHeader('Accept', 'application/json');
    }

    // Additional headers
    if (options.headers) {
      Object.keys(options.headers).forEach((headerName) => {
        if (typeof options.headers[headerName] === 'undefined') return;
        xhr.setRequestHeader(headerName, options.headers[headerName]);
      });
    }

    // Check for crossDomain
    if (typeof options.crossDomain === 'undefined') {
      // eslint-disable-next-line
      options.crossDomain = /^([\w-]+:)?\/\/([^\/]+)/.test(options.url) && RegExp.$2 !== win.location.host;
    }

    if (!options.crossDomain) {
      xhr.setRequestHeader('X-Requested-With', 'XMLHttpRequest');
    }

    if (options.xhrFields) {
      Utils.extend(xhr, options.xhrFields);
    }


    // Handle XHR
    xhr.onload = function onload() {
      if ((xhr.status >= 200 && xhr.status < 300) || xhr.status === 0) {
        let responseData;
        if (options.dataType === 'json') {
          let parseError;
          try {
            responseData = JSON.parse(xhr.responseText);
          } catch (err) {
            parseError = true;
          }
          if (!parseError) {
            fireCallback('success', responseData, xhr.status, xhr);
          } else {
            fireCallback('error', xhr, 'parseerror', 'parseerror');
          }
        } else {
          responseData = xhr.responseType === 'text' || xhr.responseType === '' ? xhr.responseText : xhr.response;
          fireCallback('success', responseData, xhr.status, xhr);
        }
      } else {
        fireCallback('error', xhr, xhr.status, xhr.statusText);
      }
      if (options.statusCode) {
        if (globals.statusCode && globals.statusCode[xhr.status]) globals.statusCode[xhr.status](xhr);
        if (options.statusCode[xhr.status]) options.statusCode[xhr.status](xhr);
      }
      fireCallback('complete', xhr, xhr.status);
    };

    xhr.onerror = function onerror() {
      fireCallback('error', xhr, xhr.status, xhr.status);
      fireCallback('complete', xhr, 'error');
    };

    // Timeout
    if (options.timeout > 0) {
      xhr.timeout = options.timeout;
      xhr.ontimeout = () => {
        fireCallback('error', xhr, 'timeout', 'timeout');
        fireCallback('complete', xhr, 'timeout');
      };
    }

    // Ajax start callback
    proceedRequest = fireCallback('beforeSend', xhr, options);
    if (proceedRequest === false) return xhr;

    // Send XHR
    xhr.send(postData);

    // Return XHR object
    return xhr;
  }
  function RequestShortcut(method, ...args) {
    let [url, data, success, error, dataType] = [];
    if (typeof args[1] === 'function') {
      [url, success, error, dataType] = args;
    } else {
      [url, data, success, error, dataType] = args;
    }
    [success, error].forEach((callback) => {
      if (typeof callback === 'string') {
        dataType = callback;
        if (callback === success) success = undefined;
        else error = undefined;
      }
    });
    dataType = dataType || (method === 'json' || method === 'postJSON' ? 'json' : undefined);
    const requestOptions = {
      url,
      method: method === 'post' || method === 'postJSON' ? 'POST' : 'GET',
      data,
      success,
      error,
      dataType,
    };
    if (method === 'postJSON') {
      Utils.extend(requestOptions, {
        contentType: 'application/json',
        processData: false,
        crossDomain: true,
        data: typeof data === 'string' ? data : JSON.stringify(data),
      });
    }
    return Request(requestOptions);
  }
  function RequestShortcutPromise(method, ...args) {
    const [url, data, dataType] = args;
    return new Promise((resolve, reject) => {
      RequestShortcut(
        method,
        url,
        data,
        (responseData, status, xhr) => {
          resolve({ data: responseData, status, xhr });
        },
        (xhr, status, message) => {
          // eslint-disable-next-line
          reject({ xhr, status, message });
        },
        dataType
      );
    });
  }
  Object.assign(Request, {
    get: (...args) => RequestShortcut('get', ...args),
    post: (...args) => RequestShortcut('post', ...args),
    json: (...args) => RequestShortcut('json', ...args),
    getJSON: (...args) => RequestShortcut('json', ...args),
    postJSON: (...args) => RequestShortcut('postJSON', ...args),
  });

  Request.promise = function requestPromise(requestOptions) {
    return new Promise((resolve, reject) => {
      Request(Object.assign(requestOptions, {
        success(data, status, xhr) {
          resolve({ data, status, xhr });
        },
        error(xhr, status, message) {
          // eslint-disable-next-line
          reject({ xhr, status, message });
        },
      }));
    });
  };
  Object.assign(Request.promise, {
    get: (...args) => RequestShortcutPromise('get', ...args),
    post: (...args) => RequestShortcutPromise('post', ...args),
    json: (...args) => RequestShortcutPromise('json', ...args),
    getJSON: (...args) => RequestShortcutPromise('json', ...args),
    postJSON: (...args) => RequestShortcutPromise('postJSON', ...args),
  });

  Request.setup = function setup(options) {
    if (options.type && !options.method) {
      Utils.extend(options, { method: options.type });
    }
    Utils.extend(globals, options);
  };

  var DeviceModule = {
    name: 'device',
    proto: {
      device: Device,
    },
    static: {
      device: Device,
    },
    on: {
      init() {
        const classNames = [];
        const html = doc.querySelector('html');
        const metaStatusbar = doc.querySelector('meta[name="apple-mobile-web-app-status-bar-style"]');
        if (!html) return;
        if (Device.standalone && Device.ios && metaStatusbar && metaStatusbar.content === 'black-translucent') {
          classNames.push('device-full-viewport');
        }

        // Pixel Ratio
        classNames.push(`device-pixel-ratio-${Math.floor(Device.pixelRatio)}`);
        // OS classes
        if (Device.os && !Device.desktop) {
          classNames.push(
            `device-${Device.os}`,
          );
        } else if (Device.desktop) {
          classNames.push('device-desktop');
          if (Device.os) {
            classNames.push(`device-${Device.os}`);
          }
        }
        if (Device.cordova || Device.phonegap) {
          classNames.push('device-cordova');
        }

        // Add html classes
        classNames.forEach((className) => {
          html.classList.add(className);
        });
      },
    },
  };

  var SupportModule = {
    name: 'support',
    proto: {
      support: Support,
    },
    static: {
      support: Support,
    },
  };

  var UtilsModule = {
    name: 'utils',
    proto: {
      utils: Utils,
    },
    static: {
      utils: Utils,
    },
  };

  var ResizeModule = {
    name: 'resize',
    instance: {
      getSize() {
        const app = this;
        if (!app.root[0]) return { width: 0, height: 0, left: 0, top: 0 };
        const offset = app.root.offset();
        const [width, height, left, top] = [app.root[0].offsetWidth, app.root[0].offsetHeight, offset.left, offset.top];
        app.width = width;
        app.height = height;
        app.left = left;
        app.top = top;
        return { width, height, left, top };
      },
    },
    on: {
      init() {
        const app = this;

        // Get Size
        app.getSize();

        // Emit resize
        win.addEventListener('resize', () => {
          app.emit('resize');
        }, false);

        // Emit orientationchange
        win.addEventListener('orientationchange', () => {
          app.emit('orientationchange');
        });
      },
      orientationchange() {
        const app = this;
        // Fix iPad weird body scroll
        if (app.device.ipad) {
          doc.body.scrollLeft = 0;
          setTimeout(() => {
            doc.body.scrollLeft = 0;
          }, 0);
        }
      },
      resize() {
        const app = this;
        app.getSize();
      },
    },
  };

  /* eslint no-param-reassign: "off" */

  var RequestModule = {
    name: 'request',
    proto: {
      request: Request,
    },
    static: {
      request: Request,
    },
  };

  /* eslint-disable no-nested-ternary */

  function initTouch() {
    const app = this;
    const params = app.params.touch;
    const useRipple = params[`${app.theme}TouchRipple`];

    if (Device.ios && Device.webView) {
      // Strange hack required for iOS 8 webview to work on inputs
      win.addEventListener('touchstart', () => {});
    }

    let touchStartX;
    let touchStartY;
    let targetElement;
    let isMoved;
    let tapHoldFired;
    let tapHoldTimeout;
    let preventClick;

    let activableElement;
    let activeTimeout;

    let rippleWave;
    let rippleTarget;
    let rippleTimeout;

    function findActivableElement(el) {
      const target = $(el);
      const parents = target.parents(params.activeStateElements);
      if (target.closest('.no-active-state').length) {
        return null;
      }
      let activable;
      if (target.is(params.activeStateElements)) {
        activable = target;
      }
      if (parents.length > 0) {
        activable = activable ? activable.add(parents) : parents;
      }
      if (activable && activable.length > 1) {
        const newActivable = [];
        let preventPropagation;
        for (let i = 0; i < activable.length; i += 1) {
          if (!preventPropagation) {
            newActivable.push(activable[i]);
            if (activable.eq(i).hasClass('prevent-active-state-propagation')
              || activable.eq(i).hasClass('no-active-state-propagation')
            ) {
              preventPropagation = true;
            }
          }
        }
        activable = $(newActivable);
      }
      return activable || target;
    }

    function isInsideScrollableView(el) {
      const pageContent = el.parents('.page-content');
      return pageContent.length > 0;
    }

    function addActive() {
      if (!activableElement) return;
      activableElement.addClass('active-state');
    }
    function removeActive() {
      if (!activableElement) return;
      activableElement.removeClass('active-state');
      activableElement = null;
    }

    // Ripple handlers
    function findRippleElement(el) {
      const rippleElements = params.touchRippleElements;
      const $el = $(el);
      if ($el.is(rippleElements)) {
        if ($el.hasClass('no-ripple')) {
          return false;
        }
        return $el;
      }
      if ($el.parents(rippleElements).length > 0) {
        const rippleParent = $el.parents(rippleElements).eq(0);
        if (rippleParent.hasClass('no-ripple')) {
          return false;
        }
        return rippleParent;
      }
      return false;
    }
    function createRipple($el, x, y) {
      if (!$el) return;
      rippleWave = app.touchRipple.create($el, x, y);
    }

    function removeRipple() {
      if (!rippleWave) return;
      rippleWave.remove();
      rippleWave = undefined;
      rippleTarget = undefined;
    }
    function rippleTouchStart(el) {
      rippleTarget = findRippleElement(el);
      if (!rippleTarget || rippleTarget.length === 0) {
        rippleTarget = undefined;
        return;
      }
      const inScrollable = isInsideScrollableView(rippleTarget);

      if (!inScrollable) {
        removeRipple();
        createRipple(rippleTarget, touchStartX, touchStartY);
      } else {
        clearTimeout(rippleTimeout);
        rippleTimeout = setTimeout(() => {
          removeRipple();
          createRipple(rippleTarget, touchStartX, touchStartY);
        }, 80);
      }
    }
    function rippleTouchMove() {
      clearTimeout(rippleTimeout);
      removeRipple();
    }
    function rippleTouchEnd() {
      if (!rippleWave && rippleTarget && !isMoved) {
        clearTimeout(rippleTimeout);
        createRipple(rippleTarget, touchStartX, touchStartY);
        setTimeout(removeRipple, 0);
      } else {
        removeRipple();
      }
    }

    // Mouse Handlers
    function handleMouseDown(e) {
      const $activableEl = findActivableElement(e.target);
      if ($activableEl) {
        $activableEl.addClass('active-state');
        if ('which' in e && e.which === 3) {
          setTimeout(() => {
            $('.active-state').removeClass('active-state');
          }, 0);
        }
      }

      if (useRipple) {
        touchStartX = e.pageX;
        touchStartY = e.pageY;
        rippleTouchStart(e.target, e.pageX, e.pageY);
      }
    }
    function handleMouseMove() {
      if (!params.activeStateOnMouseMove) {
        $('.active-state').removeClass('active-state');
      }
      if (useRipple) {
        rippleTouchMove();
      }
    }
    function handleMouseUp() {
      $('.active-state').removeClass('active-state');
      if (useRipple) {
        rippleTouchEnd();
      }
    }

    function handleTouchCancel() {
      targetElement = null;

      // Remove Active State
      clearTimeout(activeTimeout);
      clearTimeout(tapHoldTimeout);
      if (params.activeState) {
        removeActive();
      }

      // Remove Ripple
      if (useRipple) {
        rippleTouchEnd();
      }
    }

    function handleTouchStart(e) {
      isMoved = false;
      tapHoldFired = false;
      preventClick = false;
      if (e.targetTouches.length > 1) {
        if (activableElement) removeActive();
        return true;
      }
      if (e.touches.length > 1 && activableElement) {
        removeActive();
      }
      if (params.tapHold) {
        if (tapHoldTimeout) clearTimeout(tapHoldTimeout);
        tapHoldTimeout = setTimeout(() => {
          if (e && e.touches && e.touches.length > 1) return;
          tapHoldFired = true;
          e.preventDefault();
          preventClick = true;
          $(e.target).trigger('taphold', e);
          app.emit('taphold', e);
        }, params.tapHoldDelay);
      }
      targetElement = e.target;
      touchStartX = e.targetTouches[0].pageX;
      touchStartY = e.targetTouches[0].pageY;

      if (params.activeState) {
        activableElement = findActivableElement(targetElement);
        if (activableElement && !isInsideScrollableView(activableElement)) {
          addActive();
        } else if (activableElement) {
          activeTimeout = setTimeout(addActive, 80);
        }
      }
      if (useRipple) {
        rippleTouchStart(targetElement);
      }
      return true;
    }
    function handleTouchMove(e) {
      let touch;
      let distance;
      if (e.type === 'touchmove') {
        touch = e.targetTouches[0];
        distance = params.touchClicksDistanceThreshold;
      }

      if (distance && touch) {
        const pageX = touch.pageX;
        const pageY = touch.pageY;
        if (Math.abs(pageX - touchStartX) > distance || Math.abs(pageY - touchStartY) > distance) {
          isMoved = true;
        }
      } else {
        isMoved = true;
      }
      if (isMoved) {
        preventClick = true;
        if (params.tapHold) {
          clearTimeout(tapHoldTimeout);
        }
        if (params.activeState) {
          clearTimeout(activeTimeout);
          removeActive();
        }
        if (useRipple) {
          rippleTouchMove();
        }
      }
    }
    function handleTouchEnd(e) {
      clearTimeout(activeTimeout);
      clearTimeout(tapHoldTimeout);
      if (doc.activeElement === e.target) {
        if (params.activeState) removeActive();
        if (useRipple) {
          rippleTouchEnd();
        }
        return true;
      }
      if (params.activeState) {
        addActive();
        setTimeout(removeActive, 0);
      }
      if (useRipple) {
        rippleTouchEnd();
      }
      if ((params.tapHoldPreventClicks && tapHoldFired) || preventClick) {
        if (e.cancelable) e.preventDefault();
        preventClick = true;
        return false;
      }
      return true;
    }
    function handleClick(e) {
      const isOverswipe = e && e.detail && e.detail === 'f7Overswipe';
      let localPreventClick = preventClick;
      if (targetElement && e.target !== targetElement) {
        if (isOverswipe) {
          localPreventClick = false;
        } else {
          localPreventClick = true;
        }
      }
      if (params.tapHold && params.tapHoldPreventClicks && tapHoldFired) {
        localPreventClick = true;
      }
      if (localPreventClick) {
        e.stopImmediatePropagation();
        e.stopPropagation();
        e.preventDefault();
      }

      if (params.tapHold) {
        tapHoldTimeout = setTimeout(
          () => {
            tapHoldFired = false;
          },
          (Device.ios || Device.androidChrome ? 100 : 400)
        );
      }
      preventClick = false;
      targetElement = null;

      return !localPreventClick;
    }

    function emitAppTouchEvent(name, e) {
      app.emit({
        events: name,
        data: [e],
      });
    }
    function appClick(e) {
      emitAppTouchEvent('click', e);
    }
    function appTouchStartActive(e) {
      emitAppTouchEvent('touchstart touchstart:active', e);
    }
    function appTouchMoveActive(e) {
      emitAppTouchEvent('touchmove touchmove:active', e);
    }
    function appTouchEndActive(e) {
      emitAppTouchEvent('touchend touchend:active', e);
    }
    function appTouchStartPassive(e) {
      emitAppTouchEvent('touchstart:passive', e);
    }
    function appTouchMovePassive(e) {
      emitAppTouchEvent('touchmove:passive', e);
    }
    function appTouchEndPassive(e) {
      emitAppTouchEvent('touchend:passive', e);
    }
    function appGestureActive(e) {
      emitAppTouchEvent(`${e.type} ${e.type}:active`, e);
    }
    function appGesturePassive(e) {
      emitAppTouchEvent(`${e.type}:passive`, e);
    }


    const passiveListener = Support.passiveListener ? { passive: true } : false;
    const passiveListenerCapture = Support.passiveListener ? { passive: true, capture: true } : true;
    const activeListener = Support.passiveListener ? { passive: false } : false;
    const activeListenerCapture = Support.passiveListener ? { passive: false, capture: true } : true;

    doc.addEventListener('click', appClick, true);

    if (Support.passiveListener) {
      doc.addEventListener(app.touchEvents.start, appTouchStartActive, activeListenerCapture);
      doc.addEventListener(app.touchEvents.move, appTouchMoveActive, activeListener);
      doc.addEventListener(app.touchEvents.end, appTouchEndActive, activeListener);

      doc.addEventListener(app.touchEvents.start, appTouchStartPassive, passiveListenerCapture);
      doc.addEventListener(app.touchEvents.move, appTouchMovePassive, passiveListener);
      doc.addEventListener(app.touchEvents.end, appTouchEndPassive, passiveListener);
      if (Support.touch && Support.gestures) {
        doc.addEventListener('gesturestart', appGestureActive, activeListener);
        doc.addEventListener('gesturechange', appGestureActive, activeListener);
        doc.addEventListener('gestureend', appGestureActive, activeListener);

        doc.addEventListener('gesturestart', appGesturePassive, passiveListener);
        doc.addEventListener('gesturechange', appGesturePassive, passiveListener);
        doc.addEventListener('gestureend', appGesturePassive, passiveListener);
      }
    } else {
      doc.addEventListener(app.touchEvents.start, (e) => {
        appTouchStartActive(e);
        appTouchStartPassive(e);
      }, true);
      doc.addEventListener(app.touchEvents.move, (e) => {
        appTouchMoveActive(e);
        appTouchMovePassive(e);
      }, false);
      doc.addEventListener(app.touchEvents.end, (e) => {
        appTouchEndActive(e);
        appTouchEndPassive(e);
      }, false);
      if (Support.touch && Support.gestures) {
        doc.addEventListener('gesturestart', (e) => {
          appGestureActive(e);
          appGesturePassive(e);
        }, false);
        doc.addEventListener('gesturechange', (e) => {
          appGestureActive(e);
          appGesturePassive(e);
        }, false);
        doc.addEventListener('gestureend', (e) => {
          appGestureActive(e);
          appGesturePassive(e);
        }, false);
      }
    }

    if (Support.touch) {
      app.on('click', handleClick);
      app.on('touchstart', handleTouchStart);
      app.on('touchmove', handleTouchMove);
      app.on('touchend', handleTouchEnd);
      doc.addEventListener('touchcancel', handleTouchCancel, { passive: true });
    } else if (params.activeState) {
      app.on('touchstart', handleMouseDown);
      app.on('touchmove', handleMouseMove);
      app.on('touchend', handleMouseUp);
      doc.addEventListener('pointercancel', handleMouseUp, { passive: true });
    }
    doc.addEventListener('contextmenu', (e) => {
      if (params.disableContextMenu && (Device.ios || Device.android || Device.cordova)) {
        e.preventDefault();
      }
      if (useRipple) {
        if (activableElement) removeActive();
        rippleTouchEnd();
      }
    });
  }

  var TouchModule = {
    name: 'touch',
    params: {
      touch: {
        // Clicks
        touchClicksDistanceThreshold: 5,
        // ContextMenu
        disableContextMenu: false,
        // Tap Hold
        tapHold: false,
        tapHoldDelay: 750,
        tapHoldPreventClicks: true,
        // Active State
        activeState: true,
        activeStateElements: 'a, button, label, span, .actions-button, .stepper-button, .stepper-button-plus, .stepper-button-minus, .card-expandable, .menu-item, .link, .item-link, .accordion-item-toggle',
        activeStateOnMouseMove: false,
        mdTouchRipple: true,
        iosTouchRipple: false,
        auroraTouchRipple: false,
        touchRippleElements: '.ripple, .link, .item-link, .list-button, .links-list a, .button, button, .input-clear-button, .dialog-button, .tab-link, .item-radio, .item-checkbox, .actions-button, .searchbar-disable-button, .fab a, .checkbox, .radio, .data-table .sortable-cell:not(.input-cell), .notification-close-button, .stepper-button, .stepper-button-minus, .stepper-button-plus, .menu-item-content, .list.accordion-list .accordion-item-toggle',
      },
    },
    instance: {
      touchEvents: {
        start: Support.touch ? 'touchstart' : (Support.pointerEvents ? 'pointerdown' : 'mousedown'),
        move: Support.touch ? 'touchmove' : (Support.pointerEvents ? 'pointermove' : 'mousemove'),
        end: Support.touch ? 'touchend' : (Support.pointerEvents ? 'pointerup' : 'mouseup'),
      },
    },
    on: {
      init: initTouch,
    },
  };

  /**
   * Tokenize input string.
   */
  function lexer(str) {
      var tokens = [];
      var i = 0;
      while (i < str.length) {
          var char = str[i];
          if (char === "*" || char === "+" || char === "?") {
              tokens.push({ type: "MODIFIER", index: i, value: str[i++] });
              continue;
          }
          if (char === "\\") {
              tokens.push({ type: "ESCAPED_CHAR", index: i++, value: str[i++] });
              continue;
          }
          if (char === "{") {
              tokens.push({ type: "OPEN", index: i, value: str[i++] });
              continue;
          }
          if (char === "}") {
              tokens.push({ type: "CLOSE", index: i, value: str[i++] });
              continue;
          }
          if (char === ":") {
              var name = "";
              var j = i + 1;
              while (j < str.length) {
                  var code = str.charCodeAt(j);
                  if (
                  // `0-9`
                  (code >= 48 && code <= 57) ||
                      // `A-Z`
                      (code >= 65 && code <= 90) ||
                      // `a-z`
                      (code >= 97 && code <= 122) ||
                      // `_`
                      code === 95) {
                      name += str[j++];
                      continue;
                  }
                  break;
              }
              if (!name)
                  throw new TypeError("Missing parameter name at " + i);
              tokens.push({ type: "NAME", index: i, value: name });
              i = j;
              continue;
          }
          if (char === "(") {
              var count = 1;
              var pattern = "";
              var j = i + 1;
              if (str[j] === "?") {
                  throw new TypeError("Pattern cannot start with \"?\" at " + j);
              }
              while (j < str.length) {
                  if (str[j] === "\\") {
                      pattern += str[j++] + str[j++];
                      continue;
                  }
                  if (str[j] === ")") {
                      count--;
                      if (count === 0) {
                          j++;
                          break;
                      }
                  }
                  else if (str[j] === "(") {
                      count++;
                      if (str[j + 1] !== "?") {
                          throw new TypeError("Capturing groups are not allowed at " + j);
                      }
                  }
                  pattern += str[j++];
              }
              if (count)
                  throw new TypeError("Unbalanced pattern at " + i);
              if (!pattern)
                  throw new TypeError("Missing pattern at " + i);
              tokens.push({ type: "PATTERN", index: i, value: pattern });
              i = j;
              continue;
          }
          tokens.push({ type: "CHAR", index: i, value: str[i++] });
      }
      tokens.push({ type: "END", index: i, value: "" });
      return tokens;
  }
  /**
   * Parse a string for the raw tokens.
   */
  function parse(str, options) {
      if (options === void 0) { options = {}; }
      var tokens = lexer(str);
      var _a = options.prefixes, prefixes = _a === void 0 ? "./" : _a;
      var defaultPattern = "[^" + escapeString(options.delimiter || "/#?") + "]+?";
      var result = [];
      var key = 0;
      var i = 0;
      var path = "";
      var tryConsume = function (type) {
          if (i < tokens.length && tokens[i].type === type)
              return tokens[i++].value;
      };
      var mustConsume = function (type) {
          var value = tryConsume(type);
          if (value !== undefined)
              return value;
          var _a = tokens[i], nextType = _a.type, index = _a.index;
          throw new TypeError("Unexpected " + nextType + " at " + index + ", expected " + type);
      };
      var consumeText = function () {
          var result = "";
          var value;
          // tslint:disable-next-line
          while ((value = tryConsume("CHAR") || tryConsume("ESCAPED_CHAR"))) {
              result += value;
          }
          return result;
      };
      while (i < tokens.length) {
          var char = tryConsume("CHAR");
          var name = tryConsume("NAME");
          var pattern = tryConsume("PATTERN");
          if (name || pattern) {
              var prefix = char || "";
              if (prefixes.indexOf(prefix) === -1) {
                  path += prefix;
                  prefix = "";
              }
              if (path) {
                  result.push(path);
                  path = "";
              }
              result.push({
                  name: name || key++,
                  prefix: prefix,
                  suffix: "",
                  pattern: pattern || defaultPattern,
                  modifier: tryConsume("MODIFIER") || ""
              });
              continue;
          }
          var value = char || tryConsume("ESCAPED_CHAR");
          if (value) {
              path += value;
              continue;
          }
          if (path) {
              result.push(path);
              path = "";
          }
          var open = tryConsume("OPEN");
          if (open) {
              var prefix = consumeText();
              var name_1 = tryConsume("NAME") || "";
              var pattern_1 = tryConsume("PATTERN") || "";
              var suffix = consumeText();
              mustConsume("CLOSE");
              result.push({
                  name: name_1 || (pattern_1 ? key++ : ""),
                  pattern: name_1 && !pattern_1 ? defaultPattern : pattern_1,
                  prefix: prefix,
                  suffix: suffix,
                  modifier: tryConsume("MODIFIER") || ""
              });
              continue;
          }
          mustConsume("END");
      }
      return result;
  }
  /**
   * Compile a string to a template function for the path.
   */
  function compile(str, options) {
      return tokensToFunction(parse(str, options), options);
  }
  /**
   * Expose a method for transforming tokens into the path function.
   */
  function tokensToFunction(tokens, options) {
      if (options === void 0) { options = {}; }
      var reFlags = flags(options);
      var _a = options.encode, encode = _a === void 0 ? function (x) { return x; } : _a, _b = options.validate, validate = _b === void 0 ? true : _b;
      // Compile all the tokens into regexps.
      var matches = tokens.map(function (token) {
          if (typeof token === "object") {
              return new RegExp("^(?:" + token.pattern + ")$", reFlags);
          }
      });
      return function (data) {
          var path = "";
          for (var i = 0; i < tokens.length; i++) {
              var token = tokens[i];
              if (typeof token === "string") {
                  path += token;
                  continue;
              }
              var value = data ? data[token.name] : undefined;
              var optional = token.modifier === "?" || token.modifier === "*";
              var repeat = token.modifier === "*" || token.modifier === "+";
              if (Array.isArray(value)) {
                  if (!repeat) {
                      throw new TypeError("Expected \"" + token.name + "\" to not repeat, but got an array");
                  }
                  if (value.length === 0) {
                      if (optional)
                          continue;
                      throw new TypeError("Expected \"" + token.name + "\" to not be empty");
                  }
                  for (var j = 0; j < value.length; j++) {
                      var segment = encode(value[j], token);
                      if (validate && !matches[i].test(segment)) {
                          throw new TypeError("Expected all \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                      }
                      path += token.prefix + segment + token.suffix;
                  }
                  continue;
              }
              if (typeof value === "string" || typeof value === "number") {
                  var segment = encode(String(value), token);
                  if (validate && !matches[i].test(segment)) {
                      throw new TypeError("Expected \"" + token.name + "\" to match \"" + token.pattern + "\", but got \"" + segment + "\"");
                  }
                  path += token.prefix + segment + token.suffix;
                  continue;
              }
              if (optional)
                  continue;
              var typeOfMessage = repeat ? "an array" : "a string";
              throw new TypeError("Expected \"" + token.name + "\" to be " + typeOfMessage);
          }
          return path;
      };
  }
  /**
   * Escape a regular expression string.
   */
  function escapeString(str) {
      return str.replace(/([.+*?=^!:${}()[\]|/\\])/g, "\\$1");
  }
  /**
   * Get the flags for a regexp from the options.
   */
  function flags(options) {
      return options && options.sensitive ? "" : "i";
  }
  /**
   * Pull out keys from a regexp.
   */
  function regexpToRegexp(path, keys) {
      if (!keys)
          return path;
      // Use a negative lookahead to match only capturing groups.
      var groups = path.source.match(/\((?!\?)/g);
      if (groups) {
          for (var i = 0; i < groups.length; i++) {
              keys.push({
                  name: i,
                  prefix: "",
                  suffix: "",
                  modifier: "",
                  pattern: ""
              });
          }
      }
      return path;
  }
  /**
   * Transform an array into a regexp.
   */
  function arrayToRegexp(paths, keys, options) {
      var parts = paths.map(function (path) { return pathToRegexp(path, keys, options).source; });
      return new RegExp("(?:" + parts.join("|") + ")", flags(options));
  }
  /**
   * Create a path regexp from string input.
   */
  function stringToRegexp(path, keys, options) {
      return tokensToRegexp(parse(path, options), keys, options);
  }
  /**
   * Expose a function for taking tokens and returning a RegExp.
   */
  function tokensToRegexp(tokens, keys, options) {
      if (options === void 0) { options = {}; }
      var _a = options.strict, strict = _a === void 0 ? false : _a, _b = options.start, start = _b === void 0 ? true : _b, _c = options.end, end = _c === void 0 ? true : _c, _d = options.encode, encode = _d === void 0 ? function (x) { return x; } : _d;
      var endsWith = "[" + escapeString(options.endsWith || "") + "]|$";
      var delimiter = "[" + escapeString(options.delimiter || "/#?") + "]";
      var route = start ? "^" : "";
      // Iterate over the tokens and create our regexp string.
      for (var _i = 0, tokens_1 = tokens; _i < tokens_1.length; _i++) {
          var token = tokens_1[_i];
          if (typeof token === "string") {
              route += escapeString(encode(token));
          }
          else {
              var prefix = escapeString(encode(token.prefix));
              var suffix = escapeString(encode(token.suffix));
              if (token.pattern) {
                  if (keys)
                      keys.push(token);
                  if (prefix || suffix) {
                      if (token.modifier === "+" || token.modifier === "*") {
                          var mod = token.modifier === "*" ? "?" : "";
                          route += "(?:" + prefix + "((?:" + token.pattern + ")(?:" + suffix + prefix + "(?:" + token.pattern + "))*)" + suffix + ")" + mod;
                      }
                      else {
                          route += "(?:" + prefix + "(" + token.pattern + ")" + suffix + ")" + token.modifier;
                      }
                  }
                  else {
                      route += "(" + token.pattern + ")" + token.modifier;
                  }
              }
              else {
                  route += "(?:" + prefix + suffix + ")" + token.modifier;
              }
          }
      }
      if (end) {
          if (!strict)
              route += delimiter + "?";
          route += !options.endsWith ? "$" : "(?=" + endsWith + ")";
      }
      else {
          var endToken = tokens[tokens.length - 1];
          var isEndDelimited = typeof endToken === "string"
              ? delimiter.indexOf(endToken[endToken.length - 1]) > -1
              : // tslint:disable-next-line
                  endToken === undefined;
          if (!strict) {
              route += "(?:" + delimiter + "(?=" + endsWith + "))?";
          }
          if (!isEndDelimited) {
              route += "(?=" + delimiter + "|" + endsWith + ")";
          }
      }
      return new RegExp(route, flags(options));
  }
  /**
   * Normalize the given path string, returning a regular expression.
   *
   * An empty array can be passed in for the keys, which will hold the
   * placeholder key descriptions. For example, using `/user/:id`, `keys` will
   * contain `[{ name: 'id', delimiter: '/', optional: false, repeat: false }]`.
   */
  function pathToRegexp(path, keys, options) {
      if (path instanceof RegExp)
          return regexpToRegexp(path, keys);
      if (Array.isArray(path))
          return arrayToRegexp(path, keys, options);
      return stringToRegexp(path, keys, options);
  }

  const History = {
    queue: [],
    clearQueue() {
      if (History.queue.length === 0) return;
      const currentQueue = History.queue.shift();
      currentQueue();
    },
    routerQueue: [],
    clearRouterQueue() {
      if (History.routerQueue.length === 0) return;
      const currentQueue = History.routerQueue.pop();
      const { router, stateUrl, action } = currentQueue;

      let animate = router.params.animate;
      if (router.params.pushStateAnimate === false) animate = false;

      if (action === 'back') {
        router.back({ animate, pushState: false });
      }
      if (action === 'load') {
        router.navigate(stateUrl, { animate, pushState: false });
      }
    },
    handle(e) {
      if (History.blockPopstate) return;
      const app = this;
      // const mainView = app.views.main;
      let state = e.state;
      History.previousState = History.state;
      History.state = state;

      History.allowChange = true;
      History.clearQueue();

      state = History.state;
      if (!state) state = {};

      app.views.forEach((view) => {
        const router = view.router;
        let viewState = state[view.id];
        if (!viewState && view.params.pushState) {
          viewState = {
            url: view.router.history[0],
          };
        }
        if (!viewState) return;
        const stateUrl = viewState.url || undefined;

        let animate = router.params.animate;
        if (router.params.pushStateAnimate === false) animate = false;

        if (stateUrl !== router.url) {
          if (router.history.indexOf(stateUrl) >= 0) {
            // Go Back
            if (router.allowPageChange) {
              router.back({ animate, pushState: false });
            } else {
              History.routerQueue.push({
                action: 'back',
                router,
              });
            }
          } else if (router.allowPageChange) {
            // Load page
            router.navigate(stateUrl, { animate, pushState: false });
          } else {
            History.routerQueue.unshift({
              action: 'load',
              stateUrl,
              router,
            });
          }
        }
      });
    },
    initViewState(viewId, viewState) {
      const newState = Utils.extend({}, (History.state || {}), {
        [viewId]: viewState,
      });
      History.state = newState;
      win.history.replaceState(newState, '');
    },
    push(viewId, viewState, url) {
      if (!History.allowChange) {
        History.queue.push(() => {
          History.push(viewId, viewState, url);
        });
        return;
      }
      History.previousState = History.state;
      const newState = Utils.extend({}, (History.previousState || {}), {
        [viewId]: viewState,
      });
      History.state = newState;
      win.history.pushState(newState, '', url);
    },
    replace(viewId, viewState, url) {
      if (!History.allowChange) {
        History.queue.push(() => {
          History.replace(viewId, viewState, url);
        });
        return;
      }
      History.previousState = History.state;
      const newState = Utils.extend({}, (History.previousState || {}), {
        [viewId]: viewState,
      });
      History.state = newState;
      win.history.replaceState(newState, '', url);
    },
    go(index) {
      History.allowChange = false;
      win.history.go(index);
    },
    back() {
      History.allowChange = false;
      win.history.back();
    },
    allowChange: true,
    previousState: {},
    state: win.history.state,
    blockPopstate: true,
    init(app) {
      $(win).on('load', () => {
        setTimeout(() => {
          History.blockPopstate = false;
        }, 0);
      });

      if (doc.readyState && doc.readyState === 'complete') {
        History.blockPopstate = false;
      }

      $(win).on('popstate', History.handle.bind(app));
    },
  };

  function SwipeBack(r) {
    const router = r;
    const { $el, $navbarsEl, app, params } = router;
    let isTouched = false;
    let isMoved = false;
    const touchesStart = {};
    let isScrolling;
    let $currentPageEl = [];
    let $previousPageEl = [];
    let viewContainerWidth;
    let touchesDiff;
    let allowViewTouchMove = true;
    let touchStartTime;
    let $currentNavbarEl = [];
    let $previousNavbarEl = [];
    let dynamicNavbar;
    let $pageShadowEl;
    let $pageOpacityEl;

    let animatableNavEls;

    const paramsSwipeBackAnimateShadow = params[`${app.theme}SwipeBackAnimateShadow`];
    const paramsSwipeBackAnimateOpacity = params[`${app.theme}SwipeBackAnimateOpacity`];
    const paramsSwipeBackActiveArea = params[`${app.theme}SwipeBackActiveArea`];
    const paramsSwipeBackThreshold = params[`${app.theme}SwipeBackThreshold`];

    const transformOrigin = app.rtl ? 'right center' : 'left center';
    const transformOriginTitleLarge = app.rtl
      ? 'calc(100% - var(--f7-navbar-large-title-padding-left) - var(--f7-safe-area-left)) center'
      : 'calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center';


    function animatableNavElements() {
      const els = [];
      const inverter = app.rtl ? -1 : 1;
      const currentNavIsTransparent = $currentNavbarEl.hasClass('navbar-transparent') && !$currentNavbarEl.hasClass('navbar-large') && !$currentNavbarEl.hasClass('navbar-transparent-visible');
      const currentNavIsLarge = $currentNavbarEl.hasClass('navbar-large');
      const currentNavIsCollapsed = $currentNavbarEl.hasClass('navbar-large-collapsed');
      const currentNavIsLargeTransparent = $currentNavbarEl.hasClass('navbar-large-transparent')
        || (
          $currentNavbarEl.hasClass('navbar-large')
          && $currentNavbarEl.hasClass('navbar-transparent')
        );
      const previousNavIsTransparent = $previousNavbarEl.hasClass('navbar-transparent') && !$previousNavbarEl.hasClass('navbar-large') && !$previousNavbarEl.hasClass('navbar-transparent-visible');
      const previousNavIsLarge = $previousNavbarEl.hasClass('navbar-large');
      const previousNavIsCollapsed = $previousNavbarEl.hasClass('navbar-large-collapsed');
      const previousNavIsLargeTransparent = $previousNavbarEl.hasClass('navbar-large-transparent')
        || (
          $previousNavbarEl.hasClass('navbar-large')
          && $previousNavbarEl.hasClass('navbar-transparent')
        );
      const fromLarge = currentNavIsLarge && !currentNavIsCollapsed;
      const toLarge = previousNavIsLarge && !previousNavIsCollapsed;
      const $currentNavElements = $currentNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
      const $previousNavElements = $previousNavbarEl.find('.left, .title, .right, .subnavbar, .fading, .title-large, .navbar-bg');
      let activeNavBackIconText;
      let previousNavBackIconText;

      if (params.iosAnimateNavbarBackIcon) {
        if ($currentNavbarEl.hasClass('sliding') || $currentNavbarEl.find('.navbar-inner.sliding').length) {
          activeNavBackIconText = $currentNavbarEl.find('.left').find('.back .icon + span').eq(0);
        } else {
          activeNavBackIconText = $currentNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
        }
        if ($previousNavbarEl.hasClass('sliding') || $previousNavbarEl.find('.navbar-inner.sliding').length) {
          previousNavBackIconText = $previousNavbarEl.find('.left').find('.back .icon + span').eq(0);
        } else {
          previousNavBackIconText = $previousNavbarEl.find('.left.sliding').find('.back .icon + span').eq(0);
        }
        if (activeNavBackIconText.length) {
          $previousNavElements.each((index, el) => {
            if (!$(el).hasClass('title')) return;
            el.f7NavbarLeftOffset += activeNavBackIconText.prev('.icon')[0].offsetWidth;
          });
        }
      }
      $currentNavElements
        .each((index, navEl) => {
          const $navEl = $(navEl);
          const isSubnavbar = $navEl.hasClass('subnavbar');
          const isLeft = $navEl.hasClass('left');
          const isTitle = $navEl.hasClass('title');
          const isBg = $navEl.hasClass('navbar-bg');
          if ((isTitle || isBg) && currentNavIsTransparent) return;
          if (!fromLarge && $navEl.hasClass('.title-large')) return;
          const el = {
            el: navEl,
          };
          if (fromLarge) {
            if (isTitle) return;
            if ($navEl.hasClass('title-large')) {
              if (els.indexOf(el) < 0) els.push(el);
              el.overflow = 'visible';
              $navEl.find('.title-large-text').each((subIndex, subNavEl) => {
                els.push({
                  el: subNavEl,
                  transform: progress => `translateX(${progress * 100 * inverter}%)`,
                });
              });
              return;
            }
          }
          if (toLarge) {
            if (!fromLarge) {
              if ($navEl.hasClass('title-large')) {
                if (els.indexOf(el) < 0) els.push(el);
                el.opacity = 0;
              }
            }
            if (isLeft) {
              if (els.indexOf(el) < 0) els.push(el);
              el.opacity = progress => (1 - (progress ** 0.33));
              $navEl.find('.back span').each((subIndex, subNavEl) => {
                els.push({
                  el: subNavEl,
                  'transform-origin': transformOrigin,
                  transform: progress => `translateX(calc(${progress} * (var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset)))) translateY(calc(${progress} * (var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2))) scale(${1 + (1 * progress)})`,
                });
              });
              return;
            }
          }
          if (isBg) {
            if (els.indexOf(el) < 0) els.push(el);
            if (!fromLarge && !toLarge) {
              if (currentNavIsCollapsed) {
                if (currentNavIsLargeTransparent) {
                  el.className = 'ios-swipeback-navbar-bg-large';
                }
                el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`;
              } else {
                el.transform = progress => `translateX(${100 * progress * inverter}%)`;
              }
            }
            if (!fromLarge && toLarge) {
              el.className = 'ios-swipeback-navbar-bg-large';
              el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-1 * ${1 - progress} * var(--f7-navbar-large-title-height)))`;
            }
            if (fromLarge && toLarge) {
              el.transform = progress => `translateX(${100 * progress * inverter}%)`;
            }
            if (fromLarge && !toLarge) {
              el.transform = progress => `translateX(${100 * progress * inverter}%) translateY(calc(-${progress} * var(--f7-navbar-large-title-height)))`;
            }
            return;
          }
          if ($navEl.hasClass('title-large')) return;
          const isSliding = $navEl.hasClass('sliding') || $navEl.parents('.navbar-inner.sliding').length;
          if (els.indexOf(el) < 0) els.push(el);
          if (!isSubnavbar || (isSubnavbar && !isSliding)) {
            el.opacity = progress => (1 - (progress ** 0.33));
          }
          if (isSliding) {
            let transformTarget = el;
            if (isLeft && activeNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
              const textEl = { el: activeNavBackIconText[0] };
              transformTarget = textEl;
              els.push(textEl);
            }
            transformTarget.transform = (progress) => {
              let activeNavTranslate = progress * transformTarget.el.f7NavbarRightOffset;
              if (Device.pixelRatio === 1) activeNavTranslate = Math.round(activeNavTranslate);
              if (isSubnavbar && currentNavIsLarge) {
                return `translate3d(${activeNavTranslate}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`;
              }
              return `translate3d(${activeNavTranslate}px,0,0)`;
            };
          }
        });
      $previousNavElements
        .each((index, navEl) => {
          const $navEl = $(navEl);
          const isSubnavbar = $navEl.hasClass('subnavbar');
          const isLeft = $navEl.hasClass('left');
          const isTitle = $navEl.hasClass('title');
          const isBg = $navEl.hasClass('navbar-bg');
          if ((isTitle || isBg) && previousNavIsTransparent) return;
          const el = {
            el: navEl,
          };
          if (toLarge) {
            if (isTitle) return;
            if (els.indexOf(el) < 0) els.push(el);

            if ($navEl.hasClass('title-large')) {
              el.opacity = 1;
              el.overflow = 'visible';
              $navEl.find('.title-large-text').each((subIndex, subNavEl) => {
                els.push({
                  el: subNavEl,
                  'transform-origin': transformOriginTitleLarge,
                  opacity: progress => (progress ** 3),
                  transform: progress => `translateX(calc(${1 - progress} * (var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset)))) translateY(calc(${progress - 1} * var(--f7-navbar-large-title-height) + ${1 - progress} * var(--f7-navbar-large-title-padding-vertical))) scale(${0.5 + progress * 0.5})`,
                });
              });
              return;
            }
          }
          if (isBg) {
            if (els.indexOf(el) < 0) els.push(el);
            if (!fromLarge && !toLarge) {
              if (previousNavIsCollapsed) {
                if (previousNavIsLargeTransparent) {
                  el.className = 'ios-swipeback-navbar-bg-large';
                }
                el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-1 * var(--f7-navbar-large-title-height)))`;
              } else {
                el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%)`;
              }
            }
            if (!fromLarge && toLarge) {
              el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-1 * ${1 - progress} * var(--f7-navbar-large-title-height)))`;
            }
            if (fromLarge && !toLarge) {
              el.className = 'ios-swipeback-navbar-bg-large';
              el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%) translateY(calc(-${progress} * var(--f7-navbar-large-title-height)))`;
            }
            if (fromLarge && toLarge) {
              el.transform = progress => `translateX(${(-100 + 100 * progress) * inverter}%)`;
            }

            return;
          }
          if ($navEl.hasClass('title-large')) return;
          const isSliding = $navEl.hasClass('sliding') || $previousNavbarEl.children('.navbar-inner.sliding').length;
          if (els.indexOf(el) < 0) els.push(el);
          if (!isSubnavbar || (isSubnavbar && !isSliding)) {
            el.opacity = progress => (progress ** 3);
          }
          if (isSliding) {
            let transformTarget = el;
            if (isLeft && previousNavBackIconText.length && params.iosAnimateNavbarBackIcon) {
              const textEl = { el: previousNavBackIconText[0] };
              transformTarget = textEl;
              els.push(textEl);
            }
            transformTarget.transform = (progress) => {
              let previousNavTranslate = transformTarget.el.f7NavbarLeftOffset * (1 - progress);
              if (Device.pixelRatio === 1) previousNavTranslate = Math.round(previousNavTranslate);
              if (isSubnavbar && previousNavIsLarge) {
                return `translate3d(${previousNavTranslate}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`;
              }
              return `translate3d(${previousNavTranslate}px,0,0)`;
            };
          }
        });
      return els;
    }

    function setAnimatableNavElements({ progress, reset, transition } = {}) {
      const styles = ['overflow', 'transform', 'transform-origin', 'opacity'];
      for (let i = 0; i < animatableNavEls.length; i += 1) {
        const el = animatableNavEls[i];
        if (el && el.el) {
          if (transition === true) el.el.classList.add('navbar-page-transitioning');
          if (transition === false) el.el.classList.remove('navbar-page-transitioning');
          if (el.className && !el.classNameSet && !reset) {
            el.el.classList.add(el.className);
            el.classNameSet = true;
          }
          if (el.className && reset) {
            el.el.classList.remove(el.className);
          }
          for (let j = 0; j < styles.length; j += 1) {
            const styleProp = styles[j];
            if (el[styleProp]) {
              if (reset) {
                el.el.style[styleProp] = '';
              } else if (typeof el[styleProp] === 'function') {
                el.el.style[styleProp] = el[styleProp](progress);
              } else {
                el.el.style[styleProp] = el[styleProp];
              }
            }
          }
        }
      }
    }

    function handleTouchStart(e) {
      const swipeBackEnabled = params[`${app.theme}SwipeBack`];
      if (!allowViewTouchMove || !swipeBackEnabled || isTouched || (app.swipeout && app.swipeout.el) || !router.allowPageChange) return;
      if ($(e.target).closest('.range-slider, .calendar-months').length > 0) return;
      if ($(e.target).closest('.page-master, .page-master-detail').length > 0 && params.masterDetailBreakpoint > 0 && app.width >= params.masterDetailBreakpoint) return;
      isMoved = false;
      isTouched = true;
      isScrolling = undefined;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchStartTime = Utils.now();
      dynamicNavbar = router.dynamicNavbar;
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x)) || (pageX < touchesStart.x && !app.rtl) || (pageX > touchesStart.x && app.rtl);
      }
      if (isScrolling || e.f7PreventSwipeBack || app.preventSwipeBack) {
        isTouched = false;
        return;
      }
      if (!isMoved) {
        // Calc values during first move fired
        let cancel = false;
        const target = $(e.target);

        const swipeout = target.closest('.swipeout');
        if (swipeout.length > 0) {
          if (!app.rtl && swipeout.find('.swipeout-actions-left').length > 0) cancel = true;
          if (app.rtl && swipeout.find('.swipeout-actions-right').length > 0) cancel = true;
        }

        $currentPageEl = target.closest('.page');
        if ($currentPageEl.hasClass('no-swipeback') || target.closest('.no-swipeback, .card-opened').length > 0) cancel = true;
        $previousPageEl = $el.find('.page-previous:not(.stacked)');
        if ($previousPageEl.length > 1) {
          $previousPageEl = $previousPageEl.eq($previousPageEl.length - 1);
        }
        let notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
        viewContainerWidth = $el.width();
        if (app.rtl) {
          notFromBorder = touchesStart.x < ($el.offset().left - $el[0].scrollLeft) + (viewContainerWidth - paramsSwipeBackActiveArea);
        } else {
          notFromBorder = touchesStart.x - $el.offset().left > paramsSwipeBackActiveArea;
        }
        if (notFromBorder) cancel = true;
        if ($previousPageEl.length === 0 || $currentPageEl.length === 0) cancel = true;
        if (cancel) {
          isTouched = false;
          return;
        }

        if (paramsSwipeBackAnimateShadow) {
          $pageShadowEl = $currentPageEl.find('.page-shadow-effect');
          if ($pageShadowEl.length === 0) {
            $pageShadowEl = $('<div class="page-shadow-effect"></div>');
            $currentPageEl.append($pageShadowEl);
          }
        }
        if (paramsSwipeBackAnimateOpacity) {
          $pageOpacityEl = $previousPageEl.find('.page-opacity-effect');
          if ($pageOpacityEl.length === 0) {
            $pageOpacityEl = $('<div class="page-opacity-effect"></div>');
            $previousPageEl.append($pageOpacityEl);
          }
        }

        if (dynamicNavbar) {
          $currentNavbarEl = $navbarsEl.find('.navbar-current:not(.stacked)');
          $previousNavbarEl = $navbarsEl.find('.navbar-previous:not(.stacked)');
          if ($previousNavbarEl.length > 1) {
            $previousNavbarEl = $previousNavbarEl.eq($previousNavbarEl.length - 1);
          }

          animatableNavEls = animatableNavElements();
        }

        // Close/Hide Any Picker
        if ($('.sheet.modal-in').length > 0 && app.sheet) {
          app.sheet.close($('.sheet.modal-in'));
        }
      }
      e.f7PreventSwipePanel = true;
      isMoved = true;
      app.preventSwipePanelBySwipeBack = true;
      e.preventDefault();

      // RTL inverter
      const inverter = app.rtl ? -1 : 1;

      // Touches diff
      touchesDiff = (pageX - touchesStart.x - paramsSwipeBackThreshold) * inverter;
      if (touchesDiff < 0) touchesDiff = 0;
      const percentage = Math.min(Math.max(touchesDiff / viewContainerWidth, 0), 1);

      // Swipe Back Callback
      const callbackData = {
        percentage,
        progress: percentage,
        currentPageEl: $currentPageEl[0],
        previousPageEl: $previousPageEl[0],
        currentNavbarEl: $currentNavbarEl[0],
        previousNavbarEl: $previousNavbarEl[0],
      };
      $el.trigger('swipeback:move', callbackData);
      router.emit('swipebackMove', callbackData);

      // Transform pages
      let currentPageTranslate = touchesDiff * inverter;
      let previousPageTranslate = ((touchesDiff / 5) - (viewContainerWidth / 5)) * inverter;
      if (!app.rtl) {
        currentPageTranslate = Math.min(currentPageTranslate, viewContainerWidth);
        previousPageTranslate = Math.min(previousPageTranslate, 0);
      } else {
        currentPageTranslate = Math.max(currentPageTranslate, -viewContainerWidth);
        previousPageTranslate = Math.max(previousPageTranslate, 0);
      }
      if (Device.pixelRatio === 1) {
        currentPageTranslate = Math.round(currentPageTranslate);
        previousPageTranslate = Math.round(previousPageTranslate);
      }

      router.swipeBackActive = true;
      $([$currentPageEl[0], $previousPageEl[0]]).addClass('page-swipeback-active');

      $currentPageEl.transform(`translate3d(${currentPageTranslate}px,0,0)`);
      if (paramsSwipeBackAnimateShadow) $pageShadowEl[0].style.opacity = 1 - (1 * percentage);

      if (app.theme === 'ios') {
        $previousPageEl.transform(`translate3d(${previousPageTranslate}px,0,0)`);
      }
      if (paramsSwipeBackAnimateOpacity) $pageOpacityEl[0].style.opacity = 1 - (1 * percentage);

      // Dynamic Navbars Animation
      if (!dynamicNavbar) return;

      setAnimatableNavElements({ progress: percentage });
    }
    function handleTouchEnd() {
      app.preventSwipePanelBySwipeBack = false;
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;
      router.swipeBackActive = false;
      $([$currentPageEl[0], $previousPageEl[0]]).removeClass('page-swipeback-active');
      if (touchesDiff === 0) {
        $([$currentPageEl[0], $previousPageEl[0]]).transform('');
        if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
        if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
        if (dynamicNavbar) {
          setAnimatableNavElements({ reset: true });
        }
        return;
      }
      const timeDiff = Utils.now() - touchStartTime;
      let pageChanged = false;
      // Swipe back to previous page
      if (
        (timeDiff < 300 && touchesDiff > 10)
        || (timeDiff >= 300 && touchesDiff > viewContainerWidth / 2)
      ) {
        $currentPageEl.removeClass('page-current').addClass(`page-next${app.theme !== 'ios' ? ' page-next-on-right' : ''}`);
        $previousPageEl.removeClass('page-previous').addClass('page-current').removeAttr('aria-hidden');
        if ($pageShadowEl) $pageShadowEl[0].style.opacity = '';
        if ($pageOpacityEl) $pageOpacityEl[0].style.opacity = '';
        if (dynamicNavbar) {
          router.setNavbarPosition($currentNavbarEl, 'next');
          router.setNavbarPosition($previousNavbarEl, 'current', false);
        }
        pageChanged = true;
      }
      // Reset custom styles
      // Add transitioning class for transition-duration
      $([$currentPageEl[0], $previousPageEl[0]]).addClass('page-transitioning page-transitioning-swipeback').transform('');

      if (dynamicNavbar) {
        setAnimatableNavElements({ progress: pageChanged ? 1 : 0, transition: true });
      }
      allowViewTouchMove = false;
      router.allowPageChange = false;

      // Swipe Back Callback
      const callbackData = {
        currentPageEl: $currentPageEl[0],
        previousPageEl: $previousPageEl[0],
        currentNavbarEl: $currentNavbarEl[0],
        previousNavbarEl: $previousNavbarEl[0],
      };

      if (pageChanged) {
        // Update Route
        router.currentRoute = $previousPageEl[0].f7Page.route;
        router.currentPage = $previousPageEl[0];

        // Page before animation callback
        router.pageCallback('beforeOut', $currentPageEl, $currentNavbarEl, 'current', 'next', { route: $currentPageEl[0].f7Page.route, swipeBack: true });
        router.pageCallback('beforeIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', { route: $previousPageEl[0].f7Page.route, swipeBack: true }, $currentPageEl[0]);

        $el.trigger('swipeback:beforechange', callbackData);
        router.emit('swipebackBeforeChange', callbackData);
      } else {
        $el.trigger('swipeback:beforereset', callbackData);
        router.emit('swipebackBeforeReset', callbackData);
      }

      $currentPageEl.transitionEnd(() => {
        $([$currentPageEl[0], $previousPageEl[0]]).removeClass('page-transitioning page-transitioning-swipeback');
        if (dynamicNavbar) {
          setAnimatableNavElements({ reset: true, transition: false });
        }
        allowViewTouchMove = true;
        router.allowPageChange = true;
        if (pageChanged) {
          // Update History
          if (router.history.length === 1) {
            router.history.unshift(router.url);
          }
          router.history.pop();
          router.saveHistory();

          // Update push state
          if (params.pushState) {
            History.back();
          }

          // Page after animation callback
          router.pageCallback('afterOut', $currentPageEl, $currentNavbarEl, 'current', 'next', { route: $currentPageEl[0].f7Page.route, swipeBack: true });
          router.pageCallback('afterIn', $previousPageEl, $previousNavbarEl, 'previous', 'current', { route: $previousPageEl[0].f7Page.route, swipeBack: true });

          // Remove Old Page
          if (params.stackPages && router.initialPages.indexOf($currentPageEl[0]) >= 0) {
            $currentPageEl.addClass('stacked');
            if (dynamicNavbar) {
              $currentNavbarEl.addClass('stacked');
            }
          } else {
            router.pageCallback('beforeRemove', $currentPageEl, $currentNavbarEl, 'next', { swipeBack: true });
            router.removePage($currentPageEl);
            if (dynamicNavbar) {
              router.removeNavbar($currentNavbarEl);
            }
          }

          $el.trigger('swipeback:afterchange', callbackData);
          router.emit('swipebackAfterChange', callbackData);

          router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

          if (params.preloadPreviousPage) {
            router.back(router.history[router.history.length - 2], { preload: true });
          }
        } else {
          $el.trigger('swipeback:afterreset', callbackData);
          router.emit('swipebackAfterReset', callbackData);
        }
        if ($pageShadowEl && $pageShadowEl.length > 0) $pageShadowEl.remove();
        if ($pageOpacityEl && $pageOpacityEl.length > 0) $pageOpacityEl.remove();
      });
    }

    function attachEvents() {
      const passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
      $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
    }
    function detachEvents() {
      const passiveListener = (app.touchEvents.start === 'touchstart' && Support.passiveListener) ? { passive: true, capture: false } : false;
      $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
    }

    attachEvents();

    router.on('routerDestroy', detachEvents);
  }

  function redirect (direction, route, options) {
    const router = this;
    const redirect = route.route.redirect;
    if (options.initial && router.params.pushState) {
      options.replaceState = true; // eslint-disable-line
      options.history = true; // eslint-disable-line
    }
    function redirectResolve(redirectUrl, redirectOptions = {}) {
      router.allowPageChange = true;
      router[direction](redirectUrl, Utils.extend({}, options, redirectOptions));
    }
    function redirectReject() {
      router.allowPageChange = true;
    }
    if (typeof redirect === 'function') {
      router.allowPageChange = false;
      const redirectUrl = redirect.call(router, route, redirectResolve, redirectReject);
      if (redirectUrl && typeof redirectUrl === 'string') {
        router.allowPageChange = true;
        return router[direction](redirectUrl, options);
      }
      return router;
    }
    return router[direction](redirect, options);
  }

  function processQueue(router, routerQueue, routeQueue, to, from, resolve, reject) {
    const queue = [];

    if (Array.isArray(routeQueue)) {
      queue.push(...routeQueue);
    } else if (routeQueue && typeof routeQueue === 'function') {
      queue.push(routeQueue);
    }
    if (routerQueue) {
      if (Array.isArray(routerQueue)) {
        queue.push(...routerQueue);
      } else {
        queue.push(routerQueue);
      }
    }

    function next() {
      if (queue.length === 0) {
        resolve();
        return;
      }
      const queueItem = queue.shift();

      queueItem.call(
        router,
        to,
        from,
        () => {
          next();
        },
        () => {
          reject();
        }
      );
    }
    next();
  }

  function processRouteQueue (to, from, resolve, reject) {
    const router = this;
    function enterNextRoute() {
      if (to && to.route && (router.params.routesBeforeEnter || to.route.beforeEnter)) {
        router.allowPageChange = false;
        processQueue(
          router,
          router.params.routesBeforeEnter,
          to.route.beforeEnter,
          to,
          from,
          () => {
            router.allowPageChange = true;
            resolve();
          },
          () => {
            reject();
          },
        );
      } else {
        resolve();
      }
    }
    function leaveCurrentRoute() {
      if (from && from.route && (router.params.routesBeforeLeave || from.route.beforeLeave)) {
        router.allowPageChange = false;
        processQueue(
          router,
          router.params.routesBeforeLeave,
          from.route.beforeLeave,
          to,
          from,
          () => {
            router.allowPageChange = true;
            enterNextRoute();
          },
          () => {
            reject();
          },
        );
      } else {
        enterNextRoute();
      }
    }
    leaveCurrentRoute();
  }

  function appRouterCheck (router, method) {
    if (!router.view) {
      throw new Error(`Framework7: it is not allowed to use router methods on global app router. Use router methods only on related View, e.g. app.views.main.router.${method}(...)`);
    }
  }

  function asyncComponent (router, asyncComponent, resolve, reject) {
    function resolvePromise(componentPromise) {
      componentPromise
        .then((c) => {
          // eslint-disable-next-line
          resolve({ component: c.default || c._default || c });
        })
        .catch((err) => {
          reject();
          throw new Error(err);
        });
    }
    if (asyncComponent instanceof Promise) {
      resolvePromise(asyncComponent);
      return;
    }
    const asyncComponentResult = asyncComponent.call(router);
    if (asyncComponentResult instanceof Promise) {
      resolvePromise(asyncComponentResult);
    } else {
      resolve({ component: asyncComponentResult });
    }
  }

  function refreshPage() {
    const router = this;
    appRouterCheck(router, 'refreshPage');
    return router.navigate(router.currentRoute.url, {
      ignoreCache: true,
      reloadCurrent: true,
    });
  }

  function forward(el, forwardOptions = {}) {
    const router = this;
    const $el = $(el);
    const app = router.app;
    const view = router.view;
    const options = Utils.extend(false, {
      animate: router.params.animate,
      pushState: true,
      replaceState: false,
      history: true,
      reloadCurrent: router.params.reloadPages,
      reloadPrevious: false,
      reloadAll: false,
      clearPreviousHistory: false,
      reloadDetail: router.params.reloadDetail,
      on: {},
    }, forwardOptions);

    const masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
    const isMaster = masterDetailEnabled && options.route && options.route.route && options.route.route.master === true;
    let masterPageEl;
    let otherDetailPageEl;

    let currentRouteIsModal = router.currentRoute.modal;
    let modalType;
    if (!currentRouteIsModal) {
      ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach((modalLoadProp) => {
        if (router.currentRoute && router.currentRoute.route && router.currentRoute.route[modalLoadProp]) {
          currentRouteIsModal = true;
          modalType = modalLoadProp;
        }
      });
    }

    if (currentRouteIsModal) {
      const modalToClose = router.currentRoute.modal
                           || router.currentRoute.route.modalInstance
                           || app[modalType].get();
      const previousUrl = router.history[router.history.length - 2];
      let previousRoute = router.findMatchingRoute(previousUrl);
      if (!previousRoute && previousUrl) {
        previousRoute = {
          url: previousUrl,
          path: previousUrl.split('?')[0],
          query: Utils.parseUrlQuery(previousUrl),
          route: {
            path: previousUrl.split('?')[0],
            url: previousUrl,
          },
        };
      }

      router.modalRemove(modalToClose);
    }

    const dynamicNavbar = router.dynamicNavbar;

    const $viewEl = router.$el;
    const $newPage = $el;
    const reload = options.reloadPrevious || options.reloadCurrent || options.reloadAll;
    let $oldPage;

    let $navbarsEl;
    let $newNavbarEl;
    let $oldNavbarEl;

    router.allowPageChange = false;
    if ($newPage.length === 0) {
      router.allowPageChange = true;
      return router;
    }

    if ($newPage.length) {
      // Remove theme elements
      router.removeThemeElements($newPage);
    }

    if (dynamicNavbar) {
      $newNavbarEl = $newPage.children('.navbar');
      $navbarsEl = router.$navbarsEl;
      if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
        // Try from pageData
        $newNavbarEl = $newPage[0].f7Page.$navbarEl;
      }
    }

    // Save Keep Alive Cache
    if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
      options.route.route.keepAliveData = {
        pageEl: $el[0],
      };
    }

    // Pages In View
    const $pagesInView = $viewEl
      .children('.page:not(.stacked)')
      .filter((index, pageInView) => pageInView !== $newPage[0]);

    // Navbars In View
    let $navbarsInView;
    if (dynamicNavbar) {
      $navbarsInView = $navbarsEl
        .children('.navbar:not(.stacked)')
        .filter((index, navbarInView) => navbarInView !== $newNavbarEl[0]);
    }

    // Exit when reload previous and only 1 page in view so nothing ro reload
    if (options.reloadPrevious && $pagesInView.length < 2) {
      router.allowPageChange = true;
      return router;
    }

    // Find Detail' master page
    let isDetail;
    let reloadDetail;
    let isDetailRoot;
    if (masterDetailEnabled && !options.reloadAll) {
      for (let i = 0; i < $pagesInView.length; i += 1) {
        if (!masterPageEl
          && $pagesInView[i].classList.contains('page-master')
        ) {
          masterPageEl = $pagesInView[i];
          continue; // eslint-disable-line
        }
      }
      isDetail = !isMaster && masterPageEl;

      if (isDetail) {
        // Find Other Detail
        if (masterPageEl) {
          for (let i = 0; i < $pagesInView.length; i += 1) {
            if ($pagesInView[i].classList.contains('page-master-detail')
            ) {
              otherDetailPageEl = $pagesInView[i];
              continue; // eslint-disable-line
            }
          }
        }
      }
      reloadDetail = isDetail && options.reloadDetail && app.width >= router.params.masterDetailBreakpoint && masterPageEl;
    }
    if (isDetail) {
      isDetailRoot = !otherDetailPageEl || reloadDetail || options.reloadAll || options.reloadCurrent;
    }

    // New Page
    let newPagePosition = 'next';
    if (options.reloadCurrent || options.reloadAll || reloadDetail) {
      newPagePosition = 'current';
    } else if (options.reloadPrevious) {
      newPagePosition = 'previous';
    }
    $newPage
      .removeClass('page-previous page-current page-next')
      .addClass(`page-${newPagePosition}${isMaster ? ' page-master' : ''}${isDetail ? ' page-master-detail' : ''}${isDetailRoot ? ' page-master-detail-root' : ''}`)
      .removeClass('stacked')
      .trigger('page:unstack')
      .trigger('page:position', { position: newPagePosition });
    router.emit('pageUnstack', $newPage[0]);
    router.emit('pagePosition', $newPage[0], newPagePosition);

    if (isMaster || isDetail) {
      $newPage.trigger('page:role', { role: isMaster ? 'master' : 'detail', root: !!isDetailRoot });
      router.emit('pageRole', $newPage[0], { role: isMaster ? 'master' : 'detail', detailRoot: !!isDetailRoot });
    }

    if (dynamicNavbar && $newNavbarEl.length) {
      $newNavbarEl
        .removeClass('navbar-previous navbar-current navbar-next')
        .addClass(`navbar-${newPagePosition}${isMaster ? ' navbar-master' : ''}${isDetail ? ' navbar-master-detail' : ''}${isDetailRoot ? ' navbar-master-detail-root' : ''}`)
        .removeClass('stacked');
      $newNavbarEl.trigger('navbar:position', { position: newPagePosition });
      router.emit('navbarPosition', $newNavbarEl[0], newPagePosition);
      if (isMaster || isDetail) {
        router.emit('navbarRole', $newNavbarEl[0], { role: isMaster ? 'master' : 'detail', detailRoot: !!isDetailRoot });
      }
    }

    // Find Old Page
    if (options.reloadCurrent || reloadDetail) {
      $oldPage = $pagesInView.eq($pagesInView.length - 1);
      if (dynamicNavbar) {
        // $oldNavbarEl = $navbarsInView.eq($pagesInView.length - 1);
        $oldNavbarEl = $(app.navbar.getElByPage($oldPage));
      }
    } else if (options.reloadPrevious) {
      $oldPage = $pagesInView.eq($pagesInView.length - 2);
      if (dynamicNavbar) {
        // $oldNavbarEl = $navbarsInView.eq($pagesInView.length - 2);
        $oldNavbarEl = $(app.navbar.getElByPage($oldPage));
      }
    } else if (options.reloadAll) {
      $oldPage = $pagesInView.filter((index, pageEl) => pageEl !== $newPage[0]);
      if (dynamicNavbar) {
        $oldNavbarEl = $navbarsInView.filter((index, navbarEl) => navbarEl !== $newNavbarEl[0]);
      }
    } else {
      let removedPageEls = [];
      let removedNavbarEls = [];
      if ($pagesInView.length > 1) {
        let i = 0;
        for (i = 0; i < $pagesInView.length - 1; i += 1) {
          if (masterPageEl
            && $pagesInView[i] === masterPageEl
          ) {
            $pagesInView.eq(i).addClass('page-master-stacked');
            $pagesInView.eq(i).trigger('page:masterstack');
            router.emit('pageMasterStack', $pagesInView[i]);
            if (dynamicNavbar) {
              $(app.navbar.getElByPage(masterPageEl)).addClass('navbar-master-stacked');
              router.emit('navbarMasterStack', app.navbar.getElByPage(masterPageEl));
            }
            continue; // eslint-disable-line
          }
          const oldNavbarEl = app.navbar.getElByPage($pagesInView.eq(i));
          if (router.params.stackPages) {
            $pagesInView.eq(i).addClass('stacked');
            $pagesInView.eq(i).trigger('page:stack');
            router.emit('pageStack', $pagesInView[i]);
            if (dynamicNavbar) {
              $(oldNavbarEl).addClass('stacked');
            }
          } else {
            // Page remove event
            removedPageEls.push($pagesInView[i]);
            router.pageCallback('beforeRemove', $pagesInView[i], $navbarsInView && $navbarsInView[i], 'previous', undefined, options);
            router.removePage($pagesInView[i]);
            if (dynamicNavbar && oldNavbarEl) {
              removedNavbarEls.push(oldNavbarEl);
              router.removeNavbar(oldNavbarEl);
            }
          }
        }
      }
      $oldPage = $viewEl
        .children('.page:not(.stacked)')
        .filter((index, pageEl) => pageEl !== $newPage[0] && removedPageEls.indexOf(pageEl) < 0);
      if (dynamicNavbar) {
        $oldNavbarEl = $navbarsEl
          .children('.navbar:not(.stacked)')
          .filter((index, navbarEl) => navbarEl !== $newNavbarEl[0] && removedNavbarEls.indexOf(removedNavbarEls) < 0);
      }
      removedPageEls = [];
      removedNavbarEls = [];
    }

    if (isDetail && !options.reloadAll) {
      if ($oldPage.length > 1 || reloadDetail) {
        $oldPage = $oldPage.filter((pageIndex, pageEl) => !pageEl.classList.contains('page-master'));
      }
      if ($oldNavbarEl && ($oldNavbarEl.length > 1 || reloadDetail)) {
        $oldNavbarEl = $oldNavbarEl.filter((navbarIndex, navbarEl) => !navbarEl.classList.contains('navbar-master'));
      }
    }

    // Push State
    if (router.params.pushState && (options.pushState || options.replaceState) && !options.reloadPrevious) {
      const pushStateRoot = router.params.pushStateRoot || '';
      History[options.reloadCurrent || (reloadDetail && otherDetailPageEl) || options.reloadAll || options.replaceState ? 'replace' : 'push'](
        view.id,
        {
          url: options.route.url,
        },
        pushStateRoot + router.params.pushStateSeparator + options.route.url
      );
    }

    if (!options.reloadPrevious) {
      // Current Page & Navbar
      router.currentPageEl = $newPage[0];
      if (dynamicNavbar && $newNavbarEl.length) {
        router.currentNavbarEl = $newNavbarEl[0];
      } else {
        delete router.currentNavbarEl;
      }

      // Current Route
      router.currentRoute = options.route;
    }

    // Update router history
    const url = options.route.url;

    if (options.history) {
      if (((options.reloadCurrent || (reloadDetail && otherDetailPageEl)) && router.history.length) > 0 || options.replaceState) {
        router.history[router.history.length - (options.reloadPrevious ? 2 : 1)] = url;
      } else if (options.reloadPrevious) {
        router.history[router.history.length - 2] = url;
      } else if (options.reloadAll) {
        router.history = [url];
      } else {
        router.history.push(url);
      }
    }
    router.saveHistory();

    // Insert new page and navbar
    const newPageInDom = $newPage.parents(doc).length > 0;
    const f7Component = $newPage[0].f7Component;
    if (options.reloadPrevious) {
      if (f7Component && !newPageInDom) {
        f7Component.$mount((componentEl) => {
          $(componentEl).insertBefore($oldPage);
        });
      } else {
        $newPage.insertBefore($oldPage);
      }
      if (dynamicNavbar && $newNavbarEl.length) {
        if ($newNavbarEl.find('.title-large').length) {
          $newNavbarEl.addClass('navbar-large');
        }
        if ($oldNavbarEl.length) {
          $newNavbarEl.insertBefore($oldNavbarEl);
        } else {
          if (!router.$navbarsEl.parents(doc).length) {
            router.$el.prepend(router.$navbarsEl);
          }
          $navbarsEl.append($newNavbarEl);
        }
      }
    } else {
      if ($oldPage.next('.page')[0] !== $newPage[0]) {
        if (f7Component && !newPageInDom) {
          f7Component.$mount((componentEl) => {
            $viewEl.append(componentEl);
          });
        } else {
          $viewEl.append($newPage[0]);
        }
      }
      if (dynamicNavbar && $newNavbarEl.length) {
        if ($newNavbarEl.find('.title-large').length) {
          $newNavbarEl.addClass('navbar-large');
        }
        if (!router.$navbarsEl.parents(doc).length) {
          router.$el.prepend(router.$navbarsEl);
        }
        $navbarsEl.append($newNavbarEl[0]);
      }
    }
    if (!newPageInDom) {
      router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, (reload ? newPagePosition : 'current'), options, $oldPage);
    } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
      $newPage[0].f7PageMounted = true;
      router.pageCallback('mounted', $newPage, $newNavbarEl, newPagePosition, (reload ? newPagePosition : 'current'), options, $oldPage);
    }

    // Remove old page
    if ((options.reloadCurrent || reloadDetail) && $oldPage.length > 0) {
      if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
        $oldPage.addClass('stacked');
        $oldPage.trigger('page:stack');
        router.emit('pageStack', $oldPage[0]);
        if (dynamicNavbar) {
          $oldNavbarEl.addClass('stacked');
        }
      } else {
        // Page remove event
        router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
        router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
        router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'current', undefined, options);
        router.removePage($oldPage);
        if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
          router.removeNavbar($oldNavbarEl);
        }
      }
    } else if (options.reloadAll) {
      $oldPage.each((index, pageEl) => {
        const $oldPageEl = $(pageEl);
        const $oldNavbarElEl = $(app.navbar.getElByPage($oldPageEl));
        if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
          $oldPageEl.addClass('stacked');
          $oldPageEl.trigger('page:stack');
          router.emit('pageStack', $oldPageEl[0]);
          if (dynamicNavbar) {
            $oldNavbarElEl.addClass('stacked');
          }
        } else {
          // Page remove event
          if ($oldPageEl.hasClass('page-current')) {
            router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
            router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', undefined, options);
          }
          router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl && $oldNavbarEl.eq(index), 'previous', undefined, options);
          router.removePage($oldPageEl);
          if (dynamicNavbar && $oldNavbarElEl.length) {
            router.removeNavbar($oldNavbarElEl);
          }
        }
      });
    } else if (options.reloadPrevious) {
      if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
        $oldPage.addClass('stacked');
        $oldPage.trigger('page:stack');
        router.emit('pageStack', $oldPage[0]);
        if (dynamicNavbar) {
          $oldNavbarEl.addClass('stacked');
        }
      } else {
        // Page remove event
        router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
        router.removePage($oldPage);
        if (dynamicNavbar && $oldNavbarEl && $oldNavbarEl.length) {
          router.removeNavbar($oldNavbarEl);
        }
      }
    }

    // Load Tab
    if (options.route.route.tab) {
      router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
        history: false,
        pushState: false,
      }));
    }

    // Check master detail
    if (masterDetailEnabled) {
      view.checkMasterDetailBreakpoint();
    }

    // Page init and before init events
    router.pageCallback('init', $newPage, $newNavbarEl, newPagePosition, reload ? newPagePosition : 'current', options, $oldPage);

    if (options.reloadCurrent || options.reloadAll || reloadDetail) {
      router.allowPageChange = true;
      router.pageCallback('beforeIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
      $newPage.removeAttr('aria-hidden');
      if (dynamicNavbar && $newNavbarEl) {
        $newNavbarEl.removeAttr('aria-hidden');
      }
      router.pageCallback('afterIn', $newPage, $newNavbarEl, newPagePosition, 'current', options);
      if (options.reloadCurrent && options.clearPreviousHistory) router.clearPreviousHistory();
      if (reloadDetail) {
        router.setPagePosition($(masterPageEl), 'previous');
        if (masterPageEl.f7Page && masterPageEl.f7Page.navbarEl) {
          router.setNavbarPosition($(masterPageEl.f7Page.navbarEl), 'previous');
        }
      }
      return router;
    }
    if (options.reloadPrevious) {
      router.allowPageChange = true;
      return router;
    }

    // Before animation event
    router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
    router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'next', 'current', options);

    // Animation
    function afterAnimation() {
      router.setPagePosition($newPage, 'current', false);
      router.setPagePosition($oldPage, 'previous', !$oldPage.hasClass('page-master'));
      if (dynamicNavbar) {
        router.setNavbarPosition($newNavbarEl, 'current', false);
        router.setNavbarPosition($oldNavbarEl, 'previous', !$oldNavbarEl.hasClass('navbar-master'));
      }
      // After animation event
      router.allowPageChange = true;
      router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'previous', options);
      router.pageCallback('afterIn', $newPage, $newNavbarEl, 'next', 'current', options);

      let keepOldPage = (router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`]) && !isMaster;
      if (!keepOldPage) {
        if ($newPage.hasClass('smart-select-page') || $newPage.hasClass('photo-browser-page') || $newPage.hasClass('autocomplete-page') || $newPage.hasClass('color-picker-page')) {
          keepOldPage = true;
        }
      }
      if (!keepOldPage) {
        if (router.params.stackPages) {
          $oldPage.addClass('stacked');
          $oldPage.trigger('page:stack');
          router.emit('pageStack', $oldPage[0]);
          if (dynamicNavbar) {
            $oldNavbarEl.addClass('stacked');
          }
        } else if (!($newPage.attr('data-name') && $newPage.attr('data-name') === 'smart-select-page')) {
          // Remove event
          router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'previous', undefined, options);
          router.removePage($oldPage);
          if (dynamicNavbar && $oldNavbarEl.length) {
            router.removeNavbar($oldNavbarEl);
          }
        }
      }
      if (options.clearPreviousHistory) router.clearPreviousHistory();
      router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

      if (router.params.pushState) {
        History.clearRouterQueue();
      }
    }
    function setPositionClasses() {
      router.setPagePosition($oldPage, 'current', false);
      router.setPagePosition($newPage, 'next', false);
      if (dynamicNavbar) {
        router.setNavbarPosition($oldNavbarEl, 'current', false);
        router.setNavbarPosition($newNavbarEl, 'next', false);
      }
    }
    if (options.animate && !(isMaster && app.width >= router.params.masterDetailBreakpoint)) {
      const delay = router.params[`${router.app.theme}PageLoadDelay`];
      let transition = router.params.transition;
      if (options.transition) transition = options.transition;
      if (!transition && router.currentRoute && router.currentRoute.route) {
        transition = router.currentRoute.route.transition;
      }
      if (!transition && router.currentRoute && router.currentRoute.route.options) {
        transition = router.currentRoute.route.options.transition;
      }
      if (transition) {
        $newPage[0].f7PageTransition = transition;
      }

      if (delay) {
        setTimeout(() => {
          setPositionClasses();
          router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, () => {
            afterAnimation();
          });
        }, delay);
      } else {
        setPositionClasses();
        router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'forward', transition, () => {
          afterAnimation();
        });
      }
    } else {
      afterAnimation();
    }
    return router;
  }
  function load(loadParams = {}, loadOptions = {}, ignorePageChange) {
    const router = this;
    if (!router.allowPageChange && !ignorePageChange) return router;
    const params = loadParams;
    const options = loadOptions;
    const { url, content, el, pageName, template, templateUrl, component, componentUrl } = params;

    if (!options.reloadCurrent
      && options.route
      && options.route.route
      && options.route.route.parentPath
      && router.currentRoute.route
      && router.currentRoute.route.parentPath === options.route.route.parentPath) {
      // Do something nested
      if (options.route.url === router.url) {
        router.allowPageChange = true;
        return false;
      }
      // Check for same params
      let sameParams = Object.keys(options.route.params).length === Object.keys(router.currentRoute.params).length;
      if (sameParams) {
        // Check for equal params name
        Object.keys(options.route.params).forEach((paramName) => {
          if (
            !(paramName in router.currentRoute.params)
            || (router.currentRoute.params[paramName] !== options.route.params[paramName])
          ) {
            sameParams = false;
          }
        });
      }
      if (sameParams) {
        if (options.route.route.tab) {
          return router.tabLoad(options.route.route.tab, options);
        }
        return false;
      }
      if (!sameParams
        && options.route.route.tab
        && router.currentRoute.route.tab
        && router.currentRoute.parentPath === options.route.parentPath
      ) {
        return router.tabLoad(options.route.route.tab, options);
      }
    }

    if (
      options.route
      && options.route.url
      && router.url === options.route.url
      && !(options.reloadCurrent || options.reloadPrevious)
      && !router.params.allowDuplicateUrls
    ) {
      router.allowPageChange = true;
      return false;
    }

    if (!options.route && url) {
      options.route = router.parseRouteUrl(url);
      Utils.extend(options.route, { route: { url, path: url } });
    }

    // Component Callbacks
    function resolve(pageEl, newOptions) {
      return router.forward(pageEl, Utils.extend(options, newOptions));
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }

    if (url || templateUrl || componentUrl) {
      router.allowPageChange = false;
    }

    // Proceed
    if (content) {
      router.forward(router.getPageEl(content), options);
    } else if (template || templateUrl) {
      // Parse template and send page element
      try {
        router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (el) {
      // Load page from specified HTMLElement or by page name in pages container
      router.forward(router.getPageEl(el), options);
    } else if (pageName) {
      // Load page by page name in pages container
      router.forward(router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
    } else if (component || componentUrl) {
      // Load from component (F7/Vue/React/...)
      try {
        router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      // Load using XHR
      if (router.xhr) {
        router.xhr.abort();
        router.xhr = false;
      }
      router.xhrRequest(url, options)
        .then((pageContent) => {
          router.forward(router.getPageEl(pageContent), options);
        })
        .catch(() => {
          router.allowPageChange = true;
        });
    }
    return router;
  }
  function navigate(navigateParams, navigateOptions = {}) {
    const router = this;
    if (router.swipeBackActive) return router;
    let url;
    let createRoute;
    let name;
    let query;
    let params;
    let route;
    if (typeof navigateParams === 'string') {
      url = navigateParams;
    } else {
      url = navigateParams.url;
      createRoute = navigateParams.route;
      name = navigateParams.name;
      query = navigateParams.query;
      params = navigateParams.params;
    }
    if (name) {
      url = router.generateUrl({ name, params, query });
      if (url) {
        return router.navigate(url, navigateOptions);
      }
      return router;
    }
    const app = router.app;
    appRouterCheck(router, 'navigate');
    if (url === '#' || url === '') {
      return router;
    }

    let navigateUrl = url.replace('./', '');
    if (navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
      const currentPath = router.currentRoute.parentPath || router.currentRoute.path;
      navigateUrl = ((currentPath ? `${currentPath}/` : '/') + navigateUrl)
        .replace('///', '/')
        .replace('//', '/');
    }
    if (createRoute) {
      route = Utils.extend(router.parseRouteUrl(navigateUrl), {
        route: Utils.extend({}, createRoute),
      });
    } else {
      route = router.findMatchingRoute(navigateUrl);
    }

    if (!route) {
      return router;
    }
    if (route.route && route.route.viewName) {
      const anotherViewName = route.route.viewName;
      const anotherView = app.views[anotherViewName];
      if (!anotherView) {
        throw new Error(`Framework7: There is no View with "${anotherViewName}" name that was specified in this route`);
      }
      if (anotherView !== router.view) {
        return anotherView.router.navigate(navigateParams, navigateOptions);
      }
    }

    if (route.route.redirect) {
      return redirect.call(router, 'navigate', route, navigateOptions);
    }


    const options = {};
    if (route.route.options) {
      Utils.extend(options, route.route.options, navigateOptions);
    } else {
      Utils.extend(options, navigateOptions);
    }
    options.route = route;

    if (options && options.context) {
      route.context = options.context;
      options.route.context = options.context;
    }

    function resolve() {
      let routerLoaded = false;
      ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach((modalLoadProp) => {
        if (route.route[modalLoadProp] && !routerLoaded) {
          routerLoaded = true;
          router.modalLoad(modalLoadProp, route, options);
        }
      });
      if (route.route.keepAlive && route.route.keepAliveData) {
        router.load({ el: route.route.keepAliveData.pageEl }, options, false);
        routerLoaded = true;
      }
      ('url content component pageName el componentUrl template templateUrl').split(' ').forEach((pageLoadProp) => {
        if (route.route[pageLoadProp] && !routerLoaded) {
          routerLoaded = true;
          router.load({ [pageLoadProp]: route.route[pageLoadProp] }, options, false);
        }
      });
      if (routerLoaded) return;
      // Async
      function asyncResolve(resolveParams, resolveOptions) {
        router.allowPageChange = false;
        let resolvedAsModal = false;
        if (resolveOptions && resolveOptions.context) {
          if (!route.context) route.context = resolveOptions.context;
          else route.context = Utils.extend({}, route.context, resolveOptions.context);
          options.route.context = route.context;
        }
        ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach((modalLoadProp) => {
          if (resolveParams[modalLoadProp]) {
            resolvedAsModal = true;
            const modalRoute = Utils.extend({}, route, { route: resolveParams });
            router.allowPageChange = true;
            router.modalLoad(modalLoadProp, modalRoute, Utils.extend(options, resolveOptions));
          }
        });
        if (resolvedAsModal) return;
        router.load(resolveParams, Utils.extend(options, resolveOptions), true);
      }
      function asyncReject() {
        router.allowPageChange = true;
      }
      if (route.route.async) {
        router.allowPageChange = false;
        route.route.async.call(router, options.route, router.currentRoute, asyncResolve, asyncReject);
      }
      if (route.route.asyncComponent) {
        asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
      }
    }
    function reject() {
      router.allowPageChange = true;
    }

    if (router.params.masterDetailBreakpoint > 0 && route.route.masterRoute) {
      // load detail route
      let preloadMaster = true;
      let masterLoaded = false;
      if (router.currentRoute && router.currentRoute.route) {
        if (
          router.currentRoute.route.master
          && (
            router.currentRoute.route === route.route.masterRoute
            || router.currentRoute.route.path === route.route.masterRoute.path
          )
        ) {
          preloadMaster = false;
        }
        if (
          router.currentRoute.route.masterRoute
          && (router.currentRoute.route.masterRoute === route.route.masterRoute
            || router.currentRoute.route.masterRoute.path === route.route.masterRoute.path
          )
        ) {
          preloadMaster = false;
          masterLoaded = true;
        }
      }
      if (preloadMaster || (masterLoaded && navigateOptions.reloadAll)) {
        router.navigate(route.route.masterRoute.path, {
          animate: false,
          reloadAll: navigateOptions.reloadAll,
          reloadCurrent: navigateOptions.reloadCurrent,
          reloadPrevious: navigateOptions.reloadPrevious,
          pushState: !navigateOptions.initial,
          history: !navigateOptions.initial,
          once: {
            pageAfterIn() {
              router.navigate(navigateParams, Utils.extend({}, navigateOptions, {
                animate: false,
                reloadAll: false,
                reloadCurrent: false,
                reloadPrevious: false,
                history: !navigateOptions.initial,
                pushState: !navigateOptions.initial,
              }));
            },
          },
        });
        return router;
      }
    }

    processRouteQueue.call(
      router,
      route,
      router.currentRoute,
      () => {
        if (route.route.modules) {
          app
            .loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules])
            .then(() => {
              resolve();
            })
            .catch(() => {
              reject();
            });
        } else {
          resolve();
        }
      },
      () => {
        reject();
      },
    );

    // Return Router
    return router;
  }

  function tabLoad(tabRoute, loadOptions = {}) {
    const router = this;
    const options = Utils.extend({
      animate: router.params.animate,
      pushState: true,
      history: true,
      parentPageEl: null,
      preload: false,
      on: {},
    }, loadOptions);

    let currentRoute;
    let previousRoute;
    if (options.route) {
      // Set Route
      if (!options.preload && options.route !== router.currentRoute) {
        previousRoute = router.previousRoute;
        router.currentRoute = options.route;
      }
      if (options.preload) {
        currentRoute = options.route;
        previousRoute = router.currentRoute;
      } else {
        currentRoute = router.currentRoute;
        if (!previousRoute) previousRoute = router.previousRoute;
      }

      // Update Browser History
      if (router.params.pushState && options.pushState && !options.reloadPrevious) {
        History.replace(
          router.view.id,
          {
            url: options.route.url,
          },
          (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
        );
      }

      // Update Router History
      if (options.history) {
        router.history[Math.max(router.history.length - 1, 0)] = options.route.url;
        router.saveHistory();
      }
    }

    // Show Tab
    const $parentPageEl = $(options.parentPageEl || router.currentPageEl);
    let tabEl;
    if ($parentPageEl.length && $parentPageEl.find(`#${tabRoute.id}`).length) {
      tabEl = $parentPageEl.find(`#${tabRoute.id}`).eq(0);
    } else if (router.view.selector) {
      tabEl = `${router.view.selector} #${tabRoute.id}`;
    } else {
      tabEl = `#${tabRoute.id}`;
    }
    const tabShowResult = router.app.tab.show({
      tabEl,
      animate: options.animate,
      tabRoute: options.route,
    });

    const { $newTabEl, $oldTabEl, animated, onTabsChanged } = tabShowResult;

    if ($newTabEl && $newTabEl.parents('.page').length > 0 && options.route) {
      const tabParentPageData = $newTabEl.parents('.page')[0].f7Page;
      if (tabParentPageData && options.route) {
        tabParentPageData.route = options.route;
      }
    }

    // Tab Content Loaded
    function onTabLoaded(contentEl) {
      // Remove theme elements
      router.removeThemeElements($newTabEl);

      let tabEventTarget = $newTabEl;
      if (typeof contentEl !== 'string') tabEventTarget = $(contentEl);

      tabEventTarget.trigger('tab:init tab:mounted', tabRoute);
      router.emit('tabInit tabMounted', $newTabEl[0], tabRoute);

      if ($oldTabEl && $oldTabEl.length) {
        if (animated) {
          onTabsChanged(() => {
            router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
            if (router.params.unloadTabContent) {
              router.tabRemove($oldTabEl, $newTabEl, tabRoute);
            }
          });
        } else {
          router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
          if (router.params.unloadTabContent) {
            router.tabRemove($oldTabEl, $newTabEl, tabRoute);
          }
        }
      }
    }

    if ($newTabEl[0].f7RouterTabLoaded) {
      if (!$oldTabEl || !$oldTabEl.length) return router;
      if (animated) {
        onTabsChanged(() => {
          router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
        });
      } else {
        router.emit('routeChanged', router.currentRoute, router.previousRoute, router);
      }
      return router;
    }

    // Load Tab Content
    function loadTab(loadTabParams, loadTabOptions) {
      // Load Tab Props
      const { url, content, el, template, templateUrl, component, componentUrl } = loadTabParams;
      // Component/Template Callbacks
      function resolve(contentEl) {
        router.allowPageChange = true;
        if (!contentEl) return;
        if (typeof contentEl === 'string') {
          $newTabEl.html(contentEl);
        } else {
          $newTabEl.html('');
          if (contentEl.f7Component) {
            contentEl.f7Component.$mount((componentEl) => {
              $newTabEl.append(componentEl);
            });
          } else {
            $newTabEl.append(contentEl);
          }
        }
        $newTabEl[0].f7RouterTabLoaded = true;
        onTabLoaded(contentEl);
      }
      function reject() {
        router.allowPageChange = true;
        return router;
      }

      if (content) {
        resolve(content);
      } else if (template || templateUrl) {
        try {
          router.tabTemplateLoader(template, templateUrl, loadTabOptions, resolve, reject);
        } catch (err) {
          router.allowPageChange = true;
          throw err;
        }
      } else if (el) {
        resolve(el);
      } else if (component || componentUrl) {
        // Load from component (F7/Vue/React/...)
        try {
          router.tabComponentLoader($newTabEl[0], component, componentUrl, loadTabOptions, resolve, reject);
        } catch (err) {
          router.allowPageChange = true;
          throw err;
        }
      } else if (url) {
        // Load using XHR
        if (router.xhr) {
          router.xhr.abort();
          router.xhr = false;
        }
        router.xhrRequest(url, loadTabOptions)
          .then((tabContent) => {
            resolve(tabContent);
          })
          .catch(() => {
            router.allowPageChange = true;
          });
      }
    }

    let hasContentLoadProp;
    ('url content component el componentUrl template templateUrl').split(' ').forEach((tabLoadProp) => {
      if (tabRoute[tabLoadProp]) {
        hasContentLoadProp = true;
        loadTab({ [tabLoadProp]: tabRoute[tabLoadProp] }, options);
      }
    });

    // Async
    function asyncResolve(resolveParams, resolveOptions) {
      loadTab(resolveParams, Utils.extend(options, resolveOptions));
    }
    function asyncReject() {
      router.allowPageChange = true;
    }
    if (tabRoute.async) {
      tabRoute.async.call(router, currentRoute, previousRoute, asyncResolve, asyncReject);
    } else if (tabRoute.asyncComponent) {
      asyncComponent(router, tabRoute.asyncComponent, asyncResolve, asyncReject);
    } else if (!hasContentLoadProp) {
      router.allowPageChange = true;
    }

    return router;
  }
  function tabRemove($oldTabEl, $newTabEl, tabRoute) {
    const router = this;

    let hasTabComponentChild;
    if ($oldTabEl[0]) {
      $oldTabEl[0].f7RouterTabLoaded = false;
      delete $oldTabEl[0].f7RouterTabLoaded;
    }
    $oldTabEl.children().each((index, tabChild) => {
      if (tabChild.f7Component) {
        hasTabComponentChild = true;
        $(tabChild).trigger('tab:beforeremove', tabRoute);
        tabChild.f7Component.$destroy();
      }
    });
    if (!hasTabComponentChild) {
      $oldTabEl.trigger('tab:beforeremove', tabRoute);
    }
    router.emit('tabBeforeRemove', $oldTabEl[0], $newTabEl[0], tabRoute);
    router.removeTabContent($oldTabEl[0], tabRoute);
  }

  function modalLoad(modalType, route, loadOptions = {}) {
    const router = this;
    const app = router.app;
    const isPanel = modalType === 'panel';
    const modalOrPanel = isPanel ? 'panel' : 'modal';

    const options = Utils.extend({
      animate: router.params.animate,
      pushState: true,
      history: true,
      on: {},
    }, loadOptions);

    const modalParams = Utils.extend({}, route.route[modalType]);
    const modalRoute = route.route;

    function onModalLoaded() {
      // Create Modal
      const modal = app[modalType].create(modalParams);
      modalRoute.modalInstance = modal;

      const hasEl = modal.el;

      function closeOnSwipeBack() {
        modal.close();
      }
      modal.on(`${modalOrPanel}Open`, () => {
        if (!hasEl) {
          // Remove theme elements
          router.removeThemeElements(modal.el);

          // Emit events
          modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
          router.emit(`${!isPanel ? 'modalInit' : ''} ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
        }
        router.once('swipeBackMove', closeOnSwipeBack);
      });
      modal.on(`${modalOrPanel}Close`, () => {
        router.off('swipeBackMove', closeOnSwipeBack);
        if (!modal.closeByRouter) {
          router.back();
        }
      });

      modal.on(`${modalOrPanel}Closed`, () => {
        modal.$el.trigger(`${modalType.toLowerCase()}:beforeremove`, route, modal);
        modal.emit(`${!isPanel ? 'modalBeforeRemove ' : ''}${modalType}BeforeRemove`, modal.el, route, modal);
        const modalComponent = modal.el.f7Component;
        if (modalComponent) {
          modalComponent.$destroy();
        }
        Utils.nextTick(() => {
          if (modalComponent || modalParams.component) {
            router.removeModal(modal.el);
          }
          modal.destroy();
          delete modal.route;
          delete modalRoute.modalInstance;
        });
      });

      if (options.route) {
        // Update Browser History
        if (router.params.pushState && options.pushState) {
          History.push(
            router.view.id,
            {
              url: options.route.url,
              modal: modalType,
            },
            (router.params.pushStateRoot || '') + router.params.pushStateSeparator + options.route.url
          );
        }

        // Set Route
        if (options.route !== router.currentRoute) {
          modal.route = Utils.extend(options.route, { modal });
          router.currentRoute = modal.route;
        }

        // Update Router History
        if (options.history) {
          router.history.push(options.route.url);
          router.saveHistory();
        }
      }

      if (hasEl) {
        // Remove theme elements
        router.removeThemeElements(modal.el);

        // Emit events
        modal.$el.trigger(`${modalType.toLowerCase()}:init ${modalType.toLowerCase()}:mounted`, route, modal);
        router.emit(`${modalOrPanel}Init ${modalType}Init ${modalType}Mounted`, modal.el, route, modal);
      }

      // Open
      modal.open();
    }

    // Load Modal Content
    function loadModal(loadModalParams, loadModalOptions) {
      // Load Modal Props
      const { url, content, template, templateUrl, component, componentUrl } = loadModalParams;

      // Component/Template Callbacks
      function resolve(contentEl) {
        if (contentEl) {
          if (typeof contentEl === 'string') {
            modalParams.content = contentEl;
          } else if (contentEl.f7Component) {
            contentEl.f7Component.$mount((componentEl) => {
              modalParams.el = componentEl;
              app.root.append(componentEl);
            });
          } else {
            modalParams.el = contentEl;
          }
          onModalLoaded();
        }
      }
      function reject() {
        router.allowPageChange = true;
        return router;
      }

      if (content) {
        resolve(content);
      } else if (template || templateUrl) {
        try {
          router.modalTemplateLoader(template, templateUrl, loadModalOptions, resolve, reject);
        } catch (err) {
          router.allowPageChange = true;
          throw err;
        }
      } else if (component || componentUrl) {
        // Load from component (F7/Vue/React/...)
        try {
          router.modalComponentLoader(app.root[0], component, componentUrl, loadModalOptions, resolve, reject);
        } catch (err) {
          router.allowPageChange = true;
          throw err;
        }
      } else if (url) {
        // Load using XHR
        if (router.xhr) {
          router.xhr.abort();
          router.xhr = false;
        }
        router.xhrRequest(url, loadModalOptions)
          .then((modalContent) => {
            modalParams.content = modalContent;
            onModalLoaded();
          })
          .catch(() => {
            router.allowPageChange = true;
          });
      } else {
        onModalLoaded();
      }
    }

    let foundLoadProp;
    ('url content component el componentUrl template templateUrl').split(' ').forEach((modalLoadProp) => {
      if (modalParams[modalLoadProp] && !foundLoadProp) {
        foundLoadProp = true;
        loadModal({ [modalLoadProp]: modalParams[modalLoadProp] }, options);
      }
    });
    if (!foundLoadProp && modalType === 'actions') {
      onModalLoaded();
    }

    // Async
    function asyncResolve(resolveParams, resolveOptions) {
      loadModal(resolveParams, Utils.extend(options, resolveOptions));
    }
    function asyncReject() {
      router.allowPageChange = true;
    }
    if (modalParams.async) {
      modalParams.async.call(router, options.route, router.currentRoute, asyncResolve, asyncReject);
    }
    if (modalParams.asyncComponent) {
      asyncComponent(router, modalParams.asyncComponent, asyncResolve, asyncReject);
    }
    return router;
  }
  function modalRemove(modal) {
    Utils.extend(modal, { closeByRouter: true });
    modal.close();
  }

  function backward(el, backwardOptions) {
    const router = this;
    const $el = $(el);
    const app = router.app;
    const view = router.view;

    const options = Utils.extend({
      animate: router.params.animate,
      pushState: true,
      replaceState: false,
    }, backwardOptions);

    const masterDetailEnabled = router.params.masterDetailBreakpoint > 0;
    const isMaster = masterDetailEnabled && options.route && options.route.route && options.route.route.master === true;
    let masterPageEl;
    let masterPageRemoved;

    const dynamicNavbar = router.dynamicNavbar;

    const $newPage = $el;
    const $oldPage = router.$el.children('.page-current');
    const currentIsMaster = masterDetailEnabled && $oldPage.hasClass('page-master');

    if ($newPage.length) {
      // Remove theme elements
      router.removeThemeElements($newPage);
    }

    let $navbarsEl;
    let $newNavbarEl;
    let $oldNavbarEl;

    if (dynamicNavbar) {
      $newNavbarEl = $newPage.children('.navbar');
      $navbarsEl = router.$navbarsEl;
      if ($newNavbarEl.length === 0 && $newPage[0] && $newPage[0].f7Page) {
        // Try from pageData
        $newNavbarEl = $newPage[0].f7Page.$navbarEl;
      }
      $oldNavbarEl = $navbarsEl.find('.navbar-current');
    }

    router.allowPageChange = false;
    if ($newPage.length === 0 || $oldPage.length === 0) {
      router.allowPageChange = true;
      return router;
    }

    // Remove theme elements
    router.removeThemeElements($newPage);

    // Save Keep Alive Cache
    if (options.route && options.route.route && options.route.route.keepAlive && !options.route.route.keepAliveData) {
      options.route.route.keepAliveData = {
        pageEl: $el[0],
      };
    }

    // Pages In View
    let isDetail;
    let isDetailRoot;
    if (masterDetailEnabled) {
      const $pagesInView = router.$el
        .children('.page:not(.stacked)')
        .filter((index, pageInView) => pageInView !== $newPage[0]);

      // Find Detail' master page
      for (let i = 0; i < $pagesInView.length; i += 1) {
        if (!masterPageEl
          && $pagesInView[i].classList.contains('page-master')
        ) {
          masterPageEl = $pagesInView[i];
          continue; // eslint-disable-line
        }
      }

      isDetail = !isMaster
        && masterPageEl
        && (router.history.indexOf(options.route.url) > router.history.indexOf(masterPageEl.f7Page.route.url));

      if (!isDetail && !isMaster && masterPageEl && masterPageEl.f7Page && options.route.route.masterRoute) {
        isDetail = options.route.route.masterRoute.path === masterPageEl.f7Page.route.route.path;
      }
    }
    if (isDetail && masterPageEl && masterPageEl.f7Page) {
      isDetailRoot = router.history.indexOf(options.route.url) - router.history.indexOf(masterPageEl.f7Page.route.url) === 1;
    }

    // New Page
    $newPage
      .addClass(`page-previous${isMaster ? ' page-master' : ''}${isDetail ? ' page-master-detail' : ''}${isDetailRoot ? ' page-master-detail-root' : ''}`)
      .removeClass('stacked')
      .removeAttr('aria-hidden')
      .trigger('page:unstack')
      .trigger('page:position', { position: 'previous' });
    router.emit('pageUnstack', $newPage[0]);
    router.emit('pagePosition', $newPage[0], 'previous');
    if (isMaster || isDetail) {
      $newPage.trigger('page:role', { role: isMaster ? 'master' : 'detail', root: !!isDetailRoot });
      router.emit('pageRole', $newPage[0], { role: isMaster ? 'master' : 'detail', detailRoot: !!isDetailRoot });
    }

    if (dynamicNavbar && $newNavbarEl.length > 0) {
      $newNavbarEl
        .addClass(`navbar-previous${isMaster ? ' navbar-master' : ''}${isDetail ? ' navbar-master-detail' : ''}${isDetailRoot ? ' navbar-master-detail-root' : ''}`)
        .removeClass('stacked')
        .removeAttr('aria-hidden');
      $newNavbarEl.trigger('navbar:position', { position: 'previous' });
      router.emit('navbarPosition', $newNavbarEl[0], 'previous');
      if (isMaster || isDetailRoot) {
        router.emit('navbarRole', $newNavbarEl[0], { role: isMaster ? 'master' : 'detail', detailRoot: !!isDetailRoot });
      }
    }

    // Remove previous page in case of "forced"
    let backIndex;
    if (options.force) {
      if ($oldPage.prev('.page-previous:not(.stacked)').length > 0 || $oldPage.prev('.page-previous').length === 0) {
        if (router.history.indexOf(options.route.url) >= 0) {
          backIndex = router.history.length - router.history.indexOf(options.route.url) - 1;
          router.history = router.history.slice(0, router.history.indexOf(options.route.url) + 2);
          view.history = router.history;
        } else if (router.history[[router.history.length - 2]]) {
          router.history[router.history.length - 2] = options.route.url;
        } else {
          router.history.unshift(router.url);
        }

        if (backIndex && router.params.stackPages) {
          $oldPage.prevAll('.page-previous').each((index, pageToRemove) => {
            const $pageToRemove = $(pageToRemove);
            let $navbarToRemove;
            if (dynamicNavbar) {
              // $navbarToRemove = $oldNavbarEl.prevAll('.navbar-previous').eq(index);
              $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
            }
            if ($pageToRemove[0] !== $newPage[0] && $pageToRemove.index() > $newPage.index()) {
              if (router.initialPages.indexOf($pageToRemove[0]) >= 0) {
                $pageToRemove.addClass('stacked');
                $pageToRemove.trigger('page:stack');
                router.emit('pageStack', $pageToRemove[0]);
                if (dynamicNavbar) {
                  $navbarToRemove.addClass('stacked');
                }
              } else {
                router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
                if ($pageToRemove[0] === masterPageEl) {
                  masterPageRemoved = true;
                }
                router.removePage($pageToRemove);
                if (dynamicNavbar && $navbarToRemove.length > 0) {
                  router.removeNavbar($navbarToRemove);
                }
              }
            }
          });
        } else {
          const $pageToRemove = $oldPage.prev('.page-previous:not(.stacked)');
          let $navbarToRemove;
          if (dynamicNavbar) {
            // $navbarToRemove = $oldNavbarEl.prev('.navbar-inner:not(.stacked)');
            $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
          }
          if (router.params.stackPages && router.initialPages.indexOf($pageToRemove[0]) >= 0) {
            $pageToRemove.addClass('stacked');
            $pageToRemove.trigger('page:stack');
            router.emit('pageStack', $pageToRemove[0]);
            $navbarToRemove.addClass('stacked');
          } else if ($pageToRemove.length > 0) {
            router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined, options);
            if ($pageToRemove[0] === masterPageEl) {
              masterPageRemoved = true;
            }
            router.removePage($pageToRemove);
            if (dynamicNavbar && $navbarToRemove.length) {
              router.removeNavbar($navbarToRemove);
            }
          }
        }
      }
    }

    // Insert new page
    const newPageInDom = $newPage.parents(doc).length > 0;
    const f7Component = $newPage[0].f7Component;

    function insertPage() {
      if ($newPage.next($oldPage).length === 0) {
        if (!newPageInDom && f7Component) {
          f7Component.$mount((componentEl) => {
            $(componentEl).insertBefore($oldPage);
          });
        } else {
          $newPage.insertBefore($oldPage);
        }
      }
      if (dynamicNavbar && $newNavbarEl.length) {
        if ($newNavbarEl.find('.title-large').length) {
          $newNavbarEl.addClass('navbar-large');
        }
        $newNavbarEl.insertBefore($oldNavbarEl);
        if ($oldNavbarEl.length > 0) {
          $newNavbarEl.insertBefore($oldNavbarEl);
        } else {
          if (!router.$navbarsEl.parents(doc).length) {
            router.$el.prepend(router.$navbarsEl);
          }
          $navbarsEl.append($newNavbarEl);
        }
      }
      if (!newPageInDom) {
        router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
      } else if (options.route && options.route.route && options.route.route.keepAlive && !$newPage[0].f7PageMounted) {
        $newPage[0].f7PageMounted = true;
        router.pageCallback('mounted', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
      }
    }

    if (options.preload) {
      // Insert Page
      insertPage();
      // Tab route
      if (options.route.route.tab) {
        router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
          history: false,
          pushState: false,
          preload: true,
        }));
      }
      if (isMaster) {
        $newPage
          .removeClass('page-master-stacked')
          .trigger('page:masterunstack');
        router.emit('pageMasterUnstack', $newPage[0]);
        if (dynamicNavbar) {
          $(app.navbar.getElByPage($newPage)).removeClass('navbar-master-stacked');
          router.emit('navbarMasterUnstack', app.navbar.getElByPage($newPage));
        }
      }
      // Page init and before init events
      router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);
      const $previousPages = $newPage.prevAll('.page-previous:not(.stacked):not(.page-master)');
      if ($previousPages.length > 0) {
        $previousPages.each((index, pageToRemove) => {
          const $pageToRemove = $(pageToRemove);
          let $navbarToRemove;
          if (dynamicNavbar) {
            // $navbarToRemove = $newNavbarEl.prevAll('.navbar-previous:not(.stacked)').eq(index);
            $navbarToRemove = $(app.navbar.getElByPage($pageToRemove));
          }
          if (router.params.stackPages && router.initialPages.indexOf(pageToRemove) >= 0) {
            $pageToRemove.addClass('stacked');
            $pageToRemove.trigger('page:stack');
            router.emit('pageStack', $pageToRemove[0]);
            if (dynamicNavbar) {
              $navbarToRemove.addClass('stacked');
            }
          } else {
            router.pageCallback('beforeRemove', $pageToRemove, $navbarToRemove, 'previous', undefined);
            router.removePage($pageToRemove);
            if (dynamicNavbar && $navbarToRemove.length) {
              router.removeNavbar($navbarToRemove);
            }
          }
        });
      }
      router.allowPageChange = true;
      return router;
    }

    // History State
    if (!(Device.ie || Device.edge || (Device.firefox && !Device.ios))) {
      if (router.params.pushState && options.pushState) {
        if (options.replaceState) {
          const pushStateRoot = router.params.pushStateRoot || '';
          History.replace(
            view.id,
            {
              url: options.route.url,
            },
            pushStateRoot + router.params.pushStateSeparator + options.route.url
          );
        } else if (backIndex) {
          History.go(-backIndex);
        } else {
          History.back();
        }
      }
    }

    // Update History
    if (options.replaceState) {
      router.history[router.history.length - 1] = options.route.url;
    } else {
      if (router.history.length === 1) {
        router.history.unshift(router.url);
      }
      router.history.pop();
    }
    router.saveHistory();

    // Current Page & Navbar
    router.currentPageEl = $newPage[0];
    if (dynamicNavbar && $newNavbarEl.length) {
      router.currentNavbarEl = $newNavbarEl[0];
    } else {
      delete router.currentNavbarEl;
    }

    // Current Route
    router.currentRoute = options.route;

    // History State
    if (Device.ie || Device.edge || (Device.firefox && !Device.ios)) {
      if (router.params.pushState && options.pushState) {
        if (options.replaceState) {
          const pushStateRoot = router.params.pushStateRoot || '';
          History.replace(
            view.id,
            {
              url: options.route.url,
            },
            pushStateRoot + router.params.pushStateSeparator + options.route.url
          );
        } else if (backIndex) {
          History.go(-backIndex);
        } else {
          History.back();
        }
      }
    }

    // Insert Page
    insertPage();

    // Load Tab
    if (options.route.route.tab) {
      router.tabLoad(options.route.route.tab, Utils.extend({}, options, {
        history: false,
        pushState: false,
      }));
    }

    // Check master detail

    if (masterDetailEnabled && (currentIsMaster || masterPageRemoved)) {
      view.checkMasterDetailBreakpoint(false);
    }

    // Page init and before init events
    router.pageCallback('init', $newPage, $newNavbarEl, 'previous', 'current', options, $oldPage);

    // Before animation callback
    router.pageCallback('beforeOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
    router.pageCallback('beforeIn', $newPage, $newNavbarEl, 'previous', 'current', options);

    // Animation
    function afterAnimation() {
      // Set classes
      router.setPagePosition($newPage, 'current', false);
      router.setPagePosition($oldPage, 'next', true);
      if (dynamicNavbar) {
        router.setNavbarPosition($newNavbarEl, 'current', false);
        router.setNavbarPosition($oldNavbarEl, 'next', true);
      }

      // After animation event
      router.pageCallback('afterOut', $oldPage, $oldNavbarEl, 'current', 'next', options);
      router.pageCallback('afterIn', $newPage, $newNavbarEl, 'previous', 'current', options);

      // Remove Old Page
      if (router.params.stackPages && router.initialPages.indexOf($oldPage[0]) >= 0) {
        $oldPage.addClass('stacked');
        $oldPage.trigger('page:stack');
        router.emit('pageStack', $oldPage[0]);
        if (dynamicNavbar) {
          $oldNavbarEl.addClass('stacked');
        }
      } else {
        router.pageCallback('beforeRemove', $oldPage, $oldNavbarEl, 'next', undefined, options);
        router.removePage($oldPage);
        if (dynamicNavbar && $oldNavbarEl.length) {
          router.removeNavbar($oldNavbarEl);
        }
      }

      router.allowPageChange = true;
      router.emit('routeChanged', router.currentRoute, router.previousRoute, router);

      // Preload previous page
      const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];
      if (preloadPreviousPage && router.history[router.history.length - 2] && !isMaster) {
        router.back(router.history[router.history.length - 2], { preload: true });
      }
      if (router.params.pushState) {
        History.clearRouterQueue();
      }
    }

    function setPositionClasses() {
      router.setPagePosition($oldPage, 'current');
      router.setPagePosition($newPage, 'previous', false);
      if (dynamicNavbar) {
        router.setNavbarPosition($oldNavbarEl, 'current');
        router.setNavbarPosition($newNavbarEl, 'previous', false);
      }
    }

    if (options.animate && !(currentIsMaster && app.width >= router.params.masterDetailBreakpoint)) {
      let transition = router.params.transition;
      if ($oldPage[0] && $oldPage[0].f7PageTransition) {
        transition = $oldPage[0].f7PageTransition;
        delete $oldPage[0].f7PageTransition;
      }
      if (options.transition) transition = options.transition;
      if (!transition && router.previousRoute && router.previousRoute.route) {
        transition = router.previousRoute.route.transition;
      }
      if (!transition && router.previousRoute && router.previousRoute.route && router.previousRoute.route.options) {
        transition = router.previousRoute.route.options.transition;
      }
      setPositionClasses();
      router.animate($oldPage, $newPage, $oldNavbarEl, $newNavbarEl, 'backward', transition, () => {
        afterAnimation();
      });
    } else {
      afterAnimation();
    }

    return router;
  }
  function loadBack(backParams, backOptions, ignorePageChange) {
    const router = this;

    if (!router.allowPageChange && !ignorePageChange) return router;
    const params = backParams;
    const options = backOptions;
    const { url, content, el, pageName, template, templateUrl, component, componentUrl } = params;

    if (
      options.route.url
      && router.url === options.route.url
      && !(options.reloadCurrent || options.reloadPrevious)
      && !router.params.allowDuplicateUrls
    ) {
      return false;
    }

    if (!options.route && url) {
      options.route = router.parseRouteUrl(url);
    }

    // Component Callbacks
    function resolve(pageEl, newOptions) {
      return router.backward(pageEl, Utils.extend(options, newOptions));
    }
    function reject() {
      router.allowPageChange = true;
      return router;
    }

    if (url || templateUrl || componentUrl) {
      router.allowPageChange = false;
    }

    // Proceed
    if (content) {
      router.backward(router.getPageEl(content), options);
    } else if (template || templateUrl) {
      // Parse template and send page element
      try {
        router.pageTemplateLoader(template, templateUrl, options, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (el) {
      // Load page from specified HTMLElement or by page name in pages container
      router.backward(router.getPageEl(el), options);
    } else if (pageName) {
      // Load page by page name in pages container
      router.backward(router.$el.children(`.page[data-name="${pageName}"]`).eq(0), options);
    } else if (component || componentUrl) {
      // Load from component (F7/Vue/React/...)
      try {
        router.pageComponentLoader(router.el, component, componentUrl, options, resolve, reject);
      } catch (err) {
        router.allowPageChange = true;
        throw err;
      }
    } else if (url) {
      // Load using XHR
      if (router.xhr) {
        router.xhr.abort();
        router.xhr = false;
      }
      router.xhrRequest(url, options)
        .then((pageContent) => {
          router.backward(router.getPageEl(pageContent), options);
        })
        .catch(() => {
          router.allowPageChange = true;
        });
    }
    return router;
  }
  function back(...args) {
    const router = this;
    if (router.swipeBackActive) return router;
    let navigateUrl;
    let navigateOptions;
    let route;
    if (typeof args[0] === 'object') {
      navigateOptions = args[0] || {};
    } else {
      navigateUrl = args[0];
      navigateOptions = args[1] || {};
    }

    const { name, params, query } = navigateOptions;
    if (name) {
      navigateUrl = router.generateUrl({ name, params, query });
      if (navigateUrl) {
        return router.back(navigateUrl, Utils.extend({}, navigateOptions, {
          name: null,
          params: null,
          query: null,
        }));
      }
      return router;
    }

    const app = router.app;
    appRouterCheck(router, 'back');

    let currentRouteIsModal = router.currentRoute.modal;
    let modalType;
    if (!currentRouteIsModal) {
      ('popup popover sheet loginScreen actions customModal panel').split(' ').forEach((modalLoadProp) => {
        if (router.currentRoute.route[modalLoadProp]) {
          currentRouteIsModal = true;
          modalType = modalLoadProp;
        }
      });
    }
    if (currentRouteIsModal) {
      const modalToClose = router.currentRoute.modal
                           || router.currentRoute.route.modalInstance
                           || app[modalType].get();
      const previousUrl = router.history[router.history.length - 2];
      let previousRoute;
      // check if previous route is modal too
      if (modalToClose && modalToClose.$el) {
        const prevOpenedModals = modalToClose.$el.prevAll('.modal-in');
        if (prevOpenedModals.length && prevOpenedModals[0].f7Modal) {
          previousRoute = prevOpenedModals[0].f7Modal.route;
        }
      }
      if (!previousRoute) {
        previousRoute = router.findMatchingRoute(previousUrl);
      }

      if (!previousRoute && previousUrl) {
        previousRoute = {
          url: previousUrl,
          path: previousUrl.split('?')[0],
          query: Utils.parseUrlQuery(previousUrl),
          route: {
            path: previousUrl.split('?')[0],
            url: previousUrl,
          },
        };
      }
      if (!navigateUrl || navigateUrl.replace(/[# ]/g, '').trim().length === 0) {
        if (!previousRoute || !modalToClose) {
          return router;
        }
      }
      const forceOtherUrl = navigateOptions.force && previousRoute && navigateUrl;
      if (previousRoute && modalToClose) {
        const isBrokenPushState = Device.ie || Device.edge || (Device.firefox && !Device.ios);
        const needHistoryBack = router.params.pushState && navigateOptions.pushState !== false;
        if (needHistoryBack && !isBrokenPushState) {
          History.back();
        }
        router.currentRoute = previousRoute;
        router.history.pop();
        router.saveHistory();

        if (needHistoryBack && isBrokenPushState) {
          History.back();
        }

        router.modalRemove(modalToClose);
        if (forceOtherUrl) {
          router.navigate(navigateUrl, { reloadCurrent: true });
        }
      } else if (modalToClose) {
        router.modalRemove(modalToClose);
        if (navigateUrl) {
          router.navigate(navigateUrl, { reloadCurrent: true });
        }
      }
      return router;
    }
    let $previousPage = router.$el.children('.page-current').prevAll('.page-previous:not(.page-master)').eq(0);

    let skipMaster;
    if (router.params.masterDetailBreakpoint > 0) {
      const $previousMaster = router.$el.children('.page-current').prevAll('.page-master').eq(0);
      if ($previousMaster.length) {
        const expectedPreviousPageUrl = router.history[router.history.length - 2];
        const expectedPreviousPageRoute = router.findMatchingRoute(expectedPreviousPageUrl);
        if (expectedPreviousPageRoute && expectedPreviousPageRoute.route === $previousMaster[0].f7Page.route.route) {
          $previousPage = $previousMaster;
          if (!navigateOptions.preload) {
            skipMaster = app.width >= router.params.masterDetailBreakpoint;
          }
        }
      }
    }
    if (!navigateOptions.force && $previousPage.length && !skipMaster) {
      if (router.params.pushState
        && $previousPage[0].f7Page
        && router.history[router.history.length - 2] !== $previousPage[0].f7Page.route.url
      ) {
        router.back(
          router.history[router.history.length - 2],
          Utils.extend(navigateOptions, { force: true })
        );
        return router;
      }
      const previousPageRoute = $previousPage[0].f7Page.route;

      processRouteQueue.call(
        router,
        previousPageRoute,
        router.currentRoute,
        () => {
          router.loadBack({ el: $previousPage }, Utils.extend(navigateOptions, {
            route: previousPageRoute,
          }));
        },
        () => {}
      );

      return router;
    }

    // Navigate URL
    if (navigateUrl === '#') {
      navigateUrl = undefined;
    }
    if (navigateUrl && navigateUrl[0] !== '/' && navigateUrl.indexOf('#') !== 0) {
      navigateUrl = ((router.path || '/') + navigateUrl).replace('//', '/');
    }
    if (!navigateUrl && router.history.length > 1) {
      navigateUrl = router.history[router.history.length - 2];
    }
    if (skipMaster && !navigateOptions.force && router.history[router.history.length - 3]) {
      return router.back(router.history[router.history.length - 3], Utils.extend({}, navigateOptions || {}, {
        force: true,
        animate: false,
      }));
    }
    if (skipMaster && !navigateOptions.force) {
      return router;
    }

    // Find route to load
    route = router.findMatchingRoute(navigateUrl);
    if (!route) {
      if (navigateUrl) {
        route = {
          url: navigateUrl,
          path: navigateUrl.split('?')[0],
          query: Utils.parseUrlQuery(navigateUrl),
          route: {
            path: navigateUrl.split('?')[0],
            url: navigateUrl,
          },
        };
      }
    }
    if (!route) {
      return router;
    }

    if (route.route.redirect) {
      return redirect.call(router, 'back', route, navigateOptions);
    }

    const options = {};
    if (route.route.options) {
      Utils.extend(options, route.route.options, navigateOptions);
    } else {
      Utils.extend(options, navigateOptions);
    }
    options.route = route;

    if (options && options.context) {
      route.context = options.context;
      options.route.context = options.context;
    }

    let backForceLoaded;
    if (options.force && router.params.stackPages) {
      router.$el.children('.page-previous.stacked').each((index, pageEl) => {
        if (pageEl.f7Page && pageEl.f7Page.route && pageEl.f7Page.route.url === route.url) {
          backForceLoaded = true;
          router.loadBack({ el: pageEl }, options);
        }
      });
      if (backForceLoaded) {
        return router;
      }
    }
    function resolve() {
      let routerLoaded = false;
      if (route.route.keepAlive && route.route.keepAliveData) {
        router.loadBack({ el: route.route.keepAliveData.pageEl }, options);
        routerLoaded = true;
      }
      ('url content component pageName el componentUrl template templateUrl').split(' ').forEach((pageLoadProp) => {
        if (route.route[pageLoadProp] && !routerLoaded) {
          routerLoaded = true;
          router.loadBack({ [pageLoadProp]: route.route[pageLoadProp] }, options);
        }
      });
      if (routerLoaded) return;
      // Async
      function asyncResolve(resolveParams, resolveOptions) {
        router.allowPageChange = false;
        if (resolveOptions && resolveOptions.context) {
          if (!route.context) route.context = resolveOptions.context;
          else route.context = Utils.extend({}, route.context, resolveOptions.context);
          options.route.context = route.context;
        }
        router.loadBack(resolveParams, Utils.extend(options, resolveOptions), true);
      }
      function asyncReject() {
        router.allowPageChange = true;
      }
      if (route.route.async) {
        router.allowPageChange = false;
        route.route.async.call(router, route, router.currentRoute, asyncResolve, asyncReject);
      }
      if (route.route.asyncComponent) {
        asyncComponent(router, route.route.asyncComponent, asyncResolve, asyncReject);
      }
    }
    function reject() {
      router.allowPageChange = true;
    }

    if (options.preload) {
      resolve();
    } else {
      processRouteQueue.call(
        router,
        route,
        router.currentRoute,
        () => {
          if (route.route.modules) {
            app
              .loadModules(Array.isArray(route.route.modules) ? route.route.modules : [route.route.modules])
              .then(() => {
                resolve();
              })
              .catch(() => {
                reject();
              });
          } else {
            resolve();
          }
        },
        () => {
          reject();
        },
      );
    }

    // Return Router
    return router;
  }

  function clearPreviousPages(router) {
    appRouterCheck(router, 'clearPreviousPages');
    const app = router.app;
    const dynamicNavbar = router.dynamicNavbar;

    const $pagesToRemove = router.$el
      .children('.page')
      .filter((index, pageInView) => {
        if (router.currentRoute && (router.currentRoute.modal || router.currentRoute.panel)) return true;
        return pageInView !== router.currentPageEl;
      });

    $pagesToRemove.each((index, pageEl) => {
      const $oldPageEl = $(pageEl);
      const $oldNavbarEl = $(app.navbar.getElByPage($oldPageEl));
      if (router.params.stackPages && router.initialPages.indexOf($oldPageEl[0]) >= 0) {
        $oldPageEl.addClass('stacked');
        if (dynamicNavbar) {
          $oldNavbarEl.addClass('stacked');
        }
      } else {
        // Page remove event
        router.pageCallback('beforeRemove', $oldPageEl, $oldNavbarEl, 'previous', undefined, {});
        router.removePage($oldPageEl);
        if (dynamicNavbar && $oldNavbarEl.length) {
          router.removeNavbar($oldNavbarEl);
        }
      }
    });
  }

  function clearPreviousHistory() {
    const router = this;
    appRouterCheck(router, 'clearPreviousHistory');
    const url = router.history[router.history.length - 1];

    clearPreviousPages(router);

    router.history = [url];
    router.view.history = [url];
    router.saveHistory();
  }

  class Router extends Framework7Class {
    constructor(app, view) {
      super({}, [typeof view === 'undefined' ? app : view]);
      const router = this;

      // Is App Router
      router.isAppRouter = typeof view === 'undefined';

      if (router.isAppRouter) {
        // App Router
        Utils.extend(false, router, {
          app,
          params: app.params.view,
          routes: app.routes || [],
          cache: app.cache,
        });
      } else {
        // View Router
        Utils.extend(false, router, {
          app,
          view,
          viewId: view.id,
          params: view.params,
          routes: view.routes,
          $el: view.$el,
          el: view.el,
          $navbarsEl: view.$navbarsEl,
          navbarsEl: view.navbarsEl,
          history: view.history,
          scrollHistory: view.scrollHistory,
          cache: app.cache,
          dynamicNavbar: app.theme === 'ios' && view.params.iosDynamicNavbar,
          initialPages: [],
          initialNavbars: [],
        });
      }

      // Install Modules
      router.useModules();

      // Temporary Dom
      router.tempDom = doc.createElement('div');

      // AllowPageChage
      router.allowPageChange = true;

      // Current Route
      let currentRoute = {};
      let previousRoute = {};
      Object.defineProperty(router, 'currentRoute', {
        enumerable: true,
        configurable: true,
        set(newRoute = {}) {
          previousRoute = Utils.extend({}, currentRoute);
          currentRoute = newRoute;
          if (!currentRoute) return;
          router.url = currentRoute.url;
          router.emit('routeChange', newRoute, previousRoute, router);
        },
        get() {
          return currentRoute;
        },
      });
      Object.defineProperty(router, 'previousRoute', {
        enumerable: true,
        configurable: true,
        get() {
          return previousRoute;
        },
        set(newRoute) {
          previousRoute = newRoute;
        },
      });

      return router;
    }

    animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction) {
      const router = this;
      const dynamicNavbar = router.dynamicNavbar;
      const animateIcon = router.params.iosAnimateNavbarBackIcon;

      let newNavEls;
      let oldNavEls;
      function animatableNavEl($el, $navbarInner) {
        const isSliding = $el.hasClass('sliding') || $navbarInner.hasClass('sliding');
        const isSubnavbar = $el.hasClass('subnavbar');
        const needsOpacityTransition = isSliding ? !isSubnavbar : true;
        const $iconEl = $el.find('.back .icon');
        let isIconLabel;
        if (isSliding && animateIcon && $el.hasClass('left') && $iconEl.length > 0 && $iconEl.next('span').length) {
          $el = $iconEl.next('span'); // eslint-disable-line
          isIconLabel = true;
        }
        return {
          $el,
          isIconLabel,
          leftOffset: $el[0].f7NavbarLeftOffset,
          rightOffset: $el[0].f7NavbarRightOffset,
          isSliding,
          isSubnavbar,
          needsOpacityTransition,
        };
      }
      if (dynamicNavbar) {
        newNavEls = [];
        oldNavEls = [];
        $newNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each((index, navEl) => {
          const $navEl = $(navEl);
          if ($navEl.hasClass('left') && fromLarge && direction === 'forward') return;
          if ($navEl.hasClass('title') && toLarge) return;
          newNavEls.push(animatableNavEl($navEl, $newNavbarEl.children('.navbar-inner')));
        });
        if (!($oldNavbarEl.hasClass('navbar-master') && router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint)) {
          $oldNavbarEl.children('.navbar-inner').children('.left, .right, .title, .subnavbar').each((index, navEl) => {
            const $navEl = $(navEl);
            if ($navEl.hasClass('left') && toLarge && !fromLarge && direction === 'forward') return;
            if ($navEl.hasClass('left') && toLarge && direction === 'backward') return;
            if ($navEl.hasClass('title') && fromLarge) {
              return;
            }
            oldNavEls.push(animatableNavEl($navEl, $oldNavbarEl.children('.navbar-inner')));
          });
        }
        [oldNavEls, newNavEls].forEach((navEls) => {
          navEls.forEach((navEl) => {
            const n = navEl;
            const { isSliding, $el } = navEl;
            const otherEls = navEls === oldNavEls ? newNavEls : oldNavEls;
            if (!(isSliding && $el.hasClass('title') && otherEls)) return;
            otherEls.forEach((otherNavEl) => {
              if (otherNavEl.isIconLabel) {
                const iconTextEl = otherNavEl.$el[0];
                n.leftOffset += iconTextEl ? (iconTextEl.offsetLeft || 0) : 0;
              }
            });
          });
        });
      }

      return { newNavEls, oldNavEls };
    }

    animate($oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, transition, callback) {
      const router = this;
      if (router.params.animateCustom) {
        router.params.animateCustom.apply(router, [$oldPageEl, $newPageEl, $oldNavbarEl, $newNavbarEl, direction, callback]);
        return;
      }
      const dynamicNavbar = router.dynamicNavbar;
      const ios = router.app.theme === 'ios';
      if (transition) {
        const routerCustomTransitionClass = `router-transition-custom router-transition-${transition}-${direction}`;
        // Animate
        const onCustomTransitionDone = () => {
          router.$el.removeClass(routerCustomTransitionClass);
          if (dynamicNavbar && router.$navbarsEl.length) {
            if ($newNavbarEl) {
              router.$navbarsEl.prepend($newNavbarEl);
            }
            if ($oldNavbarEl) {
              router.$navbarsEl.prepend($oldNavbarEl);
            }
          }
          if (callback) callback();
        };

        (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(onCustomTransitionDone);
        if (dynamicNavbar) {
          if ($newNavbarEl && $newPageEl) {
            router.setNavbarPosition($newNavbarEl, '');
            $newNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
            $newPageEl.prepend($newNavbarEl);
          }
          if ($oldNavbarEl && $oldPageEl) {
            router.setNavbarPosition($oldNavbarEl, '');
            $oldNavbarEl.removeClass('navbar-next navbar-previous navbar-current');
            $oldPageEl.prepend($oldNavbarEl);
          }
        }

        router.$el.addClass(routerCustomTransitionClass);
        return;
      }


      // Router Animation class
      const routerTransitionClass = `router-transition-${direction} router-transition`;

      let newNavEls;
      let oldNavEls;

      let fromLarge;
      let toLarge;

      let oldIsLarge;
      let newIsLarge;

      if (ios && dynamicNavbar) {
        const betweenMasterAndDetail = router.params.masterDetailBreakpoint > 0 && router.app.width >= router.params.masterDetailBreakpoint
          && (
            ($oldNavbarEl.hasClass('navbar-master') && $newNavbarEl.hasClass('navbar-master-detail'))
            || ($oldNavbarEl.hasClass('navbar-master-detail') && $newNavbarEl.hasClass('navbar-master'))
          );
        if (!betweenMasterAndDetail) {
          oldIsLarge = $oldNavbarEl && $oldNavbarEl.hasClass('navbar-large');
          newIsLarge = $newNavbarEl && $newNavbarEl.hasClass('navbar-large');
          fromLarge = oldIsLarge && !$oldNavbarEl.hasClass('navbar-large-collapsed');
          toLarge = newIsLarge && !$newNavbarEl.hasClass('navbar-large-collapsed');
        }
        const navEls = router.animatableNavElements($newNavbarEl, $oldNavbarEl, toLarge, fromLarge, direction);
        newNavEls = navEls.newNavEls;
        oldNavEls = navEls.oldNavEls;
      }

      function animateNavbars(progress) {
        if (!(ios && dynamicNavbar)) return;
        if (progress === 1) {
          if (toLarge) {
            $newNavbarEl.addClass('router-navbar-transition-to-large');
            $oldNavbarEl.addClass('router-navbar-transition-to-large');
          }
          if (fromLarge) {
            $newNavbarEl.addClass('router-navbar-transition-from-large');
            $oldNavbarEl.addClass('router-navbar-transition-from-large');
          }
        }
        newNavEls.forEach((navEl) => {
          const $el = navEl.$el;
          const offset = direction === 'forward' ? navEl.rightOffset : navEl.leftOffset;
          if (navEl.isSliding) {
            if (navEl.isSubnavbar && newIsLarge) {
              $el[0].style.setProperty('transform', `translate3d(${offset * (1 - progress)}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`, 'important');
            } else {
              $el.transform(`translate3d(${offset * (1 - progress)}px,0,0)`);
            }
          }
        });
        oldNavEls.forEach((navEl) => {
          const $el = navEl.$el;
          const offset = direction === 'forward' ? navEl.leftOffset : navEl.rightOffset;
          if (navEl.isSliding) {
            if (navEl.isSubnavbar && oldIsLarge) {
              $el.transform(`translate3d(${offset * (progress)}px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0)`);
            } else {
              $el.transform(`translate3d(${offset * (progress)}px,0,0)`);
            }
          }
        });
      }

      // AnimationEnd Callback
      function onDone() {
        if (router.dynamicNavbar) {
          if ($newNavbarEl) {
            $newNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
            $newNavbarEl.addClass('navbar-no-title-large-transition');
            Utils.nextFrame(() => {
              $newNavbarEl.removeClass('navbar-no-title-large-transition');
            });
          }
          if ($oldNavbarEl) {
            $oldNavbarEl.removeClass('router-navbar-transition-to-large router-navbar-transition-from-large');
          }
          if ($newNavbarEl.hasClass('sliding')) {
            $newNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
          } else {
            $newNavbarEl.find('.sliding').transform('');
          }
          if ($oldNavbarEl.hasClass('sliding')) {
            $oldNavbarEl.find('.title, .left, .right, .left .icon, .subnavbar').transform('');
          } else {
            $oldNavbarEl.find('.sliding').transform('');
          }
        }
        router.$el.removeClass(routerTransitionClass);
        if (callback) callback();
      }

      (direction === 'forward' ? $newPageEl : $oldPageEl).animationEnd(() => {
        onDone();
      });

      // Animate
      if (dynamicNavbar) {
        // Prepare Navbars
        animateNavbars(0);
        Utils.nextFrame(() => {
          // Add class, start animation
          animateNavbars(1);
          router.$el.addClass(routerTransitionClass);
        });
      } else {
        // Add class, start animation
        router.$el.addClass(routerTransitionClass);
      }
    }

    removeModal(modalEl) {
      const router = this;
      router.removeEl(modalEl);
    }
    // eslint-disable-next-line
    removeTabContent(tabEl) {
      const $tabEl = $(tabEl);
      $tabEl.html('');
    }

    removeNavbar(el) {
      const router = this;
      router.removeEl(el);
    }

    removePage(el) {
      const $el = $(el);
      const f7Page = $el && $el[0] && $el[0].f7Page;
      const router = this;
      if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
        $el.remove();
        return;
      }
      router.removeEl(el);
    }

    removeEl(el) {
      if (!el) return;
      const router = this;
      const $el = $(el);
      if ($el.length === 0) return;
      $el.find('.tab').each((tabIndex, tabEl) => {
        $(tabEl).children().each((index, tabChild) => {
          if (tabChild.f7Component) {
            $(tabChild).trigger('tab:beforeremove');
            tabChild.f7Component.$destroy();
          }
        });
      });
      if ($el[0].f7Component && $el[0].f7Component.$destroy) {
        $el[0].f7Component.$destroy();
      }
      if (!router.params.removeElements) {
        return;
      }
      if (router.params.removeElementsWithTimeout) {
        setTimeout(() => {
          $el.remove();
        }, router.params.removeElementsTimeout);
      } else {
        $el.remove();
      }
    }

    getPageEl(content) {
      const router = this;
      if (typeof content === 'string') {
        router.tempDom.innerHTML = content;
      } else {
        if ($(content).hasClass('page')) {
          return content;
        }
        router.tempDom.innerHTML = '';
        $(router.tempDom).append(content);
      }

      return router.findElement('.page', router.tempDom);
    }

    findElement(stringSelector, container, notStacked) {
      const router = this;
      const view = router.view;
      const app = router.app;

      // Modals Selector
      const modalsSelector = '.popup, .dialog, .popover, .actions-modal, .sheet-modal, .login-screen, .page';

      const $container = $(container);
      let selector = stringSelector;
      if (notStacked) selector += ':not(.stacked)';

      let found = $container
        .find(selector)
        .filter((index, el) => $(el).parents(modalsSelector).length === 0);

      if (found.length > 1) {
        if (typeof view.selector === 'string') {
          // Search in related view
          found = $container.find(`${view.selector} ${selector}`);
        }
        if (found.length > 1) {
          // Search in main view
          found = $container.find(`.${app.params.viewMainClass} ${selector}`);
        }
      }
      if (found.length === 1) return found;

      // Try to find not stacked
      if (!notStacked) found = router.findElement(selector, $container, true);
      if (found && found.length === 1) return found;
      if (found && found.length > 1) return $(found[0]);
      return undefined;
    }

    flattenRoutes(routes = this.routes) {
      const router = this;
      let flattenedRoutes = [];
      routes.forEach((route) => {
        let hasTabRoutes = false;
        if ('tabs' in route && route.tabs) {
          const mergedPathsRoutes = route.tabs.map((tabRoute) => {
            const tRoute = Utils.extend({}, route, {
              path: (`${route.path}/${tabRoute.path}`).replace('///', '/').replace('//', '/'),
              parentPath: route.path,
              tab: tabRoute,
            });
            delete tRoute.tabs;
            delete tRoute.routes;
            return tRoute;
          });
          hasTabRoutes = true;
          flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
        }
        if ('detailRoutes' in route) {
          const mergedPathsRoutes = route.detailRoutes.map((detailRoute) => {
            const dRoute = Utils.extend({}, detailRoute);
            dRoute.masterRoute = route;
            dRoute.masterRoutePath = route.path;
            return dRoute;
          });
          flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes));
        }
        if ('routes' in route) {
          const mergedPathsRoutes = route.routes.map((childRoute) => {
            const cRoute = Utils.extend({}, childRoute);
            cRoute.path = (`${route.path}/${cRoute.path}`).replace('///', '/').replace('//', '/');
            return cRoute;
          });
          if (hasTabRoutes) {
            flattenedRoutes = flattenedRoutes.concat(router.flattenRoutes(mergedPathsRoutes));
          } else {
            flattenedRoutes = flattenedRoutes.concat(route, router.flattenRoutes(mergedPathsRoutes));
          }
        }
        if (!('routes' in route) && !('tabs' in route && route.tabs) && !('detailRoutes' in route)) {
          flattenedRoutes.push(route);
        }
      });
      return flattenedRoutes;
    }

    // eslint-disable-next-line
    parseRouteUrl(url) {
      if (!url) return {};
      const query = Utils.parseUrlQuery(url);
      const hash = url.split('#')[1];
      const params = {};
      const path = url.split('#')[0].split('?')[0];
      return {
        query,
        hash,
        params,
        url,
        path,
      };
    }

    generateUrl(parameters = {}) {
      if (typeof parameters === 'string') {
        return parameters;
      }
      const { name, params, query } = parameters;
      if (!name) {
        throw new Error('Framework7: name parameter is required');
      }
      const router = this;
      const route = router.findRouteByKey('name', name);
      if (!route) {
        throw new Error(`Framework7: route with name "${name}" not found`);
      }
      const url = router.constructRouteUrl(route, { params, query });
      if (!url) {
        throw new Error(`Framework7: can't construct URL for route with name "${name}"`);
      }
      return url;
    }

    // eslint-disable-next-line
    constructRouteUrl(route, { params, query } = {}) {
      const { path } = route;
      const toUrl = compile(path);
      let url;
      try {
        url = toUrl(params || {});
      } catch (error) {
        throw new Error(`Framework7: error constructing route URL from passed params:\nRoute: ${path}\n${error.toString()}`);
      }

      if (query) {
        if (typeof query === 'string') url += `?${query}`;
        else url += `?${Utils.serializeObject(query)}`;
      }

      return url;
    }

    findTabRoute(tabEl) {
      const router = this;
      const $tabEl = $(tabEl);
      const parentPath = router.currentRoute.route.parentPath;
      const tabId = $tabEl.attr('id');
      const flattenedRoutes = router.flattenRoutes(router.routes);
      let foundTabRoute;
      flattenedRoutes.forEach((route) => {
        if (
          route.parentPath === parentPath
          && route.tab
          && route.tab.id === tabId
        ) {
          foundTabRoute = route;
        }
      });
      return foundTabRoute;
    }

    findRouteByKey(key, value) {
      const router = this;
      const routes = router.routes;
      const flattenedRoutes = router.flattenRoutes(routes);
      let matchingRoute;

      flattenedRoutes.forEach((route) => {
        if (matchingRoute) return;
        if (route[key] === value) {
          matchingRoute = route;
        }
      });
      return matchingRoute;
    }

    findMatchingRoute(url) {
      if (!url) return undefined;
      const router = this;
      const routes = router.routes;
      const flattenedRoutes = router.flattenRoutes(routes);
      const { path, query, hash, params } = router.parseRouteUrl(url);
      let matchingRoute;
      flattenedRoutes.forEach((route) => {
        if (matchingRoute) return;
        const keys = [];

        const pathsToMatch = [route.path];
        if (route.alias) {
          if (typeof route.alias === 'string') pathsToMatch.push(route.alias);
          else if (Array.isArray(route.alias)) {
            route.alias.forEach((aliasPath) => {
              pathsToMatch.push(aliasPath);
            });
          }
        }

        let matched;
        pathsToMatch.forEach((pathToMatch) => {
          if (matched) return;
          matched = pathToRegexp(pathToMatch, keys).exec(path);
        });

        if (matched) {
          keys.forEach((keyObj, index) => {
            if (typeof keyObj.name === 'number') return;
            const paramValue = matched[index + 1];
            if (typeof paramValue === 'undefined' || paramValue === null) {
              params[keyObj.name] = paramValue;
            } else {
              params[keyObj.name] = decodeURIComponent(paramValue);
            }
          });

          let parentPath;
          if (route.parentPath) {
            parentPath = path.split('/').slice(0, route.parentPath.split('/').length - 1).join('/');
          }

          matchingRoute = {
            query,
            hash,
            params,
            url,
            path,
            parentPath,
            route,
            name: route.name,
          };
        }
      });
      return matchingRoute;
    }

    // eslint-disable-next-line
    replaceRequestUrlParams(url = '', options = {}) {
      let compiledUrl = url;
      if (typeof compiledUrl === 'string'
        && compiledUrl.indexOf('{{') >= 0
        && options
        && options.route
        && options.route.params
        && Object.keys(options.route.params).length
      ) {
        Object.keys(options.route.params).forEach((paramName) => {
          const regExp = new RegExp(`{{${paramName}}}`, 'g');
          compiledUrl = compiledUrl.replace(regExp, options.route.params[paramName] || '');
        });
      }
      return compiledUrl;
    }

    removeFromXhrCache(url) {
      const router = this;
      const xhrCache = router.cache.xhr;
      let index = false;
      for (let i = 0; i < xhrCache.length; i += 1) {
        if (xhrCache[i].url === url) index = i;
      }
      if (index !== false) xhrCache.splice(index, 1);
    }

    xhrRequest(requestUrl, options) {
      const router = this;
      const params = router.params;
      const { ignoreCache } = options;
      let url = requestUrl;

      let hasQuery = url.indexOf('?') >= 0;
      if (params.passRouteQueryToRequest
        && options
        && options.route
        && options.route.query
        && Object.keys(options.route.query).length
      ) {
        url += `${hasQuery ? '&' : '?'}${Utils.serializeObject(options.route.query)}`;
        hasQuery = true;
      }

      if (params.passRouteParamsToRequest
        && options
        && options.route
        && options.route.params
        && Object.keys(options.route.params).length
      ) {
        url += `${hasQuery ? '&' : '?'}${Utils.serializeObject(options.route.params)}`;
        hasQuery = true;
      }

      if (url.indexOf('{{') >= 0) {
        url = router.replaceRequestUrlParams(url, options);
      }
      // should we ignore get params or not
      if (params.xhrCacheIgnoreGetParameters && url.indexOf('?') >= 0) {
        url = url.split('?')[0];
      }
      return new Promise((resolve, reject) => {
        if (params.xhrCache && !ignoreCache && url.indexOf('nocache') < 0 && params.xhrCacheIgnore.indexOf(url) < 0) {
          for (let i = 0; i < router.cache.xhr.length; i += 1) {
            const cachedUrl = router.cache.xhr[i];
            if (cachedUrl.url === url) {
              // Check expiration
              if (Utils.now() - cachedUrl.time < params.xhrCacheDuration) {
                // Load from cache
                resolve(cachedUrl.content);
                return;
              }
            }
          }
        }
        router.xhr = router.app.request({
          url,
          method: 'GET',
          beforeSend(xhr) {
            router.emit('routerAjaxStart', xhr, options);
          },
          complete(xhr, status) {
            router.emit('routerAjaxComplete', xhr);
            if ((status !== 'error' && status !== 'timeout' && (xhr.status >= 200 && xhr.status < 300)) || xhr.status === 0) {
              if (params.xhrCache && xhr.responseText !== '') {
                router.removeFromXhrCache(url);
                router.cache.xhr.push({
                  url,
                  time: Utils.now(),
                  content: xhr.responseText,
                });
              }
              router.emit('routerAjaxSuccess', xhr, options);
              resolve(xhr.responseText);
            } else {
              router.emit('routerAjaxError', xhr, options);
              reject(xhr);
            }
          },
          error(xhr) {
            router.emit('routerAjaxError', xhr, options);
            reject(xhr);
          },
        });
      });
    }

    setNavbarPosition($el, position, ariaHidden) {
      const router = this;
      $el.removeClass('navbar-previous navbar-current navbar-next');
      if (position) {
        $el.addClass(`navbar-${position}`);
      }

      if (ariaHidden === false) {
        $el.removeAttr('aria-hidden');
      } else if (ariaHidden === true) {
        $el.attr('aria-hidden', 'true');
      }
      $el.trigger('navbar:position', { position });
      router.emit('navbarPosition', $el[0], position);
    }

    setPagePosition($el, position, ariaHidden) {
      const router = this;
      $el.removeClass('page-previous page-current page-next');
      $el.addClass(`page-${position}`);
      if (ariaHidden === false) {
        $el.removeAttr('aria-hidden');
      } else if (ariaHidden === true) {
        $el.attr('aria-hidden', 'true');
      }
      $el.trigger('page:position', { position });
      router.emit('pagePosition', $el[0], position);
    }

    // Remove theme elements
    removeThemeElements(el) {
      const router = this;
      const theme = router.app.theme;
      let toRemove;
      if (theme === 'ios') {
        toRemove = '.md-only, .aurora-only, .if-md, .if-aurora, .if-not-ios, .not-ios';
      } else if (theme === 'md') {
        toRemove = '.ios-only, .aurora-only, .if-ios, .if-aurora, .if-not-md, .not-md';
      } else if (theme === 'aurora') {
        toRemove = '.ios-only, .md-only, .if-ios, .if-md, .if-not-aurora, .not-aurora';
      }
      $(el).find(toRemove).remove();
    }

    getPageData(pageEl, navbarEl, from, to, route = {}, pageFromEl) {
      const router = this;
      const $pageEl = $(pageEl).eq(0);
      const $navbarEl = $(navbarEl).eq(0);
      const currentPage = $pageEl[0].f7Page || {};
      let direction;
      let pageFrom;
      if ((from === 'next' && to === 'current') || (from === 'current' && to === 'previous')) direction = 'forward';
      if ((from === 'current' && to === 'next') || (from === 'previous' && to === 'current')) direction = 'backward';
      if (currentPage && !currentPage.fromPage) {
        const $pageFromEl = $(pageFromEl);
        if ($pageFromEl.length) {
          pageFrom = $pageFromEl[0].f7Page;
        }
      }
      pageFrom = currentPage.pageFrom || pageFrom;
      if (pageFrom && pageFrom.pageFrom) {
        pageFrom.pageFrom = null;
      }
      const page = {
        app: router.app,
        view: router.view,
        router,
        $el: $pageEl,
        el: $pageEl[0],
        $pageEl,
        pageEl: $pageEl[0],
        $navbarEl,
        navbarEl: $navbarEl[0],
        name: $pageEl.attr('data-name'),
        position: from,
        from,
        to,
        direction,
        route: currentPage.route ? currentPage.route : route,
        pageFrom,
      };

      $pageEl[0].f7Page = page;
      return page;
    }

    // Callbacks
    pageCallback(callback, pageEl, navbarEl, from, to, options = {}, pageFromEl) {
      if (!pageEl) return;
      const router = this;
      const $pageEl = $(pageEl);
      if (!$pageEl.length) return;
      const $navbarEl = $(navbarEl);
      const { route } = options;
      const restoreScrollTopOnBack = router.params.restoreScrollTopOnBack
        && !(
          router.params.masterDetailBreakpoint > 0
          && $pageEl.hasClass('page-master')
          && router.app.width >= router.params.masterDetailBreakpoint
        );
      const keepAlive = $pageEl[0].f7Page && $pageEl[0].f7Page.route && $pageEl[0].f7Page.route.route && $pageEl[0].f7Page.route.route.keepAlive;

      if (callback === 'beforeRemove' && keepAlive) {
        callback = 'beforeUnmount'; // eslint-disable-line
      }

      const camelName = `page${callback[0].toUpperCase() + callback.slice(1, callback.length)}`;
      const colonName = `page:${callback.toLowerCase()}`;

      let page = {};
      if (callback === 'beforeRemove' && $pageEl[0].f7Page) {
        page = Utils.extend($pageEl[0].f7Page, { from, to, position: from });
      } else {
        page = router.getPageData($pageEl[0], $navbarEl[0], from, to, route, pageFromEl);
      }
      page.swipeBack = !!options.swipeBack;

      const { on = {}, once = {} } = options.route ? options.route.route : {};
      if (options.on) {
        Utils.extend(on, options.on);
      }
      if (options.once) {
        Utils.extend(once, options.once);
      }

      function attachEvents() {
        if ($pageEl[0].f7RouteEventsAttached) return;
        $pageEl[0].f7RouteEventsAttached = true;
        if (on && Object.keys(on).length > 0) {
          $pageEl[0].f7RouteEventsOn = on;
          Object.keys(on).forEach((eventName) => {
            on[eventName] = on[eventName].bind(router);
            $pageEl.on(Utils.eventNameToColonCase(eventName), on[eventName]);
          });
        }
        if (once && Object.keys(once).length > 0) {
          $pageEl[0].f7RouteEventsOnce = once;
          Object.keys(once).forEach((eventName) => {
            once[eventName] = once[eventName].bind(router);
            $pageEl.once(Utils.eventNameToColonCase(eventName), once[eventName]);
          });
        }
      }

      function detachEvents() {
        if (!$pageEl[0].f7RouteEventsAttached) return;
        if ($pageEl[0].f7RouteEventsOn) {
          Object.keys($pageEl[0].f7RouteEventsOn).forEach((eventName) => {
            $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOn[eventName]);
          });
        }
        if ($pageEl[0].f7RouteEventsOnce) {
          Object.keys($pageEl[0].f7RouteEventsOnce).forEach((eventName) => {
            $pageEl.off(Utils.eventNameToColonCase(eventName), $pageEl[0].f7RouteEventsOnce[eventName]);
          });
        }
        $pageEl[0].f7RouteEventsAttached = null;
        $pageEl[0].f7RouteEventsOn = null;
        $pageEl[0].f7RouteEventsOnce = null;
        delete $pageEl[0].f7RouteEventsAttached;
        delete $pageEl[0].f7RouteEventsOn;
        delete $pageEl[0].f7RouteEventsOnce;
      }

      if (callback === 'mounted') {
        attachEvents();
      }
      if (callback === 'init') {
        if (restoreScrollTopOnBack && (from === 'previous' || !from) && to === 'current' && router.scrollHistory[page.route.url] && !$pageEl.hasClass('no-restore-scroll')) {
          let $pageContent = $pageEl.find('.page-content');
          if ($pageContent.length > 0) {
            // eslint-disable-next-line
            $pageContent = $pageContent.filter((pageContentIndex, pageContentEl) => {
              return (
                $(pageContentEl).parents('.tab:not(.tab-active)').length === 0
                && !$(pageContentEl).is('.tab:not(.tab-active)')
              );
            });
          }
          $pageContent.scrollTop(router.scrollHistory[page.route.url]);
        }
        attachEvents();
        if ($pageEl[0].f7PageInitialized) {
          $pageEl.trigger('page:reinit', page);
          router.emit('pageReinit', page);
          return;
        }
        $pageEl[0].f7PageInitialized = true;
      }
      if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'previous') {
        // Save scroll position
        let $pageContent = $pageEl.find('.page-content');
        if ($pageContent.length > 0) {
          // eslint-disable-next-line
          $pageContent = $pageContent.filter((pageContentIndex, pageContentEl) => {
            return (
              $(pageContentEl).parents('.tab:not(.tab-active)').length === 0
              && !$(pageContentEl).is('.tab:not(.tab-active)')
            );
          });
        }
        router.scrollHistory[page.route.url] = $pageContent.scrollTop();
      }
      if (restoreScrollTopOnBack && callback === 'beforeOut' && from === 'current' && to === 'next') {
        // Delete scroll position
        delete router.scrollHistory[page.route.url];
      }

      $pageEl.trigger(colonName, page);
      router.emit(camelName, page);

      if (callback === 'beforeRemove' || callback === 'beforeUnmount') {
        detachEvents();
        if (!keepAlive) {
          if ($pageEl[0].f7Page && $pageEl[0].f7Page.navbarEl) {
            delete $pageEl[0].f7Page.navbarEl.f7Page;
          }
          $pageEl[0].f7Page = null;
        }
      }
    }

    saveHistory() {
      const router = this;
      router.view.history = router.history;
      if (router.params.pushState) {
        win.localStorage[`f7router-${router.view.id}-history`] = JSON.stringify(router.history);
      }
    }

    restoreHistory() {
      const router = this;
      if (router.params.pushState && win.localStorage[`f7router-${router.view.id}-history`]) {
        router.history = JSON.parse(win.localStorage[`f7router-${router.view.id}-history`]);
        router.view.history = router.history;
      }
    }

    clearHistory() {
      const router = this;
      router.history = [];
      if (router.view) router.view.history = [];
      router.saveHistory();
    }

    updateCurrentUrl(newUrl) {
      const router = this;
      appRouterCheck(router, 'updateCurrentUrl');
      // Update history
      if (router.history.length) {
        router.history[router.history.length - 1] = newUrl;
      } else {
        router.history.push(newUrl);
      }

      // Update current route params
      const { query, hash, params, url, path } = router.parseRouteUrl(newUrl);
      if (router.currentRoute) {
        Utils.extend(router.currentRoute, {
          query,
          hash,
          params,
          url,
          path,
        });
      }

      if (router.params.pushState) {
        const pushStateRoot = router.params.pushStateRoot || '';
        History.replace(
          router.view.id,
          {
            url: newUrl,
          },
          pushStateRoot + router.params.pushStateSeparator + newUrl
        );
      }

      // Save History
      router.saveHistory();

      router.emit('routeUrlUpdate', router.currentRoute, router);
    }

    init() {
      const router = this;
      const { app, view } = router;

      // Init Swipeback
      if (
        (view && router.params.iosSwipeBack && app.theme === 'ios')
        || (view && router.params.mdSwipeBack && app.theme === 'md')
        || (view && router.params.auroraSwipeBack && app.theme === 'aurora')
      ) {
        SwipeBack(router);
      }

      let initUrl = router.params.url;
      let documentUrl = doc.location.href.split(doc.location.origin)[1];
      let historyRestored;
      const { pushState, pushStateOnLoad, pushStateSeparator, pushStateAnimateOnLoad } = router.params;
      let { pushStateRoot } = router.params;
      if (win.cordova && pushState && !pushStateSeparator && !pushStateRoot && doc.location.pathname.indexOf('index.html')) {
        // eslint-disable-next-line
        console.warn('Framework7: wrong or not complete pushState configuration, trying to guess pushStateRoot');
        pushStateRoot = doc.location.pathname.split('index.html')[0];
      }
      if (!pushState || !pushStateOnLoad) {
        if (!initUrl) {
          initUrl = documentUrl;
        }
        if (doc.location.search && initUrl.indexOf('?') < 0) {
          initUrl += doc.location.search;
        }
        if (doc.location.hash && initUrl.indexOf('#') < 0) {
          initUrl += doc.location.hash;
        }
      } else {
        if (pushStateRoot && documentUrl.indexOf(pushStateRoot) >= 0) {
          documentUrl = documentUrl.split(pushStateRoot)[1];
          if (documentUrl === '') documentUrl = '/';
        }
        if (pushStateSeparator.length > 0 && documentUrl.indexOf(pushStateSeparator) >= 0) {
          initUrl = documentUrl.split(pushStateSeparator)[1];
        } else {
          initUrl = documentUrl;
        }
        router.restoreHistory();
        if (router.history.indexOf(initUrl) >= 0) {
          router.history = router.history.slice(0, router.history.indexOf(initUrl) + 1);
        } else if (router.params.url === initUrl) {
          router.history = [initUrl];
        } else if (History.state && History.state[view.id] && History.state[view.id].url === router.history[router.history.length - 1]) {
          initUrl = router.history[router.history.length - 1];
        } else {
          router.history = [documentUrl.split(pushStateSeparator)[0] || '/', initUrl];
        }
        if (router.history.length > 1) {
          historyRestored = true;
        } else {
          router.history = [];
        }
        router.saveHistory();
      }
      let currentRoute;
      if (router.history.length > 1) {
        // Will load page
        currentRoute = router.findMatchingRoute(router.history[0]);
        if (!currentRoute) {
          currentRoute = Utils.extend(router.parseRouteUrl(router.history[0]), {
            route: {
              url: router.history[0],
              path: router.history[0].split('?')[0],
            },
          });
        }
      } else {
        // Don't load page
        currentRoute = router.findMatchingRoute(initUrl);
        if (!currentRoute) {
          currentRoute = Utils.extend(router.parseRouteUrl(initUrl), {
            route: {
              url: initUrl,
              path: initUrl.split('?')[0],
            },
          });
        }
      }

      if (router.params.stackPages) {
        router.$el.children('.page').each((index, pageEl) => {
          const $pageEl = $(pageEl);
          router.initialPages.push($pageEl[0]);
          if (router.dynamicNavbar && $pageEl.children('.navbar').length > 0) {
            router.initialNavbars.push($pageEl.children('.navbar')[0]);
          }
        });
      }

      if (router.$el.children('.page:not(.stacked)').length === 0 && initUrl && router.params.loadInitialPage) {
        // No pages presented in DOM, reload new page
        router.navigate(initUrl, {
          initial: true,
          reloadCurrent: true,
          pushState: false,
        });
      } else if (router.$el.children('.page:not(.stacked)').length) {
        // Init current DOM page
        let hasTabRoute;
        router.currentRoute = currentRoute;
        router.$el.children('.page:not(.stacked)').each((index, pageEl) => {
          const $pageEl = $(pageEl);
          let $navbarEl;
          router.setPagePosition($pageEl, 'current');
          if (router.dynamicNavbar) {
            $navbarEl = $pageEl.children('.navbar');
            if ($navbarEl.length > 0) {
              if (!router.$navbarsEl.parents(doc).length) {
                router.$el.prepend(router.$navbarsEl);
              }
              router.setNavbarPosition($navbarEl, 'current');
              router.$navbarsEl.append($navbarEl);
              if ($navbarEl.children('.title-large').length) {
                $navbarEl.addClass('navbar-large');
              }
              $pageEl.children('.navbar').remove();
            } else {
              router.$navbarsEl.addClass('navbar-hidden');
              if ($navbarEl.children('.title-large').length) {
                router.$navbarsEl.addClass('navbar-hidden navbar-large-hidden');
              }
            }
          }
          if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.master && router.params.masterDetailBreakpoint > 0) {
            $pageEl.addClass('page-master');
            $pageEl.trigger('page:role', { role: 'master' });
            if ($navbarEl && $navbarEl.length) {
              $navbarEl.addClass('navbar-master');
            }
            view.checkMasterDetailBreakpoint();
          }
          const initOptions = {
            route: router.currentRoute,
          };
          if (router.currentRoute && router.currentRoute.route && router.currentRoute.route.options) {
            Utils.extend(initOptions, router.currentRoute.route.options);
          }
          router.currentPageEl = $pageEl[0];
          if (router.dynamicNavbar && $navbarEl.length) {
            router.currentNavbarEl = $navbarEl[0];
          }
          router.removeThemeElements($pageEl);
          if (router.dynamicNavbar && $navbarEl.length) {
            router.removeThemeElements($navbarEl);
          }
          if (initOptions.route.route.tab) {
            hasTabRoute = true;
            router.tabLoad(initOptions.route.route.tab, Utils.extend({}, initOptions));
          }
          router.pageCallback('init', $pageEl, $navbarEl, 'current', undefined, initOptions);
        });
        if (historyRestored) {
          router.navigate(initUrl, {
            initial: true,
            pushState: false,
            history: false,
            animate: pushStateAnimateOnLoad,
            once: {
              pageAfterIn() {
                const preloadPreviousPage = router.params.preloadPreviousPage || router.params[`${app.theme}SwipeBack`];
                if (preloadPreviousPage && router.history.length > 2) {
                  router.back({ preload: true });
                }
              },
            },
          });
        }
        if (!historyRestored && !hasTabRoute) {
          router.history.push(initUrl);
          router.saveHistory();
        }
      }
      if (initUrl && pushState && pushStateOnLoad && (!History.state || !History.state[view.id])) {
        History.initViewState(view.id, {
          url: initUrl,
        });
      }
      router.emit('local::init routerInit', router);
    }

    destroy() {
      let router = this;

      router.emit('local::destroy routerDestroy', router);

      // Delete props & methods
      Object.keys(router).forEach((routerProp) => {
        router[routerProp] = null;
        delete router[routerProp];
      });

      router = null;
    }
  }

  // Load
  Router.prototype.forward = forward;
  Router.prototype.load = load;
  Router.prototype.navigate = navigate;
  Router.prototype.refreshPage = refreshPage;
  // Tab
  Router.prototype.tabLoad = tabLoad;
  Router.prototype.tabRemove = tabRemove;
  // Modal
  Router.prototype.modalLoad = modalLoad;
  Router.prototype.modalRemove = modalRemove;
  // Back
  Router.prototype.backward = backward;
  Router.prototype.loadBack = loadBack;
  Router.prototype.back = back;
  // Clear history
  Router.prototype.clearPreviousHistory = clearPreviousHistory;

  var RouterModule = {
    name: 'router',
    static: {
      Router,
    },
    instance: {
      cache: {
        xhr: [],
        templates: [],
        components: [],
      },
    },
    create() {
      const instance = this;
      if (instance.app) {
        // View Router
        if (instance.params.router) {
          instance.router = new Router(instance.app, instance);
        }
      } else {
        // App Router
        instance.router = new Router(instance);
      }
    },
  };

  function resizableView(view) {
    const app = view.app;
    if (view.resizableInitialized) return;
    Utils.extend(view, {
      resizable: true,
      resizableWidth: null,
      resizableInitialized: true,
    });
    const $htmlEl = $('html');
    const { $el } = view;
    if (!$el) return;

    let $resizeHandlerEl;

    let isTouched;
    let isMoved;
    const touchesStart = {};
    let touchesDiff;
    let width;

    let minWidth;
    let maxWidth;

    function transformCSSWidth(v) {
      if (!v) return null;
      if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
        return parseInt(v, 10) / 100 * app.width;
      }
      const newV = parseInt(v, 10);
      if (Number.isNaN(newV)) return null;
      return newV;
    }

    function isResizable() {
      return view.resizable && $el.hasClass('view-resizable') && $el.hasClass('view-master-detail');
    }

    function handleTouchStart(e) {
      if (!isResizable()) return;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isMoved = false;
      isTouched = true;
      const $pageMasterEl = $el.children('.page-master');
      minWidth = transformCSSWidth($pageMasterEl.css('min-width'));
      maxWidth = transformCSSWidth($pageMasterEl.css('max-width'));
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      e.f7PreventSwipePanel = true;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

      if (!isMoved) {
        width = $resizeHandlerEl[0].offsetLeft + $resizeHandlerEl[0].offsetWidth;
        $el.addClass('view-resizing');
        $htmlEl.css('cursor', 'col-resize');
      }

      isMoved = true;

      e.preventDefault();

      touchesDiff = (pageX - touchesStart.x);

      let newWidth = width + touchesDiff;
      if (minWidth && !Number.isNaN(minWidth)) {
        newWidth = Math.max(newWidth, minWidth);
      }
      if (maxWidth && !Number.isNaN(maxWidth)) {
        newWidth = Math.min(newWidth, maxWidth);
      }
      newWidth = Math.min(Math.max(newWidth, 0), app.width);

      view.resizableWidth = newWidth;
      $htmlEl[0].style.setProperty('--f7-page-master-width', `${newWidth}px`);

      $el.trigger('view:resize', newWidth);
      view.emit('local::resize viewResize', view, newWidth);
    }
    function handleTouchEnd() {
      $('html').css('cursor', '');
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;

      $htmlEl[0].style.setProperty('--f7-page-master-width', `${view.resizableWidth}px`);
      $el.removeClass('view-resizing');
    }

    function handleResize() {
      if (!view.resizableWidth) return;
      minWidth = transformCSSWidth($resizeHandlerEl.css('min-width'));
      maxWidth = transformCSSWidth($resizeHandlerEl.css('max-width'));

      if (minWidth && !Number.isNaN(minWidth) && view.resizableWidth < minWidth) {
        view.resizableWidth = Math.max(view.resizableWidth, minWidth);
      }
      if (maxWidth && !Number.isNaN(maxWidth) && view.resizableWidth > maxWidth) {
        view.resizableWidth = Math.min(view.resizableWidth, maxWidth);
      }
      view.resizableWidth = Math.min(Math.max(view.resizableWidth, 0), app.width);

      $htmlEl[0].style.setProperty('--f7-page-master-width', `${view.resizableWidth}px`);
    }

    $resizeHandlerEl = view.$el.children('.view-resize-handler');
    if (!$resizeHandlerEl.length) {
      view.$el.append('<div class="view-resize-handler"></div>');
      $resizeHandlerEl = view.$el.children('.view-resize-handler');
    }
    view.$resizeHandlerEl = $resizeHandlerEl;

    $el.addClass('view-resizable');

    // Add Events
    const passive = Support.passiveListener ? { passive: true } : false;

    view.$el.on(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('resize', handleResize);
    view.on('beforeOpen', handleResize);

    view.once('viewDestroy', () => {
      $el.removeClass('view-resizable');
      view.$resizeHandlerEl.remove();
      view.$el.off(app.touchEvents.start, '.view-resize-handler', handleTouchStart, passive);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('resize', handleResize);
      view.off('beforeOpen', handleResize);
    });
  }

  class View extends Framework7Class {
    constructor(appInstance, el, viewParams = {}) {
      super(viewParams, [appInstance]);

      const app = appInstance;
      const $el = $(el);
      const view = this;

      const defaults = {
        routes: [],
        routesAdd: [],
      };

      if ($el.length === 0) {
        let message = 'Framework7: can\'t create a View instance because ';
        message += (typeof el === 'string')
          ? `the selector "${el}" didn't match any element`
          : 'el must be an HTMLElement or Dom7 object';

        throw new Error(message);
      }

      // Default View params
      view.params = Utils.extend(defaults, app.params.view, viewParams);

      // Routes
      if (view.params.routes.length > 0) {
        view.routes = view.params.routes;
      } else {
        view.routes = [].concat(app.routes, view.params.routesAdd);
      }

      // Selector
      let selector;
      if (typeof el === 'string') selector = el;
      else {
        // Supposed to be HTMLElement or Dom7
        selector = ($el.attr('id') ? `#${$el.attr('id')}` : '') + ($el.attr('class') ? `.${$el.attr('class').replace(/ /g, '.').replace('.active', '')}` : '');
      }

      // DynamicNavbar
      let $navbarsEl;
      if (app.theme === 'ios' && view.params.iosDynamicNavbar) {
        $navbarsEl = $el.children('.navbars').eq(0);
        if ($navbarsEl.length === 0) {
          $navbarsEl = $('<div class="navbars"></div>');
        }
      }

      // View Props
      Utils.extend(false, view, {
        app,
        $el,
        el: $el[0],
        name: view.params.name,
        main: view.params.main || $el.hasClass('view-main'),
        $navbarsEl,
        navbarsEl: $navbarsEl ? $navbarsEl[0] : undefined,
        selector,
        history: [],
        scrollHistory: {},
      });

      // Save in DOM
      $el[0].f7View = view;

      // Install Modules
      view.useModules();

      // Add to app
      app.views.push(view);
      if (view.main) {
        app.views.main = view;
      }
      if (view.name) {
        app.views[view.name] = view;
      }

      // Index
      view.index = app.views.indexOf(view);

      // View ID
      let viewId;
      if (view.name) {
        viewId = `view_${view.name}`;
      } else if (view.main) {
        viewId = 'view_main';
      } else {
        viewId = `view_${view.index}`;
      }
      view.id = viewId;

      // Init View
      if (app.initialized) {
        view.init();
      } else {
        app.on('init', () => {
          view.init();
        });
      }

      return view;
    }

    destroy() {
      let view = this;
      const app = view.app;

      view.$el.trigger('view:beforedestroy');
      view.emit('local::beforeDestroy viewBeforeDestroy', view);

      app.off('resize', view.checkMasterDetailBreakpoint);

      if (view.main) {
        app.views.main = null;
        delete app.views.main;
      } else if (view.name) {
        app.views[view.name] = null;
        delete app.views[view.name];
      }
      view.$el[0].f7View = null;
      delete view.$el[0].f7View;

      app.views.splice(app.views.indexOf(view), 1);

      // Destroy Router
      if (view.params.router && view.router) {
        view.router.destroy();
      }

      view.emit('local::destroy viewDestroy', view);

      // Delete props & methods
      Object.keys(view).forEach((viewProp) => {
        view[viewProp] = null;
        delete view[viewProp];
      });

      view = null;
    }

    checkMasterDetailBreakpoint(force) {
      const view = this;
      const app = view.app;
      const wasMasterDetail = view.$el.hasClass('view-master-detail');
      const isMasterDetail = app.width >= view.params.masterDetailBreakpoint && view.$el.children('.page-master').length;
      if ((typeof force === 'undefined' && isMasterDetail) || force === true) {
        view.$el.addClass('view-master-detail');
        if (!wasMasterDetail) {
          view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
          view.$el.trigger('view:masterDetailBreakpoint');
        }
      } else {
        view.$el.removeClass('view-master-detail');
        if (wasMasterDetail) {
          view.emit('local::masterDetailBreakpoint viewMasterDetailBreakpoint', view);
          view.$el.trigger('view:masterDetailBreakpoint');
        }
      }
    }

    initMasterDetail() {
      const view = this;
      const app = view.app;
      view.checkMasterDetailBreakpoint = view.checkMasterDetailBreakpoint.bind(view);
      view.checkMasterDetailBreakpoint();
      if (view.params.masterDetailResizable) {
        resizableView(view);
      }
      app.on('resize', view.checkMasterDetailBreakpoint);
    }

    init() {
      const view = this;
      if (view.params.router) {
        if (view.params.masterDetailBreakpoint > 0) {
          view.initMasterDetail();
        }
        view.router.init();
        view.$el.trigger('view:init');
        view.emit('local::init viewInit', view);
      }
    }
  }

  // Use Router
  View.use(RouterModule);

  function initClicks(app) {
    function handleClicks(e) {
      const $clickedEl = $(e.target);
      const $clickedLinkEl = $clickedEl.closest('a');
      const isLink = $clickedLinkEl.length > 0;
      const url = isLink && $clickedLinkEl.attr('href');
      // const isTabLink = isLink && $clickedLinkEl.hasClass('tab-link') && ($clickedLinkEl.attr('data-tab') || (url && url.indexOf('#') === 0));

      // Check if link is external
      if (isLink) {
        // eslint-disable-next-line
        if ($clickedLinkEl.is(app.params.clicks.externalLinks) || (url && url.indexOf('javascript:') >= 0)) {
          const target = $clickedLinkEl.attr('target');
          if (
            url
            && win.cordova
            && win.cordova.InAppBrowser
            && (target === '_system' || target === '_blank')
          ) {
            e.preventDefault();
            win.cordova.InAppBrowser.open(url, target);
          }
          return;
        }
      }

      // Modules Clicks
      Object.keys(app.modules).forEach((moduleName) => {
        const moduleClicks = app.modules[moduleName].clicks;
        if (!moduleClicks) return;
        if (e.preventF7Router) return;
        Object.keys(moduleClicks).forEach((clickSelector) => {
          const matchingClickedElement = $clickedEl.closest(clickSelector).eq(0);
          if (matchingClickedElement.length > 0) {
            moduleClicks[clickSelector].call(app, matchingClickedElement, matchingClickedElement.dataset(), e);
          }
        });
      });

      // Load Page
      let clickedLinkData = {};
      if (isLink) {
        e.preventDefault();
        clickedLinkData = $clickedLinkEl.dataset();
      }

      // Prevent Router
      if (e.preventF7Router) return;
      if ($clickedLinkEl.hasClass('prevent-router') || $clickedLinkEl.hasClass('router-prevent')) return;

      const validUrl = url && url.length > 0 && url[0] !== '#';
      if (validUrl || $clickedLinkEl.hasClass('back')) {
        let view;
        if (clickedLinkData.view && clickedLinkData.view === 'current') {
          view = app.views.current;
        } else if (clickedLinkData.view) {
          view = $(clickedLinkData.view)[0].f7View;
        } else {
          view = $clickedEl.parents('.view')[0] && $clickedEl.parents('.view')[0].f7View;
          if (!$clickedLinkEl.hasClass('back') && view && view.params.linksView) {
            if (typeof view.params.linksView === 'string') view = $(view.params.linksView)[0].f7View;
            else if (view.params.linksView instanceof View) view = view.params.linksView;
          }
        }
        if (!view) {
          if (app.views.main) view = app.views.main;
        }
        if (!view || !view.router) return;
        if (clickedLinkData.context && typeof clickedLinkData.context === 'string') {
          try {
            clickedLinkData.context = JSON.parse(clickedLinkData.context);
          } catch (err) {
            // something wrong there
          }
        }
        if ($clickedLinkEl[0].f7RouteProps) {
          clickedLinkData.props = $clickedLinkEl[0].f7RouteProps;
        }
        if ($clickedLinkEl.hasClass('back')) view.router.back(url, clickedLinkData);
        else view.router.navigate(url, clickedLinkData);
      }
    }

    app.on('click', handleClicks);
  }
  var ClicksModule = {
    name: 'clicks',
    params: {
      clicks: {
        // External Links
        externalLinks: '.external',
      },
    },
    on: {
      init() {
        const app = this;
        initClicks(app);
      },
    },
  };

  var HistoryModule = {
    name: 'history',
    static: {
      history: History,
    },
    on: {
      init() {
        History.init(this);
      },
    },
  };

  const SW = {
    registrations: [],
    register(path, scope) {
      const app = this;
      if (!('serviceWorker' in win.navigator) || !app.serviceWorker.container) {
        return new Promise((resolve, reject) => {
          reject(new Error('Service worker is not supported'));
        });
      }
      return new Promise((resolve, reject) => {
        app.serviceWorker.container.register(path, (scope ? { scope } : {}))
          .then((reg) => {
            SW.registrations.push(reg);
            app.emit('serviceWorkerRegisterSuccess', reg);
            resolve(reg);
          }).catch((error) => {
            app.emit('serviceWorkerRegisterError', error);
            reject(error);
          });
      });
    },
    unregister(registration) {
      const app = this;
      if (!('serviceWorker' in win.navigator) || !app.serviceWorker.container) {
        return new Promise((resolve, reject) => {
          reject(new Error('Service worker is not supported'));
        });
      }
      let registrations;
      if (!registration) registrations = SW.registrations;
      else if (Array.isArray(registration)) registrations = registration;
      else registrations = [registration];
      return Promise.all(registrations.map(reg => new Promise((resolve, reject) => {
        reg.unregister()
          .then(() => {
            if (SW.registrations.indexOf(reg) >= 0) {
              SW.registrations.splice(SW.registrations.indexOf(reg), 1);
            }
            app.emit('serviceWorkerUnregisterSuccess', reg);
            resolve();
          })
          .catch((error) => {
            app.emit('serviceWorkerUnregisterError', reg, error);
            reject(error);
          });
      })));
    },
  };

  var ServiceWorkerModule = {
    name: 'sw',
    params: {
      serviceWorker: {
        path: undefined,
        scope: undefined,
      },
    },
    create() {
      const app = this;
      Utils.extend(app, {
        serviceWorker: {
          container: ('serviceWorker' in win.navigator) ? win.navigator.serviceWorker : undefined,
          registrations: SW.registrations,
          register: SW.register.bind(app),
          unregister: SW.unregister.bind(app),
        },
      });
    },
    on: {
      init() {
        if (!('serviceWorker' in win.navigator)) return;
        const app = this;
        if (!app.serviceWorker.container) return;
        const paths = app.params.serviceWorker.path;
        const scope = app.params.serviceWorker.scope;
        if (!paths || (Array.isArray(paths) && !paths.length)) return;
        const toRegister = Array.isArray(paths) ? paths : [paths];
        toRegister.forEach((path) => {
          app.serviceWorker.register(path, scope);
        });
      },
    },
  };

  const Statusbar = {
    hide() {
      if (Device.cordova && win.StatusBar) {
        win.StatusBar.hide();
      }
    },
    show() {
      if (Device.cordova && win.StatusBar) {
        win.StatusBar.show();
      }
    },
    onClick() {
      const app = this;
      let pageContent;
      if ($('.popup.modal-in').length > 0) {
        // Check for opened popup
        pageContent = $('.popup.modal-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
      } else if ($('.panel.panel-in').length > 0) {
        // Check for opened panel
        pageContent = $('.panel.panel-in').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
      } else if ($('.views > .view.tab-active').length > 0) {
        // View in tab bar app layout
        pageContent = $('.views > .view.tab-active').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
      } else if ($('.views').length > 0) {
        pageContent = $('.views').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
      } else {
        pageContent = app.root.children('.view').find('.page:not(.page-previous):not(.page-next):not(.cached)').find('.page-content');
      }

      if (pageContent && pageContent.length > 0) {
        // Check for tab
        if (pageContent.hasClass('tab')) {
          pageContent = pageContent.parent('.tabs').children('.page-content.tab-active');
        }
        if (pageContent.length > 0) pageContent.scrollTop(0, 300);
      }
    },
    setTextColor(color) {
      if (Device.cordova && win.StatusBar) {
        if (color === 'white') {
          win.StatusBar.styleLightContent();
        } else {
          win.StatusBar.styleDefault();
        }
      }
    },
    setBackgroundColor(color) {
      if (Device.cordova && win.StatusBar) {
        win.StatusBar.backgroundColorByHexString(color);
      }
    },
    isVisible() {
      if (Device.cordova && win.StatusBar) {
        return win.StatusBar.isVisible;
      }
      return false;
    },
    overlaysWebView(overlays = true) {
      if (Device.cordova && win.StatusBar) {
        win.StatusBar.overlaysWebView(overlays);
      }
    },
    init() {
      const app = this;
      const params = app.params.statusbar;
      if (!params.enabled) return;

      if (Device.cordova && win.StatusBar) {
        if (params.scrollTopOnClick) {
          $(win).on('statusTap', Statusbar.onClick.bind(app));
        }
        if (Device.ios) {
          if (params.iosOverlaysWebView) {
            win.StatusBar.overlaysWebView(true);
          } else {
            win.StatusBar.overlaysWebView(false);
          }
          if (params.iosTextColor === 'white') {
            win.StatusBar.styleLightContent();
          } else {
            win.StatusBar.styleDefault();
          }
        }
        if (Device.android) {
          if (params.androidOverlaysWebView) {
            win.StatusBar.overlaysWebView(true);
          } else {
            win.StatusBar.overlaysWebView(false);
          }
          if (params.androidTextColor === 'white') {
            win.StatusBar.styleLightContent();
          } else {
            win.StatusBar.styleDefault();
          }
        }
      }
      if (params.iosBackgroundColor && Device.ios) {
        Statusbar.setBackgroundColor(params.iosBackgroundColor);
      }
      if (params.androidBackgroundColor && Device.android) {
        Statusbar.setBackgroundColor(params.androidBackgroundColor);
      }
    },
  };

  var Statusbar$1 = {
    name: 'statusbar',
    params: {
      statusbar: {
        enabled: true,

        scrollTopOnClick: true,

        iosOverlaysWebView: true,
        iosTextColor: 'black',
        iosBackgroundColor: null,

        androidOverlaysWebView: false,
        androidTextColor: 'black',
        androidBackgroundColor: null,
      },
    },
    create() {
      const app = this;
      Utils.extend(app, {
        statusbar: {
          hide: Statusbar.hide,
          show: Statusbar.show,
          overlaysWebView: Statusbar.overlaysWebView,
          setTextColor: Statusbar.setTextColor,
          setBackgroundColor: Statusbar.setBackgroundColor,
          isVisible: Statusbar.isVisible,
          init: Statusbar.init.bind(app),
        },
      });
    },
    on: {
      init() {
        const app = this;
        Statusbar.init.call(app);
      },
    },
  };

  function getCurrentView(app) {
    const $popoverView = $('.popover.modal-in .view');
    const $popupView = $('.popup.modal-in .view');
    const $panelView = $('.panel.panel-in .view');
    let $viewsEl = $('.views');
    if ($viewsEl.length === 0) $viewsEl = app.root;
    // Find active view as tab
    let $viewEl = $viewsEl.children('.view');
    // Propably in tabs or split view
    if ($viewEl.length > 1) {
      if ($viewEl.hasClass('tab')) {
        // Tabs
        $viewEl = $viewsEl.children('.view.tab-active');
      }
    }
    if ($popoverView.length > 0 && $popoverView[0].f7View) return $popoverView[0].f7View;
    if ($popupView.length > 0 && $popupView[0].f7View) return $popupView[0].f7View;
    if ($panelView.length > 0 && $panelView[0].f7View) return $panelView[0].f7View;
    if ($viewEl.length > 0) {
      if ($viewEl.length === 1 && $viewEl[0].f7View) return $viewEl[0].f7View;
      if ($viewEl.length > 1) {
        return app.views.main;
      }
    }
    return undefined;
  }

  var View$1 = {
    name: 'view',
    params: {
      view: {
        name: undefined,
        main: false,
        router: true,
        linksView: null,
        stackPages: false,
        xhrCache: true,
        xhrCacheIgnore: [],
        xhrCacheIgnoreGetParameters: false,
        xhrCacheDuration: 1000 * 60 * 10, // Ten minutes
        componentCache: true,
        preloadPreviousPage: true,
        allowDuplicateUrls: false,
        reloadPages: false,
        reloadDetail: false,
        masterDetailBreakpoint: 0,
        masterDetailResizable: false,
        removeElements: true,
        removeElementsWithTimeout: false,
        removeElementsTimeout: 0,
        restoreScrollTopOnBack: true,
        unloadTabContent: true,
        passRouteQueryToRequest: true,
        passRouteParamsToRequest: false,
        loadInitialPage: true,
        // Swipe Back
        iosSwipeBack: true,
        iosSwipeBackAnimateShadow: true,
        iosSwipeBackAnimateOpacity: true,
        iosSwipeBackActiveArea: 30,
        iosSwipeBackThreshold: 0,
        mdSwipeBack: false,
        mdSwipeBackAnimateShadow: true,
        mdSwipeBackAnimateOpacity: false,
        mdSwipeBackActiveArea: 30,
        mdSwipeBackThreshold: 0,
        auroraSwipeBack: false,
        auroraSwipeBackAnimateShadow: false,
        auroraSwipeBackAnimateOpacity: true,
        auroraSwipeBackActiveArea: 30,
        auroraSwipeBackThreshold: 0,
        // Push State
        pushState: false,
        pushStateRoot: undefined,
        pushStateAnimate: true,
        pushStateAnimateOnLoad: false,
        pushStateSeparator: '#!',
        pushStateOnLoad: true,
        // Animate Pages
        animate: true,
        // iOS Dynamic Navbar
        iosDynamicNavbar: true,
        // Animate iOS Navbar Back Icon
        iosAnimateNavbarBackIcon: true,
        // Delays
        iosPageLoadDelay: 0,
        mdPageLoadDelay: 0,
        auroraPageLoadDelay: 0,
        // Routes hooks
        routesBeforeEnter: null,
        routesBeforeLeave: null,
      },
    },
    static: {
      View,
    },
    create() {
      const app = this;
      Utils.extend(app, {
        views: Utils.extend([], {
          create(el, params) {
            return new View(app, el, params);
          },
          get(viewEl) {
            const $viewEl = $(viewEl);
            if ($viewEl.length && $viewEl[0].f7View) return $viewEl[0].f7View;
            return undefined;
          },
        }),
      });
      Object.defineProperty(app.views, 'current', {
        enumerable: true,
        configurable: true,
        get() {
          return getCurrentView(app);
        },
      });
      // Alias
      app.view = app.views;
    },
    on: {
      init() {
        const app = this;
        $('.view-init').each((index, viewEl) => {
          if (viewEl.f7View) return;
          const viewParams = $(viewEl).dataset();
          app.views.create(viewEl, viewParams);
        });
      },
      modalOpen(modal) {
        const app = this;
        modal.$el.find('.view-init').each((index, viewEl) => {
          if (viewEl.f7View) return;
          const viewParams = $(viewEl).dataset();
          app.views.create(viewEl, viewParams);
        });
      },
      modalBeforeDestroy(modal) {
        if (!modal || !modal.$el) return;
        modal.$el.find('.view-init').each((index, viewEl) => {
          const view = viewEl.f7View;
          if (!view) return;
          view.destroy();
        });
      },
    },
    vnode: {
      'view-init': {
        insert(vnode) {
          const app = this;
          const viewEl = vnode.elm;
          if (viewEl.f7View) return;
          const viewParams = $(viewEl).dataset();
          app.views.create(viewEl, viewParams);
        },
        destroy(vnode) {
          const viewEl = vnode.elm;
          const view = viewEl.f7View;
          if (!view) return;
          view.destroy();
        },
      },
    },
  };

  const Navbar = {
    size(el) {
      const app = this;

      let $el = $(el);

      if ($el.hasClass('navbars')) {
        $el = $el.children('.navbar').each((index, navbarEl) => {
          app.navbar.size(navbarEl);
        });
        return;
      }

      const $innerEl = $el.children('.navbar-inner');
      if (!$innerEl.length) return;

      const needCenterTitle = (
        $innerEl.hasClass('navbar-inner-centered-title')
        || app.params.navbar[`${app.theme}CenterTitle`]
      );
      const needLeftTitle = app.theme === 'ios' && !app.params.navbar[`${app.theme}CenterTitle`];

      if (!needCenterTitle && !needLeftTitle) return;

      if (
        $el.hasClass('stacked')
        || $el.parents('.stacked').length > 0
        || $el.parents('.tab:not(.tab-active)').length > 0
        || $el.parents('.popup:not(.modal-in)').length > 0
      ) {
        return;
      }

      if (app.theme !== 'ios' && app.params.navbar[`${app.theme}CenterTitle`]) {
        $innerEl.addClass('navbar-inner-centered-title');
      }
      if (app.theme === 'ios' && !app.params.navbar.iosCenterTitle) {
        $innerEl.addClass('navbar-inner-left-title');
      }

      const $viewEl = $el.parents('.view').eq(0);
      const left = app.rtl ? $innerEl.children('.right') : $innerEl.children('.left');
      const right = app.rtl ? $innerEl.children('.left') : $innerEl.children('.right');
      const title = $innerEl.children('.title');
      const subnavbar = $innerEl.children('.subnavbar');
      const noLeft = left.length === 0;
      const noRight = right.length === 0;
      const leftWidth = noLeft ? 0 : left.outerWidth(true);
      const rightWidth = noRight ? 0 : right.outerWidth(true);
      const titleWidth = title.outerWidth(true);
      const navbarStyles = $innerEl.styles();
      const navbarWidth = $innerEl[0].offsetWidth;
      const navbarInnerWidth = navbarWidth - parseInt(navbarStyles.paddingLeft, 10) - parseInt(navbarStyles.paddingRight, 10);
      const isPrevious = $el.hasClass('navbar-previous');
      const sliding = $innerEl.hasClass('sliding');

      let router;
      let dynamicNavbar;

      if ($viewEl.length > 0 && $viewEl[0].f7View) {
        router = $viewEl[0].f7View.router;
        dynamicNavbar = router && router.dynamicNavbar;
      }

      let currLeft;
      let diff;
      if (noRight) {
        currLeft = navbarInnerWidth - titleWidth;
      }
      if (noLeft) {
        currLeft = 0;
      }
      if (!noLeft && !noRight) {
        currLeft = ((navbarInnerWidth - rightWidth - titleWidth) + leftWidth) / 2;
      }
      let requiredLeft = (navbarInnerWidth - titleWidth) / 2;
      if (navbarInnerWidth - leftWidth - rightWidth > titleWidth) {
        if (requiredLeft < leftWidth) {
          requiredLeft = leftWidth;
        }
        if (requiredLeft + titleWidth > navbarInnerWidth - rightWidth) {
          requiredLeft = navbarInnerWidth - rightWidth - titleWidth;
        }
        diff = requiredLeft - currLeft;
      } else {
        diff = 0;
      }

      // RTL inverter
      const inverter = app.rtl ? -1 : 1;

      if (dynamicNavbar && app.theme === 'ios') {
        if (title.hasClass('sliding') || (title.length > 0 && sliding)) {
          let titleLeftOffset = -(currLeft + diff) * inverter;
          const titleRightOffset = (navbarInnerWidth - currLeft - diff - titleWidth) * inverter;

          if (isPrevious) {
            if (router && router.params.iosAnimateNavbarBackIcon) {
              const activeNavbarBackLink = $el.parent().find('.navbar-current').children('.left.sliding').find('.back .icon ~ span');
              if (activeNavbarBackLink.length > 0) {
                titleLeftOffset += activeNavbarBackLink[0].offsetLeft;
              }
            }
          }
          title[0].f7NavbarLeftOffset = titleLeftOffset;
          title[0].f7NavbarRightOffset = titleRightOffset;
        }
        if (!noLeft && (left.hasClass('sliding') || sliding)) {
          if (app.rtl) {
            left[0].f7NavbarLeftOffset = (-(navbarInnerWidth - left[0].offsetWidth) / 2) * inverter;
            left[0].f7NavbarRightOffset = leftWidth * inverter;
          } else {
            left[0].f7NavbarLeftOffset = -leftWidth;
            left[0].f7NavbarRightOffset = ((navbarInnerWidth - left[0].offsetWidth) / 2);
            if (router && router.params.iosAnimateNavbarBackIcon && left.find('.back .icon').length > 0) {
              if (left.find('.back .icon ~ span').length) {
                const leftOffset = left[0].f7NavbarLeftOffset;
                const rightOffset = left[0].f7NavbarRightOffset;
                left[0].f7NavbarLeftOffset = 0;
                left[0].f7NavbarRightOffset = 0;
                left.find('.back .icon ~ span')[0].f7NavbarLeftOffset = leftOffset;
                left.find('.back .icon ~ span')[0].f7NavbarRightOffset = rightOffset - left.find('.back .icon')[0].offsetWidth;
              }
            }
          }
        }
        if (!noRight && (right.hasClass('sliding') || sliding)) {
          if (app.rtl) {
            right[0].f7NavbarLeftOffset = -rightWidth * inverter;
            right[0].f7NavbarRightOffset = ((navbarInnerWidth - right[0].offsetWidth) / 2) * inverter;
          } else {
            right[0].f7NavbarLeftOffset = -(navbarInnerWidth - right[0].offsetWidth) / 2;
            right[0].f7NavbarRightOffset = rightWidth;
          }
        }
        if (subnavbar.length && (subnavbar.hasClass('sliding') || sliding)) {
          subnavbar[0].f7NavbarLeftOffset = app.rtl ? subnavbar[0].offsetWidth : -subnavbar[0].offsetWidth;
          subnavbar[0].f7NavbarRightOffset = -subnavbar[0].f7NavbarLeftOffset;
        }
      }

      // Center title
      if (needCenterTitle) {
        let titleLeft = diff;
        if (app.rtl && noLeft && noRight && title.length > 0) titleLeft = -titleLeft;
        title.css({ left: `${titleLeft}px` });
      }
    },
    hide(el, animate = true, hideStatusbar = false) {
      const app = this;
      let $el = $(el);
      const isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length;
      if (isDynamic) $el = $el.parents('.navbars');
      if (!$el.length) return;
      if ($el.hasClass('navbar-hidden')) return;
      let className = `navbar-hidden${animate ? ' navbar-transitioning' : ''}`;
      const currentIsLarge = isDynamic
        ? $el.find('.navbar-current .title-large').length
        : $el.find('.title-large').length;
      if (currentIsLarge) {
        className += ' navbar-large-hidden';
      }
      if (hideStatusbar) {
        className += ' navbar-hidden-statusbar';
      }
      $el.transitionEnd(() => {
        $el.removeClass('navbar-transitioning');
      });
      $el.addClass(className);
      if (isDynamic) {
        $el.children('.navbar').each((index, subEl) => {
          $(subEl).trigger('navbar:hide');
          app.emit('navbarHide', subEl);
        });
      } else {
        $el.trigger('navbar:hide');
        app.emit('navbarHide', $el[0]);
      }
    },
    show(el = '.navbar-hidden', animate = true) {
      const app = this;
      let $el = $(el);
      const isDynamic = $el.hasClass('navbar') && $el.parent('.navbars').length;
      if (isDynamic) $el = $el.parents('.navbars');
      if (!$el.length) return;
      if (!$el.hasClass('navbar-hidden')) return;
      if (animate) {
        $el.addClass('navbar-transitioning');
        $el.transitionEnd(() => {
          $el.removeClass('navbar-transitioning');
        });
      }
      $el.removeClass('navbar-hidden navbar-large-hidden navbar-hidden-statusbar');
      if (isDynamic) {
        $el.children('.navbar').each((index, subEl) => {
          $(subEl).trigger('navbar:show');
          app.emit('navbarShow', subEl);
        });
      } else {
        $el.trigger('navbar:show');
        app.emit('navbarShow', $el[0]);
      }
    },
    getElByPage(page) {
      let $pageEl;
      let $navbarEl;
      let pageData;
      if (page.$navbarEl || page.$el) {
        pageData = page;
        $pageEl = page.$el;
      } else {
        $pageEl = $(page);
        if ($pageEl.length > 0) pageData = $pageEl[0].f7Page;
      }
      if (pageData && pageData.$navbarEl && pageData.$navbarEl.length > 0) {
        $navbarEl = pageData.$navbarEl;
      } else if ($pageEl) {
        $navbarEl = $pageEl.children('.navbar');
      }
      if (!$navbarEl || ($navbarEl && $navbarEl.length === 0)) return undefined;
      return $navbarEl[0];
    },
    getPageByEl(navbarEl) {
      const $navbarEl = $(navbarEl);
      if ($navbarEl.parents('.page').length) {
        return $navbarEl.parents('.page')[0];
      }
      let pageEl;
      $navbarEl.parents('.view').find('.page').each((index, el) => {
        if (el && el.f7Page && el.f7Page.navbarEl && $navbarEl[0] === el.f7Page.navbarEl) {
          pageEl = el;
        }
      });
      return pageEl;
    },

    collapseLargeTitle(navbarEl) {
      const app = this;
      let $navbarEl = $(navbarEl);
      if ($navbarEl.hasClass('navbars')) {
        $navbarEl = $navbarEl.find('.navbar');
        if ($navbarEl.length > 1) {
          $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
        }
        if ($navbarEl.length > 1 || !$navbarEl.length) {
          return;
        }
      }
      const $pageEl = $(app.navbar.getPageByEl($navbarEl));
      $navbarEl.addClass('navbar-large-collapsed');
      $pageEl.eq(0).addClass('page-with-navbar-large-collapsed').trigger('page:navbarlargecollapsed');
      app.emit('pageNavbarLargeCollapsed', $pageEl[0]);
      $navbarEl.trigger('navbar:collapse');
      app.emit('navbarCollapse', $navbarEl[0]);
    },
    expandLargeTitle(navbarEl) {
      const app = this;
      let $navbarEl = $(navbarEl);
      if ($navbarEl.hasClass('navbars')) {
        $navbarEl = $navbarEl.find('.navbar-large');
        if ($navbarEl.length > 1) {
          $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
        }
        if ($navbarEl.length > 1 || !$navbarEl.length) {
          return;
        }
      }
      const $pageEl = $(app.navbar.getPageByEl($navbarEl));
      $navbarEl.removeClass('navbar-large-collapsed');
      $pageEl.eq(0).removeClass('page-with-navbar-large-collapsed').trigger('page:navbarlargeexpanded');
      app.emit('pageNavbarLargeExpanded', $pageEl[0]);
      $navbarEl.trigger('navbar:expand');
      app.emit('navbarExpand', $navbarEl[0]);
    },
    toggleLargeTitle(navbarEl) {
      const app = this;
      let $navbarEl = $(navbarEl);
      if ($navbarEl.hasClass('navbars')) {
        $navbarEl = $navbarEl.find('.navbar-large');
        if ($navbarEl.length > 1) {
          $navbarEl = $(navbarEl).find('.navbar-large.navbar-current');
        }
        if ($navbarEl.length > 1 || !$navbarEl.length) {
          return;
        }
      }
      if ($navbarEl.hasClass('navbar-large-collapsed')) {
        app.navbar.expandLargeTitle($navbarEl);
      } else {
        app.navbar.collapseLargeTitle($navbarEl);
      }
    },
    initNavbarOnScroll(pageEl, navbarEl, needHide, needCollapse, needTransparent) {
      const app = this;
      const $pageEl = $(pageEl);
      const $navbarEl = $(navbarEl);
      const $titleLargeEl = $navbarEl.find('.title-large');
      const isLarge = $titleLargeEl.length || $navbarEl.hasClass('.navbar-large');
      let navbarHideHeight = 44;
      const snapPageScrollToLargeTitle = app.params.navbar.snapPageScrollToLargeTitle;
      const snapPageScrollToTransparentNavbar = app.params.navbar.snapPageScrollToTransparentNavbar;

      let previousScrollTop;
      let currentScrollTop;

      let scrollHeight;
      let offsetHeight;
      let reachEnd;
      let action;
      let navbarHidden;

      let navbarCollapsed;
      let navbarTitleLargeHeight;

      let navbarOffsetHeight;

      if (needCollapse || (needHide && isLarge)) {
        navbarTitleLargeHeight = $navbarEl.css('--f7-navbar-large-title-height');

        if (navbarTitleLargeHeight && navbarTitleLargeHeight.indexOf('px') >= 0) {
          navbarTitleLargeHeight = parseInt(navbarTitleLargeHeight, 10);
          if (Number.isNaN(navbarTitleLargeHeight) && $titleLargeEl.length) {
            navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
          } else if (Number.isNaN(navbarTitleLargeHeight)) {
            if (app.theme === 'ios') navbarTitleLargeHeight = 52;
            else if (app.theme === 'md') navbarTitleLargeHeight = 48;
            else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
          }
        } else if ($titleLargeEl.length) {
          navbarTitleLargeHeight = $titleLargeEl[0].offsetHeight;
        } else { // eslint-disable-next-line
          if (app.theme === 'ios') navbarTitleLargeHeight = 52;
          else if (app.theme === 'md') navbarTitleLargeHeight = 48;
          else if (app.theme === 'aurora') navbarTitleLargeHeight = 38;
        }
      }

      if (needHide && isLarge) {
        navbarHideHeight += navbarTitleLargeHeight;
      }

      let scrollChanged;
      let scrollContent;
      let scrollTimeoutId;
      let touchEndTimeoutId;
      const touchSnapTimeout = 70;
      const desktopSnapTimeout = 300;

      function snapLargeNavbar() {
        const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
        if (inSearchbarExpanded) return;
        if (!scrollContent || currentScrollTop < 0) return;
        if (currentScrollTop >= navbarTitleLargeHeight / 2 && currentScrollTop < navbarTitleLargeHeight) {
          $(scrollContent).scrollTop(navbarTitleLargeHeight, 100);
        } else if (currentScrollTop < navbarTitleLargeHeight) {
          $(scrollContent).scrollTop(0, 200);
        }
      }

      function snapTransparentNavbar() {
        const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
        if (inSearchbarExpanded) return;
        if (!scrollContent || currentScrollTop < 0) return;
        if (currentScrollTop >= navbarOffsetHeight / 2 && currentScrollTop < navbarOffsetHeight) {
          $(scrollContent).scrollTop(navbarOffsetHeight, 100);
        } else if (currentScrollTop < navbarOffsetHeight) {
          $(scrollContent).scrollTop(0, 200);
        }
      }

      function handleNavbarTransparent() {
        const isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
        const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
        if (inSearchbarExpanded || isHidden) return;
        if (!navbarOffsetHeight) {
          navbarOffsetHeight = navbarEl.offsetHeight;
        }
        let opacity = currentScrollTop / navbarOffsetHeight;
        const notTransparent = $navbarEl.hasClass('navbar-transparent-visible');
        opacity = Math.max(Math.min(opacity, 1), 0);

        if ((notTransparent && opacity === 1) || (!notTransparent && opacity === 0)) {
          $navbarEl.find('.navbar-bg, .title').css('opacity', '');
          return;
        }
        if (notTransparent && opacity === 0) {
          $navbarEl.trigger('navbar:transparenthide');
          app.emit('navbarTransparentHide', $navbarEl[0]);
          $navbarEl.removeClass('navbar-transparent-visible');
          $navbarEl.find('.navbar-bg, .title').css('opacity', '');
          return;
        }
        if (!notTransparent && opacity === 1) {
          $navbarEl.trigger('navbar:transparentshow');
          app.emit('navbarTransparentShow', $navbarEl[0]);
          $navbarEl.addClass('navbar-transparent-visible');
          $navbarEl.find('.navbar-bg, .title').css('opacity', '');
          return;
        }

        $navbarEl.find('.navbar-bg, .title').css('opacity', opacity);

        if (snapPageScrollToTransparentNavbar) {
          if (!Support.touch) {
            clearTimeout(scrollTimeoutId);
            scrollTimeoutId = setTimeout(() => {
              snapTransparentNavbar();
            }, desktopSnapTimeout);
          } else if (touchEndTimeoutId) {
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
            touchEndTimeoutId = setTimeout(() => {
              snapTransparentNavbar();
              clearTimeout(touchEndTimeoutId);
              touchEndTimeoutId = null;
            }, touchSnapTimeout);
          }
        }
      }

      let previousCollapseProgress = null;
      let collapseProgress = null;
      function handleLargeNavbarCollapse() {
        const isHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
        if (isHidden) return;
        const isLargeTransparent = $navbarEl.hasClass('navbar-large-transparent')
          || (
            $navbarEl.hasClass('navbar-large')
            && $navbarEl.hasClass('navbar-transparent')
          );
        previousCollapseProgress = collapseProgress;
        collapseProgress = Math.min(Math.max((currentScrollTop / navbarTitleLargeHeight), 0), 1);
        const previousCollapseWasInMiddle = previousCollapseProgress > 0 && previousCollapseProgress < 1;
        const inSearchbarExpanded = $navbarEl.hasClass('with-searchbar-expandable-enabled');
        if (inSearchbarExpanded) return;
        navbarCollapsed = $navbarEl.hasClass('navbar-large-collapsed');
        if (collapseProgress === 0 && navbarCollapsed) {
          app.navbar.expandLargeTitle($navbarEl[0]);
        } else if (collapseProgress === 1 && !navbarCollapsed) {
          app.navbar.collapseLargeTitle($navbarEl[0]);
        }
        if (
          (collapseProgress === 0 && navbarCollapsed)
          || (collapseProgress === 0 && previousCollapseWasInMiddle)
          || (collapseProgress === 1 && !navbarCollapsed)
          || (collapseProgress === 1 && previousCollapseWasInMiddle)
        ) {
          if (app.theme === 'md') {
            $navbarEl.find('.navbar-inner').css('overflow', '');
          }
          $navbarEl.find('.title').css('opacity', '');
          $navbarEl.find('.title-large-text, .subnavbar').css('transform', '');
          if (isLargeTransparent) {
            $navbarEl.find('.navbar-bg').css('opacity', '');
          } else {
            $navbarEl.find('.navbar-bg').css('transform', '');
          }
        } else if (collapseProgress > 0 && collapseProgress < 1) {
          if (app.theme === 'md') {
            $navbarEl.find('.navbar-inner').css('overflow', 'visible');
          }
          $navbarEl.find('.title').css('opacity', collapseProgress);
          $navbarEl.find('.title-large-text, .subnavbar').css('transform', `translate3d(0px, ${-1 * collapseProgress * navbarTitleLargeHeight}px, 0)`);
          if (isLargeTransparent) {
            $navbarEl.find('.navbar-bg').css('opacity', collapseProgress);
          } else {
            $navbarEl.find('.navbar-bg').css('transform', `translate3d(0px, ${-1 * collapseProgress * navbarTitleLargeHeight}px, 0)`);
          }
        }

        if (snapPageScrollToLargeTitle) {
          if (!Support.touch) {
            clearTimeout(scrollTimeoutId);
            scrollTimeoutId = setTimeout(() => {
              snapLargeNavbar();
            }, desktopSnapTimeout);
          } else if (touchEndTimeoutId) {
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
            touchEndTimeoutId = setTimeout(() => {
              snapLargeNavbar();
              clearTimeout(touchEndTimeoutId);
              touchEndTimeoutId = null;
            }, touchSnapTimeout);
          }
        }
      }

      function handleTitleHideShow() {
        if ($pageEl.hasClass('page-with-card-opened')) return;
        scrollHeight = scrollContent.scrollHeight;
        offsetHeight = scrollContent.offsetHeight;
        reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
        navbarHidden = $navbarEl.hasClass('navbar-hidden') || $navbarEl.parent('.navbars').hasClass('navbar-hidden');
        if (reachEnd) {
          if (app.params.navbar.showOnPageScrollEnd) {
            action = 'show';
          }
        } else if (previousScrollTop > currentScrollTop) {
          if (app.params.navbar.showOnPageScrollTop || currentScrollTop <= navbarHideHeight) {
            action = 'show';
          } else {
            action = 'hide';
          }
        } else if (currentScrollTop > navbarHideHeight) {
          action = 'hide';
        } else {
          action = 'show';
        }

        if (action === 'show' && navbarHidden) {
          app.navbar.show($navbarEl);
          navbarHidden = false;
        } else if (action === 'hide' && !navbarHidden) {
          app.navbar.hide($navbarEl);
          navbarHidden = true;
        }
        previousScrollTop = currentScrollTop;
      }

      function handleScroll(e) {
        scrollContent = this;
        if (e && e.target && e.target !== scrollContent) {
          return;
        }
        currentScrollTop = scrollContent.scrollTop;
        scrollChanged = currentScrollTop;
        if (needCollapse) {
          handleLargeNavbarCollapse();
        } else if (needTransparent) {
          handleNavbarTransparent();
        }
        if ($pageEl.hasClass('page-previous')) return;
        if (needHide) {
          handleTitleHideShow();
        }
      }
      function handeTouchStart() {
        scrollChanged = false;
      }
      function handleTouchEnd() {
        clearTimeout(touchEndTimeoutId);
        touchEndTimeoutId = null;
        touchEndTimeoutId = setTimeout(() => {
          if (scrollChanged !== false) {
            if (needTransparent && !needCollapse) {
              snapTransparentNavbar();
            } else {
              snapLargeNavbar();
            }
            clearTimeout(touchEndTimeoutId);
            touchEndTimeoutId = null;
          }
        }, touchSnapTimeout);
      }
      $pageEl.on('scroll', '.page-content', handleScroll, true);
      if (Support.touch && ((needCollapse && snapPageScrollToLargeTitle) || (needTransparent && snapPageScrollToTransparentNavbar))) {
        app.on('touchstart:passive', handeTouchStart);
        app.on('touchend:passive', handleTouchEnd);
      }
      if (needCollapse) {
        $pageEl.find('.page-content').each((pageContentIndex, pageContentEl) => {
          if (pageContentEl.scrollTop > 0) handleScroll.call(pageContentEl);
        });
      } else if (needTransparent) {
        $pageEl.find('.page-content').each((pageContentIndex, pageContentEl) => {
          if (pageContentEl.scrollTop > 0) handleScroll.call(pageContentEl);
        });
      }
      $pageEl[0].f7DetachNavbarScrollHandlers = function f7DetachNavbarScrollHandlers() {
        delete $pageEl[0].f7DetachNavbarScrollHandlers;
        $pageEl.off('scroll', '.page-content', handleScroll, true);
        if (Support.touch && ((needCollapse && snapPageScrollToLargeTitle) || (needTransparent && snapPageScrollToTransparentNavbar))) {
          app.off('touchstart:passive', handeTouchStart);
          app.off('touchend:passive', handleTouchEnd);
        }
      };
    },
  };
  var Navbar$1 = {
    name: 'navbar',
    create() {
      const app = this;
      Utils.extend(app, {
        navbar: {
          size: Navbar.size.bind(app),
          hide: Navbar.hide.bind(app),
          show: Navbar.show.bind(app),
          getElByPage: Navbar.getElByPage.bind(app),
          getPageByEl: Navbar.getPageByEl.bind(app),
          collapseLargeTitle: Navbar.collapseLargeTitle.bind(app),
          expandLargeTitle: Navbar.expandLargeTitle.bind(app),
          toggleLargeTitle: Navbar.toggleLargeTitle.bind(app),
          initNavbarOnScroll: Navbar.initNavbarOnScroll.bind(app),
        },
      });
    },
    params: {
      navbar: {
        scrollTopOnTitleClick: true,
        iosCenterTitle: true,
        mdCenterTitle: false,
        auroraCenterTitle: true,
        hideOnPageScroll: false,
        showOnPageScrollEnd: true,
        showOnPageScrollTop: true,
        collapseLargeTitleOnScroll: true,
        snapPageScrollToLargeTitle: true,
        snapPageScrollToTransparentNavbar: true,
      },
    },
    on: {
      'panelBreakpoint panelCollapsedBreakpoint panelResize viewResize resize viewMasterDetailBreakpoint': function onPanelResize() {
        const app = this;
        $('.navbar').each((index, navbarEl) => {
          app.navbar.size(navbarEl);
        });
      },
      pageBeforeRemove(page) {
        if (page.$el[0].f7DetachNavbarScrollHandlers) {
          page.$el[0].f7DetachNavbarScrollHandlers();
        }
      },
      pageBeforeIn(page) {
        const app = this;
        if (app.theme !== 'ios') return;
        let $navbarsEl;
        const view = page.$el.parents('.view')[0].f7View;
        const navbarEl = app.navbar.getElByPage(page);
        if (!navbarEl) {
          $navbarsEl = page.$el.parents('.view').children('.navbars');
        } else {
          $navbarsEl = $(navbarEl).parents('.navbars');
        }
        if (page.$el.hasClass('no-navbar') || (view.router.dynamicNavbar && !navbarEl)) {
          const animate = !!(page.pageFrom && page.router.history.length > 0);
          app.navbar.hide($navbarsEl, animate);
        } else {
          app.navbar.show($navbarsEl);
        }
      },
      pageReinit(page) {
        const app = this;
        const $navbarEl = $(app.navbar.getElByPage(page));
        if (!$navbarEl || $navbarEl.length === 0) return;
        app.navbar.size($navbarEl);
      },
      pageInit(page) {
        const app = this;
        const $navbarEl = $(app.navbar.getElByPage(page));
        if (!$navbarEl || $navbarEl.length === 0) return;

        // Size
        app.navbar.size($navbarEl);

        // Need Collapse On Scroll
        let needCollapseOnScrollHandler;
        if ($navbarEl.find('.title-large').length > 0) {
          $navbarEl.addClass('navbar-large');
        }
        if ($navbarEl.hasClass('navbar-large')) {
          if (app.params.navbar.collapseLargeTitleOnScroll) needCollapseOnScrollHandler = true;
          page.$el.addClass('page-with-navbar-large');
        }

        // Need transparent on scroll
        let needTransparentOnScroll;
        if (!needCollapseOnScrollHandler && $navbarEl.hasClass('navbar-transparent')) {
          needTransparentOnScroll = true;
        }

        // Need Hide On Scroll
        let needHideOnScrollHandler;
        if (
          app.params.navbar.hideOnPageScroll
          || page.$el.find('.hide-navbar-on-scroll').length
          || page.$el.hasClass('hide-navbar-on-scroll')
          || page.$el.find('.hide-bars-on-scroll').length
          || page.$el.hasClass('hide-bars-on-scroll')
        ) {
          if (
            page.$el.find('.keep-navbar-on-scroll').length
            || page.$el.hasClass('keep-navbar-on-scroll')
            || page.$el.find('.keep-bars-on-scroll').length
            || page.$el.hasClass('keep-bars-on-scroll')
          ) {
            needHideOnScrollHandler = false;
          } else {
            needHideOnScrollHandler = true;
          }
        }

        if (needCollapseOnScrollHandler || needHideOnScrollHandler || needTransparentOnScroll) {
          app.navbar.initNavbarOnScroll(page.el, $navbarEl[0], needHideOnScrollHandler, needCollapseOnScrollHandler, needTransparentOnScroll);
        }
      },
      'panelOpen panelSwipeOpen modalOpen': function onPanelModalOpen(instance) {
        const app = this;
        instance.$el.find('.navbar:not(.navbar-previous):not(.stacked)').each((index, navbarEl) => {
          app.navbar.size(navbarEl);
        });
      },
      tabShow(tabEl) {
        const app = this;
        $(tabEl).find('.navbar:not(.navbar-previous):not(.stacked)').each((index, navbarEl) => {
          app.navbar.size(navbarEl);
        });
      },
    },
    clicks: {
      '.navbar .title': function onTitleClick($clickedEl) {
        const app = this;
        if (!app.params.navbar.scrollTopOnTitleClick) return;
        if ($clickedEl.closest('a').length > 0) {
          return;
        }
        let $pageContentEl;

        // Find active page
        const $navbarEl = $clickedEl.parents('.navbar');
        const $navbarsEl = $navbarEl.parents('.navbars');

        // Static Layout
        $pageContentEl = $navbarEl.parents('.page-content');

        if ($pageContentEl.length === 0) {
          // Fixed Layout
          if ($navbarEl.parents('.page').length > 0) {
            $pageContentEl = $navbarEl.parents('.page').find('.page-content');
          }
          // Through Layout iOS
          if ($pageContentEl.length === 0 && $navbarsEl.length) {
            if ($navbarsEl.nextAll('.page-current:not(.stacked)').length > 0) {
              $pageContentEl = $navbarsEl.nextAll('.page-current:not(.stacked)').find('.page-content');
            }
          }
          // Through Layout
          if ($pageContentEl.length === 0) {
            if ($navbarEl.nextAll('.page-current:not(.stacked)').length > 0) {
              $pageContentEl = $navbarEl.nextAll('.page-current:not(.stacked)').find('.page-content');
            }
          }
        }
        if ($pageContentEl && $pageContentEl.length > 0) {
          // Check for tab
          if ($pageContentEl.hasClass('tab')) {
            $pageContentEl = $pageContentEl.parent('.tabs').children('.page-content.tab-active');
          }
          if ($pageContentEl.length > 0) $pageContentEl.scrollTop(0, 300);
        }
      },
    },
    vnode: {
      navbar: {
        postpatch(vnode) {
          const app = this;
          app.navbar.size(vnode.elm);
        },
      },
    },
  };

  const Toolbar = {
    setHighlight(tabbarEl) {
      const app = this;
      if (app.theme !== 'md') return;

      const $tabbarEl = $(tabbarEl);

      if ($tabbarEl.length === 0 || !($tabbarEl.hasClass('tabbar') || $tabbarEl.hasClass('tabbar-labels'))) return;

      let $highlightEl = $tabbarEl.find('.tab-link-highlight');
      const tabLinksCount = $tabbarEl.find('.tab-link').length;
      if (tabLinksCount === 0) {
        $highlightEl.remove();
        return;
      }

      if ($highlightEl.length === 0) {
        $tabbarEl.children('.toolbar-inner').append('<span class="tab-link-highlight"></span>');
        $highlightEl = $tabbarEl.find('.tab-link-highlight');
      } else if ($highlightEl.next().length) {
        $tabbarEl.children('.toolbar-inner').append($highlightEl);
      }

      const $activeLink = $tabbarEl.find('.tab-link-active');
      let highlightWidth;
      let highlightTranslate;

      if ($tabbarEl.hasClass('tabbar-scrollable') && $activeLink && $activeLink[0]) {
        highlightWidth = `${$activeLink[0].offsetWidth}px`;
        highlightTranslate = `${$activeLink[0].offsetLeft}px`;
      } else {
        const activeIndex = $activeLink.index();
        highlightWidth = `${100 / tabLinksCount}%`;
        highlightTranslate = `${(app.rtl ? -activeIndex : activeIndex) * 100}%`;
      }

      Utils.nextFrame(() => {
        $highlightEl
          .css('width', highlightWidth)
          .transform(`translate3d(${highlightTranslate},0,0)`);
      });
    },
    init(tabbarEl) {
      const app = this;
      app.toolbar.setHighlight(tabbarEl);
    },
    hide(el, animate = true) {
      const app = this;
      const $el = $(el);
      if ($el.hasClass('toolbar-hidden')) return;
      const className = `toolbar-hidden${animate ? ' toolbar-transitioning' : ''}`;
      $el.transitionEnd(() => {
        $el.removeClass('toolbar-transitioning');
      });
      $el.addClass(className);
      $el.trigger('toolbar:hide');
      app.emit('toolbarHide', $el[0]);
    },
    show(el, animate = true) {
      const app = this;
      const $el = $(el);
      if (!$el.hasClass('toolbar-hidden')) return;
      if (animate) {
        $el.addClass('toolbar-transitioning');
        $el.transitionEnd(() => {
          $el.removeClass('toolbar-transitioning');
        });
      }
      $el.removeClass('toolbar-hidden');
      $el.trigger('toolbar:show');
      app.emit('toolbarShow', $el[0]);
    },
    initToolbarOnScroll(pageEl) {
      const app = this;
      const $pageEl = $(pageEl);
      let $toolbarEl = $pageEl.parents('.view').children('.toolbar');
      if ($toolbarEl.length === 0) {
        $toolbarEl = $pageEl.find('.toolbar');
      }
      if ($toolbarEl.length === 0) {
        $toolbarEl = $pageEl.parents('.views').children('.tabbar, .tabbar-labels');
      }
      if ($toolbarEl.length === 0) {
        return;
      }

      let previousScrollTop;
      let currentScrollTop;

      let scrollHeight;
      let offsetHeight;
      let reachEnd;
      let action;
      let toolbarHidden;
      function handleScroll(e) {
        if ($pageEl.hasClass('page-with-card-opened')) return;
        if ($pageEl.hasClass('page-previous')) return;
        const scrollContent = this;
        if (e && e.target && e.target !== scrollContent) {
          return;
        }
        currentScrollTop = scrollContent.scrollTop;
        scrollHeight = scrollContent.scrollHeight;
        offsetHeight = scrollContent.offsetHeight;
        reachEnd = currentScrollTop + offsetHeight >= scrollHeight;
        toolbarHidden = $toolbarEl.hasClass('toolbar-hidden');

        if (reachEnd) {
          if (app.params.toolbar.showOnPageScrollEnd) {
            action = 'show';
          }
        } else if (previousScrollTop > currentScrollTop) {
          if (app.params.toolbar.showOnPageScrollTop || currentScrollTop <= 44) {
            action = 'show';
          } else {
            action = 'hide';
          }
        } else if (currentScrollTop > 44) {
          action = 'hide';
        } else {
          action = 'show';
        }

        if (action === 'show' && toolbarHidden) {
          app.toolbar.show($toolbarEl);
          toolbarHidden = false;
        } else if (action === 'hide' && !toolbarHidden) {
          app.toolbar.hide($toolbarEl);
          toolbarHidden = true;
        }

        previousScrollTop = currentScrollTop;
      }
      $pageEl.on('scroll', '.page-content', handleScroll, true);
      $pageEl[0].f7ScrollToolbarHandler = handleScroll;
    },
  };
  var Toolbar$1 = {
    name: 'toolbar',
    create() {
      const app = this;
      Utils.extend(app, {
        toolbar: {
          hide: Toolbar.hide.bind(app),
          show: Toolbar.show.bind(app),
          setHighlight: Toolbar.setHighlight.bind(app),
          initToolbarOnScroll: Toolbar.initToolbarOnScroll.bind(app),
          init: Toolbar.init.bind(app),
        },
      });
    },
    params: {
      toolbar: {
        hideOnPageScroll: false,
        showOnPageScrollEnd: true,
        showOnPageScrollTop: true,
      },
    },
    on: {
      pageBeforeRemove(page) {
        if (page.$el[0].f7ScrollToolbarHandler) {
          page.$el.off('scroll', '.page-content', page.$el[0].f7ScrollToolbarHandler, true);
        }
      },
      pageBeforeIn(page) {
        const app = this;
        let $toolbarEl = page.$el.parents('.view').children('.toolbar');
        if ($toolbarEl.length === 0) {
          $toolbarEl = page.$el.parents('.views').children('.tabbar, .tabbar-labels');
        }
        if ($toolbarEl.length === 0) {
          $toolbarEl = page.$el.find('.toolbar');
        }
        if ($toolbarEl.length === 0) {
          return;
        }
        if (page.$el.hasClass('no-toolbar')) {
          app.toolbar.hide($toolbarEl);
        } else {
          app.toolbar.show($toolbarEl);
        }
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.tabbar, .tabbar-labels').each((index, tabbarEl) => {
          app.toolbar.init(tabbarEl);
        });
        if (
          app.params.toolbar.hideOnPageScroll
          || page.$el.find('.hide-toolbar-on-scroll').length
          || page.$el.hasClass('hide-toolbar-on-scroll')
          || page.$el.find('.hide-bars-on-scroll').length
          || page.$el.hasClass('hide-bars-on-scroll')
        ) {
          if (
            page.$el.find('.keep-toolbar-on-scroll').length
            || page.$el.hasClass('keep-toolbar-on-scroll')
            || page.$el.find('.keep-bars-on-scroll').length
            || page.$el.hasClass('keep-bars-on-scroll')
          ) {
            return;
          }
          app.toolbar.initToolbarOnScroll(page.el);
        }
      },
      init() {
        const app = this;
        app.root.find('.tabbar, .tabbar-labels').each((index, tabbarEl) => {
          app.toolbar.init(tabbarEl);
        });
      },
    },
    vnode: {
      tabbar: {
        insert(vnode) {
          const app = this;
          app.toolbar.init(vnode.elm);
        },
      },
    },
  };

  var Subnavbar = {
    name: 'subnavbar',
    on: {
      pageInit(page) {
        if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find('.subnavbar').length) {
          page.$el.addClass('page-with-subnavbar');
        }
        if (page.$el.find('.subnavbar').length) {
          page.$el.addClass('page-with-subnavbar');
        }
      },
    },
  };

  class TouchRipple {
    constructor($el, x, y) {
      const ripple = this;
      if (!$el) return undefined;
      const box = $el[0].getBoundingClientRect();
      const center = {
        x: x - box.left,
        y: y - box.top,
      };
      const width = box.width;
      const height = box.height;
      const diameter = Math.max((((height ** 2) + (width ** 2)) ** 0.5), 48);

      ripple.$rippleWaveEl = $(`<div class="ripple-wave" style="width: ${diameter}px; height: ${diameter}px; margin-top:-${diameter / 2}px; margin-left:-${diameter / 2}px; left:${center.x}px; top:${center.y}px;"></div>`);

      $el.prepend(ripple.$rippleWaveEl);

      ripple.rippleTransform = `translate3d(${-center.x + (width / 2)}px, ${-center.y + (height / 2)}px, 0) scale(1)`;

      Utils.nextFrame(() => {
        if (!ripple || !ripple.$rippleWaveEl) return;
        ripple.$rippleWaveEl.transform(ripple.rippleTransform);
      });

      return ripple;
    }

    destroy() {
      let ripple = this;
      if (ripple.$rippleWaveEl) {
        ripple.$rippleWaveEl.remove();
      }
      Object.keys(ripple).forEach((key) => {
        ripple[key] = null;
        delete ripple[key];
      });
      ripple = null;
    }

    remove() {
      const ripple = this;
      if (ripple.removing) return;
      const $rippleWaveEl = this.$rippleWaveEl;
      const rippleTransform = this.rippleTransform;
      let removeTimeout = Utils.nextTick(() => {
        ripple.destroy();
      }, 400);
      ripple.removing = true;
      $rippleWaveEl
        .addClass('ripple-wave-fill')
        .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'))
        .transitionEnd(() => {
          clearTimeout(removeTimeout);
          Utils.nextFrame(() => {
            $rippleWaveEl
              .addClass('ripple-wave-out')
              .transform(rippleTransform.replace('scale(1)', 'scale(1.01)'));

            removeTimeout = Utils.nextTick(() => {
              ripple.destroy();
            }, 700);

            $rippleWaveEl.transitionEnd(() => {
              clearTimeout(removeTimeout);
              ripple.destroy();
            });
          });
        });
    }
  }

  var TouchRipple$1 = {
    name: 'touch-ripple',
    static: {
      TouchRipple,
    },
    create() {
      const app = this;
      app.touchRipple = {
        create(...args) {
          return new TouchRipple(...args);
        },
      };
    },
  };

  const openedModals = [];
  const dialogsQueue = [];
  function clearDialogsQueue() {
    if (dialogsQueue.length === 0) return;
    const dialog = dialogsQueue.shift();
    dialog.open();
  }
  class Modal extends Framework7Class {
    constructor(app, params) {
      super(params, [app]);

      const modal = this;

      const defaults = {};

      // Extend defaults with modules params
      modal.useModulesParams(defaults);

      modal.params = Utils.extend(defaults, params);
      modal.opened = false;

      // Install Modules
      modal.useModules();

      return this;
    }

    onOpen() {
      const modal = this;
      modal.opened = true;
      openedModals.push(modal);
      $('html').addClass(`with-modal-${modal.type.toLowerCase()}`);
      modal.$el.trigger(`modal:open ${modal.type.toLowerCase()}:open`);
      modal.emit(`local::open modalOpen ${modal.type}Open`, modal);
    }

    onOpened() {
      const modal = this;
      modal.$el.trigger(`modal:opened ${modal.type.toLowerCase()}:opened`);
      modal.emit(`local::opened modalOpened ${modal.type}Opened`, modal);
    }

    onClose() {
      const modal = this;
      modal.opened = false;
      if (!modal.type || !modal.$el) return;
      openedModals.splice(openedModals.indexOf(modal), 1);
      $('html').removeClass(`with-modal-${modal.type.toLowerCase()}`);
      modal.$el.trigger(`modal:close ${modal.type.toLowerCase()}:close`);
      modal.emit(`local::close modalClose ${modal.type}Close`, modal);
    }

    onClosed() {
      const modal = this;
      if (!modal.type || !modal.$el) return;
      modal.$el.removeClass('modal-out');
      modal.$el.hide();
      modal.$el.trigger(`modal:closed ${modal.type.toLowerCase()}:closed`);
      modal.emit(`local::closed modalClosed ${modal.type}Closed`, modal);
    }

    open(animateModal) {
      const modal = this;
      const app = modal.app;
      const $el = modal.$el;
      const $backdropEl = modal.$backdropEl;
      const type = modal.type;
      let animate = true;
      if (typeof animateModal !== 'undefined') animate = animateModal;
      else if (typeof modal.params.animate !== 'undefined') {
        animate = modal.params.animate;
      }

      if (!$el || $el.hasClass('modal-in')) {
        return modal;
      }

      if (type === 'dialog' && app.params.modal.queueDialogs) {
        let pushToQueue;
        if ($('.dialog.modal-in').length > 0) {
          pushToQueue = true;
        } else if (openedModals.length > 0) {
          openedModals.forEach((openedModal) => {
            if (openedModal.type === 'dialog') pushToQueue = true;
          });
        }
        if (pushToQueue) {
          dialogsQueue.push(modal);
          return modal;
        }
      }

      const $modalParentEl = $el.parent();
      const wasInDom = $el.parents(doc).length > 0;
      if (app.params.modal.moveToRoot && !$modalParentEl.is(app.root)) {
        app.root.append($el);
        modal.once(`${type}Closed`, () => {
          if (wasInDom) {
            $modalParentEl.append($el);
          } else {
            $el.remove();
          }
        });
      }
      // Show Modal
      $el.show();

      /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
      modal._clientLeft = $el[0].clientLeft;

      // Modal
      function transitionEnd() {
        if ($el.hasClass('modal-out')) {
          modal.onClosed();
        } else if ($el.hasClass('modal-in')) {
          modal.onOpened();
        }
      }
      if (animate) {
        if ($backdropEl) {
          $backdropEl.removeClass('not-animated');
          $backdropEl.addClass('backdrop-in');
        }
        $el
          .animationEnd(() => {
            transitionEnd();
          });
        $el
          .transitionEnd(() => {
            transitionEnd();
          });
        $el
          .removeClass('modal-out not-animated')
          .addClass('modal-in');
        modal.onOpen();
      } else {
        if ($backdropEl) {
          $backdropEl.addClass('backdrop-in not-animated');
        }
        $el.removeClass('modal-out').addClass('modal-in not-animated');
        modal.onOpen();
        modal.onOpened();
      }

      return modal;
    }

    close(animateModal) {
      const modal = this;
      const $el = modal.$el;
      const $backdropEl = modal.$backdropEl;

      let animate = true;
      if (typeof animateModal !== 'undefined') animate = animateModal;
      else if (typeof modal.params.animate !== 'undefined') {
        animate = modal.params.animate;
      }

      if (!$el || !$el.hasClass('modal-in')) {
        if (dialogsQueue.indexOf(modal) >= 0) {
          dialogsQueue.splice(dialogsQueue.indexOf(modal), 1);
        }
        return modal;
      }

      // backdrop
      if ($backdropEl) {
        let needToHideBackdrop = true;
        if (modal.type === 'popup') {
          modal.$el.prevAll('.popup.modal-in').each((index, popupEl) => {
            const popupInstance = popupEl.f7Modal;
            if (!popupInstance) return;
            if (
              popupInstance.params.closeByBackdropClick
              && popupInstance.params.backdrop
              && popupInstance.backdropEl === modal.backdropEl
            ) {
              needToHideBackdrop = false;
            }
          });
        }
        if (needToHideBackdrop) {
          $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');
          $backdropEl.removeClass('backdrop-in');
        }
      }

      // Modal
      $el[animate ? 'removeClass' : 'addClass']('not-animated');
      function transitionEnd() {
        if ($el.hasClass('modal-out')) {
          modal.onClosed();
        } else if ($el.hasClass('modal-in')) {
          modal.onOpened();
        }
      }
      if (animate) {
        $el
          .animationEnd(() => {
            transitionEnd();
          });
        $el
          .transitionEnd(() => {
            transitionEnd();
          });
        $el
          .removeClass('modal-in')
          .addClass('modal-out');
        // Emit close
        modal.onClose();
      } else {
        $el
          .addClass('not-animated')
          .removeClass('modal-in')
          .addClass('modal-out');
        // Emit close
        modal.onClose();
        modal.onClosed();
      }

      if (modal.type === 'dialog') {
        clearDialogsQueue();
      }

      return modal;
    }

    destroy() {
      const modal = this;
      if (modal.destroyed) return;
      modal.emit(`local::beforeDestroy modalBeforeDestroy ${modal.type}BeforeDestroy`, modal);
      if (modal.$el) {
        modal.$el.trigger(`modal:beforedestroy ${modal.type.toLowerCase()}:beforedestroy`);
        if (modal.$el.length && modal.$el[0].f7Modal) {
          delete modal.$el[0].f7Modal;
        }
      }
      Utils.deleteProps(modal);
      modal.destroyed = true;
    }
  }

  class CustomModal extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend({
        backdrop: true,
        closeByBackdropClick: true,
        on: {},
      }, params);

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const customModal = this;

      customModal.params = extendedParams;

      // Find Element
      let $el;
      if (!customModal.params.el) {
        $el = $(customModal.params.content);
      } else {
        $el = $(customModal.params.el);
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      if ($el.length === 0) {
        return customModal.destroy();
      }
      let $backdropEl;
      if (customModal.params.backdrop) {
        $backdropEl = app.root.children('.custom-modal-backdrop');
        if ($backdropEl.length === 0) {
          $backdropEl = $('<div class="custom-modal-backdrop"></div>');
          app.root.append($backdropEl);
        }
      }

      function handleClick(e) {
        if (!customModal || customModal.destroyed) return;
        if ($backdropEl && e.target === $backdropEl[0]) {
          customModal.close();
        }
      }

      customModal.on('customModalOpened', () => {
        if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
          app.on('click', handleClick);
        }
      });
      customModal.on('customModalClose', () => {
        if (customModal.params.closeByBackdropClick && customModal.params.backdrop) {
          app.off('click', handleClick);
        }
      });

      Utils.extend(customModal, {
        app,
        $el,
        el: $el[0],
        $backdropEl,
        backdropEl: $backdropEl && $backdropEl[0],
        type: 'customModal',
      });

      $el[0].f7Modal = customModal;

      return customModal;
    }
  }

  var Modal$1 = {
    name: 'modal',
    static: {
      Modal,
      CustomModal,
    },
    create() {
      const app = this;
      app.customModal = {
        create(params) {
          return new CustomModal(app, params);
        },
      };
    },
    params: {
      modal: {
        moveToRoot: true,
        queueDialogs: true,
      },
    },
  };

  var Appbar = {
    name: 'appbar',
  };

  class Dialog extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend({
        title: app.params.dialog.title,
        text: undefined,
        content: '',
        buttons: [],
        verticalButtons: false,
        onClick: undefined,
        cssClass: undefined,
        destroyOnClose: false,
        on: {},
      }, params);
      if (typeof extendedParams.closeByBackdropClick === 'undefined') {
        extendedParams.closeByBackdropClick = app.params.dialog.closeByBackdropClick;
      }
      if (typeof extendedParams.backdrop === 'undefined') {
        extendedParams.backdrop = app.params.dialog.backdrop;
      }

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const dialog = this;

      const { title, text, content, buttons, verticalButtons, cssClass, backdrop } = extendedParams;

      dialog.params = extendedParams;

      // Find Element
      let $el;
      if (!dialog.params.el) {
        const dialogClasses = ['dialog'];
        if (buttons.length === 0) dialogClasses.push('dialog-no-buttons');
        if (buttons.length > 0) dialogClasses.push(`dialog-buttons-${buttons.length}`);
        if (verticalButtons) dialogClasses.push('dialog-buttons-vertical');
        if (cssClass) dialogClasses.push(cssClass);

        let buttonsHTML = '';
        if (buttons.length > 0) {
          buttonsHTML = `
          <div class="dialog-buttons">
            ${buttons.map(button => `
              <span class="dialog-button${button.bold ? ' dialog-button-bold' : ''}${button.color ? ` color-${button.color}` : ''}${button.cssClass ? ` ${button.cssClass}` : ''}">${button.text}</span>
            `).join('')}
          </div>
        `;
        }

        const dialogHtml = `
        <div class="${dialogClasses.join(' ')}">
          <div class="dialog-inner">
            ${title ? `<div class="dialog-title">${title}</div>` : ''}
            ${text ? `<div class="dialog-text">${text}</div>` : ''}
            ${content}
          </div>
          ${buttonsHTML}
        </div>
      `;
        $el = $(dialogHtml);
      } else {
        $el = $(dialog.params.el);
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      if ($el.length === 0) {
        return dialog.destroy();
      }

      let $backdropEl;
      if (backdrop) {
        $backdropEl = app.root.children('.dialog-backdrop');
        if ($backdropEl.length === 0) {
          $backdropEl = $('<div class="dialog-backdrop"></div>');
          app.root.append($backdropEl);
        }
      }

      // Assign events
      function buttonOnClick(e) {
        const buttonEl = this;
        const index = $(buttonEl).index();
        const button = buttons[index];
        if (button.onClick) button.onClick(dialog, e);
        if (dialog.params.onClick) dialog.params.onClick(dialog, index);
        if (button.close !== false) dialog.close();
      }
      let addKeyboardHander;
      function onKeyDown(e) {
        const keyCode = e.keyCode;
        buttons.forEach((button, index) => {
          if (button.keyCodes && button.keyCodes.indexOf(keyCode) >= 0) {
            if (doc.activeElement) doc.activeElement.blur();
            if (button.onClick) button.onClick(dialog, e);
            if (dialog.params.onClick) dialog.params.onClick(dialog, index);
            if (button.close !== false) dialog.close();
          }
        });
      }
      if (buttons && buttons.length > 0) {
        dialog.on('open', () => {
          $el.find('.dialog-button').each((index, buttonEl) => {
            const button = buttons[index];
            if (button.keyCodes) addKeyboardHander = true;
            $(buttonEl).on('click', buttonOnClick);
          });
          if (
            addKeyboardHander
            && !app.device.ios
            && !app.device.android
            && !app.device.cordova
          ) {
            $(doc).on('keydown', onKeyDown);
          }
        });
        dialog.on('close', () => {
          $el.find('.dialog-button').each((index, buttonEl) => {
            $(buttonEl).off('click', buttonOnClick);
          });
          if (
            addKeyboardHander
            && !app.device.ios
            && !app.device.android
            && !app.device.cordova
          ) {
            $(doc).off('keydown', onKeyDown);
          }
          addKeyboardHander = false;
        });
      }
      Utils.extend(dialog, {
        app,
        $el,
        el: $el[0],
        $backdropEl,
        backdropEl: $backdropEl && $backdropEl[0],
        type: 'dialog',
        setProgress(progress, duration) {
          app.progressbar.set($el.find('.progressbar'), progress, duration);
          return dialog;
        },
        setText(newText) {
          let $textEl = $el.find('.dialog-text');
          if ($textEl.length === 0) {
            $textEl = $('<div class="dialog-text"></div>');
            if (typeof title !== 'undefined') {
              $textEl.insertAfter($el.find('.dialog-title'));
            } else {
              $el.find('.dialog-inner').prepend($textEl);
            }
          }
          $textEl.html(newText);
          dialog.params.text = newText;
          return dialog;
        },
        setTitle(newTitle) {
          let $titleEl = $el.find('.dialog-title');
          if ($titleEl.length === 0) {
            $titleEl = $('<div class="dialog-title"></div>');
            $el.find('.dialog-inner').prepend($titleEl);
          }
          $titleEl.html(newTitle);
          dialog.params.title = newTitle;
          return dialog;
        },
      });

      function handleClick(e) {
        const target = e.target;
        const $target = $(target);
        if ($target.closest(dialog.el).length === 0) {
          if (
            dialog.params.closeByBackdropClick
            && dialog.backdropEl
            && dialog.backdropEl === target
          ) {
            dialog.close();
          }
        }
      }

      dialog.on('opened', () => {
        if (dialog.params.closeByBackdropClick) {
          app.on('click', handleClick);
        }
      });
      dialog.on('close', () => {
        if (dialog.params.closeByBackdropClick) {
          app.off('click', handleClick);
        }
      });

      $el[0].f7Modal = dialog;

      if (dialog.params.destroyOnClose) {
        dialog.once('closed', () => {
          setTimeout(() => {
            dialog.destroy();
          }, 0);
        });
      }

      return dialog;
    }
  }

  var Dialog$1 = {
    name: 'dialog',
    params: {
      dialog: {
        title: undefined,
        buttonOk: 'OK',
        buttonCancel: 'Cancel',
        usernamePlaceholder: 'Username',
        passwordPlaceholder: 'Password',
        preloaderTitle: 'Loading... ',
        progressTitle: 'Loading... ',
        backdrop: true,
        closeByBackdropClick: false,
        destroyPredefinedDialogs: true,
        keyboardActions: true,
        autoFocus: true,
      },
    },
    static: {
      Dialog,
    },
    create() {
      const app = this;
      function defaultDialogTitle() {
        return app.params.dialog.title || app.name;
      }
      const destroyOnClose = app.params.dialog.destroyPredefinedDialogs;
      const keyboardActions = app.params.dialog.keyboardActions;
      const autoFocus = app.params.dialog.autoFocus;
      const autoFocusHandler = (autoFocus ? {
        on: {
          opened(dialog) {
            dialog.$el.find('input').eq(0).focus();
          },
        },
      } : {});

      app.dialog = Utils.extend(
        ModalMethods({
          app,
          constructor: Dialog,
          defaultSelector: '.dialog.modal-in',
        }),
        {
          // Shortcuts
          alert(...args) {
            let [text, title, callbackOk] = args;
            if (args.length === 2 && typeof args[1] === 'function') {
              [text, callbackOk, title] = args;
            }
            return new Dialog(app, {
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text,
              buttons: [{
                text: app.params.dialog.buttonOk,
                bold: true,
                onClick: callbackOk,
                keyCodes: keyboardActions ? [13, 27] : null,
              }],
              destroyOnClose,
            }).open();
          },
          prompt(...args) {
            let [text, title, callbackOk, callbackCancel, defaultValue] = args;
            if (typeof args[1] === 'function') {
              [text, callbackOk, callbackCancel, defaultValue, title] = args;
            }
            defaultValue = typeof defaultValue === 'undefined' || defaultValue === null ? '' : defaultValue;
            return new Dialog(app, {
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text,
              content: `<div class="dialog-input-field input"><input type="text" class="dialog-input" value="${defaultValue}"></div>`,
              buttons: [
                {
                  text: app.params.dialog.buttonCancel,
                  keyCodes: keyboardActions ? [27] : null,
                  color: app.theme === 'aurora' ? 'gray' : null,
                },
                {
                  text: app.params.dialog.buttonOk,
                  bold: true,
                  keyCodes: keyboardActions ? [13] : null,
                },
              ],
              onClick(dialog, index) {
                const inputValue = dialog.$el.find('.dialog-input').val();
                if (index === 0 && callbackCancel) callbackCancel(inputValue);
                if (index === 1 && callbackOk) callbackOk(inputValue);
              },
              destroyOnClose,
              ...autoFocusHandler,
            }).open();
          },
          confirm(...args) {
            let [text, title, callbackOk, callbackCancel] = args;
            if (typeof args[1] === 'function') {
              [text, callbackOk, callbackCancel, title] = args;
            }
            return new Dialog(app, {
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text,
              buttons: [
                {
                  text: app.params.dialog.buttonCancel,
                  onClick: callbackCancel,
                  keyCodes: keyboardActions ? [27] : null,
                  color: app.theme === 'aurora' ? 'gray' : null,
                },
                {
                  text: app.params.dialog.buttonOk,
                  bold: true,
                  onClick: callbackOk,
                  keyCodes: keyboardActions ? [13] : null,
                },
              ],
              destroyOnClose,
            }).open();
          },
          login(...args) {
            let [text, title, callbackOk, callbackCancel] = args;
            if (typeof args[1] === 'function') {
              [text, callbackOk, callbackCancel, title] = args;
            }
            return new Dialog(app, {
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text,
              content: `
              <div class="dialog-input-field dialog-input-double input">
                <input type="text" name="dialog-username" placeholder="${app.params.dialog.usernamePlaceholder}" class="dialog-input">
              </div>
              <div class="dialog-input-field dialog-input-double input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
              buttons: [
                {
                  text: app.params.dialog.buttonCancel,
                  keyCodes: keyboardActions ? [27] : null,
                  color: app.theme === 'aurora' ? 'gray' : null,
                },
                {
                  text: app.params.dialog.buttonOk,
                  bold: true,
                  keyCodes: keyboardActions ? [13] : null,
                },
              ],
              onClick(dialog, index) {
                const username = dialog.$el.find('[name="dialog-username"]').val();
                const password = dialog.$el.find('[name="dialog-password"]').val();
                if (index === 0 && callbackCancel) callbackCancel(username, password);
                if (index === 1 && callbackOk) callbackOk(username, password);
              },
              destroyOnClose,
              ...autoFocusHandler,
            }).open();
          },
          password(...args) {
            let [text, title, callbackOk, callbackCancel] = args;
            if (typeof args[1] === 'function') {
              [text, callbackOk, callbackCancel, title] = args;
            }
            return new Dialog(app, {
              title: typeof title === 'undefined' ? defaultDialogTitle() : title,
              text,
              content: `
              <div class="dialog-input-field input">
                <input type="password" name="dialog-password" placeholder="${app.params.dialog.passwordPlaceholder}" class="dialog-input">
              </div>`,
              buttons: [
                {
                  text: app.params.dialog.buttonCancel,
                  keyCodes: keyboardActions ? [27] : null,
                  color: app.theme === 'aurora' ? 'gray' : null,
                },
                {
                  text: app.params.dialog.buttonOk,
                  bold: true,
                  keyCodes: keyboardActions ? [13] : null,
                },
              ],
              onClick(dialog, index) {
                const password = dialog.$el.find('[name="dialog-password"]').val();
                if (index === 0 && callbackCancel) callbackCancel(password);
                if (index === 1 && callbackOk) callbackOk(password);
              },
              destroyOnClose,
              ...autoFocusHandler,
            }).open();
          },
          preloader(title, color) {
            const preloaderInner = Utils[`${app.theme}PreloaderContent`] || '';
            return new Dialog(app, {
              title: typeof title === 'undefined' || title === null ? app.params.dialog.preloaderTitle : title,
              content: `<div class="preloader${color ? ` color-${color}` : ''}">${preloaderInner}</div>`,
              cssClass: 'dialog-preloader',
              destroyOnClose,
            }).open();
          },
          progress(...args) {
            let [title, progress, color] = args;
            if (args.length === 2) {
              if (typeof args[0] === 'number') {
                [progress, color, title] = args;
              } else if (typeof args[0] === 'string' && typeof args[1] === 'string') {
                [title, color, progress] = args;
              }
            } else if (args.length === 1) {
              if (typeof args[0] === 'number') {
                [progress, title, color] = args;
              }
            }
            const infinite = typeof progress === 'undefined';
            const dialog = new Dialog(app, {
              title: typeof title === 'undefined' ? app.params.dialog.progressTitle : title,
              cssClass: 'dialog-progress',
              content: `
              <div class="progressbar${infinite ? '-infinite' : ''}${color ? ` color-${color}` : ''}">
                ${!infinite ? '<span></span>' : ''}
              </div>
            `,
              destroyOnClose,
            });
            if (!infinite) dialog.setProgress(progress);
            return dialog.open();
          },
        }
      );
    },
  };

  class Popup extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend(
        { on: {} },
        app.params.popup,
        params
      );

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const popup = this;

      popup.params = extendedParams;

      // Find Element
      let $el;
      if (!popup.params.el) {
        $el = $(popup.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
      } else {
        $el = $(popup.params.el).eq(0);
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      if ($el.length === 0) {
        return popup.destroy();
      }

      let $backdropEl;
      if (popup.params.backdrop && popup.params.backdropEl) {
        $backdropEl = $(popup.params.backdropEl);
      } else if (popup.params.backdrop) {
        $backdropEl = app.root.children('.popup-backdrop');
        if ($backdropEl.length === 0) {
          $backdropEl = $('<div class="popup-backdrop"></div>');
          app.root.append($backdropEl);
        }
      }

      Utils.extend(popup, {
        app,
        push: $el.hasClass('popup-push') || popup.params.push,
        $el,
        el: $el[0],
        $backdropEl,
        backdropEl: $backdropEl && $backdropEl[0],
        type: 'popup',
        $htmlEl: $('html'),
      });

      if (popup.params.push) {
        $el.addClass('popup-push');
      }

      function handleClick(e) {
        const target = e.target;
        const $target = $(target);
        const keyboardOpened = !app.device.desktop && app.device.cordova && ((win.Keyboard && win.Keyboard.isVisible) || (win.cordova.plugins && win.cordova.plugins.Keyboard && win.cordova.plugins.Keyboard.isVisible));
        if (keyboardOpened) return;
        if ($target.closest(popup.el).length === 0) {
          if (
            popup.params
            && popup.params.closeByBackdropClick
            && popup.params.backdrop
            && popup.backdropEl
            && popup.backdropEl === target
          ) {
            let needToClose = true;
            popup.$el.nextAll('.popup.modal-in').each((index, popupEl) => {
              const popupInstance = popupEl.f7Modal;
              if (!popupInstance) return;
              if (
                popupInstance.params.closeByBackdropClick
                && popupInstance.params.backdrop
                && popupInstance.backdropEl === popup.backdropEl
              ) {
                needToClose = false;
              }
            });
            if (needToClose) {
              popup.close();
            }
          }
        }
      }

      function onKeyDown(e) {
        const keyCode = e.keyCode;
        if (keyCode === 27 && popup.params.closeOnEscape) {
          popup.close();
        }
      }

      let pushOffset;
      let isPush;

      function pushViewScale(offset) {
        return (app.height - offset * 2) / app.height;
      }

      let allowSwipeToClose = true;
      let isTouched = false;
      let startTouch;
      let currentTouch;
      let isScrolling;
      let touchStartTime;
      let touchesDiff;
      let isMoved = false;
      let pageContentEl;
      let pageContentScrollTop;
      let pageContentOffsetHeight;
      let pageContentScrollHeight;
      let popupHeight;
      let $pushEl;

      function handleTouchStart(e) {
        if (isTouched || !allowSwipeToClose || !popup.params.swipeToClose) return;
        if (popup.params.swipeHandler && $(e.target).closest(popup.params.swipeHandler).length === 0) {
          return;
        }
        isTouched = true;
        isMoved = false;
        startTouch = {
          x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
          y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY,
        };
        touchStartTime = Utils.now();
        isScrolling = undefined;
        if (!popup.params.swipeHandler && e.type === 'touchstart') {
          pageContentEl = $(e.target).closest('.page-content')[0];
        }
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        currentTouch = {
          x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
          y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY,
        };

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
        }
        if (isScrolling) {
          isTouched = false;
          isMoved = false;
          return;
        }

        touchesDiff = startTouch.y - currentTouch.y;
        if (isPush && pushOffset && touchesDiff > 0) {
          touchesDiff = 0;
        }
        const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';
        $el.transition(0);

        if (typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose) {
          $el.transform('');
          $el.transition('');
          return;
        }

        if (!isMoved) {
          if (isPush && pushOffset) {
            popupHeight = $el[0].offsetHeight;
            $pushEl = $el.prevAll('.popup.modal-in').eq(0);
            if ($pushEl.length === 0) {
              $pushEl = app.root.children('.view, .views');
            }
          }
          if (pageContentEl) {
            pageContentScrollTop = pageContentEl.scrollTop;
            pageContentScrollHeight = pageContentEl.scrollHeight;
            pageContentOffsetHeight = pageContentEl.offsetHeight;
            if (
              !(pageContentScrollHeight === pageContentOffsetHeight)
              && !(direction === 'to-bottom' && pageContentScrollTop === 0)
              && !(direction === 'to-top' && pageContentScrollTop === (pageContentScrollHeight - pageContentOffsetHeight))
            ) {
              $el.transform('');
              $el.transition('');
              isTouched = false;
              isMoved = false;
              return;
            }
          }
          isMoved = true;
          popup.emit('local::swipeStart popupSwipeStart', popup);
          popup.$el.trigger('popup:swipestart');
        } else {
          popup.emit('local::swipeMove popupSwipeMove', popup);
          popup.$el.trigger('popup:swipemove');
        }

        e.preventDefault();
        if (isPush && pushOffset) {
          const pushProgress = 1 - Math.abs(touchesDiff / popupHeight);
          const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
          if ($pushEl.hasClass('popup')) {
            if ($pushEl.hasClass('popup-push')) {
              $pushEl.transition(0).transform(
                `translate3d(0, calc(-1 * ${pushProgress} * (var(--f7-popup-push-offset) + 10px)) , 0px) scale(${scale})`
              );
            } else {
              $pushEl.transition(0).transform(
                `translate3d(0, 0px , 0px) scale(${scale})`
              );
            }
          } else {
            $pushEl.transition(0).transform(`translate3d(0,0,0) scale(${scale})`);
          }
        }
        $el.transition(0).transform(`translate3d(0,${-touchesDiff}px,0)`);
      }
      function handleTouchEnd() {
        isTouched = false;
        if (!isMoved) {
          return;
        }
        popup.emit('local::swipeEnd popupSwipeEnd', popup);
        popup.$el.trigger('popup:swipeend');
        isMoved = false;
        allowSwipeToClose = false;
        $el.transition('');
        if (isPush && pushOffset) {
          $pushEl.transition('').transform('');
        }
        const direction = touchesDiff <= 0 ? 'to-bottom' : 'to-top';
        if ((typeof popup.params.swipeToClose === 'string' && direction !== popup.params.swipeToClose)) {
          $el.transform('');
          allowSwipeToClose = true;
          return;
        }
        const diff = Math.abs(touchesDiff);
        const timeDiff = (new Date()).getTime() - touchStartTime;
        if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > 100)) {
          Utils.nextTick(() => {
            if (direction === 'to-bottom') {
              $el.addClass('swipe-close-to-bottom');
            } else {
              $el.addClass('swipe-close-to-top');
            }
            $el.transform('');
            popup.emit('local::swipeclose popupSwipeClose', popup);
            popup.$el.trigger('popup:swipeclose');
            popup.close();
            allowSwipeToClose = true;
          });
          return;
        }
        allowSwipeToClose = true;
        $el.transform('');
      }

      const passive = Support.passiveListener ? { passive: true } : false;
      if (popup.params.swipeToClose) {
        $el.on(app.touchEvents.start, handleTouchStart, passive);
        app.on('touchmove', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        popup.once('popupDestroy', () => {
          $el.off(app.touchEvents.start, handleTouchStart, passive);
          app.off('touchmove', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
        });
      }

      let hasPreviousPushPopup;

      popup.on('open', () => {
        hasPreviousPushPopup = false;
        if (popup.params.closeOnEscape) {
          $(doc).on('keydown', onKeyDown);
        }
        $el.prevAll('.popup.modal-in').addClass('popup-behind');
        if (popup.push) {
          isPush = popup.push && (
            (app.width < 630 || app.height < 630)
            || $el.hasClass('popup-tablet-fullscreen')
          );
        }
        if (isPush) {
          pushOffset = parseInt($el.css('--f7-popup-push-offset'), 10);
          if (Number.isNaN(pushOffset)) pushOffset = 0;
          if (pushOffset) {
            $el.addClass('popup-push');
            popup.$htmlEl.addClass('with-modal-popup-push');
            popup.$htmlEl[0].style.setProperty('--f7-popup-push-scale', pushViewScale(pushOffset));
          }
        }
      });
      popup.on('opened', () => {
        $el.removeClass('swipe-close-to-bottom swipe-close-to-top');
        if (popup.params.closeByBackdropClick) {
          app.on('click', handleClick);
        }
      });
      popup.on('close', () => {
        hasPreviousPushPopup = popup.$el.prevAll('.popup-push.modal-in').length > 0;
        if (popup.params.closeOnEscape) {
          $(doc).off('keydown', onKeyDown);
        }
        if (popup.params.closeByBackdropClick) {
          app.off('click', handleClick);
        }
        $el.prevAll('.popup.modal-in').eq(0).removeClass('popup-behind');
        if (isPush && pushOffset && !hasPreviousPushPopup) {
          popup.$htmlEl.removeClass('with-modal-popup-push');
          popup.$htmlEl.addClass('with-modal-popup-push-closing');
        }
      });
      popup.on('closed', () => {
        if (isPush && pushOffset && !hasPreviousPushPopup) {
          popup.$htmlEl.removeClass('with-modal-popup-push-closing');
          popup.$htmlEl[0].style.removeProperty('--f7-popup-push-scale');
        }
      });

      $el[0].f7Modal = popup;

      return popup;
    }
  }

  var Popup$1 = {
    name: 'popup',
    params: {
      popup: {
        backdrop: true,
        backdropEl: undefined,
        closeByBackdropClick: true,
        closeOnEscape: false,
        swipeToClose: false,
        swipeHandler: null,
        push: false,
      },
    },
    static: {
      Popup,
    },
    create() {
      const app = this;
      app.popup = ModalMethods({
        app,
        constructor: Popup,
        defaultSelector: '.popup.modal-in',
        parentSelector: '.popup',
      });
    },
    clicks: {
      '.popup-open': function openPopup($clickedEl, data = {}) {
        const app = this;
        app.popup.open(data.popup, data.animate, $clickedEl);
      },
      '.popup-close': function closePopup($clickedEl, data = {}) {
        const app = this;
        app.popup.close(data.popup, data.animate, $clickedEl);
      },
    },
  };

  class LoginScreen extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend({
        on: {},
      }, params);

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const loginScreen = this;

      loginScreen.params = extendedParams;

      // Find Element
      let $el;
      if (!loginScreen.params.el) {
        $el = $(loginScreen.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
      } else {
        $el = $(loginScreen.params.el).eq(0);
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      if ($el.length === 0) {
        return loginScreen.destroy();
      }

      Utils.extend(loginScreen, {
        app,
        $el,
        el: $el[0],
        type: 'loginScreen',
      });

      $el[0].f7Modal = loginScreen;

      return loginScreen;
    }
  }

  var LoginScreen$1 = {
    name: 'loginScreen',
    static: {
      LoginScreen,
    },
    create() {
      const app = this;
      app.loginScreen = ModalMethods({
        app,
        constructor: LoginScreen,
        defaultSelector: '.login-screen.modal-in',
      });
    },
    clicks: {
      '.login-screen-open': function openLoginScreen($clickedEl, data = {}) {
        const app = this;
        app.loginScreen.open(data.loginScreen, data.animate, $clickedEl);
      },
      '.login-screen-close': function closeLoginScreen($clickedEl, data = {}) {
        const app = this;
        app.loginScreen.close(data.loginScreen, data.animate, $clickedEl);
      },
    },
  };

  class Popover extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend(
        { on: {} },
        app.params.popover,
        params
      );

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const popover = this;

      popover.params = extendedParams;

      // Find Element
      let $el;
      if (!popover.params.el) {
        $el = $(popover.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
      } else {
        $el = $(popover.params.el).eq(0);
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      // Find Target
      const $targetEl = $(popover.params.targetEl).eq(0);

      if ($el.length === 0) {
        return popover.destroy();
      }

      // Backdrop
      let $backdropEl;
      if (popover.params.backdrop && popover.params.backdropEl) {
        $backdropEl = $(popover.params.backdropEl);
      } else if (popover.params.backdrop) {
        $backdropEl = app.root.children('.popover-backdrop');
        if ($backdropEl.length === 0) {
          $backdropEl = $('<div class="popover-backdrop"></div>');
          app.root.append($backdropEl);
        }
      }

      // Find Angle
      let $angleEl;
      if ($el.find('.popover-angle').length === 0) {
        $angleEl = $('<div class="popover-angle"></div>');
        $el.prepend($angleEl);
      } else {
        $angleEl = $el.find('.popover-angle');
      }

      // Open
      const originalOpen = popover.open;

      Utils.extend(popover, {
        app,
        $el,
        el: $el[0],
        $targetEl,
        targetEl: $targetEl[0],
        $angleEl,
        angleEl: $angleEl[0],
        $backdropEl,
        backdropEl: $backdropEl && $backdropEl[0],
        type: 'popover',
        open(...args) {
          let [targetEl, animate] = args;
          if (typeof args[0] === 'boolean') [animate, targetEl] = args;
          if (targetEl) {
            popover.$targetEl = $(targetEl);
            popover.targetEl = popover.$targetEl[0];
          }
          return originalOpen.call(popover, animate);
        },
      });

      function handleResize() {
        popover.resize();
      }
      popover.on('popoverOpen', () => {
        popover.resize();
        app.on('resize', handleResize);
        $(win).on('keyboardDidShow keyboardDidHide', handleResize);
        popover.on('popoverClose popoverBeforeDestroy', () => {
          app.off('resize', handleResize);
          $(win).off('keyboardDidShow keyboardDidHide', handleResize);
        });
      });

      function handleClick(e) {
        const target = e.target;
        const $target = $(target);
        const keyboardOpened = !app.device.desktop && app.device.cordova && ((win.Keyboard && win.Keyboard.isVisible) || (win.cordova.plugins && win.cordova.plugins.Keyboard && win.cordova.plugins.Keyboard.isVisible));
        if (keyboardOpened) return;
        if ($target.closest(popover.el).length === 0) {
          if (
            popover.params.closeByBackdropClick
            && popover.params.backdrop
            && popover.backdropEl
            && popover.backdropEl === target
          ) {
            popover.close();
          } else if (popover.params.closeByOutsideClick) {
            popover.close();
          }
        }
      }

      function onKeyDown(e) {
        const keyCode = e.keyCode;
        if (keyCode === 27 && popover.params.closeOnEscape) {
          popover.close();
        }
      }

      if (popover.params.closeOnEscape) {
        popover.on('popoverOpen', () => {
          $(doc).on('keydown', onKeyDown);
        });
        popover.on('popoverClose', () => {
          $(doc).off('keydown', onKeyDown);
        });
      }

      popover.on('popoverOpened', () => {
        if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
          app.on('click', handleClick);
        }
      });
      popover.on('popoverClose', () => {
        if (popover.params.closeByOutsideClick || popover.params.closeByBackdropClick) {
          app.off('click', handleClick);
        }
      });

      $el[0].f7Modal = popover;

      return popover;
    }

    resize() {
      const popover = this;
      const { app, $el, $targetEl, $angleEl } = popover;
      const { targetX, targetY } = popover.params;
      $el.css({ left: '', top: '' });
      const [width, height] = [$el.width(), $el.height()];
      let angleSize = 0;
      let angleLeft;
      let angleTop;
      if (app.theme === 'ios' || app.theme === 'aurora') {
        $angleEl.removeClass('on-left on-right on-top on-bottom').css({ left: '', top: '' });
        angleSize = $angleEl.width() / 2;
      } else {
        $el.removeClass('popover-on-left popover-on-right popover-on-top popover-on-bottom popover-on-middle').css({ left: '', top: '' });
      }

      let targetWidth;
      let targetHeight;
      let targetOffsetLeft;
      let targetOffsetTop;
      let safeAreaTop = parseInt($('html').css('--f7-safe-area-top'), 10);
      if (Number.isNaN(safeAreaTop)) safeAreaTop = 0;
      if ($targetEl && $targetEl.length > 0) {
        targetWidth = $targetEl.outerWidth();
        targetHeight = $targetEl.outerHeight();

        const targetOffset = $targetEl.offset();
        targetOffsetLeft = targetOffset.left - app.left;
        targetOffsetTop = targetOffset.top - app.top;

        const targetParentPage = $targetEl.parents('.page');
        if (targetParentPage.length > 0) {
          targetOffsetTop -= targetParentPage[0].scrollTop;
        }
      } else if (typeof targetX !== 'undefined' && targetY !== 'undefined') {
        targetOffsetLeft = targetX;
        targetOffsetTop = targetY;
        targetWidth = popover.params.targetWidth || 0;
        targetHeight = popover.params.targetHeight || 0;
      }

      let [left, top, diff] = [0, 0, 0];
      // Top Position
      let position = app.theme === 'md' ? 'bottom' : 'top';
      if (app.theme === 'md') {
        if (height < app.height - targetOffsetTop - targetHeight) {
          // On bottom
          position = 'bottom';
          top = targetOffsetTop + targetHeight;
        } else if (height < targetOffsetTop - safeAreaTop) {
          // On top
          top = targetOffsetTop - height;
          position = 'top';
        } else {
          // On middle
          position = 'middle';
          top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
        }
        top = Math.max(8, Math.min(top, app.height - height - 8));

        // Horizontal Position
        let hPosition;
        if (targetOffsetLeft < app.width / 2) {
          hPosition = 'right';
          left = position === 'middle'
            ? targetOffsetLeft + targetWidth
            : targetOffsetLeft;
        } else {
          hPosition = 'left';
          left = position === 'middle'
            ? targetOffsetLeft - width
            : (targetOffsetLeft + targetWidth) - width;
        }
        left = Math.max(8, Math.min(left, app.width - width - 8));
        $el.addClass(`popover-on-${position} popover-on-${hPosition}`);
      } else {
        // ios and aurora
        if ((height + angleSize) < targetOffsetTop - safeAreaTop) {
          // On top
          top = targetOffsetTop - height - angleSize;
        } else if ((height + angleSize) < app.height - targetOffsetTop - targetHeight) {
          // On bottom
          position = 'bottom';
          top = targetOffsetTop + targetHeight + angleSize;
        } else {
          // On middle
          position = 'middle';
          top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
          diff = top;
          top = Math.max(5, Math.min(top, app.height - height - 5));
          diff -= top;
        }

        // Horizontal Position
        if (position === 'top' || position === 'bottom') {
          left = ((targetWidth / 2) + targetOffsetLeft) - (width / 2);
          diff = left;
          left = Math.max(5, Math.min(left, app.width - width - 5));
          if (position === 'top') {
            $angleEl.addClass('on-bottom');
          }
          if (position === 'bottom') {
            $angleEl.addClass('on-top');
          }
          diff -= left;
          angleLeft = ((width / 2) - angleSize) + diff;
          angleLeft = Math.max(Math.min(angleLeft, width - (angleSize * 2) - 13), 13);
          $angleEl.css({ left: `${angleLeft}px` });
        } else if (position === 'middle') {
          left = targetOffsetLeft - width - angleSize;
          $angleEl.addClass('on-right');
          if (left < 5 || (left + width > app.width)) {
            if (left < 5) left = targetOffsetLeft + targetWidth + angleSize;
            if (left + width > app.width) left = app.width - width - 5;
            $angleEl.removeClass('on-right').addClass('on-left');
          }
          angleTop = ((height / 2) - angleSize) + diff;
          angleTop = Math.max(Math.min(angleTop, height - (angleSize * 2) - 13), 13);
          $angleEl.css({ top: `${angleTop}px` });
        }
      }

      // Apply Styles
      $el.css({ top: `${top}px`, left: `${left}px` });
    }
  }

  var Popover$1 = {
    name: 'popover',
    params: {
      popover: {
        backdrop: true,
        backdropEl: undefined,
        closeByBackdropClick: true,
        closeByOutsideClick: true,
        closeOnEscape: false,
      },
    },
    static: {
      Popover,
    },
    create() {
      const app = this;
      app.popover = Utils.extend(
        ModalMethods({
          app,
          constructor: Popover,
          defaultSelector: '.popover.modal-in',
        }),
        {
          open(popoverEl, targetEl, animate) {
            let $popoverEl = $(popoverEl);
            if ($popoverEl.length > 1) {
              // check if same popover in other page
              const $targetPage = $(targetEl).parents('.page');
              if ($targetPage.length) {
                $popoverEl.each((index, el) => {
                  const $el = $(el);
                  if ($el.parents($targetPage)[0] === $targetPage[0]) {
                    $popoverEl = $el;
                  }
                });
              }
            }
            if ($popoverEl.length > 1) {
              $popoverEl = $popoverEl.eq($popoverEl.length - 1);
            }
            let popover = $popoverEl[0].f7Modal;
            const data = $popoverEl.dataset();
            if (!popover) {
              popover = new Popover(app, Object.assign(
                {
                  el: $popoverEl,
                  targetEl,
                },
                data
              ));
            }
            return popover.open(targetEl, animate);
          },
        }
      );
    },
    clicks: {
      '.popover-open': function openPopover($clickedEl, data = {}) {
        const app = this;
        app.popover.open(data.popover, $clickedEl, data.animate);
      },
      '.popover-close': function closePopover($clickedEl, data = {}) {
        const app = this;
        app.popover.close(data.popover, data.animate, $clickedEl);
      },
    },
  };

  /* eslint indent: ["off"] */

  class Actions extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend(
        { on: {} },
        app.params.actions,
        params
      );

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const actions = this;

      actions.params = extendedParams;

      // Buttons
      let groups;
      if (actions.params.buttons) {
        groups = actions.params.buttons;
        if (!Array.isArray(groups[0])) groups = [groups];
      }
      actions.groups = groups;

      // Find Element
      let $el;
      if (actions.params.el) {
        $el = $(actions.params.el).eq(0);
      } else if (actions.params.content) {
        $el = $(actions.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
      } else if (actions.params.buttons) {
        if (actions.params.convertToPopover) {
          actions.popoverHtml = actions.renderPopover();
        }
        actions.actionsHtml = actions.render();
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      if ($el && $el.length === 0 && !(actions.actionsHtml || actions.popoverHtml)) {
        return actions.destroy();
      }

      // Backdrop
      let $backdropEl;
      if (actions.params.backdrop && actions.params.backdropEl) {
        $backdropEl = $(actions.params.backdropEl);
      } else if (actions.params.backdrop) {
        $backdropEl = app.root.children('.actions-backdrop');
        if ($backdropEl.length === 0) {
          $backdropEl = $('<div class="actions-backdrop"></div>');
          app.root.append($backdropEl);
        }
      }

      const originalOpen = actions.open;
      const originalClose = actions.close;

      let popover;
      function buttonOnClick(e) {
        const $buttonEl = $(this);
        let buttonIndex;
        let groupIndex;
        if ($buttonEl.hasClass('list-button') || $buttonEl.hasClass('item-link')) {
          buttonIndex = $buttonEl.parents('li').index();
          groupIndex = $buttonEl.parents('.list').index();
        } else {
          buttonIndex = $buttonEl.index();
          groupIndex = $buttonEl.parents('.actions-group').index();
        }
        if (typeof groups !== 'undefined') {
          const button = groups[groupIndex][buttonIndex];
          if (button.onClick) button.onClick(actions, e);
          if (actions.params.onClick) actions.params.onClick(actions, e);
          if (button.close !== false) actions.close();
        }
      }
      actions.open = function open(animate) {
        let convertToPopover = false;
        const { targetEl, targetX, targetY, targetWidth, targetHeight } = actions.params;
        if (actions.params.convertToPopover && (targetEl || (targetX !== undefined && targetY !== undefined))) {
          // Popover
          if (
            actions.params.forceToPopover
            || (app.device.ios && app.device.ipad)
            || app.width >= 768
            || (app.device.desktop && app.theme === 'aurora')
          ) {
            convertToPopover = true;
          }
        }
        if (convertToPopover && actions.popoverHtml) {
          popover = app.popover.create({
            content: actions.popoverHtml,
            backdrop: actions.params.backdrop,
            targetEl,
            targetX,
            targetY,
            targetWidth,
            targetHeight,
            on: {
              open() {
                if (!actions.$el) {
                  actions.$el = popover.$el;
                }
                actions.$el.trigger(`modal:open ${actions.type.toLowerCase()}:open`);
                actions.emit(`local::open modalOpen ${actions.type}Open`, actions);
              },
              opened() {
                if (!actions.$el) {
                  actions.$el = popover.$el;
                }
                actions.$el.trigger(`modal:opened ${actions.type.toLowerCase()}:opened`);
                actions.emit(`local::opened modalOpened ${actions.type}Opened`, actions);
              },
              close() {
                if (!actions.$el) {
                  actions.$el = popover.$el;
                }
                actions.$el.trigger(`modal:close ${actions.type.toLowerCase()}:close`);
                actions.emit(`local::close modalClose ${actions.type}Close`, actions);
              },
              closed() {
                if (!actions.$el) {
                  actions.$el = popover.$el;
                }
                actions.$el.trigger(`modal:closed ${actions.type.toLowerCase()}:closed`);
                actions.emit(`local::closed modalClosed ${actions.type}Closed`, actions);
              },
            },
          });
          popover.open(animate);
          popover.once('popoverOpened', () => {
            popover.$el.find('.list-button, .item-link').each((groupIndex, buttonEl) => {
              $(buttonEl).on('click', buttonOnClick);
            });
          });
          popover.once('popoverClosed', () => {
            popover.$el.find('.list-button, .item-link').each((groupIndex, buttonEl) => {
              $(buttonEl).off('click', buttonOnClick);
            });
            Utils.nextTick(() => {
              popover.destroy();
              popover = undefined;
            });
          });
        } else {
          actions.$el = actions.actionsHtml ? $(actions.actionsHtml) : actions.$el;
          actions.$el[0].f7Modal = actions;
          if (actions.groups) {
            actions.$el.find('.actions-button').each((groupIndex, buttonEl) => {
              $(buttonEl).on('click', buttonOnClick);
            });
            actions.once('actionsClosed', () => {
              actions.$el.find('.actions-button').each((groupIndex, buttonEl) => {
                $(buttonEl).off('click', buttonOnClick);
              });
            });
          }
          actions.el = actions.$el[0];
          originalOpen.call(actions, animate);
        }
        return actions;
      };

      actions.close = function close(animate) {
        if (popover) {
          popover.close(animate);
        } else {
          originalClose.call(actions, animate);
        }
        return actions;
      };

      Utils.extend(actions, {
        app,
        $el,
        el: $el ? $el[0] : undefined,
        $backdropEl,
        backdropEl: $backdropEl && $backdropEl[0],
        type: 'actions',
      });

      function handleClick(e) {
        const target = e.target;
        const $target = $(target);
        const keyboardOpened = !app.device.desktop && app.device.cordova && ((win.Keyboard && win.Keyboard.isVisible) || (win.cordova.plugins && win.cordova.plugins.Keyboard && win.cordova.plugins.Keyboard.isVisible));
        if (keyboardOpened) return;
        if ($target.closest(actions.el).length === 0) {
          if (
            actions.params.closeByBackdropClick
            && actions.params.backdrop
            && actions.backdropEl
            && actions.backdropEl === target
          ) {
            actions.close();
          } else if (actions.params.closeByOutsideClick) {
            actions.close();
          }
        }
      }

      function onKeyDown(e) {
        const keyCode = e.keyCode;
        if (keyCode === 27 && actions.params.closeOnEscape) {
          actions.close();
        }
      }

      if (actions.params.closeOnEscape) {
        actions.on('open', () => {
          $(doc).on('keydown', onKeyDown);
        });
        actions.on('close', () => {
          $(doc).off('keydown', onKeyDown);
        });
      }

      actions.on('opened', () => {
        if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
          app.on('click', handleClick);
        }
      });
      actions.on('close', () => {
        if (actions.params.closeByBackdropClick || actions.params.closeByOutsideClick) {
          app.off('click', handleClick);
        }
      });

      if ($el) {
        $el[0].f7Modal = actions;
      }

      return actions;
    }

    render() {
      const actions = this;
      if (actions.params.render) return actions.params.render.call(actions, actions);
      const { groups } = actions;
      const cssClass = actions.params.cssClass;
      return `
      <div class="actions-modal${actions.params.grid ? ' actions-grid' : ''} ${cssClass || ''}">
        ${groups.map(group => `<div class="actions-group">
            ${group.map((button) => {
              const buttonClasses = [`actions-${button.label ? 'label' : 'button'}`];
              const { color, bg, bold, disabled, label, text, icon } = button;
              if (color) buttonClasses.push(`color-${color}`);
              if (bg) buttonClasses.push(`bg-color-${bg}`);
              if (bold) buttonClasses.push('actions-button-bold');
              if (disabled) buttonClasses.push('disabled');
              if (label) {
                return `<div class="${buttonClasses.join(' ')}">${text}</div>`;
              }
              return `
                <div class="${buttonClasses.join(' ')}">
                  ${icon ? `<div class="actions-button-media">${icon}</div>` : ''}
                  <div class="actions-button-text">${text}</div>
                </div>`.trim();
            }).join('')}
          </div>`).join('')}
      </div>
    `.trim();
    }

    renderPopover() {
      const actions = this;
      if (actions.params.renderPopover) return actions.params.renderPopover.call(actions, actions);
      const { groups } = actions;
      const cssClass = actions.params.cssClass;
      return `
      <div class="popover popover-from-actions ${cssClass || ''}">
        <div class="popover-inner">
          ${groups.map(group => `
            <div class="list">
              <ul>
                ${group.map((button) => {
                  const itemClasses = [];
                  const { color, bg, bold, disabled, label, text, icon } = button;
                  if (color) itemClasses.push(`color-${color}`);
                  if (bg) itemClasses.push(`bg-color-${bg}`);
                  if (bold) itemClasses.push('popover-from-actions-bold');
                  if (disabled) itemClasses.push('disabled');
                  if (label) {
                    itemClasses.push('popover-from-actions-label');
                    return `<li class="${itemClasses.join(' ')}">${text}</li>`;
                  }
                  if (icon) {
                    itemClasses.push('item-link item-content');
                    return `
                      <li>
                        <a class="${itemClasses.join(' ')}">
                          <div class="item-media">
                            ${icon}
                          </div>
                          <div class="item-inner">
                            <div class="item-title">
                              ${text}
                            </div>
                          </div>
                        </a>
                      </li>
                    `;
                  }
                  itemClasses.push('list-button');
                  return `
                    <li>
                      <a class="${itemClasses.join(' ')}">${text}</a>
                    </li>
                  `;
                }).join('')}
              </ul>
            </div>
          `).join('')}
        </div>
      </div>
    `.trim();
    }
  }

  var Actions$1 = {
    name: 'actions',
    params: {
      actions: {
        convertToPopover: true,
        forceToPopover: false,
        backdrop: true,
        backdropEl: undefined,
        cssClass: null,
        closeByBackdropClick: true,
        closeOnEscape: false,
        render: null,
        renderPopover: null,
      },
    },
    static: {
      Actions,
    },
    create() {
      const app = this;
      app.actions = ModalMethods({
        app,
        constructor: Actions,
        defaultSelector: '.actions-modal.modal-in',
      });
    },
    clicks: {
      '.actions-open': function openActions($clickedEl, data = {}) {
        const app = this;
        app.actions.open(data.actions, data.animate, $clickedEl);
      },
      '.actions-close': function closeActions($clickedEl, data = {}) {
        const app = this;
        app.actions.close(data.actions, data.animate, $clickedEl);
      },
    },
  };

  class Sheet extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend(
        { on: {} },
        app.params.sheet,
        params
      );

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const sheet = this;

      sheet.params = extendedParams;
      if (typeof sheet.params.backdrop === 'undefined') {
        sheet.params.backdrop = app.theme !== 'ios';
      }

      // Find Element
      let $el;
      if (!sheet.params.el) {
        $el = $(sheet.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
      } else {
        $el = $(sheet.params.el).eq(0);
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      if ($el.length === 0) {
        return sheet.destroy();
      }
      let $backdropEl;

      if (sheet.params.backdrop && sheet.params.backdropEl) {
        $backdropEl = $(sheet.params.backdropEl);
      } else if (sheet.params.backdrop) {
        $backdropEl = app.root.children('.sheet-backdrop');
        if ($backdropEl.length === 0) {
          $backdropEl = $('<div class="sheet-backdrop"></div>');
          app.root.append($backdropEl);
        }
      }

      Utils.extend(sheet, {
        app,
        push: $el.hasClass('sheet-modal-push') || sheet.params.push,
        $el,
        el: $el[0],
        $backdropEl,
        backdropEl: $backdropEl && $backdropEl[0],
        type: 'sheet',
        $htmlEl: $('html'),
      });

      if (sheet.params.push) {
        $el.addClass('sheet-modal-push');
      }

      let $pageContentEl;
      function scrollToElementOnOpen() {
        const $scrollEl = $(sheet.params.scrollToEl).eq(0);
        if ($scrollEl.length === 0) return;
        $pageContentEl = $scrollEl.parents('.page-content');
        if ($pageContentEl.length === 0) return;

        const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
        const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
        const pageHeight = $pageContentEl[0].offsetHeight - paddingTop - $el.height();
        const pageScrollHeight = $pageContentEl[0].scrollHeight - paddingTop - $el.height();
        const pageScroll = $pageContentEl.scrollTop();

        let newPaddingBottom;

        const scrollElTop = ($scrollEl.offset().top - paddingTop) + $scrollEl[0].offsetHeight;
        if (scrollElTop > pageHeight) {
          const scrollTop = (pageScroll + scrollElTop) - pageHeight;
          if (scrollTop + pageHeight > pageScrollHeight) {
            newPaddingBottom = ((scrollTop + pageHeight) - pageScrollHeight) + paddingBottom;
            if (pageHeight === pageScrollHeight) {
              newPaddingBottom = $el.height();
            }
            $pageContentEl.css({
              'padding-bottom': `${newPaddingBottom}px`,
            });
          }
          $pageContentEl.scrollTop(scrollTop, 300);
        }
      }

      function scrollToElementOnClose() {
        if ($pageContentEl && $pageContentEl.length > 0) {
          $pageContentEl.css({
            'padding-bottom': '',
          });
        }
      }
      function handleClick(e) {
        const target = e.target;
        const $target = $(target);
        const keyboardOpened = !app.device.desktop && app.device.cordova && ((win.Keyboard && win.Keyboard.isVisible) || (win.cordova.plugins && win.cordova.plugins.Keyboard && win.cordova.plugins.Keyboard.isVisible));
        if (keyboardOpened) return;
        if ($target.closest(sheet.el).length === 0) {
          if (
            sheet.params.closeByBackdropClick
            && sheet.params.backdrop
            && sheet.backdropEl
            && sheet.backdropEl === target
          ) {
            sheet.close();
          } else if (sheet.params.closeByOutsideClick) {
            sheet.close();
          }
        }
      }

      function onKeyDown(e) {
        const keyCode = e.keyCode;
        if (keyCode === 27 && sheet.params.closeOnEscape) {
          sheet.close();
        }
      }

      let pushOffset;

      function pushViewScale(offset) {
        return (app.height - offset * 2) / app.height;
      }


      let isTouched = false;
      let startTouch;
      let currentTouch;
      let isScrolling;
      let touchStartTime;
      let touchesDiff;
      let isMoved = false;
      let isTopSheetModal;
      let swipeStepTranslate;
      let startTranslate;
      let currentTranslate;
      let sheetElOffsetHeight;
      let minTranslate;
      let maxTranslate;
      let $pushViewEl;
      let pushBorderRadius;
      let sheetPageContentEl;
      let sheetPageContentScrollTop;
      let sheetPageContentScrollHeight;
      let sheetPageContentOffsetHeight;

      function handleTouchStart(e) {
        if (isTouched || !(sheet.params.swipeToClose || sheet.params.swipeToStep)) return;
        if (sheet.params.swipeHandler && $(e.target).closest(sheet.params.swipeHandler).length === 0) {
          return;
        }
        isTouched = true;
        isMoved = false;
        startTouch = {
          x: e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX,
          y: e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY,
        };
        touchStartTime = Utils.now();
        isScrolling = undefined;
        isTopSheetModal = $el.hasClass('sheet-modal-top');
        if (!sheet.params.swipeHandler && e.type === 'touchstart') {
          sheetPageContentEl = $(e.target).closest('.page-content')[0];
        }
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        currentTouch = {
          x: e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX,
          y: e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY,
        };

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(currentTouch.x - startTouch.x) > Math.abs(currentTouch.y - startTouch.y));
        }
        if (isScrolling) {
          isTouched = false;
          isMoved = false;
          return;
        }

        touchesDiff = startTouch.y - currentTouch.y;

        const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';

        if (!isMoved) {
          if (sheetPageContentEl && !$el.hasClass('modal-in-swipe-step')) {
            sheetPageContentScrollTop = sheetPageContentEl.scrollTop;
            sheetPageContentScrollHeight = sheetPageContentEl.scrollHeight;
            sheetPageContentOffsetHeight = sheetPageContentEl.offsetHeight;
            if (
              !(sheetPageContentScrollHeight === sheetPageContentOffsetHeight)
              && !(direction === 'to-bottom' && sheetPageContentScrollTop === 0)
              && !(direction === 'to-top' && sheetPageContentScrollTop === (sheetPageContentScrollHeight - sheetPageContentOffsetHeight))
            ) {
              $el.transform('');
              isTouched = false;
              isMoved = false;
              return;
            }
          }
          if (sheet.push && pushOffset) {
            $pushViewEl = app.root.children('.view, .views');
          }
          sheetElOffsetHeight = $el[0].offsetHeight;
          startTranslate = Utils.getTranslate($el[0], 'y');
          if (isTopSheetModal) {
            minTranslate = sheet.params.swipeToClose ? -sheetElOffsetHeight : -swipeStepTranslate;
            maxTranslate = 0;
          } else {
            minTranslate = 0;
            maxTranslate = sheet.params.swipeToClose ? sheetElOffsetHeight : swipeStepTranslate;
          }
          isMoved = true;
        }
        currentTranslate = startTranslate - touchesDiff;
        currentTranslate = Math.min(Math.max(currentTranslate, minTranslate), maxTranslate);
        e.preventDefault();
        if (sheet.push && pushOffset) {
          let progress = (currentTranslate - startTranslate) / sheetElOffsetHeight;
          if (sheet.params.swipeToStep) {
            if (isTopSheetModal) {
              progress = (currentTranslate / swipeStepTranslate);
            } else {
              progress = 1 - (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
            }
          }
          progress = Math.abs(progress);
          progress = Math.min(Math.max(progress, 0), 1);
          const pushProgress = 1 - progress;
          const scale = 1 - (1 - pushViewScale(pushOffset)) * pushProgress;
          $pushViewEl.transition(0).transform(`translate3d(0,0,0) scale(${scale})`);
          if (sheet.params.swipeToStep) {
            $pushViewEl.css('border-radius', `${pushBorderRadius * pushProgress}px`);
          }
        }
        $el
          .transition(0)
          .transform(`translate3d(0,${currentTranslate}px,0)`);
        if (sheet.params.swipeToStep) {
          let progress;
          if (isTopSheetModal) {
            progress = 1 - (currentTranslate / swipeStepTranslate);
          } else {
            progress = (swipeStepTranslate - currentTranslate) / swipeStepTranslate;
          }
          progress = Math.min(Math.max(progress, 0), 1);
          $el.trigger('sheet:stepprogress', progress);
          sheet.emit('local::stepProgress sheetStepProgress', sheet, progress);
        }
      }
      function handleTouchEnd() {
        isTouched = false;
        if (!isMoved) {
          return;
        }
        isMoved = false;
        $el.transform('').transition('');
        if (sheet.push && pushOffset) {
          $pushViewEl.transition('').transform('');
          $pushViewEl.css('border-radius', '');
        }

        const direction = touchesDiff < 0 ? 'to-bottom' : 'to-top';

        const diff = Math.abs(touchesDiff);
        if (diff === 0 || currentTranslate === startTranslate) return;

        const timeDiff = (new Date()).getTime() - touchStartTime;

        if (!sheet.params.swipeToStep) {
          if (direction !== (isTopSheetModal ? 'to-top' : 'to-bottom')) {
            return;
          }
          if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > (sheetElOffsetHeight / 2))) {
            sheet.close();
          }
          return;
        }

        const openDirection = isTopSheetModal ? 'to-bottom' : 'to-top';
        const closeDirection = isTopSheetModal ? 'to-top' : 'to-bottom';
        const absCurrentTranslate = Math.abs(currentTranslate);
        const absSwipeStepTranslate = Math.abs(swipeStepTranslate);

        if (timeDiff < 300 && diff > 10) {
          if (direction === openDirection && absCurrentTranslate < absSwipeStepTranslate) {
            // open step
            $el.removeClass('modal-in-swipe-step');
            $el.trigger('sheet:stepprogress', 1);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, 1);
            $el.trigger('sheet:stepopen');
            sheet.emit('local::stepOpen sheetStepOpen', sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
              $pushViewEl.css('border-radius', '');
            }
          }
          if (direction === closeDirection && absCurrentTranslate > absSwipeStepTranslate) {
            // close sheet
            if (sheet.params.swipeToClose) {
              sheet.close();
            } else {
              // close step
              $el.addClass('modal-in-swipe-step');
              $el.trigger('sheet:stepprogress', 0);
              sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
              $el.trigger('sheet:stepclose');
              sheet.emit('local::stepClose sheetStepClose', sheet);
              if (sheet.push && pushOffset) {
                sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
                $pushViewEl.css('border-radius', '0px');
              }
            }
          }
          if (direction === closeDirection && absCurrentTranslate <= absSwipeStepTranslate) {
            // close step
            $el.addClass('modal-in-swipe-step');
            $el.trigger('sheet:stepprogress', 0);
            sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
            $el.trigger('sheet:stepclose');
            sheet.emit('local::stepClose sheetStepClose', sheet);
            if (sheet.push && pushOffset) {
              sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
              $pushViewEl.css('border-radius', '0px');
            }
          }
          return;
        }
        if (timeDiff >= 300) {
          const stepOpened = !$el.hasClass('modal-in-swipe-step');
          if (!stepOpened) {
            if (absCurrentTranslate < (absSwipeStepTranslate / 2)) {
              // open step
              $el.removeClass('modal-in-swipe-step');
              $el.trigger('sheet:stepprogress', 1);
              sheet.emit('local::stepProgress sheetStepProgress', sheet, 1);
              $el.trigger('sheet:stepopen');
              sheet.emit('local::stepOpen sheetStepOpen', sheet);
              if (sheet.push && pushOffset) {
                sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
                $pushViewEl.css('border-radius', '');
              }
            } else if ((absCurrentTranslate - absSwipeStepTranslate) > (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
              // close sheet
              if (sheet.params.swipeToClose) sheet.close();
            }
          } else if (stepOpened) {
            if (absCurrentTranslate > absSwipeStepTranslate + (sheetElOffsetHeight - absSwipeStepTranslate) / 2) {
              // close sheet
              if (sheet.params.swipeToClose) sheet.close();
            } else if (absCurrentTranslate > absSwipeStepTranslate / 2) {
              // close step
              $el.addClass('modal-in-swipe-step');
              $el.trigger('sheet:stepprogress', 0);
              sheet.emit('local::stepProgress sheetStepProgress', sheet, 0);
              $el.trigger('sheet:stepclose');
              sheet.emit('local::stepClose sheetStepClose', sheet);
              if (sheet.push && pushOffset) {
                sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
                $pushViewEl.css('border-radius', '0px');
              }
            }
          }
        }
      }

      sheet.setSwipeStep = function setSwipeStep(byResize = true) {
        const $swipeStepEl = $el.find('.sheet-modal-swipe-step').eq(0);
        if (!$swipeStepEl.length) return;
        if ($el.hasClass('sheet-modal-top')) {
          swipeStepTranslate = -($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
        } else {
          swipeStepTranslate = $el[0].offsetHeight - ($swipeStepEl.offset().top - $el.offset().top + $swipeStepEl[0].offsetHeight);
        }
        $el[0].style.setProperty('--f7-sheet-swipe-step', `${swipeStepTranslate}px`);
        if (!byResize) {
          $el.addClass('modal-in-swipe-step');
        }
      };

      function onResize() {
        sheet.setSwipeStep(true);
      }

      const passive = Support.passiveListener ? { passive: true } : false;
      if (sheet.params.swipeToClose || sheet.params.swipeToStep) {
        $el.on(app.touchEvents.start, handleTouchStart, passive);
        app.on('touchmove', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        sheet.once('sheetDestroy', () => {
          $el.off(app.touchEvents.start, handleTouchStart, passive);
          app.off('touchmove', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
        });
      }

      sheet.on('open', () => {
        if (sheet.params.closeOnEscape) {
          $(doc).on('keydown', onKeyDown);
        }
        $el.prevAll('.popup.modal-in').addClass('popup-behind');
        if (sheet.params.swipeToStep) {
          sheet.setSwipeStep(false);
          app.on('resize', onResize);
        }
        if (sheet.params.scrollToEl) {
          scrollToElementOnOpen();
        }

        if (sheet.push) {
          pushOffset = parseInt($el.css('--f7-sheet-push-offset'), 10);
          if (Number.isNaN(pushOffset)) pushOffset = 0;
          if (pushOffset) {
            $el.addClass('sheet-modal-push');
            sheet.$htmlEl.addClass('with-modal-sheet-push');
            if (!sheet.params.swipeToStep) {
              sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
            } else {
              $pushViewEl = app.root.children('.view, .views');
              pushBorderRadius = parseFloat($el.css(`border-${isTopSheetModal ? 'bottom' : 'top'}-left-radius`));
              $pushViewEl.css('border-radius', '0px');
            }
          }
        }
      });
      sheet.on('opened', () => {
        if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
          app.on('click', handleClick);
        }
      });
      sheet.on('close', () => {
        if (sheet.params.swipeToStep) {
          $el.removeClass('modal-in-swipe-step');
          app.off('resize', onResize);
        }
        if (sheet.params.closeOnEscape) {
          $(doc).off('keydown', onKeyDown);
        }
        if (sheet.params.scrollToEl) {
          scrollToElementOnClose();
        }
        if (sheet.params.closeByOutsideClick || sheet.params.closeByBackdropClick) {
          app.off('click', handleClick);
        }
        $el.prevAll('.popup.modal-in').eq(0).removeClass('popup-behind');
        if (sheet.push && pushOffset) {
          sheet.$htmlEl.removeClass('with-modal-sheet-push');
          sheet.$htmlEl.addClass('with-modal-sheet-push-closing');
        }
      });
      sheet.on('closed', () => {
        if (sheet.push && pushOffset) {
          sheet.$htmlEl.removeClass('with-modal-sheet-push-closing');
          sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
        }
      });

      sheet.stepOpen = function stepOpen() {
        $el.removeClass('modal-in-swipe-step');
        if (sheet.push) {
          if (!pushOffset) {
            pushOffset = parseInt($el.css('--f7-sheet-push-offset'), 10);
            if (Number.isNaN(pushOffset)) pushOffset = 0;
          }
          if (pushOffset) {
            sheet.$htmlEl[0].style.setProperty('--f7-sheet-push-scale', pushViewScale(pushOffset));
          }
        }
      };
      sheet.stepClose = function stepClose() {
        $el.addClass('modal-in-swipe-step');
        if (sheet.push) {
          sheet.$htmlEl[0].style.removeProperty('--f7-sheet-push-scale');
        }
      };
      sheet.stepToggle = function stepToggle() {
        $el.toggleClass('modal-in-swipe-step');
      };

      $el[0].f7Modal = sheet;

      return sheet;
    }
  }

  var Sheet$1 = {
    name: 'sheet',
    params: {
      sheet: {
        push: false,
        backdrop: undefined,
        backdropEl: undefined,
        closeByBackdropClick: true,
        closeByOutsideClick: false,
        closeOnEscape: false,
        swipeToClose: false,
        swipeToStep: false,
        swipeHandler: null,
      },
    },
    static: {
      Sheet,
    },
    create() {
      const app = this;
      app.sheet = Utils.extend(
        {},
        ModalMethods({
          app,
          constructor: Sheet,
          defaultSelector: '.sheet-modal.modal-in',
        }),
        {
          stepOpen(sheet) {
            const sheetInstance = app.sheet.get(sheet);
            if (sheetInstance && sheetInstance.stepOpen) return sheetInstance.stepOpen();
            return undefined;
          },
          stepClose(sheet) {
            const sheetInstance = app.sheet.get(sheet);
            if (sheetInstance && sheetInstance.stepClose) return sheetInstance.stepClose();
            return undefined;
          },
          stepToggle(sheet) {
            const sheetInstance = app.sheet.get(sheet);
            if (sheetInstance && sheetInstance.stepToggle) return sheetInstance.stepToggle();
            return undefined;
          },
        },
      );
    },
    clicks: {
      '.sheet-open': function openSheet($clickedEl, data = {}) {
        const app = this;
        if ($('.sheet-modal.modal-in').length > 0 && data.sheet && $(data.sheet)[0] !== $('.sheet-modal.modal-in')[0]) {
          app.sheet.close('.sheet-modal.modal-in');
        }
        app.sheet.open(data.sheet, data.animate, $clickedEl);
      },
      '.sheet-close': function closeSheet($clickedEl, data = {}) {
        const app = this;
        app.sheet.close(data.sheet, data.animate, $clickedEl);
      },
    },
  };

  class Toast extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend({
        on: {},
      }, app.params.toast, params);

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const toast = this;

      toast.app = app;

      toast.params = extendedParams;

      const { closeButton, closeTimeout } = toast.params;

      let $el;
      if (!toast.params.el) {
        // Find Element
        const toastHtml = toast.render();

        $el = $(toastHtml);
      } else {
        $el = $(toast.params.el);
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      if ($el.length === 0) {
        return toast.destroy();
      }

      Utils.extend(toast, {
        $el,
        el: $el[0],
        type: 'toast',
      });

      $el[0].f7Modal = toast;

      if (closeButton) {
        $el.find('.toast-button').on('click', () => {
          toast.emit('local::closeButtonClick toastCloseButtonClick', toast);
          toast.close();
        });

        toast.on('beforeDestroy', () => {
          $el.find('.toast-button').off('click');
        });
      }

      let timeoutId;
      toast.on('open', () => {
        $('.toast.modal-in').each((index, openedEl) => {
          const toastInstance = app.toast.get(openedEl);
          if (openedEl !== toast.el && toastInstance) {
            toastInstance.close();
          }
        });
        if (closeTimeout) {
          timeoutId = Utils.nextTick(() => {
            toast.close();
          }, closeTimeout);
        }
      });
      toast.on('close', () => {
        win.clearTimeout(timeoutId);
      });

      if (toast.params.destroyOnClose) {
        toast.once('closed', () => {
          setTimeout(() => {
            toast.destroy();
          }, 0);
        });
      }

      return toast;
    }

    render() {
      const toast = this;
      if (toast.params.render) return toast.params.render.call(toast, toast);
      const { position, cssClass, icon, text, closeButton, closeButtonColor, closeButtonText } = toast.params;
      return `
      <div class="toast toast-${position} ${cssClass || ''} ${icon ? 'toast-with-icon' : ''}">
        <div class="toast-content">
          ${icon ? `<div class="toast-icon">${icon}</div>` : ''}
          <div class="toast-text">${text}</div>
          ${closeButton && !icon ? `
          <a class="toast-button button ${closeButtonColor ? `color-${closeButtonColor}` : ''}">${closeButtonText}</a>
          `.trim() : ''}
        </div>
      </div>
    `.trim();
    }
  }

  var Toast$1 = {
    name: 'toast',
    static: {
      Toast,
    },
    create() {
      const app = this;
      app.toast = Utils.extend(
        {},
        ModalMethods({
          app,
          constructor: Toast,
          defaultSelector: '.toast.modal-in',
        }),
        {
          // Shortcuts
          show(params) {
            Utils.extend(params, {
              destroyOnClose: true,
            });
            return new Toast(app, params).open();
          },
        }
      );
    },
    params: {
      toast: {
        icon: null,
        text: null,
        position: 'bottom',
        closeButton: false,
        closeButtonColor: null,
        closeButtonText: 'Ok',
        closeTimeout: null,
        cssClass: null,
        render: null,
      },
    },
  };

  const Preloader = {
    init(el) {
      const app = this;
      const $el = $(el);
      if ($el.length === 0 || $el.children('.preloader-inner').length > 0 || $el.children('.preloader-inner-line').length > 0) return;
      $el.append(Utils[`${app.theme}PreloaderContent`]);
    },
    // Modal
    visible: false,
    show(color = 'white') {
      const app = this;
      if (Preloader.visible) return;
      const preloaderInner = Utils[`${app.theme}PreloaderContent`] || '';
      $('html').addClass('with-modal-preloader');
      app.root.append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
      Preloader.visible = true;
    },
    showIn(el, color = 'white') {
      const app = this;
      const preloaderInner = Utils[`${app.theme}PreloaderContent`] || '';
      $(el || 'html').addClass('with-modal-preloader');
      $(el || app.root).append(`
      <div class="preloader-backdrop"></div>
      <div class="preloader-modal">
        <div class="preloader color-${color}">${preloaderInner}</div>
      </div>
    `);
    },
    hide() {
      const app = this;
      if (!Preloader.visible) return;
      $('html').removeClass('with-modal-preloader');
      app.root.find('.preloader-backdrop, .preloader-modal').remove();
      Preloader.visible = false;
    },
    hideIn(el) {
      const app = this;
      $(el || 'html').removeClass('with-modal-preloader');
      $(el || app.root).find('.preloader-backdrop, .preloader-modal').remove();
    },
  };
  var Preloader$1 = {
    name: 'preloader',
    create() {
      const app = this;
      Utils.extend(app, {
        preloader: {
          init: Preloader.init.bind(app),
          show: Preloader.show.bind(app),
          hide: Preloader.hide.bind(app),
          showIn: Preloader.showIn.bind(app),
          hideIn: Preloader.hideIn.bind(app),
        },
      });
    },
    on: {
      photoBrowserOpen(pb) {
        const app = this;
        pb.$el.find('.preloader').each((index, preloaderEl) => {
          app.preloader.init(preloaderEl);
        });
      },
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.preloader').each((index, preloaderEl) => {
          app.preloader.init(preloaderEl);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.preloader').each((index, preloaderEl) => {
          app.preloader.init(preloaderEl);
        });
      },
    },
    vnode: {
      preloader: {
        insert(vnode) {
          const app = this;
          const preloaderEl = vnode.elm;
          app.preloader.init(preloaderEl);
        },
      },
    },
  };

  const Progressbar = {
    set(...args) {
      const app = this;
      let [el, progress, duration] = args;
      if (typeof args[0] === 'number') {
        [progress, duration] = args;
        el = app.root;
      }
      if (typeof progress === 'undefined' || progress === null) return el;
      if (!progress) progress = 0;

      const $el = $(el || app.root);
      if ($el.length === 0) {
        return el;
      }
      const progressNormalized = Math.min(Math.max(progress, 0), 100);
      let $progressbarEl;
      if ($el.hasClass('progressbar')) $progressbarEl = $el.eq(0);
      else {
        $progressbarEl = $el.children('.progressbar');
      }
      if ($progressbarEl.length === 0 || $progressbarEl.hasClass('progressbar-infinite')) {
        return $progressbarEl;
      }
      let $progressbarLine = $progressbarEl.children('span');
      if ($progressbarLine.length === 0) {
        $progressbarLine = $('<span></span>');
        $progressbarEl.append($progressbarLine);
      }
      $progressbarLine
        .transition(typeof duration !== 'undefined' ? duration : '')
        .transform(`translate3d(${(-100 + progressNormalized)}%,0,0)`);

      return $progressbarEl[0];
    },
    show(...args) {
      const app = this;

      // '.page', 50, 'multi'
      let [el, progress, color] = args;
      let type = 'determined';

      if (args.length === 2) {
        if ((typeof args[0] === 'string' || typeof args[0] === 'object') && typeof args[1] === 'string') {
          // '.page', 'multi'
          [el, color, progress] = args;
          type = 'infinite';
        } else if (typeof args[0] === 'number' && typeof args[1] === 'string') {
          // 50, 'multi'
          [progress, color] = args;
          el = app.root;
        }
      } else if (args.length === 1) {
        if (typeof args[0] === 'number') {
          el = app.root;
          progress = args[0];
        } else if (typeof args[0] === 'string') {
          type = 'infinite';
          el = app.root;
          color = args[0];
        }
      } else if (args.length === 0) {
        type = 'infinite';
        el = app.root;
      }

      const $el = $(el);
      if ($el.length === 0) return undefined;

      let $progressbarEl;
      if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
        $progressbarEl = $el;
      } else {
        $progressbarEl = $el.children('.progressbar:not(.progressbar-out), .progressbar-infinite:not(.progressbar-out)');
        if ($progressbarEl.length === 0) {
          $progressbarEl = $(`
          <span class="progressbar${type === 'infinite' ? '-infinite' : ''}${color ? ` color-${color}` : ''} progressbar-in">
            ${type === 'infinite' ? '' : '<span></span>'}
          </span>`);
          $el.append($progressbarEl);
        }
      }

      if (typeof progress !== 'undefined') {
        app.progressbar.set($progressbarEl, progress);
      }

      return $progressbarEl[0];
    },
    hide(el, removeAfterHide = true) {
      const app = this;
      const $el = $(el || app.root);
      if ($el.length === 0) return undefined;
      let $progressbarEl;
      if ($el.hasClass('progressbar') || $el.hasClass('progressbar-infinite')) {
        $progressbarEl = $el;
      } else {
        $progressbarEl = $el.children('.progressbar, .progressbar-infinite');
      }
      if ($progressbarEl.length === 0 || !$progressbarEl.hasClass('progressbar-in') || $progressbarEl.hasClass('progressbar-out')) {
        return $progressbarEl;
      }
      $progressbarEl
        .removeClass('progressbar-in')
        .addClass('progressbar-out')
        .animationEnd(() => {
          if (removeAfterHide) {
            $progressbarEl.remove();
          }
        });
      return $progressbarEl;
    },
  };

  var Progressbar$1 = {
    name: 'progressbar',
    create() {
      const app = this;
      Utils.extend(app, {
        progressbar: {
          set: Progressbar.set.bind(app),
          show: Progressbar.show.bind(app),
          hide: Progressbar.hide.bind(app),
        },
      });
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.progressbar').each((index, progressbarEl) => {
          const $progressbarEl = $(progressbarEl);
          app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.progressbar').each((index, progressbarEl) => {
          const $progressbarEl = $(progressbarEl);
          app.progressbar.set($progressbarEl, $progressbarEl.attr('data-progress'));
        });
      },
    },
    vnode: {
      progressbar: {
        insert(vnode) {
          const app = this;
          const el = vnode.elm;
          app.progressbar.set(el, el.getAttribute('data-progress'));
        },
        update(vnode) {
          const app = this;
          const el = vnode.elm;
          app.progressbar.set(el, el.getAttribute('data-progress'));
        },
      },
    },
  };

  const Sortable = {
    init() {
      const app = this;
      let isTouched;
      let isMoved;
      let touchStartY;
      let touchesDiff;
      let $sortingEl;
      let $sortingItems;
      let $sortableContainer;
      let sortingElHeight;
      let minTop;
      let maxTop;
      let $insertAfterEl;
      let $insertBeforeEl;
      let indexFrom;
      let $pageEl;
      let $pageContentEl;
      let pageHeight;
      let pageOffset;
      let sortingElOffsetLocal;
      let sortingElOffsetTop;
      let initialScrollTop;
      let wasTapHold;

      function handleTouchStart(e, isTapHold) {
        isMoved = false;
        isTouched = true;
        wasTapHold = false;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        $sortingEl = $(e.target).closest('li').eq(0);
        indexFrom = $sortingEl.index();
        $sortableContainer = $sortingEl.parents('.sortable');
        const $listGroup = $sortingEl.parents('.list-group');
        if ($listGroup.length && $listGroup.parents($sortableContainer).length) {
          $sortableContainer = $listGroup;
        }
        $sortingItems = $sortableContainer.children('ul').children('li:not(.disallow-sorting):not(.no-sorting)');
        if (app.panel) app.panel.allowOpen = false;
        if (app.swipeout) app.swipeout.allow = false;
        if (isTapHold) {
          $sortingEl.addClass('sorting');
          $sortableContainer.addClass('sortable-sorting');
          wasTapHold = true;
        }
      }
      function handleTouchMove(e) {
        if (!isTouched || !$sortingEl) return;
        const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (!isMoved) {
          $pageEl = $sortingEl.parents('.page');
          $pageContentEl = $sortingEl.parents('.page-content');
          const paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
          const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
          initialScrollTop = $pageContentEl[0].scrollTop;
          pageOffset = $pageEl.offset().top + paddingTop;
          pageHeight = $pageEl.height() - paddingTop - paddingBottom;
          $sortingEl.addClass('sorting');
          $sortableContainer.addClass('sortable-sorting');
          sortingElOffsetLocal = $sortingEl[0].offsetTop;
          minTop = $sortingEl[0].offsetTop;
          maxTop = $sortingEl.parent().height() - sortingElOffsetLocal - $sortingEl.height();
          sortingElHeight = $sortingEl[0].offsetHeight;
          sortingElOffsetTop = $sortingEl.offset().top;
        }
        isMoved = true;

        e.preventDefault();
        e.f7PreventSwipePanel = true;

        touchesDiff = pageY - touchStartY;

        const translateScrollOffset = $pageContentEl[0].scrollTop - initialScrollTop;
        const translate = Math.min(Math.max(touchesDiff + translateScrollOffset, -minTop), maxTop);
        $sortingEl.transform(`translate3d(0,${translate}px,0)`);

        const scrollAddition = 44;
        let allowScroll = true;
        if ((touchesDiff + translateScrollOffset) + scrollAddition < -minTop) {
          allowScroll = false;
        }
        if ((touchesDiff + translateScrollOffset) - scrollAddition > maxTop) {
          allowScroll = false;
        }

        $insertBeforeEl = undefined;
        $insertAfterEl = undefined;

        let scrollDiff;
        if (allowScroll) {
          if (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition > pageOffset + pageHeight) {
            // To Bottom
            scrollDiff = (sortingElOffsetTop + touchesDiff + sortingElHeight + scrollAddition) - (pageOffset + pageHeight);
          }
          if (sortingElOffsetTop + touchesDiff < pageOffset + scrollAddition) {
            // To Top
            scrollDiff = (sortingElOffsetTop + touchesDiff) - pageOffset - scrollAddition;
          }
          if (scrollDiff) {
            $pageContentEl[0].scrollTop += scrollDiff;
          }
        }

        $sortingItems.each((index, el) => {
          const $currentEl = $(el);
          if ($currentEl[0] === $sortingEl[0]) return;
          const currentElOffset = $currentEl[0].offsetTop;
          const currentElHeight = $currentEl.height();
          const sortingElOffset = sortingElOffsetLocal + translate;

          if ((sortingElOffset >= currentElOffset - (currentElHeight / 2)) && $sortingEl.index() < $currentEl.index()) {
            $currentEl.transform(`translate3d(0, ${-sortingElHeight}px,0)`);
            $insertAfterEl = $currentEl;
            $insertBeforeEl = undefined;
          } else if ((sortingElOffset <= currentElOffset + (currentElHeight / 2)) && $sortingEl.index() > $currentEl.index()) {
            $currentEl.transform(`translate3d(0, ${sortingElHeight}px,0)`);
            $insertAfterEl = undefined;
            if (!$insertBeforeEl) $insertBeforeEl = $currentEl;
          } else {
            $currentEl.transform('translate3d(0, 0%,0)');
          }
        });
      }
      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          if (isTouched && !isMoved) {
            if (app.panel) app.panel.allowOpen = true;
            if (app.swipeout) app.swipeout.allow = true;
            if (wasTapHold) {
              $sortingEl.removeClass('sorting');
              $sortableContainer.removeClass('sortable-sorting');
            }
          }
          isTouched = false;
          isMoved = false;
          return;
        }
        if (app.panel) app.panel.allowOpen = true;
        if (app.swipeout) app.swipeout.allow = true;

        $sortingItems.transform('');
        $sortingEl.removeClass('sorting');
        $sortableContainer.removeClass('sortable-sorting');

        let indexTo;
        if ($insertAfterEl) indexTo = $insertAfterEl.index();
        else if ($insertBeforeEl) indexTo = $insertBeforeEl.index();

        let moveElements = $sortableContainer.dataset().sortableMoveElements;
        if (typeof moveElements === 'undefined') {
          moveElements = app.params.sortable.moveElements;
        }

        if (moveElements) {
          if ($insertAfterEl) {
            $sortingEl.insertAfter($insertAfterEl);
          }
          if ($insertBeforeEl) {
            $sortingEl.insertBefore($insertBeforeEl);
          }
        }

        if (($insertAfterEl || $insertBeforeEl)
           && $sortableContainer.hasClass('virtual-list')
        ) {
          indexFrom = $sortingEl[0].f7VirtualListIndex;
          if (typeof indexFrom === 'undefined') indexFrom = $sortingEl.attr('data-virtual-list-index');
          if ($insertBeforeEl) {
            indexTo = $insertBeforeEl[0].f7VirtualListIndex;
            if (typeof indexTo === 'undefined') indexTo = $insertBeforeEl.attr('data-virtual-list-index');
          } else {
            indexTo = $insertAfterEl[0].f7VirtualListIndex;
            if (typeof indexTo === 'undefined') indexTo = $insertAfterEl.attr('data-virtual-list-index');
          }
          if (indexTo !== null) indexTo = parseInt(indexTo, 10);
          else indexTo = undefined;

          const virtualList = $sortableContainer[0].f7VirtualList;

          if (indexFrom) indexFrom = parseInt(indexFrom, 10);
          if (indexTo) indexTo = parseInt(indexTo, 10);
          if (virtualList) virtualList.moveItem(indexFrom, indexTo);
        }
        if (typeof indexTo !== 'undefined' && !Number.isNaN(indexTo) && indexTo !== indexFrom) {
          $sortingEl.trigger('sortable:sort', { from: indexFrom, to: indexTo });
          app.emit('sortableSort', $sortingEl[0], { from: indexFrom, to: indexTo, el: $sortingEl[0] }, $sortableContainer[0]);
        }

        $insertBeforeEl = undefined;
        $insertAfterEl = undefined;
        isTouched = false;
        isMoved = false;
      }

      const activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;

      $(doc).on(app.touchEvents.start, '.list.sortable .sortable-handler', handleTouchStart, activeListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);

      $(doc).on('taphold', '.sortable-tap-hold', (e, pointerEvent) => {
        handleTouchStart(pointerEvent, true);
      });
    },
    enable(el = '.list.sortable') {
      const app = this;
      const $el = $(el);
      if ($el.length === 0) return;
      $el.addClass('sortable-enabled');
      $el.trigger('sortable:enable');
      app.emit('sortableEnable', $el[0]);
    },
    disable(el = '.list.sortable') {
      const app = this;
      const $el = $(el);
      if ($el.length === 0) return;
      $el.removeClass('sortable-enabled');
      $el.trigger('sortable:disable');
      app.emit('sortableDisable', $el[0]);
    },
    toggle(el = '.list.sortable') {
      const app = this;
      const $el = $(el);
      if ($el.length === 0) return;
      if ($el.hasClass('sortable-enabled')) {
        app.sortable.disable($el);
      } else {
        app.sortable.enable($el);
      }
    },
  };
  var Sortable$1 = {
    name: 'sortable',
    params: {
      sortable: {
        moveElements: true,
      },
    },
    create() {
      const app = this;
      Utils.extend(app, {
        sortable: {
          init: Sortable.init.bind(app),
          enable: Sortable.enable.bind(app),
          disable: Sortable.disable.bind(app),
          toggle: Sortable.toggle.bind(app),
        },
      });
    },
    on: {
      init() {
        const app = this;
        if (!app.params.sortable) return;
        app.sortable.init();
      },
    },
    clicks: {
      '.sortable-enable': function enable($clickedEl, data = {}) {
        const app = this;
        app.sortable.enable(data.sortable);
      },
      '.sortable-disable': function disable($clickedEl, data = {}) {
        const app = this;
        app.sortable.disable(data.sortable);
      },
      '.sortable-toggle': function toggle($clickedEl, data = {}) {
        const app = this;
        app.sortable.toggle(data.sortable);
      },
    },
  };

  const Swipeout = {
    init() {
      const app = this;
      const touchesStart = {};
      let isTouched;
      let isMoved;
      let isScrolling;
      let touchStartTime;
      let touchesDiff;
      let $swipeoutEl;
      let $swipeoutContent;
      let $actionsRight;
      let $actionsLeft;
      let actionsLeftWidth;
      let actionsRightWidth;
      let translate;
      let opened;
      let openedActionsSide;
      let $leftButtons;
      let $rightButtons;
      let direction;
      let $overswipeLeftButton;
      let $overswipeRightButton;
      let overswipeLeft;
      let overswipeRight;

      function handleTouchStart(e) {
        if (!Swipeout.allow) return;
        isMoved = false;
        isTouched = true;
        isScrolling = undefined;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchStartTime = (new Date()).getTime();
        $swipeoutEl = $(this);
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
        }
        if (isScrolling) {
          isTouched = false;
          return;
        }

        if (!isMoved) {
          if ($('.list.sortable-opened').length > 0) return;
          $swipeoutContent = $swipeoutEl.find('.swipeout-content');
          $actionsRight = $swipeoutEl.find('.swipeout-actions-right');
          $actionsLeft = $swipeoutEl.find('.swipeout-actions-left');
          actionsLeftWidth = null;
          actionsRightWidth = null;
          $leftButtons = null;
          $rightButtons = null;
          $overswipeRightButton = null;
          $overswipeLeftButton = null;
          if ($actionsLeft.length > 0) {
            actionsLeftWidth = $actionsLeft.outerWidth();
            $leftButtons = $actionsLeft.children('a');
            $overswipeLeftButton = $actionsLeft.find('.swipeout-overswipe');
          }
          if ($actionsRight.length > 0) {
            actionsRightWidth = $actionsRight.outerWidth();
            $rightButtons = $actionsRight.children('a');
            $overswipeRightButton = $actionsRight.find('.swipeout-overswipe');
          }
          opened = $swipeoutEl.hasClass('swipeout-opened');
          if (opened) {
            openedActionsSide = $swipeoutEl.find('.swipeout-actions-left.swipeout-actions-opened').length > 0 ? 'left' : 'right';
          }
          $swipeoutEl.removeClass('swipeout-transitioning');
          if (!app.params.swipeout.noFollow) {
            $swipeoutEl.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
            $swipeoutEl.removeClass('swipeout-opened');
          }
        }
        isMoved = true;
        e.preventDefault();

        touchesDiff = pageX - touchesStart.x;
        translate = touchesDiff;

        if (opened) {
          if (openedActionsSide === 'right') translate -= actionsRightWidth;
          else translate += actionsLeftWidth;
        }

        if (
          (translate > 0 && $actionsLeft.length === 0)
          || (translate < 0 && $actionsRight.length === 0)
        ) {
          if (!opened) {
            isTouched = false;
            isMoved = false;
            $swipeoutContent.transform('');
            if ($rightButtons && $rightButtons.length > 0) {
              $rightButtons.transform('');
            }
            if ($leftButtons && $leftButtons.length > 0) {
              $leftButtons.transform('');
            }
            return;
          }
          translate = 0;
        }

        if (translate < 0) direction = 'to-left';
        else if (translate > 0) direction = 'to-right';
        else if (!direction) direction = 'to-left';

        let buttonOffset;
        let progress;

        e.f7PreventSwipePanel = true;
        if (app.params.swipeout.noFollow) {
          if (opened) {
            if (openedActionsSide === 'right' && touchesDiff > 0) {
              app.swipeout.close($swipeoutEl);
            }
            if (openedActionsSide === 'left' && touchesDiff < 0) {
              app.swipeout.close($swipeoutEl);
            }
          } else {
            if (touchesDiff < 0 && $actionsRight.length > 0) {
              app.swipeout.open($swipeoutEl, 'right');
            }
            if (touchesDiff > 0 && $actionsLeft.length > 0) {
              app.swipeout.open($swipeoutEl, 'left');
            }
          }
          isTouched = false;
          isMoved = false;
          return;
        }
        overswipeLeft = false;
        overswipeRight = false;
        if ($actionsRight.length > 0) {
          // Show right actions
          let buttonTranslate = translate;
          progress = buttonTranslate / actionsRightWidth;
          if (buttonTranslate < -actionsRightWidth) {
            buttonTranslate = -actionsRightWidth - ((-buttonTranslate - actionsRightWidth) ** 0.8);
            translate = buttonTranslate;
            if ($overswipeRightButton.length > 0) {
              overswipeRight = true;
            }
          }
          if (direction !== 'to-left') {
            progress = 0;
            buttonTranslate = 0;
          }
          $rightButtons.each((index, buttonEl) => {
            const $buttonEl = $(buttonEl);
            if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
              $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
            }
            buttonOffset = buttonEl.f7SwipeoutButtonOffset;
            if ($overswipeRightButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-left') {
              $buttonEl.css({ left: `${overswipeRight ? -buttonOffset : 0}px` });
              if (overswipeRight) {
                if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
                  $swipeoutEl.trigger('swipeout:overswipeenter');
                  app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
                }
                $buttonEl.addClass('swipeout-overswipe-active');
              } else {
                if ($buttonEl.hasClass('swipeout-overswipe-active')) {
                  $swipeoutEl.trigger('swipeout:overswipeexit');
                  app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
                }
                $buttonEl.removeClass('swipeout-overswipe-active');
              }
            }
            $buttonEl.transform(`translate3d(${buttonTranslate - (buttonOffset * (1 + Math.max(progress, -1)))}px,0,0)`);
          });
        }
        if ($actionsLeft.length > 0) {
          // Show left actions
          let buttonTranslate = translate;
          progress = buttonTranslate / actionsLeftWidth;
          if (buttonTranslate > actionsLeftWidth) {
            buttonTranslate = actionsLeftWidth + ((buttonTranslate - actionsLeftWidth) ** 0.8);
            translate = buttonTranslate;
            if ($overswipeLeftButton.length > 0) {
              overswipeLeft = true;
            }
          }
          if (direction !== 'to-right') {
            buttonTranslate = 0;
            progress = 0;
          }
          $leftButtons.each((index, buttonEl) => {
            const $buttonEl = $(buttonEl);
            if (typeof buttonEl.f7SwipeoutButtonOffset === 'undefined') {
              $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
            }
            buttonOffset = buttonEl.f7SwipeoutButtonOffset;
            if ($overswipeLeftButton.length > 0 && $buttonEl.hasClass('swipeout-overswipe') && direction === 'to-right') {
              $buttonEl.css({ left: `${overswipeLeft ? buttonOffset : 0}px` });
              if (overswipeLeft) {
                if (!$buttonEl.hasClass('swipeout-overswipe-active')) {
                  $swipeoutEl.trigger('swipeout:overswipeenter');
                  app.emit('swipeoutOverswipeEnter', $swipeoutEl[0]);
                }
                $buttonEl.addClass('swipeout-overswipe-active');
              } else {
                if ($buttonEl.hasClass('swipeout-overswipe-active')) {
                  $swipeoutEl.trigger('swipeout:overswipeexit');
                  app.emit('swipeoutOverswipeExit', $swipeoutEl[0]);
                }
                $buttonEl.removeClass('swipeout-overswipe-active');
              }
            }
            if ($leftButtons.length > 1) {
              $buttonEl.css('z-index', $leftButtons.length - index);
            }
            $buttonEl.transform(`translate3d(${buttonTranslate + (buttonOffset * (1 - Math.min(progress, 1)))}px,0,0)`);
          });
        }
        $swipeoutEl.trigger('swipeout', progress);
        app.emit('swipeout', $swipeoutEl[0], progress);
        $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
      }
      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }

        isTouched = false;
        isMoved = false;
        const timeDiff = (new Date()).getTime() - touchStartTime;
        const $actions = direction === 'to-left' ? $actionsRight : $actionsLeft;
        const actionsWidth = direction === 'to-left' ? actionsRightWidth : actionsLeftWidth;
        let action;
        let $buttons;
        let i;

        if (
          (
            timeDiff < 300
            && (
              (touchesDiff < -10 && direction === 'to-left')
              || (touchesDiff > 10 && direction === 'to-right')
            )
          )
          || (
            timeDiff >= 300
            && (Math.abs(translate) > actionsWidth / 2)
          )
        ) {
          action = 'open';
        } else {
          action = 'close';
        }
        if (timeDiff < 300) {
          if (Math.abs(translate) === 0) action = 'close';
          if (Math.abs(translate) === actionsWidth) action = 'open';
        }

        if (action === 'open') {
          Swipeout.el = $swipeoutEl[0];
          $swipeoutEl.trigger('swipeout:open');
          app.emit('swipeoutOpen', $swipeoutEl[0]);
          $swipeoutEl.addClass('swipeout-opened swipeout-transitioning');
          const newTranslate = direction === 'to-left' ? -actionsWidth : actionsWidth;
          $swipeoutContent.transform(`translate3d(${newTranslate}px,0,0)`);
          $actions.addClass('swipeout-actions-opened');
          $buttons = direction === 'to-left' ? $rightButtons : $leftButtons;
          if ($buttons) {
            for (i = 0; i < $buttons.length; i += 1) {
              $($buttons[i]).transform(`translate3d(${newTranslate}px,0,0)`);
            }
          }
          if (overswipeRight) {
            $actionsRight.find('.swipeout-overswipe').trigger('click', 'f7Overswipe');
          }
          if (overswipeLeft) {
            $actionsLeft.find('.swipeout-overswipe').trigger('click', 'f7Overswipe');
          }
        } else {
          $swipeoutEl.trigger('swipeout:close');
          app.emit('swipeoutClose', $swipeoutEl[0]);
          Swipeout.el = undefined;
          $swipeoutEl.addClass('swipeout-transitioning').removeClass('swipeout-opened');
          $swipeoutContent.transform('');
          $actions.removeClass('swipeout-actions-opened');
        }

        let buttonOffset;
        if ($leftButtons && $leftButtons.length > 0 && $leftButtons !== $buttons) {
          $leftButtons.each((index, buttonEl) => {
            const $buttonEl = $(buttonEl);
            buttonOffset = buttonEl.f7SwipeoutButtonOffset;
            if (typeof buttonOffset === 'undefined') {
              $buttonEl[0].f7SwipeoutButtonOffset = actionsLeftWidth - buttonEl.offsetLeft - buttonEl.offsetWidth;
            }
            $buttonEl.transform(`translate3d(${buttonOffset}px,0,0)`);
          });
        }
        if ($rightButtons && $rightButtons.length > 0 && $rightButtons !== $buttons) {
          $rightButtons.each((index, buttonEl) => {
            const $buttonEl = $(buttonEl);
            buttonOffset = buttonEl.f7SwipeoutButtonOffset;
            if (typeof buttonOffset === 'undefined') {
              $buttonEl[0].f7SwipeoutButtonOffset = buttonEl.offsetLeft;
            }
            $buttonEl.transform(`translate3d(${-buttonOffset}px,0,0)`);
          });
        }
        $swipeoutContent.transitionEnd(() => {
          if ((opened && action === 'open') || (!opened && action === 'close')) return;
          $swipeoutEl.trigger(action === 'open' ? 'swipeout:opened' : 'swipeout:closed');
          app.emit(action === 'open' ? 'swipeoutOpened' : 'swipeoutClosed', $swipeoutEl[0]);
          $swipeoutEl.removeClass('swipeout-transitioning');
          if (opened && action === 'close') {
            if ($actionsRight.length > 0) {
              $rightButtons.transform('');
            }
            if ($actionsLeft.length > 0) {
              $leftButtons.transform('');
            }
          }
        });
      }

      const passiveListener = app.support.passiveListener ? { passive: true } : false;

      app.on('touchstart', (e) => {
        if (Swipeout.el) {
          const $targetEl = $(e.target);
          if (!(
            $(Swipeout.el).is($targetEl[0])
            || $targetEl.parents('.swipeout').is(Swipeout.el)
            || $targetEl.hasClass('modal-in')
            || ($targetEl.attr('class') || '').indexOf('-backdrop') > 0
            || $targetEl.hasClass('actions-modal')
            || $targetEl.parents('.actions-modal.modal-in, .dialog.modal-in').length > 0
          )) {
            app.swipeout.close(Swipeout.el);
          }
        }
      });
      $(doc).on(app.touchEvents.start, 'li.swipeout', handleTouchStart, passiveListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
    },
    allow: true,
    el: undefined,
    open(...args) {
      const app = this;
      let [el, side, callback] = args;
      if (typeof args[1] === 'function') {
        [el, callback, side] = args;
      }
      const $el = $(el).eq(0);

      if ($el.length === 0) return;
      if (!$el.hasClass('swipeout') || $el.hasClass('swipeout-opened')) return;
      if (!side) {
        if ($el.find('.swipeout-actions-right').length > 0) side = 'right';
        else side = 'left';
      }
      const $swipeoutActions = $el.find(`.swipeout-actions-${side}`);
      const $swipeoutContent = $el.find('.swipeout-content');
      if ($swipeoutActions.length === 0) return;
      $el.trigger('swipeout:open').addClass('swipeout-opened').removeClass('swipeout-transitioning');
      app.emit('swipeoutOpen', $el[0]);
      $swipeoutActions.addClass('swipeout-actions-opened');
      const $buttons = $swipeoutActions.children('a');
      const swipeoutActionsWidth = $swipeoutActions.outerWidth();
      const translate = side === 'right' ? -swipeoutActionsWidth : swipeoutActionsWidth;
      if ($buttons.length > 1) {
        $buttons.each((buttonIndex, buttonEl) => {
          const $buttonEl = $(buttonEl);
          if (side === 'right') {
            $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
          } else {
            $buttonEl.css('z-index', $buttons.length - buttonIndex).transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
          }
        });
      }
      $el.addClass('swipeout-transitioning');
      $swipeoutContent.transitionEnd(() => {
        $el.trigger('swipeout:opened');
        app.emit('swipeoutOpened', $el[0]);
        if (callback) callback.call($el[0]);
      });
      Utils.nextFrame(() => {
        $buttons.transform(`translate3d(${translate}px,0,0)`);
        $swipeoutContent.transform(`translate3d(${translate}px,0,0)`);
      });
      Swipeout.el = $el[0];
    },
    close(el, callback) {
      const app = this;
      const $el = $(el).eq(0);
      if ($el.length === 0) return;
      if (!$el.hasClass('swipeout-opened')) return;
      const side = $el.find('.swipeout-actions-opened').hasClass('swipeout-actions-right') ? 'right' : 'left';
      const $swipeoutActions = $el.find('.swipeout-actions-opened').removeClass('swipeout-actions-opened');
      const $buttons = $swipeoutActions.children('a');
      const swipeoutActionsWidth = $swipeoutActions.outerWidth();
      Swipeout.allow = false;
      $el.trigger('swipeout:close');
      app.emit('swipeoutClose', $el[0]);
      $el.removeClass('swipeout-opened').addClass('swipeout-transitioning');

      let closeTimeout;
      function onSwipeoutClose() {
        Swipeout.allow = true;
        if ($el.hasClass('swipeout-opened')) return;
        $el.removeClass('swipeout-transitioning');
        $buttons.transform('');
        $el.trigger('swipeout:closed');
        app.emit('swipeoutClosed', $el[0]);
        if (callback) callback.call($el[0]);
        if (closeTimeout) clearTimeout(closeTimeout);
      }
      $el.find('.swipeout-content').transform('').transitionEnd(onSwipeoutClose);
      closeTimeout = setTimeout(onSwipeoutClose, 500);

      $buttons.each((index, buttonEl) => {
        const $buttonEl = $(buttonEl);
        if (side === 'right') {
          $buttonEl.transform(`translate3d(${-buttonEl.offsetLeft}px,0,0)`);
        } else {
          $buttonEl.transform(`translate3d(${swipeoutActionsWidth - buttonEl.offsetWidth - buttonEl.offsetLeft}px,0,0)`);
        }
        $buttonEl.css({ left: '0px' }).removeClass('swipeout-overswipe-active');
      });
      if (Swipeout.el && Swipeout.el === $el[0]) Swipeout.el = undefined;
    },
    delete(el, callback) {
      const app = this;
      const $el = $(el).eq(0);
      if ($el.length === 0) return;
      Swipeout.el = undefined;
      $el.trigger('swipeout:delete');
      app.emit('swipeoutDelete', $el[0]);
      $el.css({ height: `${$el.outerHeight()}px` });
      $el.transitionEnd(() => {
        $el.trigger('swipeout:deleted');
        app.emit('swipeoutDeleted', $el[0]);
        if (callback) callback.call($el[0]);
        if ($el.parents('.virtual-list').length > 0) {
          const virtualList = $el.parents('.virtual-list')[0].f7VirtualList;
          const virtualIndex = $el[0].f7VirtualListIndex;
          if (virtualList && typeof virtualIndex !== 'undefined') virtualList.deleteItem(virtualIndex);
        } else if (app.params.swipeout.removeElements) {
          if (app.params.swipeout.removeElementsWithTimeout) {
            setTimeout(() => {
              $el.remove();
            }, app.params.swipeout.removeElementsTimeout);
          } else {
            $el.remove();
          }
        } else {
          $el.removeClass('swipeout-deleting swipeout-transitioning');
        }
      });
      // eslint-disable-next-line
      // $el[0]._clientLeft = $el[0].clientLeft;
      Utils.nextFrame(() => {
        $el
          .addClass('swipeout-deleting swipeout-transitioning')
          .css({ height: '0px' })
          .find('.swipeout-content')
          .transform('translate3d(-100%,0,0)');
      });
    },
  };
  var Swipeout$1 = {
    name: 'swipeout',
    params: {
      swipeout: {
        actionsNoFold: false,
        noFollow: false,
        removeElements: true,
        removeElementsWithTimeout: false,
        removeElementsTimeout: 0,
      },
    },
    create() {
      const app = this;
      Utils.extend(app, {
        swipeout: {
          init: Swipeout.init.bind(app),
          open: Swipeout.open.bind(app),
          close: Swipeout.close.bind(app),
          delete: Swipeout.delete.bind(app),
        },
      });
      Object.defineProperty(app.swipeout, 'el', {
        enumerable: true,
        configurable: true,
        get: () => Swipeout.el,
        set(el) {
          Swipeout.el = el;
        },
      });
      Object.defineProperty(app.swipeout, 'allow', {
        enumerable: true,
        configurable: true,
        get: () => Swipeout.allow,
        set(allow) {
          Swipeout.allow = allow;
        },
      });
    },
    clicks: {
      '.swipeout-open': function openSwipeout($clickedEl, data = {}) {
        const app = this;
        app.swipeout.open(data.swipeout, data.side);
      },
      '.swipeout-close': function closeSwipeout($clickedEl) {
        const app = this;
        const $swipeoutEl = $clickedEl.closest('.swipeout');
        if ($swipeoutEl.length === 0) return;
        app.swipeout.close($swipeoutEl);
      },
      '.swipeout-delete': function deleteSwipeout($clickedEl, data = {}) {
        const app = this;
        const $swipeoutEl = $clickedEl.closest('.swipeout');
        if ($swipeoutEl.length === 0) return;
        const { confirm, confirmTitle } = data;
        if (data.confirm) {
          app.dialog.confirm(confirm, confirmTitle, () => {
            app.swipeout.delete($swipeoutEl);
          });
        } else {
          app.swipeout.delete($swipeoutEl);
        }
      },
    },
    on: {
      init() {
        const app = this;
        if (!app.params.swipeout) return;
        app.swipeout.init();
      },
    },
  };

  const Accordion = {
    toggleClicked($clickedEl) {
      const app = this;
      let $accordionItemEl = $clickedEl.closest('.accordion-item').eq(0);
      if (!$accordionItemEl.length) $accordionItemEl = $clickedEl.parents('li').eq(0);

      const $accordionContent = $clickedEl.parents('.accordion-item-content').eq(0);
      if ($accordionContent.length) {
        if ($accordionContent.parents($accordionItemEl).length) return;
      }

      if ($clickedEl.parents('li').length > 1 && $clickedEl.parents('li')[0] !== $accordionItemEl[0]) return;
      app.accordion.toggle($accordionItemEl);
    },
    open(el) {
      const app = this;
      const $el = $(el);
      let prevented = false;
      function prevent() {
        prevented = true;
      }
      $el.trigger('accordion:beforeopen', { prevent }, prevent);
      app.emit('accordionBeforeOpen', $el[0], prevent);
      if (prevented) return;
      const $list = $el.parents('.accordion-list').eq(0);
      let $contentEl = $el.children('.accordion-item-content');
      $contentEl.removeAttr('aria-hidden');
      if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
      if ($contentEl.length === 0) return;
      const $openedItem = $list.length > 0 && $el.parent().children('.accordion-item-opened');
      if ($openedItem.length > 0) {
        app.accordion.close($openedItem);
      }
      $contentEl.transitionEnd(() => {
        if ($el.hasClass('accordion-item-opened')) {
          $contentEl.transition(0);
          $contentEl.css('height', 'auto');
          Utils.nextFrame(() => {
            $contentEl.transition('');
            $el.trigger('accordion:opened');
            app.emit('accordionOpened', $el[0]);
          });
        } else {
          $contentEl.css('height', '');
          $el.trigger('accordion:closed');
          app.emit('accordionClosed', $el[0]);
        }
      });
      $contentEl.css('height', `${$contentEl[0].scrollHeight}px`);
      $el.trigger('accordion:open');
      $el.addClass('accordion-item-opened');
      app.emit('accordionOpen', $el[0]);
    },
    close(el) {
      const app = this;
      const $el = $(el);
      let prevented = false;
      function prevent() {
        prevented = true;
      }
      $el.trigger('accordion:beforeclose', { prevent }, prevent);
      app.emit('accordionBeforeClose', $el[0], prevent);
      if (prevented) return;
      let $contentEl = $el.children('.accordion-item-content');
      if ($contentEl.length === 0) $contentEl = $el.find('.accordion-item-content');
      $el.removeClass('accordion-item-opened');
      $contentEl.attr('aria-hidden', true);
      $contentEl.transition(0);
      $contentEl.css('height', `${$contentEl[0].scrollHeight}px`);
      // Close
      $contentEl.transitionEnd(() => {
        if ($el.hasClass('accordion-item-opened')) {
          $contentEl.transition(0);
          $contentEl.css('height', 'auto');
          Utils.nextFrame(() => {
            $contentEl.transition('');
            $el.trigger('accordion:opened');
            app.emit('accordionOpened', $el[0]);
          });
        } else {
          $contentEl.css('height', '');
          $el.trigger('accordion:closed');
          app.emit('accordionClosed', $el[0]);
        }
      });
      Utils.nextFrame(() => {
        $contentEl.transition('');
        $contentEl.css('height', '');
        $el.trigger('accordion:close');
        app.emit('accordionClose', $el[0]);
      });
    },
    toggle(el) {
      const app = this;
      const $el = $(el);
      if ($el.length === 0) return;
      if ($el.hasClass('accordion-item-opened')) app.accordion.close(el);
      else app.accordion.open(el);
    },
  };

  var Accordion$1 = {
    name: 'accordion',
    create() {
      const app = this;
      Utils.extend(app, {
        accordion: {
          open: Accordion.open.bind(app),
          close: Accordion.close.bind(app),
          toggle: Accordion.toggle.bind(app),
        },
      });
    },
    clicks: {
      '.accordion-item .item-link, .accordion-item-toggle, .links-list.accordion-list > ul > li > a': function open($clickedEl) {
        const app = this;
        Accordion.toggleClicked.call(app, $clickedEl);
      },
    },
  };

  var ContactsList = {
    name: 'contactsList',
  };

  class VirtualList extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);
      const vl = this;

      let defaultHeight;
      if (app.theme === 'md') {
        defaultHeight = 48;
      } else if (app.theme === 'ios') {
        defaultHeight = 44;
      } else if (app.theme === 'aurora') {
        defaultHeight = 38;
      }

      const defaults = {
        cols: 1,
        height: defaultHeight,
        cache: true,
        dynamicHeightBufferSize: 1,
        showFilteredItemsOnly: false,
        renderExternal: undefined,
        setListHeight: true,
        searchByItem: undefined,
        searchAll: undefined,
        itemTemplate: undefined,
        ul: null,
        createUl: true,
        scrollableParentEl: undefined,
        renderItem(item) {
          return `
          <li>
            <div class="item-content">
              <div class="item-inner">
                <div class="item-title">${item}</div>
              </div>
            </div>
          </li>
        `.trim();
        },
        on: {},
      };

      // Extend defaults with modules params
      vl.useModulesParams(defaults);

      vl.params = Utils.extend(defaults, params);
      if (vl.params.height === undefined || !vl.params.height) {
        vl.params.height = defaultHeight;
      }

      vl.$el = $(params.el);
      vl.el = vl.$el[0];

      if (vl.$el.length === 0) return undefined;
      vl.$el[0].f7VirtualList = vl;

      vl.items = vl.params.items;
      if (vl.params.showFilteredItemsOnly) {
        vl.filteredItems = [];
      }
      if (vl.params.itemTemplate) {
        if (typeof vl.params.itemTemplate === 'string') vl.renderItem = app.t7.compile(vl.params.itemTemplate);
        else if (typeof vl.params.itemTemplate === 'function') vl.renderItem = vl.params.itemTemplate;
      } else if (vl.params.renderItem) {
        vl.renderItem = vl.params.renderItem;
      }
      vl.$pageContentEl = vl.$el.parents('.page-content');
      vl.pageContentEl = vl.$pageContentEl[0];

      vl.$scrollableParentEl = vl.params.scrollableParentEl ? $(vl.params.scrollableParentEl).eq(0) : vl.$pageContentEl;
      if (!vl.$scrollableParentEl.length && vl.$pageContentEl.length) {
        vl.$scrollableParentEl = vl.$pageContentEl;
      }
      vl.scrollableParentEl = vl.$scrollableParentEl[0];

      // Bad scroll
      if (typeof vl.params.updatableScroll !== 'undefined') {
        vl.updatableScroll = vl.params.updatableScroll;
      } else {
        vl.updatableScroll = true;
        if (Device.ios && Device.osVersion.split('.')[0] < 8) {
          vl.updatableScroll = false;
        }
      }

      // Append <ul>
      const ul = vl.params.ul;
      vl.$ul = ul ? $(vl.params.ul) : vl.$el.children('ul');
      if (vl.$ul.length === 0 && vl.params.createUl) {
        vl.$el.append('<ul></ul>');
        vl.$ul = vl.$el.children('ul');
      }
      vl.ul = vl.$ul[0];

      let $itemsWrapEl;
      if (!vl.ul && !vl.params.createUl) $itemsWrapEl = vl.$el;
      else $itemsWrapEl = vl.$ul;

      Utils.extend(vl, {
        $itemsWrapEl,
        itemsWrapEl: $itemsWrapEl[0],
        // DOM cached items
        domCache: {},
        displayDomCache: {},
        // Temporary DOM Element
        tempDomElement: doc.createElement('ul'),
        // Last repain position
        lastRepaintY: null,
        // Fragment
        fragment: doc.createDocumentFragment(),
        // Props
        pageHeight: undefined,
        rowsPerScreen: undefined,
        rowsBefore: undefined,
        rowsAfter: undefined,
        rowsToRender: undefined,
        maxBufferHeight: 0,
        listHeight: undefined,
        dynamicHeight: typeof vl.params.height === 'function',
      });

      // Install Modules
      vl.useModules();

      // Attach events
      const handleScrollBound = vl.handleScroll.bind(vl);
      const handleResizeBound = vl.handleResize.bind(vl);
      let $pageEl;
      let $tabEl;
      let $panelEl;
      let $popupEl;
      vl.attachEvents = function attachEvents() {
        $pageEl = vl.$el.parents('.page').eq(0);
        $tabEl = vl.$el.parents('.tab').eq(0);
        $panelEl = vl.$el.parents('.panel').eq(0);
        $popupEl = vl.$el.parents('.popup').eq(0);

        vl.$scrollableParentEl.on('scroll', handleScrollBound);
        if ($pageEl) $pageEl.on('page:reinit', handleResizeBound);
        if ($tabEl) $tabEl.on('tab:show', handleResizeBound);
        if ($panelEl) $panelEl.on('panel:open', handleResizeBound);
        if ($popupEl) $popupEl.on('popup:open', handleResizeBound);
        app.on('resize', handleResizeBound);
      };
      vl.detachEvents = function attachEvents() {
        vl.$scrollableParentEl.off('scroll', handleScrollBound);
        if ($pageEl) $pageEl.off('page:reinit', handleResizeBound);
        if ($tabEl) $tabEl.off('tab:show', handleResizeBound);
        if ($panelEl) $panelEl.off('panel:open', handleResizeBound);
        if ($popupEl) $popupEl.off('popup:open', handleResizeBound);
        app.off('resize', handleResizeBound);
      };
      // Init
      vl.init();

      return vl;
    }

    setListSize() {
      const vl = this;
      const items = vl.filteredItems || vl.items;
      vl.pageHeight = vl.$scrollableParentEl[0].offsetHeight;
      if (vl.dynamicHeight) {
        vl.listHeight = 0;
        vl.heights = [];
        for (let i = 0; i < items.length; i += 1) {
          const itemHeight = vl.params.height(items[i]);
          vl.listHeight += itemHeight;
          vl.heights.push(itemHeight);
        }
      } else {
        vl.listHeight = Math.ceil(items.length / vl.params.cols) * vl.params.height;
        vl.rowsPerScreen = Math.ceil(vl.pageHeight / vl.params.height);
        vl.rowsBefore = vl.params.rowsBefore || vl.rowsPerScreen * 2;
        vl.rowsAfter = vl.params.rowsAfter || vl.rowsPerScreen;
        vl.rowsToRender = (vl.rowsPerScreen + vl.rowsBefore + vl.rowsAfter);
        vl.maxBufferHeight = (vl.rowsBefore / 2) * vl.params.height;
      }

      if (vl.updatableScroll || vl.params.setListHeight) {
        vl.$itemsWrapEl.css({ height: `${vl.listHeight}px` });
      }
    }

    render(force, forceScrollTop) {
      const vl = this;
      if (force) vl.lastRepaintY = null;

      let scrollTop = -(vl.$el[0].getBoundingClientRect().top - vl.$scrollableParentEl[0].getBoundingClientRect().top);

      if (typeof forceScrollTop !== 'undefined') scrollTop = forceScrollTop;
      if (vl.lastRepaintY === null || Math.abs(scrollTop - vl.lastRepaintY) > vl.maxBufferHeight || (!vl.updatableScroll && (vl.$scrollableParentEl[0].scrollTop + vl.pageHeight >= vl.$scrollableParentEl[0].scrollHeight))) {
        vl.lastRepaintY = scrollTop;
      } else {
        return;
      }

      const items = vl.filteredItems || vl.items;
      let fromIndex;
      let toIndex;
      let heightBeforeFirstItem = 0;
      let heightBeforeLastItem = 0;
      if (vl.dynamicHeight) {
        let itemTop = 0;
        let itemHeight;
        vl.maxBufferHeight = vl.pageHeight;

        for (let j = 0; j < vl.heights.length; j += 1) {
          itemHeight = vl.heights[j];
          if (typeof fromIndex === 'undefined') {
            if (itemTop + itemHeight >= scrollTop - (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize)) fromIndex = j;
            else heightBeforeFirstItem += itemHeight;
          }

          if (typeof toIndex === 'undefined') {
            if (itemTop + itemHeight >= scrollTop + (vl.pageHeight * 2 * vl.params.dynamicHeightBufferSize) || j === vl.heights.length - 1) toIndex = j + 1;
            heightBeforeLastItem += itemHeight;
          }
          itemTop += itemHeight;
        }
        toIndex = Math.min(toIndex, items.length);
      } else {
        fromIndex = (parseInt(scrollTop / vl.params.height, 10) - vl.rowsBefore) * vl.params.cols;
        if (fromIndex < 0) {
          fromIndex = 0;
        }
        toIndex = Math.min(fromIndex + (vl.rowsToRender * vl.params.cols), items.length);
      }

      let topPosition;
      const renderExternalItems = [];
      vl.reachEnd = false;
      let i;
      for (i = fromIndex; i < toIndex; i += 1) {
        let itemEl;
        // Define real item index
        const index = vl.items.indexOf(items[i]);

        if (i === fromIndex) vl.currentFromIndex = index;
        if (i === toIndex - 1) vl.currentToIndex = index;
        if (vl.filteredItems) {
          if (vl.items[index] === vl.filteredItems[vl.filteredItems.length - 1]) vl.reachEnd = true;
        } else if (index === vl.items.length - 1) vl.reachEnd = true;

        // Find items
        if (vl.params.renderExternal) {
          renderExternalItems.push(items[i]);
        } else if (vl.domCache[index]) {
          itemEl = vl.domCache[index];
          itemEl.f7VirtualListIndex = index;
        } else {
          if (vl.renderItem) {
            vl.tempDomElement.innerHTML = vl.renderItem(items[i], index).trim();
          } else {
            vl.tempDomElement.innerHTML = items[i].toString().trim();
          }
          itemEl = vl.tempDomElement.childNodes[0];
          if (vl.params.cache) vl.domCache[index] = itemEl;
          itemEl.f7VirtualListIndex = index;
        }

        // Set item top position
        if (i === fromIndex) {
          if (vl.dynamicHeight) {
            topPosition = heightBeforeFirstItem;
          } else {
            topPosition = ((i * vl.params.height) / vl.params.cols);
          }
        }
        if (!vl.params.renderExternal) {
          itemEl.style.top = `${topPosition}px`;

          // Before item insert
          vl.emit('local::itemBeforeInsert vlItemBeforeInsert', vl, itemEl, items[i]);

          // Append item to fragment
          vl.fragment.appendChild(itemEl);
        }
      }

      // Update list height with not updatable scroll
      if (!vl.updatableScroll) {
        if (vl.dynamicHeight) {
          vl.itemsWrapEl.style.height = `${heightBeforeLastItem}px`;
        } else {
          vl.itemsWrapEl.style.height = `${(i * vl.params.height) / vl.params.cols}px`;
        }
      }

      // Update list html
      if (vl.params.renderExternal) {
        if (items && items.length === 0) {
          vl.reachEnd = true;
        }
      } else {
        vl.emit('local::beforeClear vlBeforeClear', vl, vl.fragment);
        vl.itemsWrapEl.innerHTML = '';

        vl.emit('local::itemsBeforeInsert vlItemsBeforeInsert', vl, vl.fragment);

        if (items && items.length === 0) {
          vl.reachEnd = true;
          if (vl.params.emptyTemplate) vl.itemsWrapEl.innerHTML = vl.params.emptyTemplate;
        } else {
          vl.itemsWrapEl.appendChild(vl.fragment);
        }

        vl.emit('local::itemsAfterInsert vlItemsAfterInsert', vl, vl.fragment);
      }

      if (typeof forceScrollTop !== 'undefined' && force) {
        vl.$scrollableParentEl.scrollTop(forceScrollTop, 0);
      }
      if (vl.params.renderExternal) {
        vl.params.renderExternal(vl, {
          fromIndex,
          toIndex,
          listHeight: vl.listHeight,
          topPosition,
          items: renderExternalItems,
        });
      }
    }

    // Filter
    filterItems(indexes, resetScrollTop = true) {
      const vl = this;
      vl.filteredItems = [];
      for (let i = 0; i < indexes.length; i += 1) {
        vl.filteredItems.push(vl.items[indexes[i]]);
      }
      if (resetScrollTop) {
        vl.$scrollableParentEl[0].scrollTop = 0;
      }
      vl.update();
    }

    resetFilter() {
      const vl = this;
      if (vl.params.showFilteredItemsOnly) {
        vl.filteredItems = [];
      } else {
        vl.filteredItems = null;
        delete vl.filteredItems;
      }
      vl.update();
    }

    scrollToItem(index) {
      const vl = this;
      if (index > vl.items.length) return false;
      let itemTop = 0;
      if (vl.dynamicHeight) {
        for (let i = 0; i < index; i += 1) {
          itemTop += vl.heights[i];
        }
      } else {
        itemTop = index * vl.params.height;
      }
      const listTop = vl.$el[0].offsetTop;
      vl.render(true, (listTop + itemTop) - parseInt(vl.$scrollableParentEl.css('padding-top'), 10));
      return true;
    }

    handleScroll() {
      const vl = this;
      vl.render();
    }

    // Handle resize event
    isVisible() {
      const vl = this;
      return !!(vl.el.offsetWidth || vl.el.offsetHeight || vl.el.getClientRects().length);
    }

    handleResize() {
      const vl = this;
      if (vl.isVisible()) {
        vl.setListSize();
        vl.render(true);
      }
    }

    // Append
    appendItems(items) {
      const vl = this;
      for (let i = 0; i < items.length; i += 1) {
        vl.items.push(items[i]);
      }
      vl.update();
    }

    appendItem(item) {
      const vl = this;
      vl.appendItems([item]);
    }

    // Replace
    replaceAllItems(items) {
      const vl = this;
      vl.items = items;
      delete vl.filteredItems;
      vl.domCache = {};
      vl.update();
    }

    replaceItem(index, item) {
      const vl = this;
      vl.items[index] = item;
      if (vl.params.cache) delete vl.domCache[index];
      vl.update();
    }

    // Prepend
    prependItems(items) {
      const vl = this;
      for (let i = items.length - 1; i >= 0; i -= 1) {
        vl.items.unshift(items[i]);
      }
      if (vl.params.cache) {
        const newCache = {};
        Object.keys(vl.domCache).forEach((cached) => {
          newCache[parseInt(cached, 10) + items.length] = vl.domCache[cached];
        });
        vl.domCache = newCache;
      }
      vl.update();
    }

    prependItem(item) {
      const vl = this;
      vl.prependItems([item]);
    }

    // Move
    moveItem(from, to) {
      const vl = this;
      const fromIndex = from;
      let toIndex = to;
      if (fromIndex === toIndex) return;
      // remove item from array
      const item = vl.items.splice(fromIndex, 1)[0];
      if (toIndex >= vl.items.length) {
        // Add item to the end
        vl.items.push(item);
        toIndex = vl.items.length - 1;
      } else {
      // Add item to new index
        vl.items.splice(toIndex, 0, item);
      }
      // Update cache
      if (vl.params.cache) {
        const newCache = {};
        Object.keys(vl.domCache).forEach((cached) => {
          const cachedIndex = parseInt(cached, 10);
          const leftIndex = fromIndex < toIndex ? fromIndex : toIndex;
          const rightIndex = fromIndex < toIndex ? toIndex : fromIndex;
          const indexShift = fromIndex < toIndex ? -1 : 1;
          if (cachedIndex < leftIndex || cachedIndex > rightIndex) newCache[cachedIndex] = vl.domCache[cachedIndex];
          if (cachedIndex === leftIndex) newCache[rightIndex] = vl.domCache[cachedIndex];
          if (cachedIndex > leftIndex && cachedIndex <= rightIndex) newCache[cachedIndex + indexShift] = vl.domCache[cachedIndex];
        });
        vl.domCache = newCache;
      }
      vl.update();
    }

    // Insert before
    insertItemBefore(index, item) {
      const vl = this;
      if (index === 0) {
        vl.prependItem(item);
        return;
      }
      if (index >= vl.items.length) {
        vl.appendItem(item);
        return;
      }
      vl.items.splice(index, 0, item);
      // Update cache
      if (vl.params.cache) {
        const newCache = {};
        Object.keys(vl.domCache).forEach((cached) => {
          const cachedIndex = parseInt(cached, 10);
          if (cachedIndex >= index) {
            newCache[cachedIndex + 1] = vl.domCache[cachedIndex];
          }
        });
        vl.domCache = newCache;
      }
      vl.update();
    }

    // Delete
    deleteItems(indexes) {
      const vl = this;
      let prevIndex;
      let indexShift = 0;
      for (let i = 0; i < indexes.length; i += 1) {
        let index = indexes[i];
        if (typeof prevIndex !== 'undefined') {
          if (index > prevIndex) {
            indexShift = -i;
          }
        }
        index += indexShift;
        prevIndex = indexes[i];
        // Delete item
        const deletedItem = vl.items.splice(index, 1)[0];

        // Delete from filtered
        if (vl.filteredItems && vl.filteredItems.indexOf(deletedItem) >= 0) {
          vl.filteredItems.splice(vl.filteredItems.indexOf(deletedItem), 1);
        }
        // Update cache
        if (vl.params.cache) {
          const newCache = {};
          Object.keys(vl.domCache).forEach((cached) => {
            const cachedIndex = parseInt(cached, 10);
            if (cachedIndex === index) {
              delete vl.domCache[index];
            } else if (parseInt(cached, 10) > index) {
              newCache[cachedIndex - 1] = vl.domCache[cached];
            } else {
              newCache[cachedIndex] = vl.domCache[cached];
            }
          });
          vl.domCache = newCache;
        }
      }
      vl.update();
    }

    deleteAllItems() {
      const vl = this;
      vl.items = [];
      delete vl.filteredItems;
      if (vl.params.cache) vl.domCache = {};
      vl.update();
    }

    deleteItem(index) {
      const vl = this;
      vl.deleteItems([index]);
    }

    // Clear cache
    clearCache() {
      const vl = this;
      vl.domCache = {};
    }

    // Update Virtual List
    update(deleteCache) {
      const vl = this;
      if (deleteCache && vl.params.cache) {
        vl.domCache = {};
      }
      vl.setListSize();
      vl.render(true);
    }

    init() {
      const vl = this;
      vl.attachEvents();
      vl.setListSize();
      vl.render();
    }

    destroy() {
      let vl = this;
      vl.detachEvents();
      vl.$el[0].f7VirtualList = null;
      delete vl.$el[0].f7VirtualList;
      Utils.deleteProps(vl);
      vl = null;
    }
  }

  var VirtualList$1 = {
    name: 'virtualList',
    static: {
      VirtualList,
    },
    create() {
      const app = this;
      app.virtualList = ConstructorMethods({
        defaultSelector: '.virtual-list',
        constructor: VirtualList,
        app,
        domProp: 'f7VirtualList',
      });
    },
  };

  class ListIndex extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);
      const index = this;

      const defaults = {
        el: null, // where to render indexes
        listEl: null, // list el to generate indexes
        indexes: 'auto', // or array of indexes
        iosItemHeight: 14,
        mdItemHeight: 14,
        auroraItemHeight: 14,
        scrollList: true,
        label: false,
        // eslint-disable-next-line
        renderItem(itemContent, itemIndex) {
          return `
          <li>${itemContent}</li>
        `.trim();
        },
        renderSkipPlaceholder() {
          return '<li class="list-index-skip-placeholder"></li>';
        },
        on: {},
      };

      // Extend defaults with modules params
      index.useModulesParams(defaults);

      index.params = Utils.extend(defaults, params);

      let $el;
      let $listEl;
      let $pageContentEl;
      let $ul;

      if (index.params.el) {
        $el = $(index.params.el);
      } else {
        return index;
      }

      if ($el[0].f7ListIndex) {
        return $el[0].f7ListIndex;
      }

      $ul = $el.find('ul');
      if ($ul.length === 0) {
        $ul = $('<ul></ul>');
        $el.append($ul);
      }

      if (index.params.listEl) {
        $listEl = $(index.params.listEl);
      }

      if (index.params.indexes === 'auto' && !$listEl) {
        return index;
      }

      if ($listEl) {
        $pageContentEl = $listEl.parents('.page-content').eq(0);
      } else {
        $pageContentEl = $el.siblings('.page-content').eq(0);
        if ($pageContentEl.length === 0) {
          $pageContentEl = $el.parents('.page').eq(0).find('.page-content').eq(0);
        }
      }

      $el[0].f7ListIndex = index;

      Utils.extend(index, {
        app,
        $el,
        el: $el && $el[0],
        $ul,
        ul: $ul && $ul[0],
        $listEl,
        listEl: $listEl && $listEl[0],
        $pageContentEl,
        pageContentEl: $pageContentEl && $pageContentEl[0],
        indexes: params.indexes,
        height: 0,
        skipRate: 0,
      });

      // Install Modules
      index.useModules();

      // Attach events
      function handleResize() {
        const height = { index };
        index.calcSize();
        if (height !== index.height) {
          index.render();
        }
      }

      function handleClick(e) {
        const $clickedLi = $(e.target).closest('li');
        if (!$clickedLi.length) return;

        let itemIndex = $clickedLi.index();
        if (index.skipRate > 0) {
          const percentage = itemIndex / ($clickedLi.siblings('li').length - 1);
          itemIndex = Math.round((index.indexes.length - 1) * percentage);
        }
        const itemContent = index.indexes[itemIndex];

        index.$el.trigger('listindex:click', { content: itemContent, index: itemIndex });
        index.emit('local::click listIndexClick', index, itemContent, itemIndex);
        index.$el.trigger('listindex:select', { content: itemContent, index: itemIndex });
        index.emit('local::select listIndexSelect', index, itemContent, itemIndex);

        if (index.$listEl && index.params.scrollList) {
          index.scrollListToIndex(itemContent, itemIndex);
        }
      }

      const touchesStart = {};
      let isTouched;
      let isMoved;
      let topPoint;
      let bottomPoint;
      let $labelEl;
      let previousIndex = null;
      function handleTouchStart(e) {
        const $children = $ul.children();
        if (!$children.length) return;
        topPoint = $children[0].getBoundingClientRect().top;
        bottomPoint = $children[$children.length - 1].getBoundingClientRect().top + $children[0].offsetHeight;

        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        isTouched = true;
        isMoved = false;
        previousIndex = null;
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        if (!isMoved && index.params.label) {
          $labelEl = $('<span class="list-index-label"></span>');
          $el.append($labelEl);
        }
        isMoved = true;
        const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        e.preventDefault();

        let percentage = (pageY - topPoint) / (bottomPoint - topPoint);
        percentage = Math.min(Math.max(percentage, 0), 1);

        const itemIndex = Math.round((index.indexes.length - 1) * percentage);
        const itemContent = index.indexes[itemIndex];


        const ulHeight = bottomPoint - topPoint;
        const bubbleBottom = ((index.height - ulHeight) / 2) + ((1 - percentage) * ulHeight);

        if (itemIndex !== previousIndex) {
          if (index.params.label) {
            $labelEl.html(itemContent).transform(`translateY(-${bubbleBottom}px)`);
          }

          if (index.$listEl && index.params.scrollList) {
            index.scrollListToIndex(itemContent, itemIndex);
          }
        }

        previousIndex = itemIndex;

        index.$el.trigger('listindex:select');
        index.emit('local::select listIndexSelect', index, itemContent, itemIndex);
      }
      function handleTouchEnd() {
        if (!isTouched) return;
        isTouched = false;
        isMoved = false;
        if (index.params.label) {
          if ($labelEl) $labelEl.remove();
          $labelEl = undefined;
        }
      }
      const passiveListener = app.support.passiveListener ? { passive: true } : false;
      index.attachEvents = function attachEvents() {
        $el.parents('.tab').on('tab:show', handleResize);
        $el.parents('.page').on('page:reinit', handleResize);
        $el.parents('.panel').on('panel:open', handleResize);
        $el
          .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
          .on('modal:open', handleResize);
        app.on('resize', handleResize);

        $el.on('click', handleClick);
        $el.on(app.touchEvents.start, handleTouchStart, passiveListener);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      };
      index.detachEvents = function attachEvents() {
        $el.parents('.tab').off('tab:show', handleResize);
        $el.parents('.page').off('page:reinit', handleResize);
        $el.parents('.panel').off('panel:open', handleResize);
        $el
          .parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast')
          .off('modal:open', handleResize);
        app.off('resize', handleResize);

        $el.off('click', handleClick);
        $el.off(app.touchEvents.start, handleTouchStart, passiveListener);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      };
      // Init
      index.init();

      return index;
    }
    // eslint-disable-next-line
    scrollListToIndex(itemContent, itemIndex) {
      const index = this;
      const { $listEl, $pageContentEl, app } = index;
      if (!$listEl || !$pageContentEl || $pageContentEl.length === 0) return index;

      let $scrollToEl;
      $listEl.find('.list-group-title, .item-divider').each((elIndex, el) => {
        if ($scrollToEl) return;
        const $el = $(el);
        if ($el.text() === itemContent) {
          $scrollToEl = $el;
        }
      });
      if (!$scrollToEl || $scrollToEl.length === 0) return index;

      const parentTop = $scrollToEl.parent().offset().top;
      let paddingTop = parseInt($pageContentEl.css('padding-top'), 10);
      const scrollTop = $pageContentEl[0].scrollTop;
      const scrollToElTop = $scrollToEl.offset().top;
      if ($pageContentEl.parents('.page-with-navbar-large').length) {
        const navbarInnerEl = app.navbar.getElByPage($pageContentEl.parents('.page-with-navbar-large').eq(0));
        const $titleLargeEl = $(navbarInnerEl).find('.title-large');
        if ($titleLargeEl.length) {
          paddingTop -= $titleLargeEl[0].offsetHeight || 0;
        }
      }

      if (parentTop <= paddingTop) {
        $pageContentEl.scrollTop((parentTop + scrollTop) - paddingTop);
      } else {
        $pageContentEl.scrollTop((scrollToElTop + scrollTop) - paddingTop);
      }
      return index;
    }

    renderSkipPlaceholder() {
      const index = this;
      return index.params.renderSkipPlaceholder.call(index);
    }

    renderItem(itemContent, itemIndex) {
      const index = this;
      return index.params.renderItem.call(index, itemContent, itemIndex);
    }

    render() {
      const index = this;
      const { $ul, indexes, skipRate } = index;
      let wasSkipped;

      const html = indexes.map((itemContent, itemIndex) => {
        if (itemIndex % skipRate !== 0 && skipRate > 0) {
          wasSkipped = true;
          return '';
        }
        let itemHtml = index.renderItem(itemContent, itemIndex);
        if (wasSkipped) {
          itemHtml = index.renderSkipPlaceholder() + itemHtml;
        }
        wasSkipped = false;
        return itemHtml;
      }).join('');

      $ul.html(html);

      return index;
    }

    calcSize() {
      const index = this;
      const { app, params, el, indexes } = index;
      const height = el.offsetHeight;
      const itemHeight = params[`${app.theme}ItemHeight`];
      const maxItems = Math.floor(height / itemHeight);
      const items = indexes.length;
      let skipRate = 0;
      if (items > maxItems) {
        skipRate = Math.ceil(((items * 2) - 1) / maxItems);
      }

      index.height = height;
      index.skipRate = skipRate;

      return index;
    }

    calcIndexes() {
      const index = this;
      if (index.params.indexes === 'auto') {
        index.indexes = [];

        index.$listEl.find('.list-group-title, .item-divider').each((elIndex, el) => {
          const elContent = $(el).text();
          if (index.indexes.indexOf(elContent) < 0) {
            index.indexes.push(elContent);
          }
        });
      } else {
        index.indexes = index.params.indexes;
      }
      return index;
    }

    update() {
      const index = this;
      index.calcIndexes();
      index.calcSize();
      index.render();

      return index;
    }

    init() {
      const index = this;
      index.calcIndexes();
      index.calcSize();
      index.render();
      index.attachEvents();
    }

    destroy() {
      let index = this;
      index.$el.trigger('listindex:beforedestroy', index);
      index.emit('local::beforeDestroy listIndexBeforeDestroy');
      index.detachEvents();
      if (index.$el[0]) {
        index.$el[0].f7ListIndex = null;
        delete index.$el[0].f7ListIndex;
      }
      Utils.deleteProps(index);
      index = null;
    }
  }

  var ListIndex$1 = {
    name: 'listIndex',
    static: {
      ListIndex,
    },
    create() {
      const app = this;
      app.listIndex = ConstructorMethods({
        defaultSelector: '.list-index',
        constructor: ListIndex,
        app,
        domProp: 'f7ListIndex',
      });
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.list-index-init').each((index, listIndexEl) => {
          const params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
          app.listIndex.create(params);
        });
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.list-index-init').each((index, listIndexEl) => {
          if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.list-index-init').each((index, listIndexEl) => {
          const params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
          app.listIndex.create(params);
        });
      },
      pageBeforeRemove(page) {
        page.$el.find('.list-index-init').each((index, listIndexEl) => {
          if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
        });
      },
    },
    vnode: {
      'list-index-init': {
        insert(vnode) {
          const app = this;
          const listIndexEl = vnode.elm;
          const params = Utils.extend($(listIndexEl).dataset(), { el: listIndexEl });
          app.listIndex.create(params);
        },
        destroy(vnode) {
          const listIndexEl = vnode.elm;
          if (listIndexEl.f7ListIndex) listIndexEl.f7ListIndex.destroy();
        },
      },
    },
  };

  var Timeline = {
    name: 'timeline',
  };

  const Tab = {
    show(...args) {
      const app = this;

      let tabEl;
      let tabLinkEl;
      let animate;
      let tabRoute;
      if (args.length === 1 && args[0].constructor === Object) {
        tabEl = args[0].tabEl;
        tabLinkEl = args[0].tabLinkEl;
        animate = args[0].animate;
        tabRoute = args[0].tabRoute;
      } else {
        [tabEl, tabLinkEl, animate, tabRoute] = args;
        if (typeof args[1] === 'boolean') {
          [tabEl, animate, tabLinkEl, tabRoute] = args;
          if (args.length > 2 && tabLinkEl.constructor === Object) {
            [tabEl, animate, tabRoute, tabLinkEl] = args;
          }
        }
      }
      if (typeof animate === 'undefined') animate = true;

      const $newTabEl = $(tabEl);
      if (tabRoute && $newTabEl[0]) {
        $newTabEl[0].f7TabRoute = tabRoute;
      }

      if ($newTabEl.length === 0 || $newTabEl.hasClass('tab-active')) {
        return {
          $newTabEl,
          newTabEl: $newTabEl[0],
        };
      }

      let $tabLinkEl;
      if (tabLinkEl) $tabLinkEl = $(tabLinkEl);

      const $tabsEl = $newTabEl.parent('.tabs');
      if ($tabsEl.length === 0) {
        return {
          $newTabEl,
          newTabEl: $newTabEl[0],
        };
      }

      // Release swipeouts in hidden tabs
      if (app.swipeout) app.swipeout.allowOpen = true;

      // Animated tabs
      const tabsChangedCallbacks = [];

      function onTabsChanged(callback) {
        tabsChangedCallbacks.push(callback);
      }
      function tabsChanged() {
        tabsChangedCallbacks.forEach((callback) => {
          callback();
        });
      }

      let animated = false;

      if ($tabsEl.parent().hasClass('tabs-animated-wrap')) {
        $tabsEl.parent()[animate ? 'removeClass' : 'addClass']('not-animated');

        const transitionDuration = parseFloat($tabsEl.css('transition-duration').replace(',', '.'));
        if (animate && transitionDuration) {
          $tabsEl.transitionEnd(tabsChanged);
          animated = true;
        }

        const tabsTranslate = (app.rtl ? $newTabEl.index() : -$newTabEl.index()) * 100;
        $tabsEl.transform(`translate3d(${tabsTranslate}%,0,0)`);
      }

      // Swipeable tabs
      let swiper;
      if ($tabsEl.parent().hasClass('tabs-swipeable-wrap') && app.swiper) {
        swiper = $tabsEl.parent()[0].swiper;
        if (swiper && swiper.activeIndex !== $newTabEl.index()) {
          animated = true;
          swiper
            .once('slideChangeTransitionEnd', () => {
              tabsChanged();
            })
            .slideTo($newTabEl.index(), animate ? undefined : 0);
        } else if (swiper && swiper.animating) {
          animated = true;
          swiper
            .once('slideChangeTransitionEnd', () => {
              tabsChanged();
            });
        }
      }

      // Remove active class from old tabs
      const $oldTabEl = $tabsEl.children('.tab-active');
      $oldTabEl.removeClass('tab-active');
      if (!swiper || (swiper && !swiper.animating) || (swiper && tabRoute)) {
        if ($oldTabEl.hasClass('view') && $oldTabEl.children('.page').length) {
          $oldTabEl.children('.page').each((pageIndex, pageEl) => {
            $(pageEl).trigger('page:tabhide');
            app.emit('pageTabHide', pageEl);
          });
        }
        $oldTabEl.trigger('tab:hide');
        app.emit('tabHide', $oldTabEl[0]);
      }

      // Trigger 'show' event on new tab
      $newTabEl.addClass('tab-active');
      if (!swiper || (swiper && !swiper.animating) || (swiper && tabRoute)) {
        if ($newTabEl.hasClass('view') && $newTabEl.children('.page').length) {
          $newTabEl.children('.page').each((pageIndex, pageEl) => {
            $(pageEl).trigger('page:tabshow');
            app.emit('pageTabShow', pageEl);
          });
        }
        $newTabEl.trigger('tab:show');
        app.emit('tabShow', $newTabEl[0]);
      }

      // Find related link for new tab
      if (!$tabLinkEl) {
        // Search by id
        if (typeof tabEl === 'string') $tabLinkEl = $(`.tab-link[href="${tabEl}"]`);
        else $tabLinkEl = $(`.tab-link[href="#${$newTabEl.attr('id')}"]`);
        // Search by data-tab
        if (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0)) {
          $('[data-tab]').each((index, el) => {
            if ($newTabEl.is($(el).attr('data-tab'))) $tabLinkEl = $(el);
          });
        }
        if (tabRoute && (!$tabLinkEl || ($tabLinkEl && $tabLinkEl.length === 0))) {
          $tabLinkEl = $(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
          if ($tabLinkEl.length === 0) {
            $tabLinkEl = $(`.tab-link[href="${tabRoute.url}"]`);
          }
        }
        if ($tabLinkEl.length > 1 && $newTabEl.parents('.page').length) {
          // eslint-disable-next-line
          $tabLinkEl = $tabLinkEl.filter((index, tabLinkElement) => {
            return $(tabLinkElement).parents('.page')[0] === $newTabEl.parents('.page')[0];
          });
          if (app.theme === 'ios' && $tabLinkEl.length === 0 && tabRoute) {
            const $pageEl = $newTabEl.parents('.page');
            const $navbarEl = $(app.navbar.getElByPage($pageEl));
            $tabLinkEl = $navbarEl.find(`[data-route-tab-id="${tabRoute.route.tab.id}"]`);
            if ($tabLinkEl.length === 0) {
              $tabLinkEl = $navbarEl.find(`.tab-link[href="${tabRoute.url}"]`);
            }
          }
        }
      }
      if ($tabLinkEl.length > 0) {
        // Find related link for old tab
        let $oldTabLinkEl;
        if ($oldTabEl && $oldTabEl.length > 0) {
          // Search by id
          const oldTabId = $oldTabEl.attr('id');
          if (oldTabId) {
            $oldTabLinkEl = $(`.tab-link[href="#${oldTabId}"]`);
            // Search by data-route-tab-id
            if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
              $oldTabLinkEl = $(`.tab-link[data-route-tab-id="${oldTabId}"]`);
            }
          }
          // Search by data-tab
          if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
            $('[data-tab]').each((index, tabLinkElement) => {
              if ($oldTabEl.is($(tabLinkElement).attr('data-tab'))) $oldTabLinkEl = $(tabLinkElement);
            });
          }
          if (!$oldTabLinkEl || ($oldTabLinkEl && $oldTabLinkEl.length === 0)) {
            $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
          }
        } else if (tabRoute) {
          $oldTabLinkEl = $tabLinkEl.siblings('.tab-link-active');
        }

        if ($oldTabLinkEl && $oldTabLinkEl.length > 1 && $oldTabEl && $oldTabEl.parents('.page').length) {
          // eslint-disable-next-line
          $oldTabLinkEl = $oldTabLinkEl.filter((index, tabLinkElement) => {
            return $(tabLinkElement).parents('.page')[0] === $oldTabEl.parents('.page')[0];
          });
        }

        if ($oldTabLinkEl && $oldTabLinkEl.length > 0) $oldTabLinkEl.removeClass('tab-link-active');

        // Update links' classes
        if ($tabLinkEl && $tabLinkEl.length > 0) {
          $tabLinkEl.addClass('tab-link-active');
          // Material Highlight
          if (app.theme === 'md' && app.toolbar) {
            const $tabbarEl = $tabLinkEl.parents('.tabbar, .tabbar-labels');
            if ($tabbarEl.length > 0) {
              app.toolbar.setHighlight($tabbarEl);
            }
          }
        }
      }
      return {
        $newTabEl,
        newTabEl: $newTabEl[0],
        $oldTabEl,
        oldTabEl: $oldTabEl[0],
        onTabsChanged,
        animated,
      };
    },
  };
  var Tabs = {
    name: 'tabs',
    create() {
      const app = this;
      Utils.extend(app, {
        tab: {
          show: Tab.show.bind(app),
        },
      });
    },
    clicks: {
      '.tab-link': function tabLinkClick($clickedEl, data = {}) {
        const app = this;
        if (($clickedEl.attr('href') && $clickedEl.attr('href').indexOf('#') === 0) || $clickedEl.attr('data-tab')) {
          app.tab.show({
            tabEl: data.tab || $clickedEl.attr('href'),
            tabLinkEl: $clickedEl,
            animate: data.animate,
          });
        }
      },
    },
  };

  function swipePanel(panel) {
    const app = panel.app;
    if (panel.swipeInitialized) {
      return;
    }
    Utils.extend(panel, {
      swipeable: true,
      swipeInitialized: true,
    });
    const params = panel.params;
    const { $el, $backdropEl, side, effect } = panel;
    let otherPanel;

    let isTouched;
    let isGestureStarted;
    let isMoved;
    let isScrolling;
    let isInterrupted;
    const touchesStart = {};
    let touchStartTime;
    let touchesDiff;
    let translate;
    let backdropOpacity;
    let panelWidth;
    let direction;

    let $viewEl;

    let touchMoves = 0;
    function handleTouchStart(e) {
      if (!panel.swipeable || isGestureStarted) return;
      if (!app.panel.allowOpen || (!params.swipe && !params.swipeOnlyClose) || isTouched) return;
      if ($('.modal-in:not(.toast):not(.notification), .photo-browser-in').length > 0) return;
      otherPanel = app.panel.get(side === 'left' ? 'right' : 'left') || {};
      const otherPanelOpened = otherPanel.opened && otherPanel.$el && !otherPanel.$el.hasClass('panel-in-breakpoint');
      if (!panel.opened && otherPanelOpened) {
        return;
      }
      if (!params.swipeOnlyClose) {
        if (otherPanelOpened) return;
      }
      if (e.target && e.target.nodeName.toLowerCase() === 'input' && e.target.type === 'range') return;
      if ($(e.target).closest('.range-slider, .tabs-swipeable-wrap, .calendar-months, .no-swipe-panel, .card-opened').length > 0) return;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      if (params.swipeOnlyClose && !panel.opened) {
        return;
      }
      if (params.swipeActiveArea && !panel.opened) {
        if (side === 'left') {
          if (touchesStart.x > params.swipeActiveArea) return;
        }
        if (side === 'right') {
          if (touchesStart.x < app.width - params.swipeActiveArea) return;
        }
      }
      touchMoves = 0;
      $viewEl = $(panel.getViewEl());
      isMoved = false;
      isTouched = true;
      isScrolling = undefined;
      isInterrupted = false;

      touchStartTime = Utils.now();
      direction = undefined;
    }
    function handleTouchMove(e) {
      if (!isTouched || isGestureStarted || isInterrupted) return;
      touchMoves += 1;
      if (touchMoves < 2) return;
      if (e.f7PreventSwipePanel || app.preventSwipePanelBySwipeBack || app.preventSwipePanel) {
        isTouched = false;
        return;
      }
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (typeof isScrolling === 'undefined') {
        isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
      }
      if (isScrolling) {
        isTouched = false;
        return;
      }
      if (!direction) {
        if (pageX > touchesStart.x) {
          direction = 'to-right';
        } else {
          direction = 'to-left';
        }

        if (params.swipeActiveArea > 0 && !panel.opened) {
          if (side === 'left' && touchesStart.x > params.swipeActiveArea) {
            isTouched = false;
            return;
          }
          if (side === 'right' && touchesStart.x < app.width - params.swipeActiveArea) {
            isTouched = false;
            return;
          }
        }
        if ($el.hasClass('panel-in-breakpoint')) {
          isTouched = false;
          return;
        }

        if (
          (side === 'left'
            && (
              direction === 'to-left' && !$el.hasClass('panel-in')
            )
          )
          || (side === 'right'
            && (
              direction === 'to-right' && !$el.hasClass('panel-in')
            )
          )
        ) {
          isTouched = false;
          return;
        }
      }

      let threshold = panel.opened ? 0 : -params.swipeThreshold;
      if (side === 'right') threshold = -threshold;

      if (!isMoved) {
        if (!panel.opened) {
          panel.insertToRoot();
          $el.addClass('panel-in-swipe');
          $backdropEl.css('visibility', 'visible');
          $el.trigger('panel:swipeopen');
          panel.emit('local::swipeOpen panelSwipeOpen', panel);
        }
        panelWidth = $el[0].offsetWidth;
        if (effect === 'reveal' && $el.hasClass('panel-in-collapsed')) {
          panelWidth -= parseFloat($viewEl.css(`margin-${side}`));
        }
        $el.transition(0);
      }

      isMoved = true;

      e.preventDefault();

      touchesDiff = (pageX - touchesStart.x) + threshold;

      if (side === 'right') {
        if (effect === 'cover') {
          translate = touchesDiff + (panel.opened ? 0 : panelWidth);
          if (translate < 0) translate = 0;
          if (translate > panelWidth) {
            translate = panelWidth;
          }
        } else {
          translate = touchesDiff - (panel.opened ? panelWidth : 0);
          if (translate > 0) translate = 0;
          if (translate < -panelWidth) {
            translate = -panelWidth;
          }
        }
      } else {
        translate = touchesDiff + (panel.opened ? panelWidth : 0);
        if (translate < 0) translate = 0;
        if (translate > panelWidth) {
          translate = panelWidth;
        }
      }
      const noFollowProgress = Math.abs(translate / panelWidth);
      if (effect === 'reveal') {
        if (!params.swipeNoFollow) {
          $viewEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
          $backdropEl.transform(`translate3d(${translate}px,0,0)`).transition(0);
        }

        $el.trigger('panel:swipe', Math.abs(translate / panelWidth));
        panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
      } else {
        if (side === 'left') translate -= panelWidth;
        if (!params.swipeNoFollow) {
          $el.transform(`translate3d(${translate}px,0,0)`).transition(0);

          $backdropEl.transition(0);
          backdropOpacity = 1 - Math.abs(translate / panelWidth);
          $backdropEl.css({ opacity: backdropOpacity });
        }

        $el.trigger('panel:swipe', Math.abs(translate / panelWidth));
        panel.emit('local::swipe panelSwipe', panel, Math.abs(translate / panelWidth));
      }

      if (params.swipeNoFollow) {
        const stateChanged = (panel.opened && noFollowProgress === 0) || (!panel.opened && noFollowProgress === 1);
        if (stateChanged) {
          isInterrupted = true;
          // eslint-disable-next-line
          handleTouchEnd(e);
        }
      }
    }
    function handleTouchEnd(e) {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      const isGesture = e.type === 'gesturestart' || isGestureStarted;
      isTouched = false;
      isMoved = false;
      const timeDiff = (new Date()).getTime() - touchStartTime;
      let action;
      const edge = (translate === 0 || Math.abs(translate) === panelWidth) && !params.swipeNoFollow;

      const threshold = params.swipeThreshold || 0;

      if (isGesture) {
        action = 'reset';
      } else if (!panel.opened) {
        if (Math.abs(touchesDiff) < threshold) {
          action = 'reset';
        } else if (effect === 'cover') {
          if (translate === 0) {
            action = 'swap'; // open
          } else if (timeDiff < 300 && Math.abs(translate) > 0) {
            action = 'swap'; // open
          } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
            action = 'swap'; // open
          } else {
            action = 'reset'; // close
          }
        } else if (translate === 0) {
          action = 'reset';
        } else if (
          (timeDiff < 300 && Math.abs(translate) > 0)
          || (timeDiff >= 300 && (Math.abs(translate) >= panelWidth / 2))
        ) {
          action = 'swap';
        } else {
          action = 'reset';
        }
      } else if (effect === 'cover') {
        if (translate === 0) {
          action = 'reset'; // open
        } else if (timeDiff < 300 && Math.abs(translate) > 0) {
          action = 'swap'; // open
        } else if (timeDiff >= 300 && Math.abs(translate) < panelWidth / 2) {
          action = 'reset'; // open
        } else {
          action = 'swap'; // close
        }
      } else if (translate === -panelWidth) {
        action = 'reset';
      } else if (
        (timeDiff < 300 && Math.abs(translate) >= 0)
        || (timeDiff >= 300 && (Math.abs(translate) <= panelWidth / 2))
      ) {
        if (side === 'left' && translate === panelWidth) action = 'reset';
        else action = 'swap';
      } else {
        action = 'reset';
      }
      if (action === 'swap') {
        if (panel.opened) {
          panel.close(!edge);
        } else {
          panel.open(!edge);
        }
      }
      let removePanelInClass = true;
      if (action === 'reset') {
        if (!panel.opened) {
          if (edge) {
            // edge position
            $el.removeClass('panel-in-swipe');
          } else {
            removePanelInClass = false;
            const target = effect === 'reveal' ? $viewEl : $el;
            $('html').addClass('with-panel-closing');
            target.transitionEnd(() => {
              if ($el.hasClass('panel-in')) return;
              $el.removeClass('panel-in-swipe');
              $('html').removeClass('with-panel-closing');
            });
          }
        }
      }
      if (effect === 'reveal') {
        Utils.nextFrame(() => {
          $viewEl.transition('');
          $viewEl.transform('');
        });
      }
      if (removePanelInClass) {
        $el.removeClass('panel-in-swipe');
      }
      $el.transition('').transform('');
      $backdropEl.transform('').transition('').css({ opacity: '', visibility: '' });
    }
    function handleGestureStart(e) {
      isGestureStarted = true;
      handleTouchEnd(e);
    }
    function handleGestureEnd() {
      isGestureStarted = false;
    }

    // Add Events
    app.on('touchstart:passive', handleTouchStart);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('gesturestart', handleGestureStart);
    app.on('gestureend', handleGestureEnd);
    panel.on('panelDestroy', () => {
      app.off('touchstart:passive', handleTouchStart);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('gesturestart', handleGestureStart);
      app.off('gestureend', handleGestureEnd);
    });
  }

  function resizablePanel(panel) {
    const app = panel.app;
    if (panel.resizableInitialized) return;
    Utils.extend(panel, {
      resizable: true,
      resizableWidth: null,
      resizableInitialized: true,
    });
    const $htmlEl = $('html');
    const { $el, $backdropEl, side, effect } = panel;
    if (!$el) return;

    let isTouched;
    let isMoved;
    const touchesStart = {};
    let touchesDiff;
    let panelWidth;

    let $viewEl;

    let panelMinWidth;
    let panelMaxWidth;
    let visibleByBreakpoint;

    function transformCSSWidth(v) {
      if (!v) return null;
      if (v.indexOf('%') >= 0 || v.indexOf('vw') >= 0) {
        return parseInt(v, 10) / 100 * app.width;
      }
      const newV = parseInt(v, 10);
      if (Number.isNaN(newV)) return null;
      return newV;
    }

    function isResizable() {
      return panel.resizable && $el.hasClass('panel-resizable');
    }

    function handleTouchStart(e) {
      if (!isResizable()) return;
      touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      isMoved = false;
      isTouched = true;
      panelMinWidth = transformCSSWidth($el.css('min-width'));
      panelMaxWidth = transformCSSWidth($el.css('max-width'));
      visibleByBreakpoint = $el.hasClass('panel-in-breakpoint');
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;

      if (!isMoved) {
        panelWidth = $el[0].offsetWidth;
        $el.transition(0);
        $el.addClass('panel-resizing');
        $htmlEl.css('cursor', 'col-resize');
        if (effect === 'reveal' || visibleByBreakpoint) {
          $viewEl = $(panel.getViewEl());
        }
        if (effect === 'reveal' && !visibleByBreakpoint) {
          $backdropEl.transition(0);
          $viewEl.transition(0);
        }
      }

      isMoved = true;

      e.preventDefault();

      touchesDiff = (pageX - touchesStart.x);

      let newPanelWidth = side === 'left' ? panelWidth + touchesDiff : panelWidth - touchesDiff;
      if (panelMinWidth && !Number.isNaN(panelMinWidth)) {
        newPanelWidth = Math.max(newPanelWidth, panelMinWidth);
      }
      if (panelMaxWidth && !Number.isNaN(panelMaxWidth)) {
        newPanelWidth = Math.min(newPanelWidth, panelMaxWidth);
      }
      newPanelWidth = Math.min(Math.max(newPanelWidth, 0), app.width);

      panel.resizableWidth = newPanelWidth;
      $el[0].style.width = `${newPanelWidth}px`;
      if (effect === 'reveal' && !visibleByBreakpoint) {
        if ($viewEl) {
          $viewEl.transform(`translate3d(${side === 'left' ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
        }
        if ($backdropEl) {
          $backdropEl.transform(`translate3d(${side === 'left' ? newPanelWidth : -newPanelWidth}px, 0, 0)`);
        }
      } else if (visibleByBreakpoint && $viewEl) {
        $viewEl.css(`margin-${side}`, `${newPanelWidth}px`);
      }

      $el.trigger('panel:resize', newPanelWidth);
      panel.emit('local::resize panelResize', panel, newPanelWidth);
    }
    function handleTouchEnd() {
      $('html').css('cursor', '');
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;

      $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
      $el[0].style.width = '';
      if (effect === 'reveal' && !visibleByBreakpoint) {
        $viewEl.transform('');
        $backdropEl.transform('');
      }
      $el.removeClass('panel-resizing');
      Utils.nextFrame(() => {
        if (visibleByBreakpoint) return;
        $el.transition('');
        if (effect === 'reveal') {
          $backdropEl.transition('');
          if ($viewEl) $viewEl.transition('');
        }
      });
    }

    function handleResize() {
      if (!panel.opened || !panel.resizableWidth) return;
      panelMinWidth = transformCSSWidth($el.css('min-width'));
      panelMaxWidth = transformCSSWidth($el.css('max-width'));

      if (panelMinWidth && !Number.isNaN(panelMinWidth) && panel.resizableWidth < panelMinWidth) {
        panel.resizableWidth = Math.max(panel.resizableWidth, panelMinWidth);
      }
      if (panelMaxWidth && !Number.isNaN(panelMaxWidth) && panel.resizableWidth > panelMaxWidth) {
        panel.resizableWidth = Math.min(panel.resizableWidth, panelMaxWidth);
      }
      panel.resizableWidth = Math.min(Math.max(panel.resizableWidth, 0), app.width);

      $htmlEl[0].style.setProperty(`--f7-panel-${side}-width`, `${panel.resizableWidth}px`);
    }

    if (panel.$el.find('.panel-resize-handler').length === 0) {
      panel.$el.append('<div class="panel-resize-handler"></div>');
    }
    panel.$resizeHandlerEl = panel.$el.children('.panel-resize-handler');

    $el.addClass('panel-resizable');

    // Add Events
    const passive = Support.passiveListener ? { passive: true } : false;

    panel.$el.on(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
    app.on('touchmove:active', handleTouchMove);
    app.on('touchend:passive', handleTouchEnd);
    app.on('resize', handleResize);
    panel.on('beforeOpen', handleResize);

    panel.once('panelDestroy', () => {
      $el.removeClass('panel-resizable');
      panel.$resizeHandlerEl.remove();
      panel.$el.off(app.touchEvents.start, '.panel-resize-handler', handleTouchStart, passive);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      app.off('resize', handleResize);
      panel.off('beforeOpen', handleResize);
    });
  }

  class Panel extends Framework7Class {
    constructor(app, params = {}) {
      const extendedParams = Utils.extend(
        { on: {} },
        app.params.panel,
        params
      );
      super(extendedParams, [app]);

      const panel = this;

      panel.params = extendedParams;

      let $el;
      if (panel.params.el) {
        $el = $(panel.params.el).eq(0);
      } else if (panel.params.content) {
        $el = $(panel.params.content).filter((elIndex, node) => node.nodeType === 1).eq(0);
      }

      if ($el.length === 0) return panel;
      if ($el[0].f7Panel) return $el[0].f7Panel;

      $el[0].f7Panel = panel;

      let { side, effect, resizable } = panel.params;
      if (typeof side === 'undefined') side = $el.hasClass('panel-left') ? 'left' : 'right';
      if (typeof effect === 'undefined') effect = $el.hasClass('panel-cover') ? 'cover' : 'reveal';
      if (typeof resizable === 'undefined') resizable = $el.hasClass('panel-resizable');

      let $backdropEl;
      if (panel.params.backdrop && panel.params.backdropEl) {
        $backdropEl = $(panel.params.backdropEl);
      } else if (panel.params.backdrop) {
        $backdropEl = app.root.children('.panel-backdrop');
        if ($backdropEl.length === 0) {
          $backdropEl = $('<div class="panel-backdrop"></div>');
          app.root.prepend($backdropEl);
        }
      }

      Utils.extend(panel, {
        app,
        side,
        effect,
        resizable,
        $el,
        el: $el[0],
        opened: false,
        $backdropEl,
        backdropEl: $backdropEl && $backdropEl[0],
      });

      // Install Modules
      panel.useModules();

      // Init
      panel.init();

      return panel;
    }

    getViewEl() {
      const panel = this;
      const app = panel.app;
      let viewEl;
      if (app.root.children('.views').length > 0) {
        viewEl = app.root.children('.views')[0];
      } else {
        viewEl = app.root.children('.view')[0];
      }
      return viewEl;
    }

    enableVisibleBreakpoint() {
      const panel = this;
      panel.visibleBreakpointDisabled = false;
      panel.setVisibleBreakpoint();
      return panel;
    }

    disableVisibleBreakpoint() {
      const panel = this;
      panel.visibleBreakpointDisabled = true;
      panel.setVisibleBreakpoint();
      return panel;
    }

    toggleVisibleBreakpoint() {
      const panel = this;
      panel.visibleBreakpointDisabled = !panel.visibleBreakpointDisabled;
      panel.setVisibleBreakpoint();
      return panel;
    }

    setVisibleBreakpoint(emitEvents = true) {
      const panel = this;
      const app = panel.app;
      if (!panel.visibleBreakpointResizeHandler) {
        panel.visibleBreakpointResizeHandler = function visibleBreakpointResizeHandler() {
          panel.setVisibleBreakpoint();
        };
        app.on('resize', panel.visibleBreakpointResizeHandler);
      }
      const { side, $el, params, visibleBreakpointDisabled } = panel;
      const breakpoint = params.visibleBreakpoint;
      const $viewEl = $(panel.getViewEl());
      const wasVisible = $el.hasClass('panel-in-breakpoint');

      if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null && !visibleBreakpointDisabled) {
        if (!wasVisible) {
          $('html').removeClass(`with-panel-${side}-reveal with-panel-${side}-cover with-panel`);
          $el.addClass('panel-in-breakpoint').removeClass('panel-in panel-in-collapsed');
          panel.onOpen(false);
          panel.onOpened();
          $viewEl.css({
            [`margin-${side}`]: `${$el.width()}px`,
          });
          app.allowPanelOpen = true;
          if (emitEvents) {
            panel.emit('local::breakpoint panelBreakpoint', panel);
            panel.$el.trigger('panel:breakpoint');
          }
        } else {
          $viewEl.css({
            [`margin-${side}`]: `${$el.width()}px`,
          });
        }
      } else if (wasVisible) {
        $el.removeClass('panel-in-breakpoint panel-in');
        panel.onClose();
        panel.onClosed();
        $viewEl.css({
          [`margin-${side}`]: '',
        });
        if (emitEvents) {
          panel.emit('local::breakpoint panelBreakpoint', panel);
          panel.$el.trigger('panel:breakpoint');
        }
      }
    }

    enableCollapsedBreakpoint() {
      const panel = this;
      panel.collapsedBreakpointDisabled = false;
      panel.setCollapsedBreakpoint();
      return panel;
    }

    disableCollapsedBreakpoint() {
      const panel = this;
      panel.collapsedBreakpointDisabled = true;
      panel.setCollapsedBreakpoint();
      return panel;
    }

    toggleCollapsedBreakpoint() {
      const panel = this;
      panel.collapsedBreakpointDisabled = !panel.collapsedBreakpointDisabled;
      panel.setCollapsedBreakpoint();
      return panel;
    }

    setCollapsedBreakpoint(emitEvents) {
      const panel = this;
      const app = panel.app;
      if (!panel.collapsedBreakpointResizeHandler) {
        panel.collapsedBreakpointResizeHandler = function collapsedBreakpointResizeHandler() {
          panel.setCollapsedBreakpoint();
        };
        app.on('resize', panel.collapsedBreakpointResizeHandler);
      }
      const { side, $el, params, collapsedBreakpointDisabled } = panel;
      if ($el.hasClass('panel-in-breakpoint')) return;
      const breakpoint = params.collapsedBreakpoint;
      const wasVisible = $el.hasClass('panel-in-collapsed');

      if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null && !collapsedBreakpointDisabled) {
        if (!wasVisible) {
          $('html').removeClass(`with-panel-${side}-reveal with-panel-${side}-cover with-panel`);
          $el.addClass('panel-in-collapsed').removeClass('panel-in');
          panel.collapsed = true;
          app.allowPanelOpen = true;
          if (emitEvents) {
            panel.emit('local::collapsedBreakpoint panelCollapsedBreakpoint', panel);
            panel.$el.trigger('panel:collapsedbreakpoint');
          }
        }
      } else if (wasVisible) {
        $el.removeClass('panel-in-collapsed panel-in');
        panel.collapsed = false;
        if (emitEvents) {
          panel.emit('local::collapsedBreakpoint panelCollapsedBreakpoint', panel);
          panel.$el.trigger('panel:collapsedbreakpoint');
        }
      }
    }

    enableResizable() {
      const panel = this;
      if (panel.resizableInitialized) {
        panel.resizable = true;
        panel.$el.addClass('panel-resizable');
      } else {
        resizablePanel(panel);
      }
      return panel;
    }

    disableResizable() {
      const panel = this;
      panel.resizable = false;
      panel.$el.removeClass('panel-resizable');
      return panel;
    }

    enableSwipe() {
      const panel = this;
      if (panel.swipeInitialized) {
        panel.swipeable = true;
      } else {
        swipePanel(panel);
      }
      return panel;
    }

    disableSwipe() {
      const panel = this;
      panel.swipeable = false;
      return panel;
    }

    onOpen(modifyHtmlClasses = true) {
      const panel = this;
      const app = panel.app;

      panel.opened = true;
      app.panel.allowOpen = false;

      panel.$el.trigger('panel:beforeopen');
      panel.emit('local::beforeOpen panelBeforeOpen', panel);

      if (modifyHtmlClasses) {
        $('html').addClass(`with-panel with-panel-${panel.side}-${panel.effect}`);
      }

      panel.$el.trigger('panel:open');
      panel.emit('local::open panelOpen', panel);
    }

    onOpened() {
      const panel = this;
      const app = panel.app;

      app.panel.allowOpen = true;

      panel.$el.trigger('panel:opened');
      panel.emit('local::opened panelOpened', panel);
    }

    onClose() {
      const panel = this;
      const app = panel.app;

      panel.opened = false;
      app.panel.allowOpen = false;

      panel.$el.trigger('panel:beforeclose');
      panel.emit('local::beforeClose panelBeforeClose', panel);

      $('html').addClass('with-panel-closing');
      $('html').removeClass(`with-panel with-panel-${panel.side}-${panel.effect}`);

      panel.$el.trigger('panel:close');
      panel.emit('local::close panelClose', panel);
    }

    onClosed() {
      const panel = this;
      const app = panel.app;
      app.panel.allowOpen = true;
      $('html').removeClass('with-panel-closing');
      panel.$el.removeClass('panel-out');
      panel.$el.trigger('panel:closed');
      panel.emit('local::closed panelClosed', panel);
    }

    toggle(animate = true) {
      const panel = this;
      const breakpoint = panel.params.visibleBreakpoint;
      const app = panel.app;
      if (app.width >= breakpoint && typeof breakpoint !== 'undefined' && breakpoint !== null) {
        return panel.toggleVisibleBreakpoint();
      }
      if (panel.opened) panel.close(animate);
      else panel.open(animate);
      return panel;
    }

    insertToRoot() {
      const panel = this;
      const { $el, app, $backdropEl } = panel;
      const $panelParentEl = $el.parent();
      const wasInDom = $el.parents(document).length > 0;

      if (!$panelParentEl.is(app.root) || $el.prevAll('.views, .view').length) {
        const $insertBeforeEl = app.root.children('.panel, .views, .view').eq(0);
        const $insertAfterEl = app.root.children('.panel-backdrop').eq(0);

        if ($insertBeforeEl.length) {
          $el.insertBefore($insertBeforeEl);
        } else if ($insertAfterEl) {
          $el.insertBefore($insertAfterEl);
        } else {
          app.root.prepend($el);
        }

        if ($backdropEl
          && $backdropEl.length
          && (
            (
              !$backdropEl.parent().is(app.root)
              && $backdropEl.nextAll('.panel').length === 0
            )
            || (
              $backdropEl.parent().is(app.root)
              && $backdropEl.nextAll('.panel').length === 0
            )
          )
        ) {
          $backdropEl.insertBefore($el);
        }

        panel.once('panelClosed', () => {
          if (wasInDom) {
            $panelParentEl.append($el);
          } else {
            $el.remove();
          }
        });
      }
    }

    open(animate = true) {
      const panel = this;
      const app = panel.app;

      if (!app.panel.allowOpen) return false;

      const { effect, $el, $backdropEl, opened } = panel;

      if (!$el || $el.hasClass('panel-in')) {
        return panel;
      }

      panel.insertToRoot();

      // Ignore if opened
      if (opened || $el.hasClass('panel-in-breakpoint') || $el.hasClass('panel-in')) return false;

      // Close if some panel is opened
      const otherOpenedPanel = app.panel.get('.panel-in');
      if (otherOpenedPanel && otherOpenedPanel !== panel) {
        otherOpenedPanel.close(animate);
      }

      $el[animate ? 'removeClass' : 'addClass']('not-animated');
      $el.addClass('panel-in');

      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');

      if (panel.effect === 'cover') {
        /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
        panel._clientLeft = $el[0].clientLeft;
      }

      // Transitionend
      const transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

      function panelTransitionEnd() {
        transitionEndTarget.transitionEnd((e) => {
          if ($(e.target).is(transitionEndTarget)) {
            if ($el.hasClass('panel-out')) {
              panel.onClosed();
            } else {
              panel.onOpened();
            }
          } else panelTransitionEnd();
        });
      }
      if (animate) {
        if ($backdropEl) {
          $backdropEl.removeClass('not-animated');
        }
        panelTransitionEnd();
        $el
          .removeClass('panel-out not-animated')
          .addClass('panel-in');
        panel.onOpen();
      } else {
        if ($backdropEl) {
          $backdropEl.addClass('not-animated');
        }
        $el.removeClass('panel-out').addClass('panel-in not-animated');
        panel.onOpen();
        panel.onOpened();
      }

      return true;
    }

    close(animate = true) {
      const panel = this;

      const { effect, $el, $backdropEl, opened } = panel;
      if (!opened || $el.hasClass('panel-in-breakpoint') || !$el.hasClass('panel-in')) return panel;

      $el[animate ? 'removeClass' : 'addClass']('not-animated');
      $backdropEl[animate ? 'removeClass' : 'addClass']('not-animated');

      const transitionEndTarget = effect === 'reveal' ? $el.nextAll('.view, .views').eq(0) : $el;

      function transitionEnd() {
        if ($el.hasClass('panel-out')) {
          panel.onClosed();
        } else if ($el.hasClass('panel-in')) {
          panel.onOpened();
        }
        $('html').removeClass('with-panel-closing');
      }
      if (animate) {
        transitionEndTarget
          .transitionEnd(() => {
            transitionEnd();
          });
        $el
          .removeClass('panel-in')
          .addClass('panel-out');
        // Emit close
        panel.onClose();
      } else {
        $el
          .addClass('not-animated')
          .removeClass('panel-in')
          .addClass('panel-out');
        // Emit close
        panel.onClose();
        panel.onClosed();
      }

      return panel;
    }

    init() {
      const panel = this;
      // const app = panel.app;
      if (typeof panel.params.visibleBreakpoint !== 'undefined') {
        panel.setVisibleBreakpoint();
      }
      if (typeof panel.params.collapsedBreakpoint !== 'undefined') {
        panel.setCollapsedBreakpoint();
      }
      if (panel.params.swipe) {
        panel.enableSwipe();
      }
      if (panel.resizable) {
        panel.enableResizable();
      }
    }

    destroy() {
      let panel = this;
      const app = panel.app;

      if (!panel.$el) {
        // Panel already destroyed
        return;
      }

      panel.emit('local::beforeDestroy panelBeforeDestroy', panel);
      panel.$el.trigger('panel:beforedestroy');

      if (panel.visibleBreakpointResizeHandler) {
        app.off('resize', panel.visibleBreakpointResizeHandler);
      }
      if (panel.collapsedBreakpointResizeHandler) {
        app.off('resize', panel.collapsedBreakpointResizeHandler);
      }
      if (panel.$el.hasClass('panel-in-breakpoint') || panel.$el.hasClass('panel-in-collapsed')) {
        const $viewEl = $(panel.getViewEl());
        panel.$el.removeClass('panel-in-breakpoint panel-in-collapsed panel-in');
        $viewEl.css({
          [`margin-${panel.side}`]: '',
        });
        panel.emit('local::breakpoint panelBreakpoint', panel);
        panel.$el.trigger('panel:breakpoint');
      }

      panel.$el.trigger('panel:destroy');
      panel.emit('local::destroy panelDestroy', panel);
      if (panel.el) {
        panel.el.f7Panel = null;
        delete panel.el.f7Panel;
      }
      Utils.deleteProps(panel);

      panel = null;
    }
  }

  var Panel$1 = {
    name: 'panel',
    params: {
      panel: {
        opened: undefined, // default based on panel-in class
        side: undefined, // default based on panel class
        effect: undefined, // default based on panel class
        resizable: undefined, // default based on panel-resizable class
        backdrop: true,
        backdropEl: undefined,
        visibleBreakpoint: undefined,
        collapsedBreakpoint: undefined,
        swipe: false, // or true
        swipeNoFollow: false, // or true
        swipeOnlyClose: false,
        swipeActiveArea: 0,
        swipeThreshold: 0,
        closeByBackdropClick: true,
      },
    },
    static: {
      Panel,
    },
    instance: {
      panel: {
        allowOpen: true,
      },
    },
    create() {
      const app = this;
      Utils.extend(app.panel, {
        create(params) {
          return new Panel(app, params);
        },
        get(el = '.panel') {
          if (el instanceof Panel) return el;
          if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line
          const $el = $(el);
          if ($el.length === 0 || $el.length > 1) return undefined;
          return $el[0].f7Panel;
        },
        destroy(el = '.panel') {
          const panel = app.panel.get(el);
          if (panel && panel.destroy) return panel.destroy();
          return undefined;
        },
        open(el = '.panel', animate) {
          if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line
          let panel = app.panel.get(el);
          if (panel && panel.open) return panel.open(animate);
          if (!panel) {
            panel = app.panel.create({ el });
            return panel.open(animate);
          }
          return undefined;
        },
        close(el = '.panel-in', animate) {
          if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line
          let panel = app.panel.get(el);
          if (panel && panel.open) return panel.close(animate);
          if (!panel) {
            panel = app.panel.create({ el });
            return panel.close(animate);
          }
          return undefined;
        },
        toggle(el = '.panel', animate) {
          if (el === 'left' || el === 'right') el = `.panel-${el}`; // eslint-disable-line
          let panel = app.panel.get(el);
          if (panel && panel.toggle) return panel.toggle(animate);
          if (!panel) {
            panel = app.panel.create({ el });
            return panel.toggle(animate);
          }
          return undefined;
        },
      });
    },
    on: {
      init() {
        const app = this;
        $('.panel-init').each((index, panelEl) => {
          const params = Object.assign(
            { el: panelEl },
            $(panelEl).dataset() || {}
          );
          app.panel.create(params);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.panel-init').each((index, panelEl) => {
          const params = Object.assign(
            { el: panelEl },
            $(panelEl).dataset() || {}
          );
          app.panel.create(params);
        });
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.panel-init').each((index, panelEl) => {
          const panel = app.panel.get(panelEl);
          if (panel && panel.destroy) panel.destroy();
        });
      },
    },
    vnode: {
      'panel-init': {
        insert(vnode) {
          const app = this;
          const panelEl = vnode.elm;
          const params = Object.assign(
            { el: panelEl },
            $(panelEl).dataset() || {}
          );
          app.panel.create(params);
        },
        destroy(vnode) {
          const app = this;
          const panelEl = vnode.elm;
          const panel = app.panel.get(panelEl);
          if (panel && panel.destroy) panel.destroy();
        },
      },
    },
    clicks: {
      '.panel-open': function open(clickedEl, data = {}) {
        const app = this;
        app.panel.open(data.panel, data.animate);
      },
      '.panel-close': function close(clickedEl, data = {}) {
        const app = this;
        app.panel.close(data.panel, data.animate);
      },
      '.panel-toggle': function close(clickedEl, data = {}) {
        const app = this;
        app.panel.toggle(data.panel, data.animate);
      },
      '.panel-backdrop': function close() {
        const app = this;
        const $panelEl = $('.panel-in:not(.panel-out)');
        if (!$panelEl.length) return;
        const instance = $panelEl[0] && $panelEl[0].f7Panel;
        $panelEl.trigger('panel:backdrop-click');
        if (instance) {
          instance.emit('backdropClick', instance);
        }
        app.emit('panelBackdropClick', instance || $panelEl[0]);
        if (app.params.panel.closeByBackdropClick) app.panel.close();
      },
    },
  };

  /* eslint no-param-reassign: "off" */

  const CardExpandable = {
    open(cardEl = '.card-expandable', animate = true) {
      const app = this;

      const $cardEl = $(cardEl).eq(0);
      if (!$cardEl || !$cardEl.length) return;
      if ($cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) return;

      const $pageEl = $cardEl.parents('.page').eq(0);
      if (!$pageEl.length) return;

      if ($pageEl.find('.card-opened').length) {
        return;
      }

      let prevented;

      function prevent() {
        prevented = true;
      }

      $cardEl.trigger('card:beforeopen', { prevent });
      app.emit('cardBeforeOpen', $cardEl[0], prevent);

      if (prevented) return;

      const cardParams = Object.assign({ animate }, app.params.card, $cardEl.dataset());

      const $pageContentEl = $cardEl.parents('.page-content');

      let $backdropEl;
      if ($cardEl.attr('data-backdrop-el')) {
        $backdropEl = $($cardEl.attr('data-backdrop-el'));
      }
      if (!$backdropEl && cardParams.backdrop) {
        $backdropEl = $pageContentEl.find('.card-backdrop');
        if (!$backdropEl.length) {
          $backdropEl = $('<div class="card-backdrop"></div>');
          $pageContentEl.append($backdropEl);
        }
      }

      let $navbarEl;
      let $toolbarEl;
      if (cardParams.hideNavbarOnOpen) {
        $navbarEl = $pageEl.children('.navbar');
        if (!$navbarEl.length) {
          if ($pageEl[0].f7Page) $navbarEl = $pageEl[0].f7Page.$navbarEl;
        }
      }
      if (cardParams.hideToolbarOnOpen) {
        $toolbarEl = $pageEl.children('.toolbar');
        if (!$toolbarEl.length) {
          $toolbarEl = $pageEl.parents('.view').children('.toolbar');
        }
        if (!$toolbarEl.length) {
          $toolbarEl = $pageEl.parents('.views').children('.toolbar');
        }
      }

      const currTransform = $cardEl.css('transform');
      let hasTransform;
      if (currTransform && currTransform.match(/[2-9]/)) {
        hasTransform = true;
      }
      const $cardContentEl = $cardEl.children('.card-content');

      const $cardSizeEl = $(document.createElement('div')).addClass('card-expandable-size');
      $cardEl.append($cardSizeEl);

      let cardWidth = $cardEl[0].offsetWidth;
      let cardHeight = $cardEl[0].offsetHeight;
      let pageWidth = $pageEl[0].offsetWidth;
      let pageHeight = $pageEl[0].offsetHeight;

      let maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
      let maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;

      let statusbarHeight;
      if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
        statusbarHeight = parseInt($navbarEl.css('--f7-safe-area-top'), 10);
        if (Number.isNaN(statusbarHeight)) statusbarHeight = 0;
      }
      if (statusbarHeight) {
        maxHeight -= statusbarHeight;
      }

      let scaleX = maxWidth / cardWidth;
      let scaleY = maxHeight / cardHeight;

      let offset = $cardEl.offset();
      let pageOffset = $pageEl.offset();
      if (statusbarHeight) {
        pageOffset.top += statusbarHeight / 2;
      }
      offset.left -= pageOffset.left;

      let cardLeftOffset;
      let cardTopOffset;

      if (hasTransform) {
        const transformValues = currTransform
          .replace(/matrix\(|\)/g, '')
          .split(',')
          .map(el => el.trim());
        if (transformValues && transformValues.length > 1) {
          const scale = parseFloat(transformValues[0]);
          cardLeftOffset = offset.left - cardWidth * (1 - scale) / 2;
          cardTopOffset = offset.top - pageOffset.top - cardHeight * (1 - scale) / 2;
          if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
        } else {
          cardLeftOffset = $cardEl[0].offsetLeft;
          cardTopOffset = $cardEl[0].offsetTop - ($pageContentEl.length ? $pageContentEl[0].scrollTop : 0);
        }
      } else {
        cardLeftOffset = offset.left;
        cardTopOffset = offset.top - pageOffset.top;
        if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
      }

      cardLeftOffset -= (pageWidth - maxWidth) / 2;
      cardTopOffset -= (pageHeight - maxHeight) / 2;

      let cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
      if (app.rtl) {
        [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
      }
      let cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
      let translateX = (cardRightOffset - cardLeftOffset) / 2;
      let translateY = (cardBottomOffset - cardTopOffset) / 2;
      if (cardParams.hideNavbarOnOpen && $navbarEl && $navbarEl.length) {
        if ($navbarEl.closest('.navbar-hidden').length) {
          // Was hidden
          $cardEl[0].f7KeepNavbarOnClose = true;
        } else {
          delete $cardEl[0].f7KeepNavbarOnClose;
          app.navbar.hide($navbarEl, cardParams.animate, cardParams.hideStatusbarOnOpen);
        }
      }
      if (cardParams.hideToolbarOnOpen && $toolbarEl && $toolbarEl.length) {
        if ($toolbarEl.closest('.toolbar-hidden').length) {
          // Was hidden
          $cardEl[0].f7KeepToolbarOnClose = true;
        } else {
          delete $cardEl[0].f7KeepToolbarOnClose;
          app.toolbar.hide($toolbarEl, cardParams.animate);
        }
      }
      if ($backdropEl) {
        $backdropEl.removeClass('card-backdrop-out').addClass('card-backdrop-in');
      }
      $cardEl.removeClass('card-transitioning');
      if (cardParams.animate) {
        $cardEl.addClass('card-opening');
      }
      $cardEl.trigger('card:open');
      app.emit('cardOpen', $cardEl[0]);
      function transitionEnd() {
        $pageEl.addClass('page-with-card-opened');
        if (app.device.ios && $pageContentEl.length) {
          $pageContentEl.css('height', `${$pageContentEl[0].offsetHeight + 1}px`);
          setTimeout(() => {
            $pageContentEl.css('height', '');
          });
        }
        $cardEl.addClass('card-opened');
        $cardEl.removeClass('card-opening');
        $cardEl.trigger('card:opened');
        app.emit('cardOpened', $cardEl[0], $pageEl[0]);
      }
      $cardContentEl
        .css({
          width: `${maxWidth}px`,
          height: `${maxHeight}px`,
        })
        .transform(`translate3d(${app.rtl ? (cardLeftOffset + translateX) : (-cardLeftOffset - translateX)}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);

      $cardEl
        .transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
      if (cardParams.animate) {
        $cardEl.transitionEnd(() => {
          transitionEnd();
        });
      } else {
        transitionEnd();
      }

      function onResize() {
        $cardEl.removeClass('card-transitioning');
        cardWidth = $cardEl[0].offsetWidth;
        cardHeight = $cardEl[0].offsetHeight;
        pageWidth = $pageEl[0].offsetWidth;
        pageHeight = $pageEl[0].offsetHeight;
        maxWidth = $cardSizeEl[0].offsetWidth || pageWidth;
        maxHeight = $cardSizeEl[0].offsetHeight || pageHeight;

        statusbarHeight = 0;
        if ($navbarEl && !cardParams.hideStatusbarOnOpen && maxHeight === pageHeight) {
          statusbarHeight = parseInt($navbarEl.css('--f7-safe-area-top'), 10);
          if (Number.isNaN(statusbarHeight)) statusbarHeight = 0;
        }
        if (statusbarHeight) {
          maxHeight -= statusbarHeight;
        }


        scaleX = maxWidth / cardWidth;
        scaleY = maxHeight / cardHeight;

        $cardEl.transform('translate3d(0px, 0px, 0) scale(1)');
        offset = $cardEl.offset();
        pageOffset = $pageEl.offset();
        if (statusbarHeight) {
          pageOffset.top += statusbarHeight / 2;
        }
        offset.left -= pageOffset.left;
        offset.top -= pageOffset.top;

        cardLeftOffset = offset.left - (pageWidth - maxWidth) / 2;
        if (app.rtl) cardLeftOffset -= $cardEl[0].scrollLeft;
        cardTopOffset = offset.top - (pageHeight - maxHeight) / 2;

        cardRightOffset = maxWidth - cardWidth - cardLeftOffset;
        cardBottomOffset = maxHeight - cardHeight - cardTopOffset;
        if (app.rtl) {
          [cardLeftOffset, cardRightOffset] = [cardRightOffset, cardLeftOffset];
        }
        translateX = (cardRightOffset - cardLeftOffset) / 2;
        translateY = (cardBottomOffset - cardTopOffset) / 2;

        $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
        $cardContentEl
          .css({
            width: `${maxWidth}px`,
            height: `${maxHeight}px`,
          })
          .transform(`translate3d(${app.rtl ? (cardLeftOffset + translateX) : (-cardLeftOffset - translateX)}px, 0px, 0) scale(${1 / scaleX}, ${1 / scaleY})`);
      }

      let cardScrollTop;
      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchEndX;
      let touchEndY;
      let isScrolling;
      let progress;
      let isV;
      let isH;
      let $cardScrollableEl;
      function onTouchStart(e) {
        if (!$(e.target).closest($cardEl).length) return;
        if (!$cardEl.hasClass('card-opened')) return;
        $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);

        if ($cardScrollableEl[0]
          && $cardScrollableEl[0] !== $cardContentEl[0]
          && !$cardScrollableEl[0].contains(e.target)
        ) {
          cardScrollTop = 0;
        } else {
          cardScrollTop = $cardScrollableEl.scrollTop();
        }
        isTouched = true;
        touchStartX = e.targetTouches[0].pageX;
        touchStartY = e.targetTouches[0].pageY;
        isScrolling = undefined;
        isV = false;
        isH = false;
      }
      function onTouchMove(e) {
        if (!isTouched) return;
        touchEndX = e.targetTouches[0].pageX;
        touchEndY = e.targetTouches[0].pageY;
        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(touchEndY - touchStartY) > Math.abs(touchEndX - touchStartX));
        }
        if (!isH && !isV) {
          if (!isScrolling && e.targetTouches[0].clientX <= 50) {
            isH = true;
          } else {
            isV = true;
          }
        }

        if (!(isH || isV) || (isV && cardScrollTop !== 0)) {
          isTouched = true;
          isMoved = true;
          return;
        }
        if (!isMoved) {
          $cardEl.removeClass('card-transitioning');
        }

        isMoved = true;
        progress = isV ? Math.max((touchEndY - touchStartY) / 150, 0) : Math.max((touchEndX - touchStartX) / (cardWidth / 2), 0);
        if ((progress > 0 && isV) || isH) {
          if (isV && app.device.ios && $cardScrollableEl[0] === $cardContentEl[0]) {
            $cardScrollableEl.css('-webkit-overflow-scrolling', 'auto');
            $cardScrollableEl.scrollTop(0);
          }
          e.preventDefault();
        }

        if (progress > 1) progress **= 0.3;
        if (progress > (isV ? 1.3 : 1.1)) {
          isTouched = false;
          isMoved = false;
          app.card.close($cardEl);
        } else {
          $cardEl.transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX * (1 - progress * 0.2)}, ${scaleY * (1 - progress * 0.2)})`);
        }
      }
      function onTouchEnd() {
        if (!isTouched || !isMoved) return;
        isTouched = false;
        isMoved = false;
        if (app.device.ios) {
          $cardScrollableEl.css('-webkit-overflow-scrolling', '');
        }
        if (progress >= 0.8) {
          app.card.close($cardEl);
        } else {
          $cardEl
            .addClass('card-transitioning')
            .transform(`translate3d(${app.rtl ? -translateX : translateX}px, ${translateY}px, 0) scale(${scaleX}, ${scaleY})`);
        }
      }

      $cardEl[0].detachEventHandlers = function detachEventHandlers() {
        app.off('resize', onResize);
        if (Support.touch && cardParams.swipeToClose) {
          app.off('touchstart:passive', onTouchStart);
          app.off('touchmove:active', onTouchMove);
          app.off('touchend:passive', onTouchEnd);
        }
      };

      app.on('resize', onResize);
      if (Support.touch && cardParams.swipeToClose) {
        app.on('touchstart:passive', onTouchStart);
        app.on('touchmove:active', onTouchMove);
        app.on('touchend:passive', onTouchEnd);
      }
    },
    close(cardEl = '.card-expandable.card-opened', animate = true) {
      const app = this;
      const $cardEl = $(cardEl).eq(0);
      if (!$cardEl || !$cardEl.length) return;
      if (!$cardEl.hasClass('card-opened') || $cardEl.hasClass('card-opening') || $cardEl.hasClass('card-closing')) return;

      const $cardContentEl = $cardEl.children('.card-content');
      const $pageContentEl = $cardEl.parents('.page-content');

      const $pageEl = $cardEl.parents('.page').eq(0);
      if (!$pageEl.length) return;

      const cardParams = Object.assign({ animate }, app.params.card, $cardEl.dataset());
      const $cardScrollableEl = $cardEl.find(cardParams.scrollableEl);

      let $navbarEl;
      let $toolbarEl;

      let $backdropEl;
      if ($cardEl.attr('data-backdrop-el')) {
        $backdropEl = $($cardEl.attr('data-backdrop-el'));
      }
      if (cardParams.backdrop) {
        $backdropEl = $cardEl.parents('.page-content').find('.card-backdrop');
      }

      if (cardParams.hideNavbarOnOpen) {
        $navbarEl = $pageEl.children('.navbar');
        if (!$navbarEl.length) {
          if ($pageEl[0].f7Page) $navbarEl = $pageEl[0].f7Page.$navbarEl;
        }
        if ($navbarEl && $navbarEl.length && !$cardEl[0].f7KeepNavbarOnClose) {
          app.navbar.show($navbarEl, cardParams.animate);
        }
      }
      if (cardParams.hideToolbarOnOpen) {
        $toolbarEl = $pageEl.children('.toolbar');
        if (!$toolbarEl.length) {
          $toolbarEl = $pageEl.parents('.view').children('.toolbar');
        }
        if (!$toolbarEl.length) {
          $toolbarEl = $pageEl.parents('.views').children('.toolbar');
        }
        if ($toolbarEl && $toolbarEl.length && !$cardEl[0].f7KeepToolbarOnClose) {
          app.toolbar.show($toolbarEl, cardParams.animate);
        }
      }

      $pageEl.removeClass('page-with-card-opened');

      if (app.device.ios && $pageContentEl.length) {
        $pageContentEl.css('height', `${$pageContentEl[0].offsetHeight + 1}px`);
        setTimeout(() => {
          $pageContentEl.css('height', '');
        });
      }

      if ($backdropEl && $backdropEl.length) {
        $backdropEl.removeClass('card-backdrop-in').addClass('card-backdrop-out');
      }

      $cardEl.removeClass('card-opened card-transitioning');
      if (cardParams.animate) {
        $cardEl.addClass('card-closing');
      } else {
        $cardEl.addClass('card-no-transition');
      }
      $cardEl.transform('');
      $cardEl.trigger('card:close');
      app.emit('cardClose', $cardEl[0], $pageEl[0]);

      const animateWidth = $cardEl.hasClass('card-expandable-animate-width');

      function transitionEnd() {
        if (!animateWidth) {
          $cardContentEl
            .css({
              width: '',
              height: '',
            });
        }
        if ($backdropEl && $backdropEl.length) {
          $backdropEl.removeClass('card-backdrop-in card-backdrop-out');
        }
        $cardEl.removeClass('card-closing card-no-transition');
        $cardEl.trigger('card:closed');
        $cardEl.find('.card-expandable-size').remove();
        app.emit('cardClosed', $cardEl[0], $pageEl[0]);
      }
      if (animateWidth) {
        $cardContentEl
          .css({
            width: '',
            height: '',
          });
      }

      $cardContentEl
        .transform('')
        .scrollTop(0, animate ? 300 : 0);
      if ($cardScrollableEl.length && $cardScrollableEl[0] !== $cardContentEl[0]) {
        $cardScrollableEl.scrollTop(0, animate ? 300 : 0);
      }
      if (animate) {
        $cardContentEl.transitionEnd(() => {
          transitionEnd();
        });
      } else {
        transitionEnd();
      }

      if ($cardEl[0].detachEventHandlers) {
        $cardEl[0].detachEventHandlers();
        delete $cardEl[0].detachEventHandlers;
      }
    },
    toggle(cardEl = '.card-expandable', animate) {
      const app = this;
      const $cardEl = $(cardEl).eq(0);
      if (!$cardEl.length) return;
      if ($cardEl.hasClass('card-opened')) {
        app.card.close($cardEl, animate);
      } else {
        app.card.open($cardEl, animate);
      }
    },
  };

  var Card = {
    name: 'card',
    params: {
      card: {
        hideNavbarOnOpen: true,
        hideStatusbarOnOpen: true,
        hideToolbarOnOpen: true,
        scrollableEl: '.card-content',
        swipeToClose: true,
        closeByBackdropClick: true,
        backdrop: true,
      },
    },
    create() {
      const app = this;
      Utils.extend(app, {
        card: {
          open: CardExpandable.open.bind(app),
          close: CardExpandable.close.bind(app),
          toggle: CardExpandable.toggle.bind(app),
        },
      });
    },
    on: {
      pageBeforeIn(page) {
        const app = this;
        if (app.params.card.hideNavbarOnOpen && page.navbarEl && page.$el.find('.card-opened.card-expandable').length) {
          app.navbar.hide(page.navbarEl, true, app.params.card.hideStatusbarOnOpen);
        }

        if (app.params.card.hideToolbarOnOpen && page.$el.find('.card-opened.card-expandable').length) {
          let $toolbarEl = page.$el.children('.toolbar');
          if (!$toolbarEl.length) {
            $toolbarEl = page.$el.parents('.view').children('.toolbar');
          }
          if (!$toolbarEl.length) {
            $toolbarEl = page.$el.parents('.views').children('.toolbar');
          }
          if ($toolbarEl && $toolbarEl.length) {
            app.toolbar.hide($toolbarEl);
          }
        }
      },
    },
    clicks: {
      '.card-close': function closeCard($clickedEl, data) {
        const app = this;
        app.card.close(data.card, data.animate);
      },
      '.card-open': function closeCard($clickedEl, data) {
        const app = this;
        app.card.open(data.card, data.animate);
      },
      '.card-expandable': function toggleExpandableCard($clickedEl, data, e) {
        const app = this;
        if ($clickedEl.hasClass('card-opened') || $clickedEl.hasClass('card-opening') || $clickedEl.hasClass('card-closing')) return;
        if ($(e.target).closest('.card-prevent-open, .card-close').length) return;
        app.card.open($clickedEl);
      },
      '.card-backdrop-in': function onBackdropClick() {
        const app = this;
        let needToClose = false;
        if (app.params.card.closeByBackdropClick) needToClose = true;
        const $openedCardEl = $('.card-opened');
        if (!$openedCardEl.length) return;
        if ($openedCardEl.attr('data-close-by-backdrop-click') === 'true') {
          needToClose = true;
        } else if ($openedCardEl.attr('data-close-by-backdrop-click') === 'false') {
          needToClose = false;
        }
        if (needToClose) app.card.close($openedCardEl);
      },
    },
  };

  var Chip = {
    name: 'chip',
  };

  // Form Data
  const FormData$1 = {
    store(form, data) {
      const app = this;
      let formId = form;

      const $formEl = $(form);
      if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
        formId = $formEl.attr('id');
      }
      // Store form data in app.formsData
      app.form.data[`form-${formId}`] = data;

      // Store form data in local storage also
      win.localStorage[`f7form-${formId}`] = JSON.stringify(data);
    },
    get(form) {
      const app = this;
      let formId = form;

      const $formEl = $(form);
      if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
        formId = $formEl.attr('id');
      }

      if (win.localStorage[`f7form-${formId}`]) {
        return JSON.parse(win.localStorage[`f7form-${formId}`]);
      }
      if (app.form.data[`form-${formId}`]) {
        return app.form.data[`form-${formId}`];
      }
      return undefined;
    },
    remove(form) {
      const app = this;
      let formId = form;

      const $formEl = $(form);
      if ($formEl.length && $formEl.is('form') && $formEl.attr('id')) {
        formId = $formEl.attr('id');
      }

      // Delete form data from app.formsData
      if (app.form.data[`form-${formId}`]) {
        app.form.data[`form-${formId}`] = '';
        delete app.form.data[`form-${formId}`];
      }

      // Delete form data from local storage also
      if (win.localStorage[`f7form-${formId}`]) {
        win.localStorage[`f7form-${formId}`] = '';
        win.localStorage.removeItem(`f7form-${formId}`);
      }
    },
  };

  // Form Storage
  const FormStorage = {
    init(formEl) {
      const app = this;
      const $formEl = $(formEl);
      const formId = $formEl.attr('id');
      if (!formId) return;
      const initialData = app.form.getFormData(formId);
      if (initialData) {
        app.form.fillFromData($formEl, initialData);
      }
      function store() {
        const data = app.form.convertToData($formEl);
        if (!data) return;
        app.form.storeFormData(formId, data);
        $formEl.trigger('form:storedata', data);
        app.emit('formStoreData', $formEl[0], data);
      }
      $formEl.on('change submit', store);
    },
    destroy(formEl) {
      const $formEl = $(formEl);
      $formEl.off('change submit');
    },
  };

  // Form To/From Data
  function formToData(formEl) {
    const app = this;
    const $formEl = $(formEl).eq(0);
    if ($formEl.length === 0) return undefined;

    // Form data
    const data = {};

    // Skip input types
    const skipTypes = ['submit', 'image', 'button', 'file'];
    const skipNames = [];
    $formEl.find('input, select, textarea').each((inputIndex, inputEl) => {
      const $inputEl = $(inputEl);
      if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
        return;
      }
      const name = $inputEl.attr('name');
      const type = $inputEl.attr('type');
      const tag = inputEl.nodeName.toLowerCase();
      if (skipTypes.indexOf(type) >= 0) return;
      if (skipNames.indexOf(name) >= 0 || !name) return;
      if (tag === 'select' && $inputEl.prop('multiple')) {
        skipNames.push(name);
        data[name] = [];
        $formEl.find(`select[name="${name}"] option`).each((index, el) => {
          if (el.selected) data[name].push(el.value);
        });
      } else {
        switch (type) {
          case 'checkbox':
            skipNames.push(name);
            data[name] = [];
            $formEl.find(`input[name="${name}"]`).each((index, el) => {
              if (el.checked) data[name].push(el.value);
            });
            break;
          case 'radio':
            skipNames.push(name);
            $formEl.find(`input[name="${name}"]`).each((index, el) => {
              if (el.checked) data[name] = el.value;
            });
            break;
          default:
            data[name] = $inputEl.val();
            break;
        }
      }
    });
    $formEl.trigger('form:todata', data);
    app.emit('formToData', $formEl[0], data);

    return data;
  }
  function formFromData(formEl, formData) {
    const app = this;
    const $formEl = $(formEl).eq(0);
    if (!$formEl.length) return;

    let data = formData;
    const formId = $formEl.attr('id');

    if (!data && formId) {
      data = app.form.getFormData(formId);
    }

    if (!data) return;

    // Skip input types
    const skipTypes = ['submit', 'image', 'button', 'file'];
    const skipNames = [];

    $formEl.find('input, select, textarea').each((inputIndex, inputEl) => {
      const $inputEl = $(inputEl);
      if ($inputEl.hasClass('ignore-store-data') || $inputEl.hasClass('no-store-data')) {
        return;
      }
      const name = $inputEl.attr('name');
      const type = $inputEl.attr('type');
      const tag = inputEl.nodeName.toLowerCase();
      if (typeof data[name] === 'undefined' || data[name] === null) return;
      if (skipTypes.indexOf(type) >= 0) return;
      if (skipNames.indexOf(name) >= 0 || !name) return;
      if (tag === 'select' && $inputEl.prop('multiple')) {
        skipNames.push(name);
        $formEl.find(`select[name="${name}"] option`).each((index, el) => {
          const selectEl = el;
          if (data[name].indexOf(el.value) >= 0) selectEl.selected = true;
          else selectEl.selected = false;
        });
      } else {
        switch (type) {
          case 'checkbox':
            skipNames.push(name);
            $formEl.find(`input[name="${name}"]`).each((index, el) => {
              const checkboxEl = el;
              if (data[name].indexOf(el.value) >= 0) checkboxEl.checked = true;
              else checkboxEl.checked = false;
            });
            break;
          case 'radio':
            skipNames.push(name);
            $formEl.find(`input[name="${name}"]`).each((index, el) => {
              const radioEl = el;
              if (data[name] === el.value) radioEl.checked = true;
              else radioEl.checked = false;
            });
            break;
          default:
            $inputEl.val(data[name]);
            break;
        }
      }
      if (tag === 'select' || tag === 'input' || tag === 'textarea') {
        $inputEl.trigger('change', 'fromdata');
      }
    });
    $formEl.trigger('form:fromdata', data);
    app.emit('formFromData', $formEl[0], data);
  }

  function initAjaxForm() {
    const app = this;

    function onSubmitChange(e, fromData) {
      const $formEl = $(this);
      if (e.type === 'change' && !$formEl.hasClass('form-ajax-submit-onchange')) return;
      if (e.type === 'submit') e.preventDefault();

      if (e.type === 'change' && fromData === 'fromdata') return;

      const method = ($formEl.attr('method') || 'GET').toUpperCase();
      const contentType = $formEl.prop('enctype') || $formEl.attr('enctype');

      const url = $formEl.attr('action');
      if (!url) return;

      let data;
      if (method === 'POST') {
        if (contentType === 'application/x-www-form-urlencoded') {
          data = app.form.convertToData($formEl[0]);
        } else {
          data = new win.FormData($formEl[0]);
        }
      } else {
        data = Utils.serializeObject(app.form.convertToData($formEl[0]));
      }

      app.request({
        method,
        url,
        contentType,
        data,
        beforeSend(xhr) {
          $formEl.trigger('formajax:beforesend', { data, xhr });
          app.emit('formAjaxBeforeSend', $formEl[0], data, xhr);
        },
        error(xhr) {
          $formEl.trigger('formajax:error', { data, xhr });
          app.emit('formAjaxError', $formEl[0], data, xhr);
        },
        complete(xhr) {
          $formEl.trigger('formajax:complete', { data, xhr });
          app.emit('formAjaxComplete', $formEl[0], data, xhr);
        },
        success(response, status, xhr) {
          $formEl.trigger('formajax:success', { data, xhr });
          app.emit('formAjaxSuccess', $formEl[0], data, xhr);
        },
      });
    }
    $(doc).on('submit change', 'form.form-ajax-submit, form.form-ajax-submit-onchange', onSubmitChange);
  }

  var Form = {
    name: 'form',
    create() {
      const app = this;
      Utils.extend(app, {
        form: {
          data: {},
          storeFormData: FormData$1.store.bind(app),
          getFormData: FormData$1.get.bind(app),
          removeFormData: FormData$1.remove.bind(app),
          convertToData: formToData.bind(app),
          fillFromData: formFromData.bind(app),
          storage: {
            init: FormStorage.init.bind(app),
            destroy: FormStorage.destroy.bind(app),
          },
        },
      });
    },
    on: {
      init() {
        const app = this;
        initAjaxForm.call(app);
      },
      tabBeforeRemove(tabEl) {
        const app = this;
        $(tabEl).find('.form-store-data').each((index, formEl) => {
          app.form.storage.destroy(formEl);
        });
      },
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.form-store-data').each((index, formEl) => {
          app.form.storage.init(formEl);
        });
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.form-store-data').each((index, formEl) => {
          app.form.storage.destroy(formEl);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.form-store-data').each((index, formEl) => {
          app.form.storage.init(formEl);
        });
      },
    },
  };

  const Input = {
    ignoreTypes: ['checkbox', 'button', 'submit', 'range', 'radio', 'image'],
    createTextareaResizableShadow() {
      const $shadowEl = $(doc.createElement('textarea'));
      $shadowEl.addClass('textarea-resizable-shadow');
      $shadowEl.prop({
        disabled: true,
        readonly: true,
      });
      Input.textareaResizableShadow = $shadowEl;
    },
    textareaResizableShadow: undefined,
    resizeTextarea(textareaEl) {
      const app = this;
      const $textareaEl = $(textareaEl);
      if (!Input.textareaResizableShadow) {
        Input.createTextareaResizableShadow();
      }
      const $shadowEl = Input.textareaResizableShadow;
      if (!$textareaEl.length) return;
      if (!$textareaEl.hasClass('resizable')) return;
      if (Input.textareaResizableShadow.parents().length === 0) {
        app.root.append($shadowEl);
      }

      const styles = win.getComputedStyle($textareaEl[0]);
      ('padding-top padding-bottom padding-left padding-right margin-left margin-right margin-top margin-bottom width font-size font-family font-style font-weight line-height font-variant text-transform letter-spacing border box-sizing display').split(' ').forEach((style) => {
        let styleValue = styles[style];
        if (('font-size line-height letter-spacing width').split(' ').indexOf(style) >= 0) {
          styleValue = styleValue.replace(',', '.');
        }
        $shadowEl.css(style, styleValue);
      });
      const currentHeight = $textareaEl[0].clientHeight;

      $shadowEl.val('');
      const initialHeight = $shadowEl[0].scrollHeight;

      $shadowEl.val($textareaEl.val());
      $shadowEl.css('height', 0);
      const scrollHeight = $shadowEl[0].scrollHeight;

      if (currentHeight !== scrollHeight) {
        if (scrollHeight > initialHeight) {
          $textareaEl.css('height', `${scrollHeight}px`);
        } else if (scrollHeight < currentHeight) {
          $textareaEl.css('height', '');
        }
        if (scrollHeight > initialHeight || scrollHeight < currentHeight) {
          $textareaEl.trigger('textarea:resize', { initialHeight, currentHeight, scrollHeight });
          app.emit('textareaResize', { initialHeight, currentHeight, scrollHeight });
        }
      }
    },
    validate(inputEl) {
      const $inputEl = $(inputEl);
      if (!$inputEl.length) return true;
      const $itemInputEl = $inputEl.parents('.item-input');
      const $inputWrapEl = $inputEl.parents('.input');
      const validity = $inputEl[0].validity;
      const validationMessage = $inputEl.dataset().errorMessage || $inputEl[0].validationMessage || '';
      if (!validity) return true;
      if (!validity.valid) {
        let $errorEl = $inputEl.nextAll('.item-input-error-message, .input-error-message');
        if (validationMessage) {
          if ($errorEl.length === 0) {
            $errorEl = $(`<div class="${$inputWrapEl.length ? 'input-error-message' : 'item-input-error-message'}"></div>`);
            $errorEl.insertAfter($inputEl);
          }
          $errorEl.text(validationMessage);
        }
        if ($errorEl.length > 0) {
          $itemInputEl.addClass('item-input-with-error-message');
          $inputWrapEl.addClass('input-with-error-message');
        }
        $itemInputEl.addClass('item-input-invalid');
        $inputWrapEl.addClass('input-invalid');
        $inputEl.addClass('input-invalid');
        return false;
      }
      $itemInputEl.removeClass('item-input-invalid item-input-with-error-message');
      $inputWrapEl.removeClass('input-invalid input-with-error-message');
      $inputEl.removeClass('input-invalid');
      return true;
    },
    validateInputs(el) {
      const app = this;
      const validates = $(el)
        .find('input, textarea, select')
        .toArray()
        .map((inputEl) => app.input.validate(inputEl));
      return validates.indexOf(false) < 0;
    },
    focus(inputEl) {
      const $inputEl = $(inputEl);
      const type = $inputEl.attr('type');
      if (Input.ignoreTypes.indexOf(type) >= 0) return;
      $inputEl.parents('.item-input').addClass('item-input-focused');
      $inputEl.parents('.input').addClass('input-focused');
      $inputEl.addClass('input-focused');
    },
    blur(inputEl) {
      const $inputEl = $(inputEl);
      $inputEl.parents('.item-input').removeClass('item-input-focused');
      $inputEl.parents('.input').removeClass('input-focused');
      $inputEl.removeClass('input-focused');
    },
    checkEmptyState(inputEl) {
      const app = this;
      let $inputEl = $(inputEl);
      if (!$inputEl.is('input, select, textarea, .item-input [contenteditable]')) {
        $inputEl = $inputEl.find('input, select, textarea, .item-input [contenteditable]').eq(0);
      }
      if (!$inputEl.length) return;
      const isContentEditable = $inputEl[0].hasAttribute('contenteditable');
      let value;
      if (isContentEditable) {
        if ($inputEl.find('.text-editor-placeholder').length) value = '';
        else value = $inputEl.html();
      } else {
        value = $inputEl.val();
      }
      const $itemInputEl = $inputEl.parents('.item-input');
      const $inputWrapEl = $inputEl.parents('.input');
      if ((value && (typeof value === 'string' && value.trim() !== '')) || (Array.isArray(value) && value.length > 0)) {
        $itemInputEl.addClass('item-input-with-value');
        $inputWrapEl.addClass('input-with-value');
        $inputEl.addClass('input-with-value');
        $inputEl.trigger('input:notempty');
        app.emit('inputNotEmpty', $inputEl[0]);
      } else {
        $itemInputEl.removeClass('item-input-with-value');
        $inputWrapEl.removeClass('input-with-value');
        $inputEl.removeClass('input-with-value');
        $inputEl.trigger('input:empty');
        app.emit('inputEmpty', $inputEl[0]);
      }
    },
    scrollIntoView(inputEl, duration = 0, centered, force) {
      const $inputEl = $(inputEl);
      const $scrollableEl = $inputEl.parents('.page-content, .panel, .card-expandable .card-content').eq(0);
      if (!$scrollableEl.length) {
        return false;
      }
      const contentHeight = $scrollableEl[0].offsetHeight;
      const contentScrollTop = $scrollableEl[0].scrollTop;
      const contentPaddingTop = parseInt($scrollableEl.css('padding-top'), 10);
      const contentPaddingBottom = parseInt($scrollableEl.css('padding-bottom'), 10);
      const contentOffsetTop = $scrollableEl.offset().top - contentScrollTop;

      const inputOffsetTop = $inputEl.offset().top - contentOffsetTop;
      const inputHeight = $inputEl[0].offsetHeight;

      const min = (inputOffsetTop + contentScrollTop) - contentPaddingTop;
      const max = ((inputOffsetTop + contentScrollTop) - contentHeight) + contentPaddingBottom + inputHeight;
      const centeredPosition = min + ((max - min) / 2);

      if (contentScrollTop > min) {
        $scrollableEl.scrollTop(centered ? centeredPosition : min, duration);
        return true;
      }
      if (contentScrollTop < max) {
        $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
        return true;
      }
      if (force) {
        $scrollableEl.scrollTop(centered ? centeredPosition : max, duration);
      }
      return false;
    },
    init() {
      const app = this;
      Input.createTextareaResizableShadow();
      function onFocus() {
        const inputEl = this;
        if (app.params.input.scrollIntoViewOnFocus) {
          if (Device.android) {
            $(win).once('resize', () => {
              if (doc && doc.activeElement === inputEl) {
                app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
              }
            });
          } else {
            app.input.scrollIntoView(inputEl, app.params.input.scrollIntoViewDuration, app.params.input.scrollIntoViewCentered, app.params.input.scrollIntoViewAlways);
          }
        }
        app.input.focus(inputEl);
      }
      function onBlur() {
        const $inputEl = $(this);
        const tag = $inputEl[0].nodeName.toLowerCase();
        app.input.blur($inputEl);
        if ($inputEl.dataset().validate || $inputEl.attr('validate') !== null || $inputEl.attr('data-validate-on-blur') !== null) {
          app.input.validate($inputEl);
        }
        // Resize textarea
        if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
          if (Input.textareaResizableShadow) Input.textareaResizableShadow.remove();
        }
      }
      function onChange() {
        const $inputEl = $(this);
        const type = $inputEl.attr('type');
        const tag = $inputEl[0].nodeName.toLowerCase();
        const isContentEditable = $inputEl[0].hasAttribute('contenteditable');
        if (Input.ignoreTypes.indexOf(type) >= 0) return;

        // Check Empty State
        app.input.checkEmptyState($inputEl);
        if (isContentEditable) return;

        // Check validation
        if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
          app.input.validate($inputEl);
        }

        // Resize textarea
        if (tag === 'textarea' && $inputEl.hasClass('resizable')) {
          app.input.resizeTextarea($inputEl);
        }
      }
      function onInvalid(e) {
        const $inputEl = $(this);
        if ($inputEl.attr('data-validate-on-blur') === null && ($inputEl.dataset().validate || $inputEl.attr('validate') !== null)) {
          e.preventDefault();
          app.input.validate($inputEl);
        }
      }
      function clearInput() {
        const $clicked = $(this);
        const $inputEl = $clicked.siblings('input, textarea').eq(0);
        const previousValue = $inputEl.val();
        $inputEl
          .val('')
          .trigger('input change')
          .focus()
          .trigger('input:clear', previousValue);
        app.emit('inputClear', previousValue);
      }
      function preventDefault(e) {
        e.preventDefault();
      }
      $(doc).on('click', '.input-clear-button', clearInput);
      $(doc).on('mousedown', '.input-clear-button', preventDefault);
      $(doc).on('change input', 'input, textarea, select, .item-input [contenteditable]', onChange, true);
      $(doc).on('focus', 'input, textarea, select, .item-input [contenteditable]', onFocus, true);
      $(doc).on('blur', 'input, textarea, select, .item-input [contenteditable]', onBlur, true);
      $(doc).on('invalid', 'input, textarea, select', onInvalid, true);
    },
  };

  var Input$1 = {
    name: 'input',
    params: {
      input: {
        scrollIntoViewOnFocus: Device.android,
        scrollIntoViewCentered: false,
        scrollIntoViewDuration: 0,
        scrollIntoViewAlways: false,
      },
    },
    create() {
      const app = this;
      Utils.extend(app, {
        input: {
          scrollIntoView: Input.scrollIntoView.bind(app),
          focus: Input.focus.bind(app),
          blur: Input.blur.bind(app),
          validate: Input.validate.bind(app),
          validateInputs: Input.validateInputs.bind(app),
          checkEmptyState: Input.checkEmptyState.bind(app),
          resizeTextarea: Input.resizeTextarea.bind(app),
          init: Input.init.bind(app),
        },
      });
    },
    on: {
      init() {
        const app = this;
        app.input.init();
      },
      tabMounted(tabEl) {
        const app = this;
        const $tabEl = $(tabEl);
        $tabEl.find('.item-input, .input').each((itemInputIndex, itemInputEl) => {
          const $itemInputEl = $(itemInputEl);
          $itemInputEl.find('input, select, textarea, [contenteditable]').each((inputIndex, inputEl) => {
            const $inputEl = $(inputEl);
            if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
            app.input.checkEmptyState($inputEl);
          });
        });
        $tabEl.find('textarea.resizable').each((textareaIndex, textareaEl) => {
          app.input.resizeTextarea(textareaEl);
        });
      },
      pageInit(page) {
        const app = this;
        const $pageEl = page.$el;
        $pageEl.find('.item-input, .input').each((itemInputIndex, itemInputEl) => {
          const $itemInputEl = $(itemInputEl);
          $itemInputEl.find('input, select, textarea, [contenteditable]').each((inputIndex, inputEl) => {
            const $inputEl = $(inputEl);
            if (Input.ignoreTypes.indexOf($inputEl.attr('type')) >= 0) return;
            app.input.checkEmptyState($inputEl);
          });
        });
        $pageEl.find('textarea.resizable').each((textareaIndex, textareaEl) => {
          app.input.resizeTextarea(textareaEl);
        });
      },
      'panelBreakpoint panelCollapsedBreakpoint panelResize panelOpen panelSwipeOpen resize viewMasterDetailBreakpoint': function onPanelOpen(instance) {
        const app = this;
        if (instance && instance.$el) {
          instance.$el.find('textarea.resizable').each((textareaIndex, textareaEl) => {
            app.input.resizeTextarea(textareaEl);
          });
        } else {
          $('textarea.resizable').each((textareaIndex, textareaEl) => {
            app.input.resizeTextarea(textareaEl);
          });
        }
      },
    },
  };

  var Checkbox = {
    name: 'checkbox',
  };

  var Radio = {
    name: 'radio',
  };

  class Toggle extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);
      const toggle = this;

      const defaults = {};

      // Extend defaults with modules params
      toggle.useModulesParams(defaults);

      toggle.params = Utils.extend(defaults, params);

      const el = toggle.params.el;
      if (!el) return toggle;

      const $el = $(el);
      if ($el.length === 0) return toggle;

      if ($el[0].f7Toggle) return $el[0].f7Toggle;

      const $inputEl = $el.children('input[type="checkbox"]');

      Utils.extend(toggle, {
        app,
        $el,
        el: $el[0],
        $inputEl,
        inputEl: $inputEl[0],
        disabled: $el.hasClass('disabled') || $inputEl.hasClass('disabled') || $inputEl.attr('disabled') || $inputEl[0].disabled,
      });

      Object.defineProperty(toggle, 'checked', {
        enumerable: true,
        configurable: true,
        set(checked) {
          if (!toggle || typeof toggle.$inputEl === 'undefined') return;
          if (toggle.checked === checked) return;
          $inputEl[0].checked = checked;
          toggle.$inputEl.trigger('change');
        },
        get() {
          return $inputEl[0].checked;
        },
      });

      $el[0].f7Toggle = toggle;

      let isTouched;
      const touchesStart = {};
      let isScrolling;
      let touchesDiff;
      let toggleWidth;
      let touchStartTime;
      let touchStartChecked;
      function handleTouchStart(e) {
        if (isTouched || toggle.disabled) return;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchesDiff = 0;

        isTouched = true;
        isScrolling = undefined;
        touchStartTime = Utils.now();
        touchStartChecked = toggle.checked;

        toggleWidth = $el[0].offsetWidth;
        Utils.nextTick(() => {
          if (isTouched) {
            $el.addClass('toggle-active-state');
          }
        });
      }
      function handleTouchMove(e) {
        if (!isTouched || toggle.disabled) return;
        const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        const inverter = app.rtl ? -1 : 1;

        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
        }
        if (isScrolling) {
          isTouched = false;
          return;
        }
        e.preventDefault();

        touchesDiff = pageX - touchesStart.x;


        let changed;
        if (touchesDiff * inverter < 0 && Math.abs(touchesDiff) > toggleWidth / 3 && touchStartChecked) {
          changed = true;
        }
        if (touchesDiff * inverter > 0 && Math.abs(touchesDiff) > toggleWidth / 3 && !touchStartChecked) {
          changed = true;
        }
        if (changed) {
          touchesStart.x = pageX;
          toggle.checked = !touchStartChecked;
          touchStartChecked = !touchStartChecked;
        }
      }
      function handleTouchEnd() {
        if (!isTouched || toggle.disabled) {
          if (isScrolling) $el.removeClass('toggle-active-state');
          isTouched = false;
          return;
        }
        const inverter = app.rtl ? -1 : 1;
        isTouched = false;

        $el.removeClass('toggle-active-state');

        let changed;
        if ((Utils.now() - touchStartTime) < 300) {
          if (touchesDiff * inverter < 0 && touchStartChecked) {
            changed = true;
          }
          if (touchesDiff * inverter > 0 && !touchStartChecked) {
            changed = true;
          }
          if (changed) {
            toggle.checked = !touchStartChecked;
          }
        }
      }
      function handleInputChange() {
        toggle.$el.trigger('toggle:change');
        toggle.emit('local::change toggleChange', toggle);
      }
      toggle.attachEvents = function attachEvents() {
        const passive = Support.passiveListener ? { passive: true } : false;
        $el.on(app.touchEvents.start, handleTouchStart, passive);
        app.on('touchmove', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        toggle.$inputEl.on('change', handleInputChange);
      };
      toggle.detachEvents = function detachEvents() {
        const passive = Support.passiveListener ? { passive: true } : false;
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        toggle.$inputEl.off('change', handleInputChange);
      };

      // Install Modules
      toggle.useModules();

      // Init
      toggle.init();
    }

    toggle() {
      const toggle = this;
      toggle.checked = !toggle.checked;
    }

    init() {
      const toggle = this;
      toggle.attachEvents();
    }

    destroy() {
      let toggle = this;
      toggle.$el.trigger('toggle:beforedestroy');
      toggle.emit('local::beforeDestroy toggleBeforeDestroy', toggle);
      delete toggle.$el[0].f7Toggle;
      toggle.detachEvents();
      Utils.deleteProps(toggle);
      toggle = null;
    }
  }

  var Toggle$1 = {
    name: 'toggle',
    create() {
      const app = this;
      app.toggle = ConstructorMethods({
        defaultSelector: '.toggle',
        constructor: Toggle,
        app,
        domProp: 'f7Toggle',
      });
    },
    static: {
      Toggle,
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.toggle-init').each((index, toggleEl) => app.toggle.create({ el: toggleEl }));
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.toggle-init').each((index, toggleEl) => {
          if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.toggle-init').each((index, toggleEl) => app.toggle.create({ el: toggleEl }));
      },
      pageBeforeRemove(page) {
        page.$el.find('.toggle-init').each((index, toggleEl) => {
          if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
        });
      },
    },
    vnode: {
      'toggle-init': {
        insert(vnode) {
          const app = this;
          const toggleEl = vnode.elm;
          app.toggle.create({ el: toggleEl });
        },
        destroy(vnode) {
          const toggleEl = vnode.elm;
          if (toggleEl.f7Toggle) toggleEl.f7Toggle.destroy();
        },
      },
    },
  };

  class Range extends Framework7Class {
    constructor(app, params) {
      super(params, [app]);

      const range = this;

      const defaults = {
        el: null,
        inputEl: null,
        dual: false,
        step: 1,
        label: false,
        min: 0,
        max: 100,
        value: 0,
        draggableBar: true,
        vertical: false,
        verticalReversed: false,
        formatLabel: null,
        scale: false,
        scaleSteps: 5,
        scaleSubSteps: 0,
        formatScaleLabel: null,
        limitKnobPosition: app.theme === 'ios',
      };

      // Extend defaults with modules params
      range.useModulesParams(defaults);

      range.params = Utils.extend(defaults, params);

      const el = range.params.el;
      if (!el) return range;

      const $el = $(el);
      if ($el.length === 0) return range;

      if ($el[0].f7Range) return $el[0].f7Range;

      const dataset = $el.dataset();

      ('step min max value scaleSteps scaleSubSteps').split(' ').forEach((paramName) => {
        if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
          range.params[paramName] = parseFloat(dataset[paramName]);
        }
      });
      ('dual label vertical verticalReversed scale').split(' ').forEach((paramName) => {
        if (typeof params[paramName] === 'undefined' && typeof dataset[paramName] !== 'undefined') {
          range.params[paramName] = dataset[paramName];
        }
      });

      if (!range.params.value) {
        if (typeof dataset.value !== 'undefined') range.params.value = dataset.value;
        if (typeof dataset.valueLeft !== 'undefined' && typeof dataset.valueRight !== 'undefined') {
          range.params.value = [parseFloat(dataset.valueLeft), parseFloat(dataset.valueRight)];
        }
      }

      let $inputEl;
      if (!range.params.dual) {
        if (range.params.inputEl) {
          $inputEl = $(range.params.inputEl);
        } else if ($el.find('input[type="range"]').length) {
          $inputEl = $el.find('input[type="range"]').eq(0);
        }
      }

      const {
        dual, step, label, min, max, value, vertical, verticalReversed, scale, scaleSteps, scaleSubSteps, limitKnobPosition,
      } = range.params;

      Utils.extend(range, {
        app,
        $el,
        el: $el[0],
        $inputEl,
        inputEl: $inputEl ? $inputEl[0] : undefined,
        dual,
        step,
        label,
        min,
        max,
        value,
        previousValue: value,
        vertical,
        verticalReversed,
        scale,
        scaleSteps,
        scaleSubSteps,
        limitKnobPosition,
      });

      if ($inputEl) {
        ('step min max').split(' ').forEach((paramName) => {
          if (!params[paramName] && $inputEl.attr(paramName)) {
            range.params[paramName] = parseFloat($inputEl.attr(paramName));
            range[paramName] = parseFloat($inputEl.attr(paramName));
          }
        });
        if (typeof $inputEl.val() !== 'undefined') {
          range.params.value = parseFloat($inputEl.val());
          range.value = parseFloat($inputEl.val());
        }
      }

      // Dual
      if (range.dual) {
        $el.addClass('range-slider-dual');
      }
      if (range.label) {
        $el.addClass('range-slider-label');
      }

      // Vertical
      if (range.vertical) {
        $el.addClass('range-slider-vertical');
        if (range.verticalReversed) {
          $el.addClass('range-slider-vertical-reversed');
        }
      } else {
        $el.addClass('range-slider-horizontal');
      }

      // Check for layout
      const $barEl = $('<div class="range-bar"></div>');
      const $barActiveEl = $('<div class="range-bar-active"></div>');
      $barEl.append($barActiveEl);

      // Create Knobs
      const knobHTML = `
      <div class="range-knob-wrap">
        <div class="range-knob"></div>
        ${range.label ? '<div class="range-knob-label"></div>' : ''}
      </div>
    `;
      const knobs = [$(knobHTML)];

      if (range.dual) {
        knobs.push($(knobHTML));
      }

      $el.append($barEl);
      knobs.forEach(($knobEl) => {
        $el.append($knobEl);
      });

      // Labels
      const labels = [];
      if (range.label) {
        labels.push(knobs[0].find('.range-knob-label'));
        if (range.dual) {
          labels.push(knobs[1].find('.range-knob-label'));
        }
      }

      // Scale
      let $scaleEl;
      if (range.scale && range.scaleSteps > 1) {
        $scaleEl = $(`
        <div class="range-scale">
          ${range.renderScale()}
        </div>
      `);
        $el.append($scaleEl);
      }

      Utils.extend(range, {
        knobs,
        labels,
        $barEl,
        $barActiveEl,
        $scaleEl,
      });

      $el[0].f7Range = range;

      // Touch Events
      let isTouched;
      const touchesStart = {};
      let isScrolling;
      let rangeOffset;
      let rangeOffsetLeft;
      let rangeOffsetTop;
      let $touchedKnobEl;
      let dualValueIndex;
      let valueChangedByTouch;
      let targetTouchIdentifier;
      function onTouchChange() {
        valueChangedByTouch = true;
      }
      function handleTouchStart(e) {
        if (isTouched) return;
        if (!range.params.draggableBar) {
          if ($(e.target).closest('.range-knob').length === 0) {
            return;
          }
        }
        valueChangedByTouch = false;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        if (e.type === 'touchstart') {
          targetTouchIdentifier = e.targetTouches[0].identifier;
        }

        isTouched = true;
        isScrolling = undefined;
        rangeOffset = $el.offset();
        rangeOffsetLeft = rangeOffset.left;
        rangeOffsetTop = rangeOffset.top;

        let progress;
        if (range.vertical) {
          progress = (touchesStart.y - rangeOffsetTop) / range.rangeHeight;
          if (!range.verticalReversed) progress = 1 - progress;
        } else if (range.app.rtl) {
          progress = ((rangeOffsetLeft + range.rangeWidth) - touchesStart.x) / range.rangeWidth;
        } else {
          progress = (touchesStart.x - rangeOffsetLeft) / range.rangeWidth;
        }

        let newValue = (progress * (range.max - range.min)) + range.min;
        if (range.dual) {
          if (Math.abs(range.value[0] - newValue) < Math.abs(range.value[1] - newValue)) {
            dualValueIndex = 0;
            $touchedKnobEl = range.knobs[0];
            newValue = [newValue, range.value[1]];
          } else {
            dualValueIndex = 1;
            $touchedKnobEl = range.knobs[1];
            newValue = [range.value[0], newValue];
          }
        } else {
          $touchedKnobEl = range.knobs[0];
          newValue = (progress * (range.max - range.min)) + range.min;
        }
        Utils.nextTick(() => {
          if (isTouched) $touchedKnobEl.addClass('range-knob-active-state');
        }, 70);
        range.on('change', onTouchChange);
        range.setValue(newValue, true);
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        let pageX;
        let pageY;
        if (e.type === 'touchmove') {
          for (let i = 0; i < e.targetTouches.length; i += 1) {
            if (e.targetTouches[i].identifier === targetTouchIdentifier) {
              pageX = e.targetTouches[i].pageX;
              pageY = e.targetTouches[i].pageY;
            }
          }
        } else {
          pageX = e.pageX;
          pageY = e.pageY;
        }
        if (typeof pageX === 'undefined' && typeof pageY === 'undefined') return;

        if (typeof isScrolling === 'undefined' && !range.vertical) {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
        }
        if (isScrolling) {
          isTouched = false;
          return;
        }
        e.preventDefault();

        let progress;
        if (range.vertical) {
          progress = (pageY - rangeOffsetTop) / range.rangeHeight;
          if (!range.verticalReversed) progress = 1 - progress;
        } else if (range.app.rtl) {
          progress = ((rangeOffsetLeft + range.rangeWidth) - pageX) / range.rangeWidth;
        } else {
          progress = (pageX - rangeOffsetLeft) / range.rangeWidth;
        }

        let newValue = (progress * (range.max - range.min)) + range.min;
        if (range.dual) {
          let leftValue;
          let rightValue;
          if (dualValueIndex === 0) {
            leftValue = newValue;
            rightValue = range.value[1];
            if (leftValue > rightValue) {
              rightValue = leftValue;
            }
          } else {
            leftValue = range.value[0];
            rightValue = newValue;
            if (rightValue < leftValue) {
              leftValue = rightValue;
            }
          }
          newValue = [leftValue, rightValue];
        }
        range.setValue(newValue, true);
      }
      function handleTouchEnd(e) {
        if (e.type === 'touchend') {
          let touchEnded;
          for (let i = 0; i < e.changedTouches.length; i += 1) {
            if (e.changedTouches[i].identifier === targetTouchIdentifier) touchEnded = true;
          }
          if (!touchEnded) return;
        }
        if (!isTouched) {
          if (isScrolling) $touchedKnobEl.removeClass('range-knob-active-state');
          isTouched = false;
          return;
        }
        range.off('change', onTouchChange);
        isTouched = false;
        $touchedKnobEl.removeClass('range-knob-active-state');
        if (valueChangedByTouch && range.$inputEl && !range.dual) {
          range.$inputEl.trigger('change');
        }
        valueChangedByTouch = false;
        if (typeof range.previousValue !== 'undefined') {
          if (
            (
              range.dual
              && (
                range.previousValue[0] !== range.value[0]
                || range.previousValue[1] !== range.value[1]
              )
            )
            || (
              !range.dual
              && range.previousValue !== range.value
            )
          ) {
            range.$el.trigger('range:changed', range.value);
            range.emit('local::changed rangeChanged', range, range.value);
          }
        }
      }

      function handleResize() {
        range.calcSize();
        range.layout();
      }
      let parentModals;
      let parentPanel;
      let parentPage;
      range.attachEvents = function attachEvents() {
        const passive = Support.passiveListener ? { passive: true } : false;
        range.$el.on(app.touchEvents.start, handleTouchStart, passive);
        app.on('touchmove', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        app.on('tabShow', handleResize);
        app.on('resize', handleResize);
        parentModals = range.$el.parents('.sheet-modal, .actions-modal, .popup, .popover, .login-screen, .dialog, .toast');
        parentModals.on('modal:open', handleResize);
        parentPanel = range.$el.parents('.panel');
        parentPanel.on('panel:open', handleResize);
        parentPage = range.$el.parents('.page').eq(0);
        parentPage.on('page:reinit', handleResize);
      };
      range.detachEvents = function detachEvents() {
        const passive = Support.passiveListener ? { passive: true } : false;
        range.$el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        app.off('tabShow', handleResize);
        app.off('resize', handleResize);
        if (parentModals) {
          parentModals.off('modal:open', handleResize);
        }
        if (parentPanel) {
          parentPanel.off('panel:open', handleResize);
        }
        if (parentPage) {
          parentPage.off('page:reinit', handleResize);
        }
        parentModals = null;
        parentPanel = null;
        parentPage = null;
      };

      // Install Modules
      range.useModules();

      // Init
      range.init();

      return range;
    }

    calcSize() {
      const range = this;
      if (range.vertical) {
        const height = range.$el.outerHeight();
        if (height === 0) return;
        range.rangeHeight = height;
        range.knobHeight = range.knobs[0].outerHeight();
      } else {
        const width = range.$el.outerWidth();
        if (width === 0) return;
        range.rangeWidth = width;
        range.knobWidth = range.knobs[0].outerWidth();
      }
    }

    layout() {
      const range = this;
      const {
        app,
        knobWidth,
        knobHeight,
        rangeWidth,
        rangeHeight,
        min,
        max,
        knobs,
        $barActiveEl,
        value,
        label,
        labels,
        vertical,
        verticalReversed,
        limitKnobPosition,
      } = range;
      const knobSize = vertical ? knobHeight : knobWidth;
      const rangeSize = vertical ? rangeHeight : rangeWidth;
      // eslint-disable-next-line
      const positionProperty = vertical
        ? (verticalReversed ? 'top' : 'bottom')
        : (app.rtl ? 'right' : 'left');
      if (range.dual) {
        const progress = [((value[0] - min) / (max - min)), ((value[1] - min) / (max - min))];
        $barActiveEl.css({
          [positionProperty]: `${progress[0] * 100}%`,
          [vertical ? 'height' : 'width']: `${(progress[1] - progress[0]) * 100}%`,
        });
        knobs.forEach(($knobEl, knobIndex) => {
          let startPos = rangeSize * progress[knobIndex];
          if (limitKnobPosition) {
            const realStartPos = (rangeSize * progress[knobIndex]) - (knobSize / 2);
            if (realStartPos < 0) startPos = knobSize / 2;
            if ((realStartPos + knobSize) > rangeSize) startPos = rangeSize - (knobSize / 2);
          }
          $knobEl.css(positionProperty, `${startPos}px`);
          if (label) labels[knobIndex].text(range.formatLabel(value[knobIndex], labels[knobIndex][0]));
        });
      } else {
        const progress = ((value - min) / (max - min));
        $barActiveEl.css(vertical ? 'height' : 'width', `${progress * 100}%`);

        let startPos = rangeSize * progress;
        if (limitKnobPosition) {
          const realStartPos = (rangeSize * progress) - (knobSize / 2);
          if (realStartPos < 0) startPos = knobSize / 2;
          if ((realStartPos + knobSize) > rangeSize) startPos = rangeSize - (knobSize / 2);
        }
        knobs[0].css(positionProperty, `${startPos}px`);
        if (label) labels[0].text(range.formatLabel(value, labels[0][0]));
      }
      if ((range.dual && value.indexOf(min) >= 0) || (!range.dual && value === min)) {
        range.$el.addClass('range-slider-min');
      } else {
        range.$el.removeClass('range-slider-min');
      }
      if ((range.dual && value.indexOf(max) >= 0) || (!range.dual && value === max)) {
        range.$el.addClass('range-slider-max');
      } else {
        range.$el.removeClass('range-slider-max');
      }
    }

    setValue(newValue, byTouchMove) {
      const range = this;
      const { step, min, max } = range;
      let valueChanged;
      let oldValue;
      if (range.dual) {
        oldValue = [range.value[0], range.value[1]];
        let newValues = newValue;
        if (!Array.isArray(newValues)) newValues = [newValue, newValue];
        if (newValue[0] > newValue[1]) {
          newValues = [newValues[0], newValues[0]];
        }
        newValues = newValues.map(value => Math.max(Math.min(Math.round(value / step) * step, max), min));
        if (newValues[0] === range.value[0] && newValues[1] === range.value[1]) {
          return range;
        }
        newValues.forEach((value, valueIndex) => {
          range.value[valueIndex] = value;
        });
        valueChanged = oldValue[0] !== newValues[0] || oldValue[1] !== newValues[1];
        range.layout();
      } else {
        oldValue = range.value;
        const value = Math.max(Math.min(Math.round(newValue / step) * step, max), min);
        range.value = value;
        range.layout();
        valueChanged = oldValue !== value;
      }

      if (valueChanged) {
        range.previousValue = oldValue;
      }
      // Events
      if (!valueChanged) return range;
      range.$el.trigger('range:change', range.value);
      if (range.$inputEl && !range.dual) {
        range.$inputEl.val(range.value);
        if (!byTouchMove) {
          range.$inputEl.trigger('input change');
        } else {
          range.$inputEl.trigger('input');
        }
      }
      if (!byTouchMove) {
        range.$el.trigger('range:changed', range.value);
        range.emit('local::changed rangeChanged', range, range.value);
      }
      range.emit('local::change rangeChange', range, range.value);
      return range;
    }

    getValue() {
      return this.value;
    }

    formatLabel(value, labelEl) {
      const range = this;
      if (range.params.formatLabel) return range.params.formatLabel.call(range, value, labelEl);
      return value;
    }

    formatScaleLabel(value) {
      const range = this;
      if (range.params.formatScaleLabel) return range.params.formatScaleLabel.call(range, value);
      return value;
    }

    renderScale() {
      const range = this;
      const { app, verticalReversed, vertical } = range;

      // eslint-disable-next-line
      const positionProperty = vertical
        ? (verticalReversed ? 'top' : 'bottom')
        : (app.rtl ? 'right' : 'left');

      let html = '';

      Array
        .from({ length: range.scaleSteps + 1 })
        .forEach((scaleEl, index) => {
          const scaleStepValue = (range.max - range.min) / range.scaleSteps;
          const scaleValue = range.min + scaleStepValue * index;
          const progress = ((scaleValue - range.min) / (range.max - range.min));
          html += `<div class="range-scale-step" style="${positionProperty}: ${progress * 100}%">${range.formatScaleLabel(scaleValue)}</div>`;

          if (range.scaleSubSteps && range.scaleSubSteps > 1 && index < range.scaleSteps) {
            Array
              .from({ length: range.scaleSubSteps - 1 })
              .forEach((subStepEl, subIndex) => {
                const subStep = scaleStepValue / range.scaleSubSteps;
                const scaleSubValue = scaleValue + subStep * (subIndex + 1);
                const subProgress = ((scaleSubValue - range.min) / (range.max - range.min));
                html += `<div class="range-scale-step range-scale-substep" style="${positionProperty}: ${subProgress * 100}%"></div>`;
              });
          }
        });

      return html;
    }

    updateScale() {
      const range = this;
      if (!range.scale || range.scaleSteps < 2) {
        if (range.$scaleEl) range.$scaleEl.remove();
        delete range.$scaleEl;
        return;
      }
      if (!range.$scaleEl) {
        range.$scaleEl = $('<div class="range-scale"></div>');
        range.$el.append(range.$scaleEl);
      }

      range.$scaleEl.html(range.renderScale());
    }

    init() {
      const range = this;
      range.calcSize();
      range.layout();
      range.attachEvents();
      return range;
    }

    destroy() {
      let range = this;
      range.$el.trigger('range:beforedestroy');
      range.emit('local::beforeDestroy rangeBeforeDestroy', range);
      delete range.$el[0].f7Range;
      range.detachEvents();
      Utils.deleteProps(range);
      range = null;
    }
  }

  var Range$1 = {
    name: 'range',
    create() {
      const app = this;
      app.range = Utils.extend(
        ConstructorMethods({
          defaultSelector: '.range-slider',
          constructor: Range,
          app,
          domProp: 'f7Range',
        }),
        {
          getValue(el = '.range-slider') {
            const range = app.range.get(el);
            if (range) return range.getValue();
            return undefined;
          },
          setValue(el = '.range-slider', value) {
            const range = app.range.get(el);
            if (range) return range.setValue(value);
            return undefined;
          },
        }
      );
    },
    static: {
      Range,
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.range-slider-init').each((index, rangeEl) => new Range(app, {
          el: rangeEl,
        }));
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.range-slider-init').each((index, rangeEl) => {
          if (rangeEl.f7Range) rangeEl.f7Range.destroy();
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.range-slider-init').each((index, rangeEl) => new Range(app, {
          el: rangeEl,
        }));
      },
      pageBeforeRemove(page) {
        page.$el.find('.range-slider-init').each((index, rangeEl) => {
          if (rangeEl.f7Range) rangeEl.f7Range.destroy();
        });
      },
    },
    vnode: {
      'range-slider-init': {
        insert(vnode) {
          const rangeEl = vnode.elm;
          const app = this;
          app.range.create({ el: rangeEl });
        },
        destroy(vnode) {
          const rangeEl = vnode.elm;
          if (rangeEl.f7Range) rangeEl.f7Range.destroy();
        },
      },
    },
  };

  class Stepper extends Framework7Class {
    constructor(app, params) {
      super(params, [app]);
      const stepper = this;

      const defaults = {
        el: null,
        inputEl: null,
        valueEl: null,
        value: 0,
        formatValue: null,
        step: 1,
        min: 0,
        max: 100,
        watchInput: true,
        autorepeat: false,
        autorepeatDynamic: false,
        wraps: false,
        manualInputMode: false,
        decimalPoint: 4,
        buttonsEndInputMode: true,
      };

      // Extend defaults with modules params
      stepper.useModulesParams(defaults);

      stepper.params = Utils.extend(defaults, params);
      if (stepper.params.value < stepper.params.min) {
        stepper.params.value = stepper.params.min;
      }
      if (stepper.params.value > stepper.params.max) {
        stepper.params.value = stepper.params.max;
      }

      const el = stepper.params.el;
      if (!el) return stepper;

      const $el = $(el);
      if ($el.length === 0) return stepper;

      if ($el[0].f7Stepper) return $el[0].f7Stepper;

      let $inputEl;
      if (stepper.params.inputEl) {
        $inputEl = $(stepper.params.inputEl);
      } else if ($el.find('.stepper-input-wrap').find('input, textarea').length) {
        $inputEl = $el.find('.stepper-input-wrap').find('input, textarea').eq(0);
      }

      if ($inputEl && $inputEl.length) {
        ('step min max').split(' ').forEach((paramName) => {
          if (!params[paramName] && $inputEl.attr(paramName)) {
            stepper.params[paramName] = parseFloat($inputEl.attr(paramName));
          }
        });

        const decimalPoint = parseInt(stepper.params.decimalPoint, 10);
        if (Number.isNaN(decimalPoint)) {
          stepper.params.decimalPoint = 0;
        } else {
          stepper.params.decimalPoint = decimalPoint;
        }

        const inputValue = parseFloat($inputEl.val());
        if (typeof params.value === 'undefined' && !Number.isNaN(inputValue) && (inputValue || inputValue === 0)) {
          stepper.params.value = inputValue;
        }
      }

      let $valueEl;
      if (stepper.params.valueEl) {
        $valueEl = $(stepper.params.valueEl);
      } else if ($el.find('.stepper-value').length) {
        $valueEl = $el.find('.stepper-value').eq(0);
      }

      const $buttonPlusEl = $el.find('.stepper-button-plus');
      const $buttonMinusEl = $el.find('.stepper-button-minus');

      const { step, min, max, value, decimalPoint } = stepper.params;

      Utils.extend(stepper, {
        app,
        $el,
        el: $el[0],
        $buttonPlusEl,
        buttonPlusEl: $buttonPlusEl[0],
        $buttonMinusEl,
        buttonMinusEl: $buttonMinusEl[0],
        $inputEl,
        inputEl: $inputEl ? $inputEl[0] : undefined,
        $valueEl,
        valueEl: $valueEl ? $valueEl[0] : undefined,
        step,
        min,
        max,
        value,
        decimalPoint,
        typeModeChanged: false,
      });

      $el[0].f7Stepper = stepper;

      // Handle Events
      const touchesStart = {};
      let isTouched;
      let isScrolling;
      let preventButtonClick;
      let intervalId;
      let timeoutId;
      let autorepeatAction = null;
      let autorepeatInAction = false;
      let manualInput = false;

      function dynamicRepeat(current, progressions, startsIn, progressionStep, repeatEvery, action) {
        clearTimeout(timeoutId);
        timeoutId = setTimeout(() => {
          if (current === 1) {
            preventButtonClick = true;
            autorepeatInAction = true;
          }
          clearInterval(intervalId);
          action();
          intervalId = setInterval(() => {
            action();
          }, repeatEvery);
          if (current < progressions) {
            dynamicRepeat(current + 1, progressions, startsIn, progressionStep, repeatEvery / 2, action);
          }
        }, current === 1 ? startsIn : progressionStep);
      }

      function onTouchStart(e) {
        if (isTouched) return;
        if (manualInput) { return; }
        if ($(e.target).closest($buttonPlusEl).length) {
          autorepeatAction = 'increment';
        } else if ($(e.target).closest($buttonMinusEl).length) {
          autorepeatAction = 'decrement';
        }
        if (!autorepeatAction) return;

        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        isTouched = true;
        isScrolling = undefined;

        const progressions = stepper.params.autorepeatDynamic ? 4 : 1;
        dynamicRepeat(1, progressions, 500, 1000, 300, () => {
          stepper[autorepeatAction]();
        });
      }
      function onTouchMove(e) {
        if (!isTouched) return;
        if (manualInput) { return; }
        const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

        if (typeof isScrolling === 'undefined' && !autorepeatInAction) {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
        }
        const distance = (((pageX - touchesStart.x) ** 2) + ((pageY - touchesStart.y) ** 2)) ** 0.5;

        if (isScrolling || distance > 20) {
          isTouched = false;
          clearTimeout(timeoutId);
          clearInterval(intervalId);
        }
      }
      function onTouchEnd() {
        clearTimeout(timeoutId);
        clearInterval(intervalId);
        autorepeatAction = null;
        autorepeatInAction = false;
        isTouched = false;
      }

      function onMinusClick() {
        if (manualInput) {
          if (stepper.params.buttonsEndInputMode) {
            manualInput = false;
            stepper.endTypeMode(true);
          }
          return;
        }
        if (preventButtonClick) {
          preventButtonClick = false;
          return;
        }
        stepper.decrement(true);
      }
      function onPlusClick() {
        if (manualInput) {
          if (stepper.params.buttonsEndInputMode) {
            manualInput = false;
            stepper.endTypeMode(true);
          }
          return;
        }
        if (preventButtonClick) {
          preventButtonClick = false;
          return;
        }
        stepper.increment(true);
      }
      function onInputClick(e) {
        if (!e.target.readOnly && stepper.params.manualInputMode) {
          manualInput = true;
          if (typeof e.target.selectionStart === 'number') {
            e.target.selectionStart = e.target.value.length;
            e.target.selectionEnd = e.target.value.length;
          }
        }
      }
      function onInputKey(e) {
        if (e.keyCode === 13 || e.which === 13) {
          e.preventDefault();
          manualInput = false;
          stepper.endTypeMode();
        }
      }
      function onInputBlur() {
        manualInput = false;
        stepper.endTypeMode(true);
      }
      function onInput(e) {
        if (manualInput) {
          stepper.typeValue(e.target.value);
          return;
        }
        if (e.detail && e.detail.sentByF7Stepper) return;
        stepper.setValue(e.target.value, true);
      }
      stepper.attachEvents = function attachEvents() {
        $buttonMinusEl.on('click', onMinusClick);
        $buttonPlusEl.on('click', onPlusClick);
        if (stepper.params.watchInput && $inputEl && $inputEl.length) {
          $inputEl.on('input', onInput);
          $inputEl.on('click', onInputClick);
          $inputEl.on('blur', onInputBlur);
          $inputEl.on('keyup', onInputKey);
        }
        if (stepper.params.autorepeat) {
          app.on('touchstart:passive', onTouchStart);
          app.on('touchmove:active', onTouchMove);
          app.on('touchend:passive', onTouchEnd);
        }
      };
      stepper.detachEvents = function detachEvents() {
        $buttonMinusEl.off('click', onMinusClick);
        $buttonPlusEl.off('click', onPlusClick);
        if (stepper.params.watchInput && $inputEl && $inputEl.length) {
          $inputEl.off('input', onInput);
          $inputEl.off('click', onInputClick);
          $inputEl.off('blur', onInputBlur);
          $inputEl.off('keyup', onInputKey);
        }
      };

      // Install Modules
      stepper.useModules();

      // Init
      stepper.init();

      return stepper;
    }

    minus() {
      return this.decrement();
    }

    plus() {
      return this.increment();
    }

    decrement() {
      const stepper = this;
      return stepper.setValue(stepper.value - stepper.step, false, true);
    }

    increment() {
      const stepper = this;
      return stepper.setValue(stepper.value + stepper.step, false, true);
    }

    setValue(newValue, forceUpdate, withWraps) {
      const stepper = this;
      const { step, min, max } = stepper;

      const oldValue = stepper.value;

      let value = Math.round(newValue / step) * step;
      if (stepper.params.wraps && withWraps) {
        if (value > max) value = min;
        if (value < min) value = max;
      } else {
        value = Math.max(Math.min(value, max), min);
      }

      if (Number.isNaN(value)) {
        value = oldValue;
      }
      stepper.value = value;

      const valueChanged = oldValue !== value;

      // Events
      if (!valueChanged && !forceUpdate) return stepper;

      stepper.$el.trigger('stepper:change', stepper.value);
      const formattedValue = stepper.formatValue(stepper.value);
      if (stepper.$inputEl && stepper.$inputEl.length) {
        stepper.$inputEl.val(formattedValue);
        stepper.$inputEl.trigger('input change', { sentByF7Stepper: true });
      }
      if (stepper.$valueEl && stepper.$valueEl.length) {
        stepper.$valueEl.html(formattedValue);
      }
      stepper.emit('local::change stepperChange', stepper, stepper.value);
      return stepper;
    }

    endTypeMode(noBlur) {
      const stepper = this;
      const { min, max } = stepper;
      let value = parseFloat(stepper.value);

      if (Number.isNaN(value)) value = 0;

      value = Math.max(Math.min(value, max), min);

      stepper.value = value;
      if (!stepper.typeModeChanged) {
        if (stepper.$inputEl && stepper.$inputEl.length && !noBlur) {
          stepper.$inputEl.blur();
        }
        return stepper;
      }
      stepper.typeModeChanged = false;

      stepper.$el.trigger('stepper:change', stepper.value);
      const formattedValue = stepper.formatValue(stepper.value);
      if (stepper.$inputEl && stepper.$inputEl.length) {
        stepper.$inputEl.val(formattedValue);
        stepper.$inputEl.trigger('input change', { sentByF7Stepper: true });
        if (!noBlur) stepper.$inputEl.blur();
      }
      if (stepper.$valueEl && stepper.$valueEl.length) {
        stepper.$valueEl.html(formattedValue);
      }
      stepper.emit('local::change stepperChange', stepper, stepper.value);
      return stepper;
    }

    typeValue(value) {
      const stepper = this;
      stepper.typeModeChanged = true;
      let inputTxt = String(value);
      if (inputTxt.lastIndexOf('.') + 1 === inputTxt.length || inputTxt.lastIndexOf(',') + 1 === inputTxt.length) {
        if (inputTxt.lastIndexOf('.') !== inputTxt.indexOf('.') || inputTxt.lastIndexOf(',') !== inputTxt.indexOf(',')) {
          inputTxt = inputTxt.slice(0, -1);
          stepper.value = inputTxt;
          stepper.$inputEl.val(stepper.value);
          return stepper;
        }
      } else {
        let newValue = parseFloat(inputTxt.replace(',', '.'));
        if (newValue === 0) {
          stepper.value = inputTxt.replace(',', '.');
          stepper.$inputEl.val(stepper.value);
          return stepper;
        }
        if (Number.isNaN(newValue)) {
          stepper.value = 0;
          stepper.$inputEl.val(stepper.value);
          return stepper;
        }
        const powVal = 10 ** stepper.params.decimalPoint;
        newValue = (Math.round((newValue) * powVal)).toFixed(stepper.params.decimalPoint + 1) / powVal;
        stepper.value = parseFloat(String(newValue).replace(',', '.'));
        stepper.$inputEl.val(stepper.value);
        return stepper;
      }
      stepper.value = inputTxt;
      stepper.$inputEl.val(inputTxt);
      return stepper;
    }

    getValue() {
      return this.value;
    }

    formatValue(value) {
      const stepper = this;
      if (!stepper.params.formatValue) return value;
      return stepper.params.formatValue.call(stepper, value);
    }

    init() {
      const stepper = this;
      stepper.attachEvents();
      if (stepper.$valueEl && stepper.$valueEl.length) {
        const formattedValue = stepper.formatValue(stepper.value);
        stepper.$valueEl.html(formattedValue);
      }
      return stepper;
    }

    destroy() {
      let stepper = this;
      stepper.$el.trigger('stepper:beforedestroy');
      stepper.emit('local::beforeDestroy stepperBeforeDestroy', stepper);
      delete stepper.$el[0].f7Stepper;
      stepper.detachEvents();
      Utils.deleteProps(stepper);
      stepper = null;
    }
  }

  var Stepper$1 = {
    name: 'stepper',
    create() {
      const app = this;
      app.stepper = Utils.extend(
        ConstructorMethods({
          defaultSelector: '.stepper',
          constructor: Stepper,
          app,
          domProp: 'f7Stepper',
        }),
        {
          getValue(el = '.stepper') {
            const stepper = app.stepper.get(el);
            if (stepper) return stepper.getValue();
            return undefined;
          },
          setValue(el = '.stepper', value) {
            const stepper = app.stepper.get(el);
            if (stepper) return stepper.setValue(value);
            return undefined;
          },
        }
      );
    },
    static: {
      Stepper,
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.stepper-init').each((index, stepperEl) => {
          const dataset = $(stepperEl).dataset();
          app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
        });
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.stepper-init').each((index, stepperEl) => {
          if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.stepper-init').each((index, stepperEl) => {
          const dataset = $(stepperEl).dataset();
          app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
        });
      },
      pageBeforeRemove(page) {
        page.$el.find('.stepper-init').each((index, stepperEl) => {
          if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
        });
      },
    },
    vnode: {
      'stepper-init': {
        insert(vnode) {
          const app = this;
          const stepperEl = vnode.elm;
          const dataset = $(stepperEl).dataset();
          app.stepper.create(Utils.extend({ el: stepperEl }, dataset || {}));
        },
        destroy(vnode) {
          const stepperEl = vnode.elm;
          if (stepperEl.f7Stepper) stepperEl.f7Stepper.destroy();
        },
      },
    },
  };

  class SmartSelect extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);
      const ss = this;

      const defaults = Utils.extend({
        on: {},
      }, app.params.smartSelect);

      if (typeof defaults.searchbarDisableButton === 'undefined') {
        defaults.searchbarDisableButton = app.theme !== 'aurora';
      }

      // Extend defaults with modules params
      ss.useModulesParams(defaults);

      ss.params = Utils.extend({}, defaults, params);

      ss.app = app;

      const $el = $(ss.params.el).eq(0);
      if ($el.length === 0) return ss;

      if ($el[0].f7SmartSelect) return $el[0].f7SmartSelect;

      const $selectEl = $el.find('select').eq(0);
      if ($selectEl.length === 0) return ss;

      let $valueEl;
      if (ss.params.setValueText) {
        $valueEl = $(ss.params.valueEl);
        if ($valueEl.length === 0) {
          $valueEl = $el.find('.item-after');
        }
        if ($valueEl.length === 0) {
          $valueEl = $('<div class="item-after"></div>');
          $valueEl.insertAfter($el.find('.item-title'));
        }
      }

      // Url
      let url = params.url;
      if (!url) {
        if ($el.attr('href') && $el.attr('href') !== '#') url = $el.attr('href');
        else if ($selectEl.attr('name')) url = `${$selectEl.attr('name').toLowerCase()}-select/`;
      }
      if (!url) url = ss.params.url;

      const multiple = $selectEl[0].multiple;
      const inputType = multiple ? 'checkbox' : 'radio';
      const id = Utils.id();

      Utils.extend(ss, {
        $el,
        el: $el[0],
        $selectEl,
        selectEl: $selectEl[0],
        $valueEl,
        valueEl: $valueEl && $valueEl[0],
        url,
        multiple,
        inputType,
        id,
        inputName: `${inputType}-${id}`,
        selectName: $selectEl.attr('name'),
        maxLength: $selectEl.attr('maxlength') || params.maxLength,
      });

      $el[0].f7SmartSelect = ss;

      // Events
      function onClick() {
        ss.open();
      }
      function onChange() {
        const value = ss.$selectEl.val();
        ss.$el.trigger('smartselect:change', value);
        ss.emit('local::change smartSelectChange', ss, value);
        if (ss.vl) {
          ss.vl.clearCache();
        }
        ss.setValueText();
      }
      ss.attachEvents = function attachEvents() {
        $el.on('click', onClick);
        $el.on('change', 'select', onChange);
      };
      ss.detachEvents = function detachEvents() {
        $el.off('click', onClick);
        $el.off('change', 'select', onChange);
      };

      function handleInputChange() {
        let optionEl;
        let text;
        const inputEl = this;
        const value = inputEl.value;
        let optionText = [];
        let displayAs;
        if (inputEl.type === 'checkbox') {
          for (let i = 0; i < ss.selectEl.options.length; i += 1) {
            optionEl = ss.selectEl.options[i];
            if (optionEl.value === value) {
              optionEl.selected = inputEl.checked;
            }
            if (optionEl.selected) {
              displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-value-as');
              text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
              optionText.push(text.trim());
            }
          }
          if (ss.maxLength) {
            ss.checkMaxLength();
          }
        } else {
          optionEl = ss.$selectEl.find(`option[value="${value}"]`)[0];
          displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-as');
          text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
          optionText = [text];
          ss.selectEl.value = value;
        }

        ss.$selectEl.trigger('change');
        if (ss.params.setValueText) {
          ss.$valueEl.text(ss.formatValueText(optionText));
        }
        if (ss.params.closeOnSelect && ss.inputType === 'radio') {
          ss.close();
        }
      }

      ss.attachInputsEvents = function attachInputsEvents() {
        ss.$containerEl.on('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
      };
      ss.detachInputsEvents = function detachInputsEvents() {
        ss.$containerEl.off('change', 'input[type="checkbox"], input[type="radio"]', handleInputChange);
      };

      // Install Modules
      ss.useModules();

      // Init
      ss.init();

      return ss;
    }

    setValue(value) {
      const ss = this;
      let newValue = value;
      let optionText = [];
      let optionEl;
      let displayAs;
      let text;
      if (ss.multiple) {
        if (!Array.isArray(newValue)) newValue = [newValue];
        for (let i = 0; i < ss.selectEl.options.length; i += 1) {
          optionEl = ss.selectEl.options[i];
          if (newValue.indexOf(optionEl.value) >= 0) {
            optionEl.selected = true;
          } else {
            optionEl.selected = false;
          }
          if (optionEl.selected) {
            displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-value-as');
            text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
            optionText.push(text.trim());
          }
        }
      } else {
        optionEl = ss.$selectEl.find(`option[value="${newValue}"]`)[0];
        if (optionEl) {
          displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $(optionEl).data('display-as');
          text = displayAs && typeof displayAs !== 'undefined' ? displayAs : optionEl.textContent;
          optionText = [text];
        }
        ss.selectEl.value = newValue;
      }
      if (ss.params.setValueText) {
        ss.$valueEl.text(ss.formatValueText(optionText));
      }
      ss.$selectEl.trigger('change');
      return ss;
    }

    unsetValue() {
      const ss = this;
      if (ss.params.setValueText) {
        ss.$valueEl.text(ss.formatValueText([]));
      }
      ss.$selectEl.find('option').each((optionIndex, optionEl) => {
        optionEl.selected = false;
        optionEl.checked = false;
      });
      ss.$selectEl[0].value = null;

      if (ss.$containerEl) {
        ss.$containerEl.find(`input[name="${ss.inputName}"][type="checkbox"], input[name="${ss.inputName}"][type="radio"]`).prop('checked', false);
      }
      ss.$selectEl.trigger('change');
    }

    getValue() {
      const ss = this;
      return ss.$selectEl.val();
    }

    get view() {
      const { params, $el } = this;
      let view;
      if (params.view) {
        view = params.view;
      }
      if (!view) {
        view = $el.parents('.view').length && $el.parents('.view')[0].f7View;
      }
      if (!view && params.openIn === 'page') {
        throw Error('Smart Select requires initialized View');
      }
      return view;
    }

    checkMaxLength() {
      const ss = this;
      const $containerEl = ss.$containerEl;
      if (ss.selectEl.selectedOptions.length >= ss.maxLength) {
        $containerEl.find('input[type="checkbox"]').each((index, inputEl) => {
          if (!inputEl.checked) {
            $(inputEl).parents('li').addClass('disabled');
          } else {
            $(inputEl).parents('li').removeClass('disabled');
          }
        });
      } else {
        $containerEl.find('.disabled').removeClass('disabled');
      }
    }

    formatValueText(values) {
      const ss = this;
      let textValue;
      if (ss.params.formatValueText) {
        textValue = ss.params.formatValueText.call(ss, values, ss);
      } else {
        textValue = values.join(', ');
      }
      return textValue;
    }

    setValueText(value) {
      const ss = this;
      let valueArray = [];
      if (typeof value !== 'undefined') {
        if (Array.isArray(value)) {
          valueArray = value;
        } else {
          valueArray = [value];
        }
      } else {
        ss.$selectEl.find('option').each((optionIndex, optionEl) => {
          const $optionEl = $(optionEl);
          if (optionEl.selected) {
            const displayAs = optionEl.dataset ? optionEl.dataset.displayAs : $optionEl.data('display-value-as');
            if (displayAs && typeof displayAs !== 'undefined') {
              valueArray.push(displayAs);
            } else {
              valueArray.push(optionEl.textContent.trim());
            }
          }
        });
      }
      if (ss.params.setValueText) {
        ss.$valueEl.text(ss.formatValueText(valueArray));
      }
    }

    getItemsData() {
      const ss = this;
      const theme = ss.app.theme;
      const items = [];
      let previousGroupEl;
      ss.$selectEl.find('option').each((index, optionEl) => {
        const $optionEl = $(optionEl);
        const optionData = $optionEl.dataset();
        const optionImage = optionData.optionImage || ss.params.optionImage;
        const optionIcon = optionData.optionIcon || ss.params.optionIcon;
        const optionIconIos = theme === 'ios' && (optionData.optionIconIos || ss.params.optionIconIos);
        const optionIconMd = theme === 'md' && (optionData.optionIconMd || ss.params.optionIconMd);
        const optionIconAurora = theme === 'aurora' && (optionData.optionIconAurora || ss.params.optionIconAurora);
        const optionHasMedia = optionImage || optionIcon || optionIconIos || optionIconMd || optionIconAurora;
        const optionColor = optionData.optionColor;

        let optionClassName = optionData.optionClass || '';
        if ($optionEl[0].disabled) optionClassName += ' disabled';

        const optionGroupEl = $optionEl.parent('optgroup')[0];
        const optionGroupLabel = optionGroupEl && optionGroupEl.label;
        let optionIsLabel = false;
        if (optionGroupEl && optionGroupEl !== previousGroupEl) {
          optionIsLabel = true;
          previousGroupEl = optionGroupEl;
          items.push({
            groupLabel: optionGroupLabel,
            isLabel: optionIsLabel,
          });
        }
        items.push({
          value: $optionEl[0].value,
          text: $optionEl[0].textContent.trim(),
          selected: $optionEl[0].selected,
          groupEl: optionGroupEl,
          groupLabel: optionGroupLabel,
          image: optionImage,
          icon: optionIcon,
          iconIos: optionIconIos,
          iconMd: optionIconMd,
          iconAurora: optionIconAurora,
          color: optionColor,
          className: optionClassName,
          disabled: $optionEl[0].disabled,
          id: ss.id,
          hasMedia: optionHasMedia,
          checkbox: ss.inputType === 'checkbox',
          radio: ss.inputType === 'radio',
          inputName: ss.inputName,
          inputType: ss.inputType,
        });
      });
      ss.items = items;
      return items;
    }

    renderSearchbar() {
      const ss = this;
      if (ss.params.renderSearchbar) return ss.params.renderSearchbar.call(ss);
      const searchbarHTML = `
      <form class="searchbar">
        <div class="searchbar-inner">
          <div class="searchbar-input-wrap">
            <input type="search" placeholder="${ss.params.searchbarPlaceholder}"/>
            <i class="searchbar-icon"></i>
            <span class="input-clear-button"></span>
          </div>
          ${ss.params.searchbarDisableButton ? `
          <span class="searchbar-disable-button">${ss.params.searchbarDisableText}</span>
          ` : ''}
        </div>
      </form>
    `;
      return searchbarHTML;
    }

    renderItem(item, index) {
      const ss = this;
      if (ss.params.renderItem) return ss.params.renderItem.call(ss, item, index);

      function getIconContent(iconValue = '') {
        if (iconValue.indexOf(':') >= 0) {
          return iconValue.split(':')[1];
        }
        return '';
      }
      function getIconClass(iconValue = '') {
        if (iconValue.indexOf(':') >= 0) {
          let className = iconValue.split(':')[0];
          if (className === 'f7') className = 'f7-icons';
          if (className === 'material') className = 'material-icons';
          return className;
        }
        return iconValue;
      }

      let itemHtml;
      if (item.isLabel) {
        itemHtml = `<li class="item-divider">${item.groupLabel}</li>`;
      } else {
        let selected = item.selected;
        let disabled;
        if (ss.params.virtualList) {
          const ssValue = ss.getValue();
          selected = ss.multiple ? ssValue.indexOf(item.value) >= 0 : ssValue === item.value;
          if (ss.multiple) {
            disabled = ss.multiple && !selected && ssValue.length === parseInt(ss.maxLength, 10);
          }
        }

        const { icon, iconIos, iconMd, iconAurora } = item;
        const hasIcon = icon || iconIos || iconMd || iconAurora;
        const iconContent = getIconContent(icon || iconIos || iconMd || iconAurora || '');
        const iconClass = getIconClass(icon || iconIos || iconMd || iconAurora || '');

        itemHtml = `
        <li class="${item.className || ''}${disabled ? ' disabled' : ''}">
          <label class="item-${item.inputType} item-content">
            <input type="${item.inputType}" name="${item.inputName}" value="${item.value}" ${selected ? 'checked' : ''}/>
            <i class="icon icon-${item.inputType}"></i>
            ${item.hasMedia ? `
              <div class="item-media">
                ${hasIcon ? `<i class="icon ${iconClass}">${iconContent}</i>` : ''}
                ${item.image ? `<img src="${item.image}">` : ''}
              </div>
            ` : ''}
            <div class="item-inner">
              <div class="item-title${item.color ? ` text-color-${item.color}` : ''}">${item.text}</div>
            </div>
          </label>
        </li>
      `;
      }
      return itemHtml;
    }

    renderItems() {
      const ss = this;
      if (ss.params.renderItems) return ss.params.renderItems.call(ss, ss.items);
      const itemsHtml = `
      ${ss.items.map((item, index) => `${ss.renderItem(item, index)}`).join('')}
    `;
      return itemsHtml;
    }

    renderPage() {
      const ss = this;
      if (ss.params.renderPage) return ss.params.renderPage.call(ss, ss.items);
      let pageTitle = ss.params.pageTitle;
      if (typeof pageTitle === 'undefined') {
        const $itemTitleEl = ss.$el.find('.item-title');
        pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
      }
      const cssClass = ss.params.cssClass;
      const pageHtml = `
      <div class="page smart-select-page ${cssClass}" data-name="smart-select-page" data-select-name="${ss.selectName}">
        <div class="navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}">
          <div class="navbar-bg"></div>
          <div class="navbar-inner sliding ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}">
            <div class="left">
              <a class="link back">
                <i class="icon icon-back"></i>
                <span class="if-not-md">${ss.params.pageBackLinkText}</span>
              </a>
            </div>
            ${pageTitle ? `<div class="title">${pageTitle}</div>` : ''}
            ${ss.params.searchbar ? `<div class="subnavbar">${ss.renderSearchbar()}</div>` : ''}
          </div>
        </div>
        ${ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : ''}
        <div class="page-content">
          <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}">
            <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
          </div>
        </div>
      </div>
    `;
      return pageHtml;
    }

    renderPopup() {
      const ss = this;
      if (ss.params.renderPopup) return ss.params.renderPopup.call(ss, ss.items);
      let pageTitle = ss.params.pageTitle;
      if (typeof pageTitle === 'undefined') {
        const $itemTitleEl = ss.$el.find('.item-title');
        pageTitle = $itemTitleEl.length ? $itemTitleEl.text().trim() : '';
      }
      const cssClass = ss.params.cssClass || '';
      const popupHtml = `
      <div class="popup smart-select-popup ${cssClass} ${ss.params.popupTabletFullscreen ? 'popup-tablet-fullscreen' : ''}" data-select-name="${ss.selectName}">
        <div class="view">
          <div class="page smart-select-page ${ss.params.searchbar ? 'page-with-subnavbar' : ''}" data-name="smart-select-page">
            <div class="navbar ${ss.params.navbarColorTheme ? `color-${ss.params.navbarColorTheme}` : ''}">
              <div class="navbar-bg"></div>
              <div class="navbar-inner sliding">
                ${pageTitle ? `<div class="title">${pageTitle}</div>` : ''}
                <div class="right">
                  <a class="link popup-close" data-popup=".smart-select-popup[data-select-name='${ss.selectName}']">${ss.params.popupCloseLinkText}</span></a>
                </div>
                ${ss.params.searchbar ? `<div class="subnavbar">${ss.renderSearchbar()}</div>` : ''}
              </div>
            </div>
            ${ss.params.searchbar ? '<div class="searchbar-backdrop"></div>' : ''}
            <div class="page-content">
              <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}">
                <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
              </div>
            </div>
          </div>
        </div>
      </div>
    `;
      return popupHtml;
    }

    renderSheet() {
      const ss = this;
      if (ss.params.renderSheet) return ss.params.renderSheet.call(ss, ss.items);
      const cssClass = ss.params.cssClass;
      const sheetHtml = `
      <div class="sheet-modal smart-select-sheet ${cssClass}" data-select-name="${ss.selectName}">
        <div class="toolbar toolbar-top ${ss.params.toolbarColorTheme ? `color-${ss.params.toolbarColorTheme}` : ''}">
          <div class="toolbar-inner">
            <div class="left"></div>
            <div class="right">
              <a class="link sheet-close">${ss.params.sheetCloseLinkText}</a>
            </div>
          </div>
        </div>
        <div class="sheet-modal-inner">
          <div class="page-content">
            <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}">
              <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
            </div>
          </div>
        </div>
      </div>
    `;
      return sheetHtml;
    }

    renderPopover() {
      const ss = this;
      if (ss.params.renderPopover) return ss.params.renderPopover.call(ss, ss.items);
      const cssClass = ss.params.cssClass;
      const popoverHtml = `
      <div class="popover smart-select-popover ${cssClass}" data-select-name="${ss.selectName}">
        <div class="popover-inner">
          <div class="list smart-select-list-${ss.id} ${ss.params.virtualList ? ' virtual-list' : ''} ${ss.params.formColorTheme ? `color-${ss.params.formColorTheme}` : ''}">
            <ul>${!ss.params.virtualList && ss.renderItems(ss.items)}</ul>
          </div>
        </div>
      </div>
    `;
      return popoverHtml;
    }

    scrollToSelectedItem() {
      const ss = this;
      const { params, $containerEl } = ss;
      if (!ss.opened) return ss;
      if (params.virtualList) {
        let selectedIndex;
        ss.vl.items.forEach((item, index) => {
          if (typeof selectedIndex === 'undefined' && item.selected) {
            selectedIndex = index;
          }
        });
        if (typeof selectedIndex !== 'undefined') {
          ss.vl.scrollToItem(selectedIndex);
        }
      } else {
        const $selectedItemEl = $containerEl.find('input:checked').parents('li');
        if (!$selectedItemEl.length) return ss;
        const $pageContentEl = $containerEl.find('.page-content');
        $pageContentEl.scrollTop($selectedItemEl.offset().top - $pageContentEl.offset().top - parseInt($pageContentEl.css('padding-top'), 10));
      }
      return ss;
    }

    onOpen(type, containerEl) {
      const ss = this;
      const app = ss.app;
      const $containerEl = $(containerEl);
      ss.$containerEl = $containerEl;
      ss.openedIn = type;
      ss.opened = true;

      // Init VL
      if (ss.params.virtualList) {
        ss.vl = app.virtualList.create({
          el: $containerEl.find('.virtual-list'),
          items: ss.items,
          renderItem: ss.renderItem.bind(ss),
          height: ss.params.virtualListHeight,
          searchByItem(query, item) {
            if (item.text && item.text.toLowerCase().indexOf(query.trim().toLowerCase()) >= 0) return true;
            return false;
          },
        });
      }
      if (ss.params.scrollToSelectedItem) {
        ss.scrollToSelectedItem();
      }

      // Init SB
      if (ss.params.searchbar) {
        let $searchbarEl = $containerEl.find('.searchbar');
        if (type === 'page' && app.theme === 'ios') {
          $searchbarEl = $(app.navbar.getElByPage($containerEl)).find('.searchbar');
        }

        if (ss.params.appendSearchbarNotFound && (type === 'page' || type === 'popup')) {
          let $notFoundEl = null;

          if (typeof ss.params.appendSearchbarNotFound === 'string') {
            $notFoundEl = $(`<div class="block searchbar-not-found">${ss.params.appendSearchbarNotFound}</div>`);
          } else if (typeof ss.params.appendSearchbarNotFound === 'boolean') {
            $notFoundEl = $('<div class="block searchbar-not-found">Nothing found</div>');
          } else {
            $notFoundEl = ss.params.appendSearchbarNotFound;
          }

          if ($notFoundEl) {
            $containerEl.find('.page-content').append($notFoundEl[0]);
          }
        }

        const searchbarParams = Utils.extend({
          el: $searchbarEl,
          backdropEl: $containerEl.find('.searchbar-backdrop'),
          searchContainer: `.smart-select-list-${ss.id}`,
          searchIn: '.item-title',
        }, typeof ss.params.searchbar === 'object' ? ss.params.searchbar : {});

        ss.searchbar = app.searchbar.create(searchbarParams);
      }

      // Check for max length
      if (ss.maxLength) {
        ss.checkMaxLength();
      }

      // Close on select
      if (ss.params.closeOnSelect) {
        ss.$containerEl.find(`input[type="radio"][name="${ss.inputName}"]:checked`).parents('label').once('click', () => {
          ss.close();
        });
      }

      // Attach input events
      ss.attachInputsEvents();

      ss.$el.trigger('smartselect:open');
      ss.emit('local::open smartSelectOpen', ss);
    }

    onOpened() {
      const ss = this;

      ss.$el.trigger('smartselect:opened');
      ss.emit('local::opened smartSelectOpened', ss);
    }

    onClose() {
      const ss = this;
      if (ss.destroyed) return;

      // Destroy VL
      if (ss.vl && ss.vl.destroy) {
        ss.vl.destroy();
        ss.vl = null;
        delete ss.vl;
      }

      // Destroy SB
      if (ss.searchbar && ss.searchbar.destroy) {
        ss.searchbar.destroy();
        ss.searchbar = null;
        delete ss.searchbar;
      }
      // Detach events
      ss.detachInputsEvents();

      ss.$el.trigger('smartselect:close');
      ss.emit('local::close smartSelectClose', ss);
    }

    onClosed() {
      const ss = this;
      if (ss.destroyed) return;
      ss.opened = false;
      ss.$containerEl = null;
      delete ss.$containerEl;

      ss.$el.trigger('smartselect:closed');
      ss.emit('local::closed smartSelectClosed', ss);
    }

    openPage() {
      const ss = this;
      if (ss.opened) return ss;
      ss.getItemsData();
      const pageHtml = ss.renderPage(ss.items);

      ss.view.router.navigate({
        url: ss.url,
        route: {
          content: pageHtml,
          path: ss.url,
          on: {
            pageBeforeIn(e, page) {
              ss.onOpen('page', page.el);
            },
            pageAfterIn(e, page) {
              ss.onOpened('page', page.el);
            },
            pageBeforeOut(e, page) {
              ss.onClose('page', page.el);
            },
            pageAfterOut(e, page) {
              ss.onClosed('page', page.el);
            },
          },
        },
      });
      return ss;
    }

    openPopup() {
      const ss = this;
      if (ss.opened) return ss;
      ss.getItemsData();
      const popupHtml = ss.renderPopup(ss.items);

      const popupParams = {
        content: popupHtml,
        push: ss.params.popupPush,
        swipeToClose: ss.params.popupSwipeToClose,
        on: {
          popupOpen(popup) {
            ss.onOpen('popup', popup.el);
          },
          popupOpened(popup) {
            ss.onOpened('popup', popup.el);
          },
          popupClose(popup) {
            ss.onClose('popup', popup.el);
          },
          popupClosed(popup) {
            ss.onClosed('popup', popup.el);
          },
        },
      };

      if (ss.params.routableModals && ss.view) {
        ss.view.router.navigate({
          url: ss.url,
          route: {
            path: ss.url,
            popup: popupParams,
          },
        });
      } else {
        ss.modal = ss.app.popup.create(popupParams).open();
      }
      return ss;
    }

    openSheet() {
      const ss = this;
      if (ss.opened) return ss;
      ss.getItemsData();
      const sheetHtml = ss.renderSheet(ss.items);

      const sheetParams = {
        content: sheetHtml,
        backdrop: false,
        scrollToEl: ss.$el,
        closeByOutsideClick: true,
        push: ss.params.sheetPush,
        swipeToClose: ss.params.sheetSwipeToClose,
        on: {
          sheetOpen(sheet) {
            ss.onOpen('sheet', sheet.el);
          },
          sheetOpened(sheet) {
            ss.onOpened('sheet', sheet.el);
          },
          sheetClose(sheet) {
            ss.onClose('sheet', sheet.el);
          },
          sheetClosed(sheet) {
            ss.onClosed('sheet', sheet.el);
          },
        },
      };

      if (ss.params.routableModals && ss.view) {
        ss.view.router.navigate({
          url: ss.url,
          route: {
            path: ss.url,
            sheet: sheetParams,
          },
        });
      } else {
        ss.modal = ss.app.sheet.create(sheetParams).open();
      }
      return ss;
    }

    openPopover() {
      const ss = this;
      if (ss.opened) return ss;
      ss.getItemsData();
      const popoverHtml = ss.renderPopover(ss.items);
      const popoverParams = {
        content: popoverHtml,
        targetEl: ss.$el,
        on: {
          popoverOpen(popover) {
            ss.onOpen('popover', popover.el);
          },
          popoverOpened(popover) {
            ss.onOpened('popover', popover.el);
          },
          popoverClose(popover) {
            ss.onClose('popover', popover.el);
          },
          popoverClosed(popover) {
            ss.onClosed('popover', popover.el);
          },
        },
      };
      if (ss.params.routableModals && ss.view) {
        ss.view.router.navigate({
          url: ss.url,
          route: {
            path: ss.url,
            popover: popoverParams,
          },
        });
      } else {
        ss.modal = ss.app.popover.create(popoverParams).open();
      }
      return ss;
    }

    open(type) {
      const ss = this;
      if (ss.opened) return ss;
      let prevented = false;
      function prevent() {
        prevented = true;
      }
      if (ss.$el) {
        ss.$el.trigger('smartselect:beforeopen', { prevent });
      }
      ss.emit('local::beforeOpen smartSelectBeforeOpen', ss, prevent);
      if (prevented) return ss;
      const openIn = type || ss.params.openIn;
      ss[`open${openIn.split('').map((el, index) => {
      if (index === 0) return el.toUpperCase();
      return el;
    }).join('')}`]();
      return ss;
    }

    close() {
      const ss = this;
      if (!ss.opened) return ss;
      if ((ss.params.routableModals && ss.view) || ss.openedIn === 'page') {
        ss.view.router.back();
      } else {
        ss.modal.once('modalClosed', () => {
          Utils.nextTick(() => {
            if (ss.destroyed) return;
            ss.modal.destroy();
            delete ss.modal;
          });
        });
        ss.modal.close();
      }
      return ss;
    }

    init() {
      const ss = this;
      ss.attachEvents();
      ss.setValueText();
    }

    destroy() {
      const ss = this;
      ss.emit('local::beforeDestroy smartSelectBeforeDestroy', ss);
      ss.$el.trigger('smartselect:beforedestroy');
      ss.detachEvents();
      delete ss.$el[0].f7SmartSelect;
      Utils.deleteProps(ss);
      ss.destroyed = true;
    }
  }

  var SmartSelect$1 = {
    name: 'smartSelect',
    params: {
      smartSelect: {
        el: undefined,
        valueEl: undefined,
        setValueText: true,
        formatValueText: null,
        openIn: 'page', // or 'popup' or 'sheet' or 'popover'
        popupPush: false,
        popupSwipeToClose: undefined, // defaults to app
        sheetPush: false,
        sheetSwipeToClose: undefined, // defaults to app
        pageTitle: undefined,
        pageBackLinkText: 'Back',
        popupCloseLinkText: 'Close',
        popupTabletFullscreen: false,
        sheetCloseLinkText: 'Done',
        searchbar: false,
        searchbarPlaceholder: 'Search',
        searchbarDisableText: 'Cancel',
        searchbarDisableButton: undefined,
        closeOnSelect: false,
        virtualList: false,
        virtualListHeight: undefined,
        scrollToSelectedItem: false,
        formColorTheme: undefined,
        navbarColorTheme: undefined,
        routableModals: true,
        url: 'select/',
        cssClass: '',
        /*
          Custom render functions
        */
        renderPage: undefined,
        renderPopup: undefined,
        renderSheet: undefined,
        renderPopover: undefined,
        renderItems: undefined,
        renderItem: undefined,
        renderSearchbar: undefined,
      },
    },
    static: {
      SmartSelect,
    },
    create() {
      const app = this;
      app.smartSelect = Utils.extend(
        ConstructorMethods({
          defaultSelector: '.smart-select',
          constructor: SmartSelect,
          app,
          domProp: 'f7SmartSelect',
        }),
        {
          open(smartSelectEl) {
            const ss = app.smartSelect.get(smartSelectEl);
            if (ss && ss.open) return ss.open();
            return undefined;
          },
          close(smartSelectEl) {
            const ss = app.smartSelect.get(smartSelectEl);
            if (ss && ss.close) return ss.close();
            return undefined;
          },
        }
      );
    },

    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.smart-select-init').each((index, smartSelectEl) => {
          app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
        });
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.smart-select-init').each((index, smartSelectEl) => {
          if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
            smartSelectEl.f7SmartSelect.destroy();
          }
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.smart-select-init').each((index, smartSelectEl) => {
          app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
        });
      },
      pageBeforeRemove(page) {
        page.$el.find('.smart-select-init').each((index, smartSelectEl) => {
          if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
            smartSelectEl.f7SmartSelect.destroy();
          }
        });
      },
    },
    clicks: {
      '.smart-select': function open($clickedEl, data) {
        const app = this;
        if (!$clickedEl[0].f7SmartSelect) {
          const ss = app.smartSelect.create(Utils.extend({ el: $clickedEl }, data));
          ss.open();
        }
      },
    },
    vnode: {
      'smart-select-init': {
        insert(vnode) {
          const app = this;
          const smartSelectEl = vnode.elm;
          app.smartSelect.create(Utils.extend({ el: smartSelectEl }, $(smartSelectEl).dataset()));
        },
        destroy(vnode) {
          const smartSelectEl = vnode.elm;
          if (smartSelectEl.f7SmartSelect && smartSelectEl.f7SmartSelect.destroy) {
            smartSelectEl.f7SmartSelect.destroy();
          }
        },
      },
    },
  };

  function getElMinSize(dimension, $el) {
    let minSize = $el.css(`min-${dimension}`);
    if (minSize === 'auto' || minSize === 'none') {
      minSize = 0;
    } else if (minSize.indexOf('px') >= 0) {
      minSize = parseFloat(minSize);
    } else if (minSize.indexOf('%') >= 0) {
      minSize = $el.parent()[0][dimension === 'height' ? 'offsetHeight' : 'offsetWidth'] * parseFloat(minSize) / 100;
    }
    return minSize;
  }
  function getElMaxSize(dimension, $el) {
    let maxSize = $el.css(`max-${dimension}`);
    if (maxSize === 'auto' || maxSize === 'none') {
      maxSize = null;
    } else if (maxSize.indexOf('px') >= 0) {
      maxSize = parseFloat(maxSize);
    } else if (maxSize.indexOf('%') >= 0) {
      maxSize = $el.parent()[0][dimension === 'height' ? 'offsetHeight' : 'offsetWidth'] * parseFloat(maxSize) / 100;
    }
    return maxSize;
  }

  const Grid = {
    init() {
      const app = this;
      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let $resizeHandlerEl;
      let $prevResizableEl;
      let $nextResizableEl;
      let prevElSize;
      let prevElMinSize;
      let prevElMaxSize;
      let nextElSize;
      let nextElMinSize;
      let nextElMaxSize;
      let parentSize;
      let itemsInFlow;
      let gapSize;
      let isScrolling;

      function handleTouchStart(e) {
        if (isTouched || isMoved) return;
        $resizeHandlerEl = $(e.target).closest('.resize-handler');
        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        isTouched = true;
        $prevResizableEl = undefined;
        $nextResizableEl = undefined;
        isScrolling = undefined;
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        const isRow = $resizeHandlerEl.parent('.row').length === 1;
        const sizeProp = isRow ? 'height' : 'width';
        const getSizeProp = isRow ? 'offsetHeight' : 'offsetWidth';
        if (!isMoved) {
          $prevResizableEl = $resizeHandlerEl.parent(isRow ? '.row' : '.col');
          if ($prevResizableEl.length && (!$prevResizableEl.hasClass('resizable') || $prevResizableEl.hasClass('resizable-fixed'))) {
            $prevResizableEl = $prevResizableEl.prevAll('.resizable:not(.resizable-fixed)').eq(0);
          }
          $nextResizableEl = $prevResizableEl.next(isRow ? '.row' : '.col');
          if ($nextResizableEl.length && (!$nextResizableEl.hasClass('resizable') || $nextResizableEl.hasClass('resizable-fixed'))) {
            $nextResizableEl = $nextResizableEl.nextAll('.resizable:not(.resizable-fixed)').eq(0);
          }

          if ($prevResizableEl.length) {
            prevElSize = $prevResizableEl[0][getSizeProp];
            prevElMinSize = getElMinSize(sizeProp, $prevResizableEl);
            prevElMaxSize = getElMaxSize(sizeProp, $prevResizableEl);
            parentSize = $prevResizableEl.parent()[0][getSizeProp];
            itemsInFlow = $prevResizableEl.parent().children(isRow ? '.row' : '[class*="col-"], .col').length;
            gapSize = parseFloat($prevResizableEl.css(isRow ? '--f7-grid-row-gap' : '--f7-grid-gap'));
          }
          if ($nextResizableEl.length) {
            nextElSize = $nextResizableEl[0][getSizeProp];
            nextElMinSize = getElMinSize(sizeProp, $nextResizableEl);
            nextElMaxSize = getElMaxSize(sizeProp, $nextResizableEl);
            if (!$prevResizableEl.length) {
              parentSize = $nextResizableEl.parent()[0][getSizeProp];
              itemsInFlow = $nextResizableEl.parent().children(isRow ? '.row' : '[class*="col-"], .col').length;
              gapSize = parseFloat($nextResizableEl.css(isRow ? '--f7-grid-row-gap' : '--f7-grid-gap'));
            }
          }
        }

        isMoved = true;
        const touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        const touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (typeof isScrolling === 'undefined' && !isRow) {
          isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
        }
        if (isScrolling) {
          isTouched = false;
          isMoved = false;
          return;
        }

        const isAbsolute = $prevResizableEl.hasClass('resizable-absolute') || $nextResizableEl.hasClass('resizable-absolute');
        const resizeNextEl = !isRow || (isRow && !isAbsolute);

        if ((resizeNextEl && !$nextResizableEl.length) || !$prevResizableEl.length) {
          isTouched = false;
          isMoved = false;
          return;
        }

        e.preventDefault();

        let diff = isRow
          ? touchCurrentY - touchStartY
          : touchCurrentX - touchStartX;

        let prevElNewSize;
        let nextElNewSize;
        if ($prevResizableEl.length) {
          prevElNewSize = prevElSize + diff;
          if (prevElNewSize < prevElMinSize) {
            prevElNewSize = prevElMinSize;
            diff = prevElNewSize - prevElSize;
          }
          if (prevElMaxSize && prevElNewSize > prevElMaxSize) {
            prevElNewSize = prevElMaxSize;
            diff = prevElNewSize - prevElSize;
          }
        }
        if ($nextResizableEl.length && resizeNextEl) {
          nextElNewSize = nextElSize - diff;
          if (nextElNewSize < nextElMinSize) {
            nextElNewSize = nextElMinSize;
            diff = nextElSize - nextElNewSize;
            prevElNewSize = prevElSize + diff;
          }
          if (nextElMaxSize && nextElNewSize > nextElMaxSize) {
            nextElNewSize = nextElMaxSize;
            diff = nextElSize - nextElNewSize;
            prevElNewSize = prevElSize + diff;
          }
        }

        if (isAbsolute) {
          $prevResizableEl[0].style[sizeProp] = `${prevElNewSize}px`;
          if (resizeNextEl) {
            $nextResizableEl[0].style[sizeProp] = `${nextElNewSize}px`;
          }
          $prevResizableEl.trigger('grid:resize');
          $nextResizableEl.trigger('grid:resize');
          app.emit('gridResize', $prevResizableEl[0]);
          app.emit('gridResize', $nextResizableEl[0]);
          return;
        }

        const gapAddSize = (itemsInFlow - 1) * gapSize / itemsInFlow;
        const gapAddSizeCSS = isRow
          ? `${itemsInFlow - 1} * var(--f7-grid-row-gap) / ${itemsInFlow}`
          : '(var(--f7-cols-per-row) - 1) * var(--f7-grid-gap) / var(--f7-cols-per-row)';
        const prevElNewSizeNormalized = prevElNewSize + gapAddSize;
        const nextElNewSizeNormalized = nextElNewSize + gapAddSize;
        $prevResizableEl[0].style[sizeProp] = `calc(${prevElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
        $nextResizableEl[0].style[sizeProp] = `calc(${nextElNewSizeNormalized / parentSize * 100}% - ${gapAddSizeCSS})`;
        $prevResizableEl.trigger('grid:resize');
        $nextResizableEl.trigger('grid:resize');
        app.emit('gridResize', $prevResizableEl[0]);
        app.emit('gridResize', $nextResizableEl[0]);
      }

      function handleTouchEnd() {
        if (!isTouched) return;
        if (!isMoved) {
          isTouched = false;
        }
        isTouched = false;
        isMoved = false;
      }

      $(document).on(app.touchEvents.start, '.col > .resize-handler, .row > .resize-handler', handleTouchStart);
      app.on('touchmove', handleTouchMove);
      app.on('touchend', handleTouchEnd);
    },
  };

  var Grid$1 = {
    name: 'grid',
    create() {
      const app = this;
      Utils.extend(app, {
        grid: {
          init: Grid.init.bind(app),
        },
      });
    },
    on: {
      init() {
        const app = this;
        app.grid.init();
      },
    },
  };

  class Calendar extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);
      const calendar = this;

      calendar.params = Utils.extend({}, app.params.calendar, params);

      let $containerEl;
      if (calendar.params.containerEl) {
        $containerEl = $(calendar.params.containerEl);
        if ($containerEl.length === 0) return calendar;
      }

      let $inputEl;
      if (calendar.params.inputEl) {
        $inputEl = $(calendar.params.inputEl);
      }

      const isHorizontal = calendar.params.direction === 'horizontal';

      let inverter = 1;
      if (isHorizontal) {
        inverter = app.rtl ? -1 : 1;
      }

      Utils.extend(calendar, {
        app,
        $containerEl,
        containerEl: $containerEl && $containerEl[0],
        inline: $containerEl && $containerEl.length > 0,
        $inputEl,
        inputEl: $inputEl && $inputEl[0],
        initialized: false,
        opened: false,
        url: calendar.params.url,
        isHorizontal,
        inverter,
        animating: false,
        hasTimePicker: calendar.params.timePicker && !calendar.params.rangePicker && !calendar.params.multiple,
      });
      calendar.dayFormatter = new Intl.DateTimeFormat(calendar.params.locale, { day: 'numeric' });
      calendar.monthFormatter = new Intl.DateTimeFormat(calendar.params.locale, { month: 'long' });
      calendar.yearFormatter = new Intl.DateTimeFormat(calendar.params.locale, { year: 'numeric' });
      calendar.timeSelectorFormatter = new Intl.DateTimeFormat(calendar.params.locale, calendar.params.timePickerFormat);

      // Auto names
      let { monthNames, monthNamesShort, dayNames, dayNamesShort } = calendar.params;
      const { monthNamesIntl, monthNamesShortIntl, dayNamesIntl, dayNamesShortIntl } = calendar.getIntlNames();
      if (monthNames === 'auto') monthNames = monthNamesIntl;
      if (monthNamesShort === 'auto') monthNamesShort = monthNamesShortIntl;
      if (dayNames === 'auto') dayNames = dayNamesIntl;
      if (dayNamesShort === 'auto') dayNamesShort = dayNamesShortIntl;

      Utils.extend(calendar, {
        monthNames,
        monthNamesShort,
        dayNames,
        dayNamesShort,
      });

      function onInputClick() {
        calendar.open();
      }
      function onInputFocus(e) {
        e.preventDefault();
      }
      function onInputClear() {
        calendar.setValue([]);
        if (calendar.opened) {
          calendar.update();
        }
      }
      function onHtmlClick(e) {
        const $targetEl = $(e.target);
        if (calendar.destroyed || !calendar.params) return;
        if (calendar.isPopover()) return;
        if (!calendar.opened || calendar.closing) return;
        if ($targetEl.closest('[class*="backdrop"]').length) return;
        if ($inputEl && $inputEl.length > 0) {
          if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal, .calendar-modal').length === 0) {
            calendar.close();
          }
        } else if ($(e.target).closest('.sheet-modal, .calendar-modal').length === 0) {
          calendar.close();
        }
      }

      // Events
      Utils.extend(calendar, {
        attachInputEvents() {
          calendar.$inputEl.on('click', onInputClick);
          calendar.$inputEl.on('input:clear', onInputClear);
          if (calendar.params.inputReadOnly) {
            calendar.$inputEl.on('focus mousedown', onInputFocus);
          }
        },
        detachInputEvents() {
          calendar.$inputEl.off('click', onInputClick);
          calendar.$inputEl.off('input:clear', onInputClear);
          if (calendar.params.inputReadOnly) {
            calendar.$inputEl.off('focus mousedown', onInputFocus);
          }
        },
        attachHtmlEvents() {
          app.on('click', onHtmlClick);
        },
        detachHtmlEvents() {
          app.off('click', onHtmlClick);
        },
      });
      calendar.attachCalendarEvents = function attachCalendarEvents() {
        let allowItemClick = true;
        let isTouched;
        let isMoved;
        let touchStartX;
        let touchStartY;
        let touchCurrentX;
        let touchCurrentY;
        let touchStartTime;
        let touchEndTime;
        let currentTranslate;
        let wrapperWidth;
        let wrapperHeight;
        let percentage;
        let touchesDiff;
        let isScrolling;

        const { $el, $wrapperEl } = calendar;

        function handleTouchStart(e) {
          if (isMoved || isTouched) return;
          isTouched = true;
          touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
          touchCurrentX = touchStartX;
          touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
          touchCurrentY = touchStartY;
          touchStartTime = (new Date()).getTime();
          percentage = 0;
          allowItemClick = true;
          isScrolling = undefined;
          currentTranslate = calendar.monthsTranslate;
        }
        function handleTouchMove(e) {
          if (!isTouched) return;
          const { isHorizontal: isH } = calendar;

          touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
          touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
          if (typeof isScrolling === 'undefined') {
            isScrolling = !!(isScrolling || Math.abs(touchCurrentY - touchStartY) > Math.abs(touchCurrentX - touchStartX));
          }
          if (isH && isScrolling) {
            isTouched = false;
            return;
          }
          e.preventDefault();
          if (calendar.animating) {
            isTouched = false;
            return;
          }
          allowItemClick = false;
          if (!isMoved) {
            // First move
            isMoved = true;
            wrapperWidth = $wrapperEl[0].offsetWidth;
            wrapperHeight = $wrapperEl[0].offsetHeight;
            $wrapperEl.transition(0);
          }

          touchesDiff = isH ? touchCurrentX - touchStartX : touchCurrentY - touchStartY;
          percentage = touchesDiff / (isH ? wrapperWidth : wrapperHeight);
          currentTranslate = ((calendar.monthsTranslate * calendar.inverter) + percentage) * 100;

          // Transform wrapper
          $wrapperEl.transform(`translate3d(${isH ? currentTranslate : 0}%, ${isH ? 0 : currentTranslate}%, 0)`);
        }
        function handleTouchEnd() {
          if (!isTouched || !isMoved) {
            isTouched = false;
            isMoved = false;
            return;
          }
          isTouched = false;
          isMoved = false;

          touchEndTime = new Date().getTime();
          if (touchEndTime - touchStartTime < 300) {
            if (Math.abs(touchesDiff) < 10) {
              calendar.resetMonth();
            } else if (touchesDiff >= 10) {
              if (app.rtl) calendar.nextMonth();
              else calendar.prevMonth();
            } else if (app.rtl) calendar.prevMonth();
            else calendar.nextMonth();
          } else if (percentage <= -0.5) {
            if (app.rtl) calendar.prevMonth();
            else calendar.nextMonth();
          } else if (percentage >= 0.5) {
            if (app.rtl) calendar.nextMonth();
            else calendar.prevMonth();
          } else {
            calendar.resetMonth();
          }

          // Allow click
          setTimeout(() => {
            allowItemClick = true;
          }, 100);
        }

        function handleDayClick(e) {
          if (!allowItemClick) return;
          let $dayEl = $(e.target).parents('.calendar-day');
          if ($dayEl.length === 0 && $(e.target).hasClass('calendar-day')) {
            $dayEl = $(e.target);
          }
          if ($dayEl.length === 0) return;
          if ($dayEl.hasClass('calendar-day-disabled')) return;
          if (!calendar.params.rangePicker) {
            if ($dayEl.hasClass('calendar-day-next')) calendar.nextMonth();
            if ($dayEl.hasClass('calendar-day-prev')) calendar.prevMonth();
          }
          const dateYear = parseInt($dayEl.attr('data-year'), 10);
          const dateMonth = parseInt($dayEl.attr('data-month'), 10);
          const dateDay = parseInt($dayEl.attr('data-day'), 10);
          calendar.emit(
            'local::dayClick calendarDayClick',
            calendar,
            $dayEl[0],
            dateYear,
            dateMonth,
            dateDay
          );
          if (!$dayEl.hasClass('calendar-day-selected') || calendar.params.multiple || calendar.params.rangePicker) {
            const valueToAdd = new Date(dateYear, dateMonth, dateDay, 0, 0, 0);
            if (calendar.hasTimePicker) {
              if (calendar.value && calendar.value[0]) {
                valueToAdd.setHours(calendar.value[0].getHours(), calendar.value[0].getMinutes());
              } else {
                valueToAdd.setHours(new Date().getHours(), new Date().getMinutes());
              }
            }
            calendar.addValue(valueToAdd);
          }
          if (calendar.params.closeOnSelect) {
            if (
              (calendar.params.rangePicker && calendar.value.length === 2)
              || !calendar.params.rangePicker
            ) {
              calendar.close();
            }
          }
        }

        function onNextMonthClick() {
          calendar.nextMonth();
        }

        function onPrevMonthClick() {
          calendar.prevMonth();
        }

        function onNextYearClick() {
          calendar.nextYear();
        }

        function onPrevYearClick() {
          calendar.prevYear();
        }

        function onMonthSelectorClick() {
          $el.append(calendar.renderMonthPicker());
        }
        function onMonthSelectorItemClick() {
          const $clickedEl = $(this);
          if ($clickedEl.hasClass('calendar-month-picker-item-current')) {
            $el.find('.calendar-month-picker').remove();
            return;
          }
          $el.find('.calendar-month-picker-item-current').add($clickedEl).toggleClass('calendar-month-picker-item-current');
          const index = $clickedEl.index();
          const localeMonthIndex = parseInt(calendar.$el.find('.calendar-month-current').attr('data-locale-month'), 10);
          const monthIndex = calendar.currentMonth;
          const diff = localeMonthIndex - monthIndex;
          const diffIndex = index - diff;
          calendar.setYearMonth(calendar.currentYear, diffIndex, 0);
          setTimeout(() => {
            $el.find('.calendar-month-picker').remove();
          }, 200);
        }

        function onYearSelectorClick() {
          $el.append(calendar.renderYearPicker());
          const $currentEl = $el.find('.calendar-year-picker-item-current');
          const $yearPickerEl = $el.find('.calendar-year-picker');
          if (!$currentEl || !$currentEl.length) return;
          $yearPickerEl.scrollTop(
            $currentEl[0].offsetTop
            - $yearPickerEl[0].offsetHeight / 2
            + $currentEl[0].offsetHeight / 2
          );
        }

        function onYearSelectorItemClick() {
          const $clickedEl = $(this);
          if ($clickedEl.hasClass('calendar-year-picker-item-current')) {
            $el.find('.calendar-year-picker').remove();
            return;
          }
          $el.find('.calendar-year-picker-item-current').add($clickedEl).toggleClass('calendar-year-picker-item-current');
          const year = parseInt($clickedEl.attr('data-year'), 10);
          calendar.setYearMonth(year, undefined, 0);
          setTimeout(() => {
            $el.find('.calendar-year-picker').remove();
          }, 200);
        }

        function onTimeSelectorClick() {
          calendar.openTimePicker();
        }
        function onTimePickerCloseClick() {
          calendar.closeTimePicker();
        }

        const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;
        // Selectors clicks
        $el.find('.calendar-prev-month-button').on('click', onPrevMonthClick);
        $el.find('.calendar-next-month-button').on('click', onNextMonthClick);
        $el.find('.calendar-prev-year-button').on('click', onPrevYearClick);
        $el.find('.calendar-next-year-button').on('click', onNextYearClick);
        if (calendar.params.monthPicker) {
          $el.find('.current-month-value').on('click', onMonthSelectorClick);
          $el.on('click', '.calendar-month-picker-item', onMonthSelectorItemClick);
        }
        if (calendar.params.yearPicker) {
          $el.find('.current-year-value').on('click', onYearSelectorClick);
          $el.on('click', '.calendar-year-picker-item', onYearSelectorItemClick);
        }
        if (calendar.hasTimePicker) {
          $el.find('.calendar-time-selector a').on('click', onTimeSelectorClick);
          $el.on('click', '.calendar-time-picker-close', onTimePickerCloseClick);
        }
        // Day clicks
        $wrapperEl.on('click', handleDayClick);
        // Touch events
        if (calendar.params.touchMove) {
          $wrapperEl.on(app.touchEvents.start, handleTouchStart, passiveListener);
          app.on('touchmove:active', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
        }

        calendar.detachCalendarEvents = function detachCalendarEvents() {
          $el.find('.calendar-prev-month-button').off('click', onPrevMonthClick);
          $el.find('.calendar-next-month-button').off('click', onNextMonthClick);
          $el.find('.calendar-prev-year-button').off('click', onPrevYearClick);
          $el.find('.calendar-next-year-button').off('click', onNextYearClick);
          if (calendar.params.monthPicker) {
            $el.find('.current-month-value').off('click', onMonthSelectorClick);
            $el.off('click', '.calendar-month-picker-item', onMonthSelectorItemClick);
          }
          if (calendar.params.yearPicker) {
            $el.find('.current-year-value').off('click', onYearSelectorClick);
            $el.off('click', '.calendar-year-picker-item', onYearSelectorItemClick);
          }
          if (calendar.hasTimePicker) {
            $el.find('.calendar-time-selector a').off('click', onTimeSelectorClick);
            $el.off('click', '.calendar-time-picker-close', onTimePickerCloseClick);
          }
          $wrapperEl.off('click', handleDayClick);
          if (calendar.params.touchMove) {
            $wrapperEl.off(app.touchEvents.start, handleTouchStart, passiveListener);
            app.off('touchmove:active', handleTouchMove);
            app.off('touchend:passive', handleTouchEnd);
          }
        };
      };

      calendar.init();

      return calendar;
    }

    get view() {
      const { $inputEl, app, params } = this;
      let view;
      if (params.view) {
        view = params.view;
      } else if ($inputEl) {
        view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
      }
      if (!view) view = app.views.main;
      return view;
    }

    getIntlNames() {
      const calendar = this;
      const locale = calendar.params.locale;

      const monthNamesIntl = [];
      const monthNamesShortIntl = [];
      const dayNamesIntl = [];
      const dayNamesShortIntl = [];
      const formatterMonthNames = new Intl.DateTimeFormat(locale, { month: 'long' });
      const formatterMonthNamesShort = new Intl.DateTimeFormat(locale, { month: 'short' });
      const formatterDayNames = new Intl.DateTimeFormat(locale, { weekday: 'long' });
      const formatterDayNamesShort = new Intl.DateTimeFormat(locale, { weekday: 'short' });
      let year;
      let yearStarted;
      let yearEnded;
      for (let i = 0; i < 24; i += 1) {
        const date = new Date().setMonth(i, 1);
        const currentYear = calendar.yearFormatter.format(date);

        if (year && currentYear !== year) {
          if (yearStarted) yearEnded = true;
          yearStarted = true;
          year = currentYear;
        }
        if (!year) {
          year = currentYear;
        }
        if (yearStarted && year === currentYear && !yearEnded) {
          monthNamesIntl.push(formatterMonthNames.format(date));
          monthNamesShortIntl.push(formatterMonthNamesShort.format(date));
        }
      }
      const weekDay = new Date().getDay();
      for (let i = 0; i < 7; i += 1) {
        const date = new Date().getTime() + (i - weekDay) * 24 * 60 * 60 * 1000;
        dayNamesIntl.push(formatterDayNames.format(date));
        dayNamesShortIntl.push(formatterDayNamesShort.format(date));
      }

      return {
        monthNamesIntl,
        monthNamesShortIntl,
        dayNamesIntl,
        dayNamesShortIntl,
      };
    }

    normalizeDate(date) {
      const calendar = this;
      const d = new Date(date);
      if (calendar.hasTimePicker) {
        return new Date(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes());
      }
      return new Date(d.getFullYear(), d.getMonth(), d.getDate());
    }

    normalizeValues(values) {
      const calendar = this;
      let newValues = [];
      if (values && Array.isArray(values)) {
        newValues = values.map(val => calendar.normalizeDate(val));
      }
      return newValues;
    }

    initInput() {
      const calendar = this;
      if (!calendar.$inputEl) return;
      if (calendar.params.inputReadOnly) calendar.$inputEl.prop('readOnly', true);
    }

    isPopover() {
      const calendar = this;
      const { app, modal, params } = calendar;
      if (params.openIn === 'sheet') return false;
      if (modal && modal.type !== 'popover') return false;

      if (!calendar.inline && calendar.inputEl) {
        if (params.openIn === 'popover') return true;
        if (app.device.ios) {
          return !!app.device.ipad;
        }
        if (app.width >= 768) {
          return true;
        }
        if (app.device.desktop && app.theme === 'aurora') {
          return true;
        }
      }
      return false;
    }

    formatDate(d) {
      const calendar = this;
      const date = new Date(d);
      const year = date.getFullYear();
      const month = date.getMonth();
      const month1 = month + 1;
      const day = date.getDate();
      const weekDay = date.getDay();
      const { monthNames, monthNamesShort, dayNames, dayNamesShort } = calendar;
      const { dateFormat, locale } = calendar.params;

      function twoDigits(number) {
        return (number < 10) ? `0${number}` : number;
      }
      if (typeof dateFormat === 'string') {
        const tokens = {
          yyyy: year,
          yy: String(year).substring(2),
          mm: twoDigits(month1),
          m: month1,
          MM: monthNames[month],
          M: monthNamesShort[month],
          dd: twoDigits(day),
          d: day,
          DD: dayNames[weekDay],
          D: dayNamesShort[weekDay],
        };
        if (calendar.params.timePicker) {
          const hours = date.getHours();
          const minutes = date.getMinutes();
          const seconds = date.getSeconds();
          let hours12 = hours;
          if (hours > 12) hours12 = hours - 12;
          if (hours === 0) hours12 = 12;
          const a = hours >= 12 && hours !== 0 ? 'pm' : 'am';

          Object.assign(tokens, {
            HH: twoDigits(hours),
            H: hours,
            hh: twoDigits(hours12),
            h: hours12,
            ss: twoDigits(seconds),
            s: seconds,
            ':mm': twoDigits(minutes),
            ':m': minutes,
            a,
            A: a.toUpperCase(),
          });
        }
        const regexp = new RegExp(
          Object.keys(tokens).map(t => `(${t})`).join('|'),
          'g',
        );
        return dateFormat.replace(regexp, (token) => {
          if (token in tokens) return tokens[token];
          return token;
        });
      }
      if (typeof dateFormat === 'function') {
        return dateFormat(date);
      }
      // Intl Object
      const formatter = new Intl.DateTimeFormat(locale, dateFormat);
      return formatter.format(date);
    }

    formatValue() {
      const calendar = this;
      const { value } = calendar;
      if (calendar.params.formatValue) {
        return calendar.params.formatValue.call(calendar, value);
      }
      return value
        .map(v => calendar.formatDate(v))
        .join(calendar.params.rangePicker ? ' - ' : ', ');
    }

    addValue(newValue) {
      const calendar = this;
      const { multiple, rangePicker, rangePickerMinDays, rangePickerMaxDays } = calendar.params;
      if (multiple) {
        if (!calendar.value) calendar.value = [];
        let inValuesIndex;
        for (let i = 0; i < calendar.value.length; i += 1) {
          if (new Date(newValue).getTime() === new Date(calendar.value[i]).getTime()) {
            inValuesIndex = i;
          }
        }
        if (typeof inValuesIndex === 'undefined') {
          calendar.value.push(newValue);
        } else {
          calendar.value.splice(inValuesIndex, 1);
        }
        calendar.updateValue();
      } else if (rangePicker) {
        if (!calendar.value) calendar.value = [];
        if (calendar.value.length === 2 || calendar.value.length === 0) {
          calendar.value = [];
        }

        if ((calendar.value.length === 0
          || ((Math.abs(calendar.value[0].getTime() - newValue.getTime()) >= (rangePickerMinDays - 1) * 60 * 60 * 24 * 1000) && (rangePickerMaxDays === 0 || Math.abs(calendar.value[0].getTime() - newValue.getTime()) <= (rangePickerMaxDays - 1) * 60 * 60 * 24 * 1000)))) calendar.value.push(newValue);
        else calendar.value = [];

        calendar.value.sort((a, b) => a - b);
        calendar.updateValue();
      } else {
        calendar.value = [newValue];
        calendar.updateValue();
      }
    }

    setValue(values) {
      const calendar = this;
      const currentValue = calendar.value;
      if (Array.isArray(currentValue) && Array.isArray(values) && currentValue.length === values.length) {
        let equal = true;
        currentValue.forEach((v, index) => {
          if (v !== values[index]) equal = false;
        });
        if (equal) return;
      }
      calendar.value = values;
      calendar.updateValue();
    }

    getValue() {
      const calendar = this;
      return calendar.value;
    }

    updateValue(onlyHeader) {
      const calendar = this;
      const {
        $el,
        $wrapperEl,
        $inputEl,
        value,
        params,
      } = calendar;
      let i;
      if ($el && $el.length > 0) {
        $wrapperEl.find('.calendar-day-selected').removeClass('calendar-day-selected');
        let valueDate;
        if (params.rangePicker && value.length === 2) {
          for (i = new Date(value[0]).getTime(); i <= new Date(value[1]).getTime(); i += 24 * 60 * 60 * 1000) {
            valueDate = new Date(i);
            $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass('calendar-day-selected');
          }
        } else {
          for (i = 0; i < calendar.value.length; i += 1) {
            valueDate = new Date(value[i]);
            $wrapperEl.find(`.calendar-day[data-date="${valueDate.getFullYear()}-${valueDate.getMonth()}-${valueDate.getDate()}"]`).addClass('calendar-day-selected');
          }
        }
      }
      if (!onlyHeader) {
        calendar.emit('local::change calendarChange', calendar, value);
      }

      if ($el && $el.length > 0 && calendar.hasTimePicker) {
        $el.find('.calendar-time-selector a').text(value && value.length ? calendar.timeSelectorFormatter.format(value[0]) : calendar.params.timePickerPlaceholder);
      }

      if (($inputEl && $inputEl.length) || params.header) {
        const inputValue = calendar.formatValue(value);
        if (params.header && $el && $el.length) {
          $el.find('.calendar-selected-date').text(inputValue);
        }
        if ($inputEl && $inputEl.length && !onlyHeader) {
          $inputEl.val(inputValue);
          $inputEl.trigger('change');
        }
      }
    }

    updateCurrentMonthYear(dir) {
      const calendar = this;
      const { $months, $el, monthNames } = calendar;
      let currentLocaleMonth;
      let currentLocaleYear;
      if (typeof dir === 'undefined') {
        calendar.currentMonth = parseInt($months.eq(1).attr('data-month'), 10);
        calendar.currentYear = parseInt($months.eq(1).attr('data-year'), 10);
        currentLocaleMonth = $months.eq(1).attr('data-locale-month');
        currentLocaleYear = $months.eq(1).attr('data-locale-year');
      } else {
        calendar.currentMonth = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-month'), 10);
        calendar.currentYear = parseInt($months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-year'), 10);
        currentLocaleMonth = $months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-locale-month');
        currentLocaleYear = $months.eq(dir === 'next' ? ($months.length - 1) : 0).attr('data-locale-year');
      }
      $el.find('.current-month-value').text(monthNames[currentLocaleMonth]);
      $el.find('.current-year-value').text(currentLocaleYear);
    }

    update() {
      const calendar = this;
      const { currentYear, currentMonth, $wrapperEl } = calendar;
      const currentDate = new Date(currentYear, currentMonth);
      const prevMonthHtml = calendar.renderMonth(currentDate, 'prev');
      const currentMonthHtml = calendar.renderMonth(currentDate);
      const nextMonthHtml = calendar.renderMonth(currentDate, 'next');

      $wrapperEl
        .transition(0)
        .html(`${prevMonthHtml}${currentMonthHtml}${nextMonthHtml}`)
        .transform('translate3d(0,0,0)');
      calendar.$months = $wrapperEl.find('.calendar-month');
      calendar.monthsTranslate = 0;
      calendar.setMonthsTranslate();
      calendar.$months.each((index, monthEl) => {
        calendar.emit(
          'local::monthAdd calendarMonthAdd',
          monthEl
        );
      });
    }

    onMonthChangeStart(dir) {
      const calendar = this;
      const { $months, currentYear, currentMonth } = calendar;
      calendar.updateCurrentMonthYear(dir);
      $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
      const currentIndex = dir === 'next' ? $months.length - 1 : 0;

      $months.eq(currentIndex).addClass('calendar-month-current');
      $months.eq(dir === 'next' ? currentIndex - 1 : currentIndex + 1).addClass(dir === 'next' ? 'calendar-month-prev' : 'calendar-month-next');

      calendar.emit(
        'local::monthYearChangeStart calendarMonthYearChangeStart',
        calendar,
        currentYear,
        currentMonth
      );
    }

    onMonthChangeEnd(dir, rebuildBoth) {
      const calendar = this;
      const { currentYear, currentMonth, $wrapperEl, monthsTranslate } = calendar;
      calendar.animating = false;
      let nextMonthHtml;
      let prevMonthHtml;
      let currentMonthHtml;
      $wrapperEl
        .find('.calendar-month:not(.calendar-month-prev):not(.calendar-month-current):not(.calendar-month-next)')
        .remove();

      if (typeof dir === 'undefined') {
        dir = 'next'; // eslint-disable-line
        rebuildBoth = true; // eslint-disable-line
      }
      if (!rebuildBoth) {
        currentMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), dir);
      } else {
        $wrapperEl.find('.calendar-month-next, .calendar-month-prev').remove();
        prevMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'prev');
        nextMonthHtml = calendar.renderMonth(new Date(currentYear, currentMonth), 'next');
      }
      if (dir === 'next' || rebuildBoth) {
        $wrapperEl.append(currentMonthHtml || nextMonthHtml);
      }
      if (dir === 'prev' || rebuildBoth) {
        $wrapperEl.prepend(currentMonthHtml || prevMonthHtml);
      }
      const $months = $wrapperEl.find('.calendar-month');
      calendar.$months = $months;
      calendar.setMonthsTranslate(monthsTranslate);
      calendar.emit(
        'local::monthAdd calendarMonthAdd',
        calendar,
        dir === 'next' ? $months.eq($months.length - 1)[0] : $months.eq(0)[0]
      );
      calendar.emit(
        'local::monthYearChangeEnd calendarMonthYearChangeEnd',
        calendar,
        currentYear,
        currentMonth
      );
    }

    setMonthsTranslate(translate) {
      const calendar = this;
      const { $months, isHorizontal: isH, inverter } = calendar;
      // eslint-disable-next-line
      translate = translate || calendar.monthsTranslate || 0;
      if (typeof calendar.monthsTranslate === 'undefined') {
        calendar.monthsTranslate = translate;
      }
      $months.removeClass('calendar-month-current calendar-month-prev calendar-month-next');
      const prevMonthTranslate = -(translate + 1) * 100 * inverter;
      const currentMonthTranslate = -translate * 100 * inverter;
      const nextMonthTranslate = -(translate - 1) * 100 * inverter;
      $months.eq(0)
        .transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`)
        .addClass('calendar-month-prev');
      $months.eq(1)
        .transform(`translate3d(${isH ? currentMonthTranslate : 0}%, ${isH ? 0 : currentMonthTranslate}%, 0)`)
        .addClass('calendar-month-current');
      $months.eq(2)
        .transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`)
        .addClass('calendar-month-next');
    }

    nextMonth(transition) {
      const calendar = this;
      const { params, $wrapperEl, inverter, isHorizontal: isH } = calendar;
      if (typeof transition === 'undefined' || typeof transition === 'object') {
        transition = ''; // eslint-disable-line
        if (!params.animate) transition = 0; // eslint-disable-line
      }
      const nextMonth = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-month'), 10);
      const nextYear = parseInt(calendar.$months.eq(calendar.$months.length - 1).attr('data-year'), 10);
      const nextDate = new Date(nextYear, nextMonth);
      const nextDateTime = nextDate.getTime();
      const transitionEndCallback = !calendar.animating;
      if (params.maxDate) {
        if (nextDateTime > new Date(params.maxDate).getTime()) {
          calendar.resetMonth();
          return;
        }
      }
      calendar.monthsTranslate -= 1;
      if (nextMonth === calendar.currentMonth) {
        const nextMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
        const nextMonthHtml = $(calendar.renderMonth(nextDateTime, 'next'))
          .transform(`translate3d(${isH ? nextMonthTranslate : 0}%, ${isH ? 0 : nextMonthTranslate}%, 0)`)
          .addClass('calendar-month-next');
        $wrapperEl.append(nextMonthHtml[0]);
        calendar.$months = $wrapperEl.find('.calendar-month');
        calendar.emit(
          'local::monthAdd calendarMonthAdd',
          calendar.$months.eq(calendar.$months.length - 1)[0]
        );
      }
      calendar.animating = true;
      calendar.onMonthChangeStart('next');
      const translate = (calendar.monthsTranslate * 100) * inverter;

      $wrapperEl.transition(transition).transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
      if (transitionEndCallback) {
        $wrapperEl.transitionEnd(() => {
          calendar.onMonthChangeEnd('next');
        });
      }
      if (!params.animate) {
        calendar.onMonthChangeEnd('next');
      }
    }

    prevMonth(transition) {
      const calendar = this;
      const { params, $wrapperEl, inverter, isHorizontal: isH } = calendar;
      if (typeof transition === 'undefined' || typeof transition === 'object') {
        transition = ''; // eslint-disable-line
        if (!params.animate) transition = 0; // eslint-disable-line
      }
      const prevMonth = parseInt(calendar.$months.eq(0).attr('data-month'), 10);
      const prevYear = parseInt(calendar.$months.eq(0).attr('data-year'), 10);
      const prevDate = new Date(prevYear, prevMonth + 1, -1);
      const prevDateTime = prevDate.getTime();
      const transitionEndCallback = !calendar.animating;
      if (params.minDate) {
        let minDate = new Date(params.minDate);
        minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
        if (prevDateTime < minDate.getTime()) {
          calendar.resetMonth();
          return;
        }
      }
      calendar.monthsTranslate += 1;
      if (prevMonth === calendar.currentMonth) {
        const prevMonthTranslate = -(calendar.monthsTranslate) * 100 * inverter;
        const prevMonthHtml = $(calendar.renderMonth(prevDateTime, 'prev'))
          .transform(`translate3d(${isH ? prevMonthTranslate : 0}%, ${isH ? 0 : prevMonthTranslate}%, 0)`)
          .addClass('calendar-month-prev');
        $wrapperEl.prepend(prevMonthHtml[0]);
        calendar.$months = $wrapperEl.find('.calendar-month');
        calendar.emit(
          'local::monthAdd calendarMonthAdd',
          calendar.$months.eq(0)[0]
        );
      }
      calendar.animating = true;
      calendar.onMonthChangeStart('prev');
      const translate = (calendar.monthsTranslate * 100) * inverter;
      $wrapperEl
        .transition(transition)
        .transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
      if (transitionEndCallback) {
        $wrapperEl.transitionEnd(() => {
          calendar.onMonthChangeEnd('prev');
        });
      }
      if (!params.animate) {
        calendar.onMonthChangeEnd('prev');
      }
    }

    resetMonth(transition = '') {
      const calendar = this;
      const { $wrapperEl, inverter, isHorizontal: isH, monthsTranslate } = calendar;
      const translate = (monthsTranslate * 100) * inverter;
      $wrapperEl
        .transition(transition)
        .transform(`translate3d(${isH ? translate : 0}%, ${isH ? 0 : translate}%, 0)`);
    }
    // eslint-disable-next-line
    setYearMonth(year, month, transition) {
      const calendar = this;
      const { params, isHorizontal: isH, $wrapperEl, inverter } = calendar;
      // eslint-disable-next-line
      if (typeof year === 'undefined') year = calendar.currentYear;
      // eslint-disable-next-line
      if (typeof month === 'undefined') month = calendar.currentMonth;
      if (typeof transition === 'undefined' || typeof transition === 'object') {
        // eslint-disable-next-line
        transition = '';
        // eslint-disable-next-line
        if (!params.animate) transition = 0;
      }
      let targetDate;
      if (year < calendar.currentYear) {
        targetDate = new Date(year, month + 1, -1).getTime();
      } else {
        targetDate = new Date(year, month).getTime();
      }
      if (params.maxDate && targetDate > new Date(params.maxDate).getTime()) {
        return false;
      }
      if (params.minDate) {
        let minDate = new Date(params.minDate);
        minDate = new Date(minDate.getFullYear(), minDate.getMonth(), 1);
        if (targetDate < minDate.getTime()) {
          return false;
        }
      }
      const currentDate = new Date(calendar.currentYear, calendar.currentMonth).getTime();
      const dir = targetDate > currentDate ? 'next' : 'prev';
      const newMonthHTML = calendar.renderMonth(new Date(year, month));
      calendar.monthsTranslate = calendar.monthsTranslate || 0;
      const prevTranslate = calendar.monthsTranslate;
      let monthTranslate;
      const transitionEndCallback = !calendar.animating && transition !== 0;
      if (targetDate > currentDate) {
        // To next
        calendar.monthsTranslate -= 1;
        if (!calendar.animating) calendar.$months.eq(calendar.$months.length - 1).remove();
        $wrapperEl.append(newMonthHTML);
        calendar.$months = $wrapperEl.find('.calendar-month');
        monthTranslate = -(prevTranslate - 1) * 100 * inverter;
        calendar.$months
          .eq(calendar.$months.length - 1)
          .transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`)
          .addClass('calendar-month-next');
      } else {
        // To prev
        calendar.monthsTranslate += 1;
        if (!calendar.animating) calendar.$months.eq(0).remove();
        $wrapperEl.prepend(newMonthHTML);
        calendar.$months = $wrapperEl.find('.calendar-month');
        monthTranslate = -(prevTranslate + 1) * 100 * inverter;
        calendar.$months
          .eq(0)
          .transform(`translate3d(${isH ? monthTranslate : 0}%, ${isH ? 0 : monthTranslate}%, 0)`)
          .addClass('calendar-month-prev');
      }
      calendar.emit(
        'local::monthAdd calendarMonthAdd',
        dir === 'next'
          ? calendar.$months.eq(calendar.$months.length - 1)[0]
          : calendar.$months.eq(0)[0]
      );

      calendar.animating = true;
      calendar.onMonthChangeStart(dir);
      const wrapperTranslate = (calendar.monthsTranslate * 100) * inverter;
      $wrapperEl
        .transition(transition)
        .transform(`translate3d(${isH ? wrapperTranslate : 0}%, ${isH ? 0 : wrapperTranslate}%, 0)`);
      if (transitionEndCallback) {
        $wrapperEl.transitionEnd(() => {
          calendar.onMonthChangeEnd(dir, true);
        });
      }
      if (!params.animate || transition === 0) {
        calendar.onMonthChangeEnd(dir, true);
      }
    }

    nextYear() {
      const calendar = this;
      calendar.setYearMonth(calendar.currentYear + 1);
    }

    prevYear() {
      const calendar = this;
      calendar.setYearMonth(calendar.currentYear - 1);
    }
    // eslint-disable-next-line
    dateInRange(dayDate, range) {
      let match = false;
      let i;
      if (!range) return false;
      if (Array.isArray(range)) {
        for (i = 0; i < range.length; i += 1) {
          if (range[i].from || range[i].to) {
            if (range[i].from && range[i].to) {
              if ((dayDate <= new Date(range[i].to).getTime()) && (dayDate >= new Date(range[i].from).getTime())) {
                match = true;
              }
            } else if (range[i].from) {
              if (dayDate >= new Date(range[i].from).getTime()) {
                match = true;
              }
            } else if (range[i].to) {
              if (dayDate <= new Date(range[i].to).getTime()) {
                match = true;
              }
            }
          } else if (range[i].date) {
            if (dayDate === new Date(range[i].date).getTime()) {
              match = true;
            }
          } else if (dayDate === new Date(range[i]).getTime()) {
            match = true;
          }
        }
      } else if (range.from || range.to) {
        if (range.from && range.to) {
          if ((dayDate <= new Date(range.to).getTime()) && (dayDate >= new Date(range.from).getTime())) {
            match = true;
          }
        } else if (range.from) {
          if (dayDate >= new Date(range.from).getTime()) {
            match = true;
          }
        } else if (range.to) {
          if (dayDate <= new Date(range.to).getTime()) {
            match = true;
          }
        }
      } else if (range.date) {
        match = dayDate === new Date(range.date).getTime();
      } else if (typeof range === 'function') {
        match = range(new Date(dayDate));
      }
      return match;
    }
    // eslint-disable-next-line
    daysInMonth(date) {
      const d = new Date(date);
      return new Date(d.getFullYear(), d.getMonth() + 1, 0).getDate();
    }

    renderMonths(date) {
      const calendar = this;
      if (calendar.params.renderMonths) {
        return calendar.params.renderMonths.call(calendar, date);
      }
      return `
    <div class="calendar-months-wrapper">
    ${calendar.renderMonth(date, 'prev')}
    ${calendar.renderMonth(date)}
    ${calendar.renderMonth(date, 'next')}
    </div>
  `.trim();
    }

    renderMonth(d, offset) {
      const calendar = this;
      const { params, value } = calendar;
      if (params.renderMonth) {
        return params.renderMonth.call(calendar, d, offset);
      }
      let date = new Date(d);
      let year = date.getFullYear();
      let month = date.getMonth();
      let localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter.format(date));
      if (localeMonth < 0) localeMonth = month;
      let localeYear = calendar.yearFormatter.format(date);

      if (offset === 'next') {
        if (month === 11) date = new Date(year + 1, 0);
        else date = new Date(year, month + 1, 1);
      }
      if (offset === 'prev') {
        if (month === 0) date = new Date(year - 1, 11);
        else date = new Date(year, month - 1, 1);
      }
      if (offset === 'next' || offset === 'prev') {
        month = date.getMonth();
        year = date.getFullYear();
        localeMonth = calendar.monthNames.indexOf(calendar.monthFormatter.format(date));
        if (localeMonth < 0) localeMonth = month;
        localeYear = calendar.yearFormatter.format(date);
      }

      const currentValues = [];
      const today = new Date().setHours(0, 0, 0, 0);
      const minDate = params.minDate ? new Date(params.minDate).getTime() : null;
      const maxDate = params.maxDate ? new Date(params.maxDate).getTime() : null;
      const rows = 6;
      const cols = 7;
      const daysInPrevMonth = calendar.daysInMonth(new Date(date.getFullYear(), date.getMonth()).getTime() - (10 * 24 * 60 * 60 * 1000));
      const daysInMonth = calendar.daysInMonth(date);
      const minDayNumber = params.firstDay === 6 ? 0 : 1;

      let monthHtml = '';
      let dayIndex = 0 + (params.firstDay - 1);
      let disabled;
      let hasEvents;
      let firstDayOfMonthIndex = new Date(date.getFullYear(), date.getMonth()).getDay();
      if (firstDayOfMonthIndex === 0) firstDayOfMonthIndex = 7;

      if (value && value.length) {
        for (let i = 0; i < value.length; i += 1) {
          currentValues.push(new Date(value[i]).setHours(0, 0, 0, 0));
        }
      }

      for (let row = 1; row <= rows; row += 1) {
        let rowHtml = '';
        for (let col = 1; col <= cols; col += 1) {
          dayIndex += 1;
          let dayDate;
          let dayNumber = dayIndex - firstDayOfMonthIndex;
          let addClass = '';
          if (row === 1 && col === 1 && dayNumber > minDayNumber && params.firstDay !== 1) {
            dayIndex -= 7;
            dayNumber = dayIndex - firstDayOfMonthIndex;
          }

          const weekDayIndex = ((col - 1) + params.firstDay > 6)
            ? ((col - 1 - 7) + params.firstDay)
            : ((col - 1) + params.firstDay);

          if (dayNumber < 0) {
            dayNumber = daysInPrevMonth + dayNumber + 1;
            addClass += ' calendar-day-prev';
            dayDate = new Date(month - 1 < 0 ? year - 1 : year, month - 1 < 0 ? 11 : month - 1, dayNumber).getTime();
          } else {
            dayNumber += 1;
            if (dayNumber > daysInMonth) {
              dayNumber -= daysInMonth;
              addClass += ' calendar-day-next';
              dayDate = new Date(month + 1 > 11 ? year + 1 : year, month + 1 > 11 ? 0 : month + 1, dayNumber).getTime();
            } else {
              dayDate = new Date(year, month, dayNumber).getTime();
            }
          }
          // Today
          if (dayDate === today) addClass += ' calendar-day-today';

          // Selected
          if (params.rangePicker && currentValues.length === 2) {
            if (dayDate >= currentValues[0] && dayDate <= currentValues[1]) addClass += ' calendar-day-selected';
          } else if (currentValues.indexOf(dayDate) >= 0) addClass += ' calendar-day-selected';
          // Weekend
          if (params.weekendDays.indexOf(weekDayIndex) >= 0) {
            addClass += ' calendar-day-weekend';
          }
          // Events
          let eventsHtml = '';
          hasEvents = false;
          if (params.events) {
            if (calendar.dateInRange(dayDate, params.events)) {
              hasEvents = true;
            }
          }
          if (hasEvents) {
            addClass += ' calendar-day-has-events';
            eventsHtml = `
            <span class="calendar-day-events">
              <span class="calendar-day-event"></span>
            </span>
          `;
            if (Array.isArray(params.events)) {
              const eventDots = [];
              params.events.forEach((ev) => {
                const color = ev.color || '';
                if (eventDots.indexOf(color) < 0 && calendar.dateInRange(dayDate, ev)) {
                  eventDots.push(color);
                }
              });
              eventsHtml = `
              <span class="calendar-day-events">
                ${eventDots.map(color => `
                  <span class="calendar-day-event" style="${color ? `background-color: ${color}` : ''}"></span>
                `.trim()).join('')}
              </span>
            `;
            }
          }
          // Custom Ranges
          if (params.rangesClasses) {
            for (let k = 0; k < params.rangesClasses.length; k += 1) {
              if (calendar.dateInRange(dayDate, params.rangesClasses[k].range)) {
                addClass += ` ${params.rangesClasses[k].cssClass}`;
              }
            }
          }
          // Disabled
          disabled = false;
          if ((minDate && dayDate < minDate) || (maxDate && dayDate > maxDate)) {
            disabled = true;
          }
          if (params.disabled) {
            if (calendar.dateInRange(dayDate, params.disabled)) {
              disabled = true;
            }
          }
          if (disabled) {
            addClass += ' calendar-day-disabled';
          }

          dayDate = new Date(dayDate);
          const dayYear = dayDate.getFullYear();
          const dayMonth = dayDate.getMonth();
          const dayNumberDisplay = calendar.dayFormatter.format(dayDate);
          rowHtml += `
          <div data-year="${dayYear}" data-month="${dayMonth}" data-day="${dayNumber}" class="calendar-day${addClass}" data-date="${dayYear}-${dayMonth}-${dayNumber}">
            <span class="calendar-day-number">${dayNumberDisplay}${eventsHtml}</span>
          </div>`.trim();
        }
        monthHtml += `<div class="calendar-row">${rowHtml}</div>`;
      }
      monthHtml = `<div class="calendar-month" data-year="${year}" data-month="${month}" data-locale-year="${localeYear}" data-locale-month="${localeMonth}">${monthHtml}</div>`;
      return monthHtml;
    }

    renderWeekHeader() {
      const calendar = this;
      if (calendar.params.renderWeekHeader) {
        return calendar.params.renderWeekHeader.call(calendar);
      }
      const { params } = calendar;
      let weekDaysHtml = '';
      for (let i = 0; i < 7; i += 1) {
        const dayIndex = (i + params.firstDay > 6)
          ? ((i - 7) + params.firstDay)
          : (i + params.firstDay);
        const dayName = calendar.dayNamesShort[dayIndex];
        weekDaysHtml += `<div class="calendar-week-day">${dayName}</div>`;
      }
      return `
    <div class="calendar-week-header">
      ${weekDaysHtml}
    </div>
  `.trim();
    }

    renderMonthSelector() {
      const calendar = this;
      if (calendar.params.renderMonthSelector) {
        return calendar.params.renderMonthSelector.call(calendar);
      }

      return `
    <div class="calendar-month-selector">
      <a class="link icon-only calendar-prev-month-button">
        <i class="icon icon-prev"></i>
      </a>
      ${calendar.params.monthPicker ? `
        <a class="current-month-value link"></a>
      ` : `
        <span class="current-month-value"></span>
      `}
      <a class="link icon-only calendar-next-month-button">
        <i class="icon icon-next"></i>
      </a>
    </div>
  `.trim();
    }

    renderMonthPicker() {
      const calendar = this;
      const localeMonth = parseInt(calendar.$el.find('.calendar-month-current').attr('data-locale-month'), 10);
      return `
      <div class="calendar-month-picker">
        ${calendar.monthNames.map((m, index) => `
          <div class="calendar-month-picker-item ${localeMonth === index ? 'calendar-month-picker-item-current' : ''}">
            <span>${m}</span>
          </div>
        `).join('')}
      </div>
    `;
    }

    renderYearSelector() {
      const calendar = this;
      if (calendar.params.renderYearSelector) {
        return calendar.params.renderYearSelector.call(calendar);
      }
      return `
    <div class="calendar-year-selector">
      <a class="link icon-only calendar-prev-year-button">
        <i class="icon icon-prev"></i>
      </a>
      ${calendar.params.yearPicker ? `
        <a class="current-year-value link"></a>
      ` : `
        <span class="current-year-value"></span>
      `}
      <a class="link icon-only calendar-next-year-button">
        <i class="icon icon-next"></i>
      </a>
    </div>
  `.trim();
    }

    renderYearPicker() {
      const calendar = this;
      const currentYear = calendar.currentYear;
      let yearMin = calendar.params.yearPickerMin || new Date().getFullYear() - 100;
      if (calendar.params.minDate) {
        yearMin = Math.max(yearMin, new Date(calendar.params.minDate).getFullYear());
      }
      let yearMax = calendar.params.yearPickerMax || new Date().getFullYear() + 100;
      if (calendar.params.maxDate) {
        yearMax = Math.min(yearMax, new Date(calendar.params.maxDate).getFullYear());
      }
      const years = [];
      for (let i = yearMin; i <= yearMax; i += 1) {
        years.push(i);
      }
      return `
      <div class="calendar-year-picker">
        ${years.map(year => `
          <div data-year="${year}" class="calendar-year-picker-item ${year === currentYear ? 'calendar-year-picker-item-current' : ''}">
            <span>${calendar.yearFormatter.format(new Date().setFullYear(year))}</span>
          </div>
        `).join('')}
      </div>
    `;
    }

    // eslint-disable-next-line
    renderTimeSelector() {
      const calendar = this;
      const value = calendar.value && calendar.value[0];
      let timeString;
      if (value) timeString = calendar.timeSelectorFormatter.format(value);
      return `
      <div class="calendar-time-selector"><a class="link">${timeString || calendar.params.timePickerPlaceholder}</a></div>
    `;
    }

    renderHeader() {
      const calendar = this;
      if (calendar.params.renderHeader) {
        return calendar.params.renderHeader.call(calendar);
      }
      return `
    <div class="calendar-header">
      <div class="calendar-selected-date">${calendar.params.headerPlaceholder}</div>
    </div>
  `.trim();
    }

    renderFooter() {
      const calendar = this;
      const app = calendar.app;
      if (calendar.params.renderFooter) {
        return calendar.params.renderFooter.call(calendar);
      }
      return `
    <div class="calendar-footer">
      <a class="${app.theme === 'md' ? 'button' : 'link'} calendar-close sheet-close popover-close">${calendar.params.toolbarCloseText}</a>
    </div>
  `.trim();
    }

    renderToolbar() {
      const calendar = this;
      if (calendar.params.renderToolbar) {
        return calendar.params.renderToolbar.call(calendar, calendar);
      }
      return `
    <div class="toolbar toolbar-top no-shadow">
      <div class="toolbar-inner">
        ${calendar.params.monthSelector ? calendar.renderMonthSelector() : ''}
        ${calendar.params.yearSelector ? calendar.renderYearSelector() : ''}
      </div>
    </div>
  `.trim();
    }
    // eslint-disable-next-line
    renderInline() {
      const calendar = this;
      const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
      const { value, hasTimePicker } = calendar;
      const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
      const inlineHtml = `
    <div class="calendar calendar-inline ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
      ${header ? calendar.renderHeader() : ''}
      ${toolbar ? calendar.renderToolbar() : ''}
      ${weekHeader ? calendar.renderWeekHeader() : ''}
      <div class="calendar-months">
        ${calendar.renderMonths(date)}
      </div>
      ${hasTimePicker ? calendar.renderTimeSelector() : ''}
      ${footer ? calendar.renderFooter() : ''}
    </div>
  `.trim();

      return inlineHtml;
    }

    renderCustomModal() {
      const calendar = this;
      const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
      const { value, hasTimePicker } = calendar;
      const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
      const sheetHtml = `
    <div class="calendar calendar-modal ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
      ${header ? calendar.renderHeader() : ''}
      ${toolbar ? calendar.renderToolbar() : ''}
      ${weekHeader ? calendar.renderWeekHeader() : ''}
      <div class="calendar-months">
        ${calendar.renderMonths(date)}
      </div>
      ${hasTimePicker ? calendar.renderTimeSelector() : ''}
      ${footer ? calendar.renderFooter() : ''}
    </div>
  `.trim();

      return sheetHtml;
    }

    renderSheet() {
      const calendar = this;
      const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
      const { value, hasTimePicker } = calendar;
      const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
      const sheetHtml = `
    <div class="sheet-modal calendar calendar-sheet ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
      ${header ? calendar.renderHeader() : ''}
      ${toolbar ? calendar.renderToolbar() : ''}
      ${weekHeader ? calendar.renderWeekHeader() : ''}
      <div class="sheet-modal-inner calendar-months">
        ${calendar.renderMonths(date)}
      </div>
      ${hasTimePicker ? calendar.renderTimeSelector() : ''}
      ${footer ? calendar.renderFooter() : ''}
    </div>
  `.trim();

      return sheetHtml;
    }

    renderPopover() {
      const calendar = this;
      const { cssClass, toolbar, header, footer, rangePicker, weekHeader } = calendar.params;
      const { value, hasTimePicker } = calendar;
      const date = value && value.length ? value[0] : new Date().setHours(0, 0, 0);
      const popoverHtml = `
    <div class="popover calendar-popover">
      <div class="popover-inner">
        <div class="calendar ${rangePicker ? 'calendar-range' : ''} ${cssClass || ''}">
        ${header ? calendar.renderHeader() : ''}
        ${toolbar ? calendar.renderToolbar() : ''}
        ${weekHeader ? calendar.renderWeekHeader() : ''}
        <div class="calendar-months">
          ${calendar.renderMonths(date)}
        </div>
        ${hasTimePicker ? calendar.renderTimeSelector() : ''}
        ${footer ? calendar.renderFooter() : ''}
        </div>
      </div>
    </div>
  `.trim();

      return popoverHtml;
    }

    render() {
      const calendar = this;
      const { params } = calendar;
      if (params.render) return params.render.call(calendar);
      if (!calendar.inline) {
        let modalType = params.openIn;
        if (modalType === 'auto') modalType = calendar.isPopover() ? 'popover' : 'sheet';

        if (modalType === 'popover') return calendar.renderPopover();
        if (modalType === 'sheet') return calendar.renderSheet();
        return calendar.renderCustomModal();
      }
      return calendar.renderInline();
    }

    openTimePicker() {
      const calendar = this;
      const { $el, app } = calendar;
      if (!$el || !$el.length) return;
      $el.append('<div class="calendar-time-picker"></div>');
      const hoursArr = [];
      const minutesArr = [];
      for (let i = 0; i <= 23; i += 1) { hoursArr.push(i); }
      for (let i = 0; i <= 59; i += 1) { minutesArr.push(i); }
      let value;
      if (calendar.value && calendar.value.length) {
        value = [calendar.value[0].getHours(), calendar.value[0].getMinutes()];
      } else {
        value = [new Date().getHours(), new Date().getMinutes()];
      }
      calendar.timePickerInstance = app.picker.create({
        containerEl: $el.find('.calendar-time-picker'),
        value,
        toolbar: true,
        rotateEffect: false,
        toolbarCloseText: calendar.params.toolbarCloseText,
        cols: [
          {
            values: hoursArr,
          },
          {
            divider: true,
            content: ':',
          },
          {
            values: minutesArr,
            displayValues: minutesArr.map(m => (m < 10 ? `0${m}` : m)),
          },
        ],
      });
      calendar.timePickerInstance.$el.find('.toolbar a').removeClass('sheet-close popover-close').addClass('calendar-time-picker-close');
    }

    closeTimePicker() {
      const calendar = this;
      if (calendar.timePickerInstance) {
        const [hours, minutes] = calendar.timePickerInstance.value.map(v => parseInt(v, 10));
        let value = calendar.value && calendar.value.length && calendar.value[0];
        if (!value) {
          value = new Date();
          value.setHours(hours, minutes, 0, 0);
        } else {
          value = new Date(value);
          value.setHours(hours, minutes);
        }
        calendar.setValue([value]);
        calendar.timePickerInstance.close();
        calendar.timePickerInstance.destroy();
        delete calendar.timePickerInstance;
      }
      if (calendar.$el && calendar.$el.length) {
        calendar.$el.find('.calendar-time-picker').remove();
      }
    }

    onOpen() {
      const calendar = this;
      const { initialized, $el, app, $inputEl, inline, value, params } = calendar;
      calendar.closing = false;
      calendar.opened = true;
      calendar.opening = true;

      // Init main events
      calendar.attachCalendarEvents();

      const updateValue = !value && params.value;

      // Set value
      if (!initialized) {
        if (value) calendar.setValue(value, 0);
        else if (params.value) {
          calendar.setValue(calendar.normalizeValues(params.value), 0);
        }
      } else if (value) {
        calendar.setValue(value, 0);
      }

      // Update current month and year
      calendar.updateCurrentMonthYear();

      // Set initial translate
      calendar.monthsTranslate = 0;
      calendar.setMonthsTranslate();

      // Update input value
      if (updateValue) calendar.updateValue();
      else if (params.header && value) {
        calendar.updateValue(true);
      }

      // Extra focus
      if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
        $inputEl.trigger('focus');
      }

      calendar.initialized = true;

      calendar.$months.each((index, monthEl) => {
        calendar.emit('local::monthAdd calendarMonthAdd', monthEl);
      });

      // Trigger events
      if ($el) {
        $el.trigger('calendar:open');
      }
      if ($inputEl) {
        $inputEl.trigger('calendar:open');
      }
      calendar.emit('local::open calendarOpen', calendar);
    }

    onOpened() {
      const calendar = this;
      calendar.opening = false;
      if (calendar.$el) {
        calendar.$el.trigger('calendar:opened');
      }
      if (calendar.$inputEl) {
        calendar.$inputEl.trigger('calendar:opened');
      }
      calendar.emit('local::opened calendarOpened', calendar);
    }

    onClose() {
      const calendar = this;
      const app = calendar.app;
      calendar.opening = false;
      calendar.closing = true;

      if (calendar.$inputEl && app.theme === 'md') {
        calendar.$inputEl.trigger('blur');
      }
      if (calendar.detachCalendarEvents) {
        calendar.detachCalendarEvents();
      }

      if (calendar.$el) {
        calendar.$el.trigger('calendar:close');
      }
      if (calendar.$inputEl) {
        calendar.$inputEl.trigger('calendar:close');
      }
      calendar.emit('local::close calendarClose', calendar);
    }

    onClosed() {
      const calendar = this;
      calendar.opened = false;
      calendar.closing = false;

      if (!calendar.inline) {
        Utils.nextTick(() => {
          if (calendar.modal && calendar.modal.el && calendar.modal.destroy) {
            if (!calendar.params.routableModals) {
              calendar.modal.destroy();
            }
          }
          delete calendar.modal;
        });
      }
      if (calendar.timePickerInstance) {
        if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
        delete calendar.timePickerInstance;
      }
      if (calendar.$el) {
        calendar.$el.trigger('calendar:closed');
      }
      if (calendar.$inputEl) {
        calendar.$inputEl.trigger('calendar:closed');
      }
      calendar.emit('local::closed calendarClosed', calendar);
    }

    open() {
      const calendar = this;
      const { app, opened, inline, $inputEl, params } = calendar;
      if (opened) return;

      if (inline) {
        calendar.$el = $(calendar.render());
        calendar.$el[0].f7Calendar = calendar;
        calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
        calendar.$months = calendar.$wrapperEl.find('.calendar-month');
        calendar.$containerEl.append(calendar.$el);
        calendar.onOpen();
        calendar.onOpened();
        return;
      }
      let modalType = params.openIn;
      if (modalType === 'auto') {
        modalType = calendar.isPopover() ? 'popover' : 'sheet';
      }
      const modalContent = calendar.render();

      const modalParams = {
        targetEl: $inputEl,
        scrollToEl: params.scrollToInput ? $inputEl : undefined,
        content: modalContent,
        backdrop: params.backdrop === true || (modalType === 'popover' && app.params.popover.backdrop !== false && params.backdrop !== false),
        closeByBackdropClick: params.closeByBackdropClick,
        on: {
          open() {
            const modal = this;
            calendar.modal = modal;
            calendar.$el = modalType === 'popover' ? modal.$el.find('.calendar') : modal.$el;
            calendar.$wrapperEl = calendar.$el.find('.calendar-months-wrapper');
            calendar.$months = calendar.$wrapperEl.find('.calendar-month');
            calendar.$el[0].f7Calendar = calendar;
            if (modalType === 'customModal') {
              $(calendar.$el).find('.calendar-close').once('click', () => {
                calendar.close();
              });
            }
            calendar.onOpen();
          },
          opened() { calendar.onOpened(); },
          close() { calendar.onClose(); },
          closed() { calendar.onClosed(); },
        },
      };
      if (modalType === 'sheet') {
        modalParams.push = params.sheetPush;
        modalParams.swipeToClose = params.sheetSwipeToClose;
      }
      if (params.routableModals && calendar.view) {
        calendar.view.router.navigate({
          url: calendar.url,
          route: {
            path: calendar.url,
            [modalType]: modalParams,
          },
        });
      } else {
        calendar.modal = app[modalType].create(modalParams);
        calendar.modal.open();
      }
    }

    close() {
      const calendar = this;
      const { opened, inline } = calendar;
      if (!opened) return;
      if (inline) {
        calendar.onClose();
        calendar.onClosed();
        return;
      }
      if (calendar.params.routableModals && calendar.view) {
        calendar.view.router.back();
      } else {
        calendar.modal.close();
      }
    }

    init() {
      const calendar = this;

      calendar.initInput();

      if (calendar.inline) {
        calendar.open();
        calendar.emit('local::init calendarInit', calendar);
        return;
      }

      if (!calendar.initialized && calendar.params.value) {
        calendar.setValue(calendar.normalizeValues(calendar.params.value));
      }

      // Attach input Events
      if (calendar.$inputEl) {
        calendar.attachInputEvents();
      }
      if (calendar.params.closeByOutsideClick) {
        calendar.attachHtmlEvents();
      }
      calendar.emit('local::init calendarInit', calendar);
    }

    destroy() {
      const calendar = this;
      if (calendar.destroyed) return;
      const { $el } = calendar;
      calendar.emit('local::beforeDestroy calendarBeforeDestroy', calendar);
      if ($el) $el.trigger('calendar:beforedestroy');

      calendar.close();

      // Detach Events
      if (calendar.$inputEl) {
        calendar.detachInputEvents();
      }
      if (calendar.params.closeByOutsideClick) {
        calendar.detachHtmlEvents();
      }

      if (calendar.timePickerInstance) {
        if (calendar.timePickerInstance.destroy) calendar.timePickerInstance.destroy();
        delete calendar.timePickerInstance;
      }

      if ($el && $el.length) delete calendar.$el[0].f7Calendar;
      Utils.deleteProps(calendar);
      calendar.destroyed = true;
    }
  }

  var Calendar$1 = {
    name: 'calendar',
    static: {
      Calendar,
    },
    create() {
      const app = this;
      app.calendar = ConstructorMethods({
        defaultSelector: '.calendar',
        constructor: Calendar,
        app,
        domProp: 'f7Calendar',
      });
      app.calendar.close = function close(el = '.calendar') {
        const $el = $(el);
        if ($el.length === 0) return;
        const calendar = $el[0].f7Calendar;
        if (!calendar || (calendar && !calendar.opened)) return;
        calendar.close();
      };
    },
    params: {
      calendar: {
        // Calendar settings
        dateFormat: undefined,
        monthNames: 'auto',
        monthNamesShort: 'auto',
        dayNames: 'auto',
        dayNamesShort: 'auto',
        locale: undefined,
        firstDay: 1, // First day of the week, Monday
        weekendDays: [0, 6], // Sunday and Saturday
        multiple: false,
        rangePicker: false,
        rangePickerMinDays: 1, // when calendar is used as rangePicker
        rangePickerMaxDays: 0, // when calendar is used as rangePicker, 0 means unlimited
        direction: 'horizontal', // or 'vertical'
        minDate: null,
        maxDate: null,
        disabled: null, // dates range of disabled days
        events: null, // dates range of days with events
        rangesClasses: null, // array with custom classes date ranges
        touchMove: true,
        animate: true,
        closeOnSelect: false,
        monthSelector: true,
        monthPicker: true,
        yearSelector: true,
        yearPicker: true,
        yearPickerMin: undefined,
        yearPickerMax: undefined,
        timePicker: false,
        timePickerFormat: { hour: 'numeric', minute: 'numeric' },
        timePickerPlaceholder: 'Select time',
        weekHeader: true,
        value: null,
        // Common opener settings
        containerEl: null,
        openIn: 'auto', // or 'popover' or 'sheet' or 'customModal'
        sheetPush: false,
        sheetSwipeToClose: undefined,
        formatValue: null,
        inputEl: null,
        inputReadOnly: true,
        closeByOutsideClick: true,
        scrollToInput: true,
        header: false,
        headerPlaceholder: 'Select date',
        toolbar: true,
        toolbarCloseText: 'Done',
        footer: false,
        cssClass: null,
        routableModals: true,
        view: null,
        url: 'date/',
        backdrop: null,
        closeByBackdropClick: true,
        // Render functions
        renderWeekHeader: null,
        renderMonths: null,
        renderMonth: null,
        renderMonthSelector: null,
        renderYearSelector: null,
        renderHeader: null,
        renderFooter: null,
        renderToolbar: null,
        renderInline: null,
        renderPopover: null,
        renderSheet: null,
        render: null,
      },
    },
  };

  function pickerColumn (colEl, updateItems) {
    const picker = this;
    const app = picker.app;
    const $colEl = $(colEl);
    const colIndex = $colEl.index();
    const col = picker.cols[colIndex];
    if (col.divider) return;

    col.$el = $colEl;
    col.el = $colEl[0];
    col.$itemsEl = col.$el.find('.picker-items');
    col.items = col.$itemsEl.find('.picker-item');

    let itemHeight;
    let itemsHeight;
    let minTranslate;
    let maxTranslate;
    let animationFrameId;

    function updateDuringScroll() {
      animationFrameId = Utils.requestAnimationFrame(() => {
        col.updateItems(undefined, undefined, 0);
        updateDuringScroll();
      });
    }

    col.replaceValues = function replaceColValues(values, displayValues) {
      col.detachEvents();
      col.values = values;
      col.displayValues = displayValues;
      col.$itemsEl.html(picker.renderColumn(col, true));
      col.items = col.$itemsEl.find('.picker-item');
      col.calcSize();
      col.setValue(col.values[0], 0, true);
      col.attachEvents();
    };
    col.calcSize = function calcColSize() {
      if (picker.params.rotateEffect) {
        col.$el.removeClass('picker-column-absolute');
        if (!col.width) col.$el.css({ width: '' });
      }
      let colWidth = 0;
      const colHeight = col.$el[0].offsetHeight;
      itemHeight = col.items[0].offsetHeight;
      itemsHeight = itemHeight * col.items.length;
      minTranslate = ((colHeight / 2) - itemsHeight) + (itemHeight / 2);
      maxTranslate = (colHeight / 2) - (itemHeight / 2);
      if (col.width) {
        colWidth = col.width;
        if (parseInt(colWidth, 10) === colWidth) colWidth += 'px';
        col.$el.css({ width: colWidth });
      }
      if (picker.params.rotateEffect) {
        if (!col.width) {
          col.items.each((index, itemEl) => {
            const item = $(itemEl).children('span');
            colWidth = Math.max(colWidth, item[0].offsetWidth);
          });
          col.$el.css({ width: `${colWidth + 2}px` });
        }
        col.$el.addClass('picker-column-absolute');
      }
    };

    col.setValue = function setColValue(newValue, transition = '', valueCallbacks) {
      const newActiveIndex = col.$itemsEl.find(`.picker-item[data-picker-value="${newValue}"]`).index();
      if (typeof newActiveIndex === 'undefined' || newActiveIndex === -1) {
        return;
      }
      const newTranslate = (-newActiveIndex * itemHeight) + maxTranslate;
      // Update wrapper
      col.$itemsEl.transition(transition);
      col.$itemsEl.transform(`translate3d(0,${newTranslate}px,0)`);

      // Watch items
      if (picker.params.updateValuesOnMomentum && col.activeIndex && col.activeIndex !== newActiveIndex) {
        Utils.cancelAnimationFrame(animationFrameId);
        col.$itemsEl.transitionEnd(() => {
          Utils.cancelAnimationFrame(animationFrameId);
        });
        updateDuringScroll();
      }

      // Update items
      col.updateItems(newActiveIndex, newTranslate, transition, valueCallbacks);
    };

    col.updateItems = function updateColItems(activeIndex, translate, transition, valueCallbacks) {
      if (typeof translate === 'undefined') {
        // eslint-disable-next-line
        translate = Utils.getTranslate(col.$itemsEl[0], 'y');
      }
      // eslint-disable-next-line
      if (typeof activeIndex === 'undefined') activeIndex = -Math.round((translate - maxTranslate) / itemHeight);
      // eslint-disable-next-line
      if (activeIndex < 0) activeIndex = 0;
      // eslint-disable-next-line
      if (activeIndex >= col.items.length) activeIndex = col.items.length - 1;
      const previousActiveIndex = col.activeIndex;
      col.activeIndex = activeIndex;
      col.$itemsEl.find('.picker-item-selected').removeClass('picker-item-selected');

      col.items.transition(transition);

      const selectedItem = col.items.eq(activeIndex).addClass('picker-item-selected').transform('');

      // Set 3D rotate effect
      if (picker.params.rotateEffect) {
        col.items.each((index, itemEl) => {
          const $itemEl = $(itemEl);
          const itemOffsetTop = $itemEl.index() * itemHeight;
          const translateOffset = maxTranslate - translate;
          const itemOffset = itemOffsetTop - translateOffset;
          const percentage = itemOffset / itemHeight;
          const itemsFit = Math.ceil(col.height / itemHeight / 2) + 1;

          let angle = (-18 * percentage);
          if (angle > 180) angle = 180;
          if (angle < -180) angle = -180;
          if (Math.abs(percentage) > itemsFit) {
            $itemEl.addClass('picker-item-far');
          } else {
            $itemEl.removeClass('picker-item-far');
          }
          $itemEl.transform(`translate3d(0, ${-translate + maxTranslate}px, ${picker.needsOriginFix ? -110 : 0}px) rotateX(${angle}deg)`);
        });
      }

      if (valueCallbacks || typeof valueCallbacks === 'undefined') {
        // Update values
        col.value = selectedItem.attr('data-picker-value');
        col.displayValue = col.displayValues ? col.displayValues[activeIndex] : col.value;
        // On change callback
        if (previousActiveIndex !== activeIndex) {
          if (col.onChange) {
            col.onChange(picker, col.value, col.displayValue);
          }
          picker.updateValue();
        }
      }
    };

    let allowItemClick = true;
    let isTouched;
    let isMoved;
    let touchStartY;
    let touchCurrentY;
    let touchStartTime;
    let touchEndTime;
    let startTranslate;
    let returnTo;
    let currentTranslate;
    let prevTranslate;
    let velocityTranslate;
    function handleTouchStart(e) {
      if (isMoved || isTouched) return;
      e.preventDefault();
      isTouched = true;
      touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      touchCurrentY = touchStartY;
      touchStartTime = (new Date()).getTime();

      allowItemClick = true;
      startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
      currentTranslate = startTranslate;
    }
    function handleTouchMove(e) {
      if (!isTouched) return;
      e.preventDefault();
      allowItemClick = false;
      touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      if (!isMoved) {
        // First move
        Utils.cancelAnimationFrame(animationFrameId);
        isMoved = true;
        startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
        currentTranslate = startTranslate;
        col.$itemsEl.transition(0);
      }

      const diff = touchCurrentY - touchStartY;
      currentTranslate = startTranslate + diff;
      returnTo = undefined;

      // Normalize translate
      if (currentTranslate < minTranslate) {
        currentTranslate = minTranslate - ((minTranslate - currentTranslate) ** 0.8);
        returnTo = 'min';
      }
      if (currentTranslate > maxTranslate) {
        currentTranslate = maxTranslate + ((currentTranslate - maxTranslate) ** 0.8);
        returnTo = 'max';
      }
      // Transform wrapper
      col.$itemsEl.transform(`translate3d(0,${currentTranslate}px,0)`);

      // Update items
      col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnTouchmove);

      // Calc velocity
      velocityTranslate = currentTranslate - prevTranslate || currentTranslate;
      prevTranslate = currentTranslate;
    }
    function handleTouchEnd() {
      if (!isTouched || !isMoved) {
        isTouched = false;
        isMoved = false;
        return;
      }
      isTouched = false;
      isMoved = false;
      col.$itemsEl.transition('');
      if (returnTo) {
        if (returnTo === 'min') {
          col.$itemsEl.transform(`translate3d(0,${minTranslate}px,0)`);
        } else {
          col.$itemsEl.transform(`translate3d(0,${maxTranslate}px,0)`);
        }
      }
      touchEndTime = new Date().getTime();
      let newTranslate;
      if (touchEndTime - touchStartTime > 300) {
        newTranslate = currentTranslate;
      } else {
        newTranslate = currentTranslate + (velocityTranslate * picker.params.momentumRatio);
      }

      newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);

      // Active Index
      const activeIndex = Math.round(Math.abs(((newTranslate - maxTranslate) / itemHeight)));

      // Normalize translate
      if (!picker.params.freeMode) newTranslate = (-activeIndex * itemHeight) + maxTranslate;

      // Transform wrapper
      col.$itemsEl.transform(`translate3d(0,${parseInt(newTranslate, 10)}px,0)`);

      // Update items
      col.updateItems(activeIndex, newTranslate, '', true);

      // Watch items
      if (picker.params.updateValuesOnMomentum) {
        updateDuringScroll();
        col.$itemsEl.transitionEnd(() => {
          Utils.cancelAnimationFrame(animationFrameId);
        });
      }

      // Allow click
      setTimeout(() => {
        allowItemClick = true;
      }, 100);
    }

    let mousewheelTimeout;
    function handleMouseWheel(e) {
      const { deltaX, deltaY } = e;
      if (Math.abs(deltaX) > Math.abs(deltaY)) return;
      clearTimeout(mousewheelTimeout);

      e.preventDefault();

      Utils.cancelAnimationFrame(animationFrameId);
      startTranslate = Utils.getTranslate(col.$itemsEl[0], 'y');
      col.$itemsEl.transition(0);

      currentTranslate = startTranslate - deltaY;
      returnTo = undefined;

      // Normalize translate
      if (currentTranslate < minTranslate) {
        currentTranslate = minTranslate;
        returnTo = 'min';
      }
      if (currentTranslate > maxTranslate) {
        currentTranslate = maxTranslate;
        returnTo = 'max';
      }
      // Transform wrapper
      col.$itemsEl.transform(`translate3d(0,${currentTranslate}px,0)`);

      // Update items
      col.updateItems(undefined, currentTranslate, 0, picker.params.updateValuesOnMousewheel);

      // On end
      mousewheelTimeout = setTimeout(() => {
        col.$itemsEl.transition('');
        if (returnTo) {
          if (returnTo === 'min') {
            col.$itemsEl.transform(`translate3d(0,${minTranslate}px,0)`);
          } else {
            col.$itemsEl.transform(`translate3d(0,${maxTranslate}px,0)`);
          }
        }
        touchEndTime = new Date().getTime();
        let newTranslate = currentTranslate;
        newTranslate = Math.max(Math.min(newTranslate, maxTranslate), minTranslate);

        // Active Index
        const activeIndex = Math.round(Math.abs(((newTranslate - maxTranslate) / itemHeight)));

        // Normalize translate
        if (!picker.params.freeMode) newTranslate = (-activeIndex * itemHeight) + maxTranslate;

        // Transform wrapper
        col.$itemsEl.transform(`translate3d(0,${parseInt(newTranslate, 10)}px,0)`);

        // Update items
        col.updateItems(activeIndex, newTranslate, '', true);
      }, 200);
    }

    function handleClick() {
      if (!allowItemClick) return;
      Utils.cancelAnimationFrame(animationFrameId);
      const value = $(this).attr('data-picker-value');
      col.setValue(value);
    }

    const activeListener = app.support.passiveListener ? { passive: false, capture: false } : false;
    col.attachEvents = function attachColEvents() {
      col.$el.on(app.touchEvents.start, handleTouchStart, activeListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      if (picker.params.mousewheel) {
        col.$el.on('wheel', handleMouseWheel);
      }
      col.items.on('click', handleClick);
    };
    col.detachEvents = function detachColEvents() {
      col.$el.off(app.touchEvents.start, handleTouchStart, activeListener);
      app.off('touchmove:active', handleTouchMove);
      app.off('touchend:passive', handleTouchEnd);
      if (picker.params.mousewheel) {
        col.$el.off('wheel', handleMouseWheel);
      }
      col.items.off('click', handleClick);
    };

    col.init = function initCol() {
      col.calcSize();
      col.$itemsEl.transform(`translate3d(0,${maxTranslate}px,0)`).transition(0);
      if (colIndex === 0) col.$el.addClass('picker-column-first');
      if (colIndex === picker.cols.length - 1) col.$el.addClass('picker-column-last');
      // Update items on init
      if (updateItems) col.updateItems(0, maxTranslate, 0);

      col.attachEvents();
    };

    col.destroy = function destroyCol() {
      col.detachEvents();
    };

    col.init();
  }

  class Picker extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);
      const picker = this;
      picker.params = Utils.extend({}, app.params.picker, params);

      let $containerEl;
      if (picker.params.containerEl) {
        $containerEl = $(picker.params.containerEl);
        if ($containerEl.length === 0) return picker;
      }

      let $inputEl;
      if (picker.params.inputEl) {
        $inputEl = $(picker.params.inputEl);
      }


      let $scrollToEl = picker.params.scrollToInput ? $inputEl : undefined;
      if (picker.params.scrollToEl) {
        const scrollToEl = $(picker.params.scrollToEl);
        if (scrollToEl.length > 0) {
          $scrollToEl = scrollToEl;
        }
      }

      Utils.extend(picker, {
        app,
        $containerEl,
        containerEl: $containerEl && $containerEl[0],
        inline: $containerEl && $containerEl.length > 0,
        needsOriginFix: app.device.ios || ((win.navigator.userAgent.toLowerCase().indexOf('safari') >= 0 && win.navigator.userAgent.toLowerCase().indexOf('chrome') < 0) && !app.device.android),
        cols: [],
        $inputEl,
        inputEl: $inputEl && $inputEl[0],
        $scrollToEl,
        initialized: false,
        opened: false,
        url: picker.params.url,
      });

      function onResize() {
        picker.resizeCols();
      }
      function onInputClick() {
        picker.open();
      }
      function onInputFocus(e) {
        e.preventDefault();
      }
      function onHtmlClick(e) {
        if (picker.destroyed || !picker.params) return;
        const $targetEl = $(e.target);
        if (picker.isPopover()) return;
        if (!picker.opened || picker.closing) return;
        if ($targetEl.closest('[class*="backdrop"]').length) return;
        if ($inputEl && $inputEl.length > 0) {
          if ($targetEl[0] !== $inputEl[0] && $targetEl.closest('.sheet-modal').length === 0) {
            picker.close();
          }
        } else if ($(e.target).closest('.sheet-modal').length === 0) {
          picker.close();
        }
      }

      // Events
      Utils.extend(picker, {
        attachResizeEvent() {
          app.on('resize', onResize);
        },
        detachResizeEvent() {
          app.off('resize', onResize);
        },
        attachInputEvents() {
          picker.$inputEl.on('click', onInputClick);
          if (picker.params.inputReadOnly) {
            picker.$inputEl.on('focus mousedown', onInputFocus);
          }
        },
        detachInputEvents() {
          picker.$inputEl.off('click', onInputClick);
          if (picker.params.inputReadOnly) {
            picker.$inputEl.off('focus mousedown', onInputFocus);
          }
        },
        attachHtmlEvents() {
          app.on('click', onHtmlClick);
        },
        detachHtmlEvents() {
          app.off('click', onHtmlClick);
        },
      });

      picker.init();

      return picker;
    }

    get view() {
      const { app, params, $inputEl } = this;
      let view;
      if (params.view) {
        view = params.view;
      } else if ($inputEl) {
        view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
      }
      if (!view) view = app.views.main;
      return view;
    }

    initInput() {
      const picker = this;
      if (!picker.$inputEl) return;
      if (picker.params.inputReadOnly) picker.$inputEl.prop('readOnly', true);
    }

    resizeCols() {
      const picker = this;
      if (!picker.opened) return;
      for (let i = 0; i < picker.cols.length; i += 1) {
        if (!picker.cols[i].divider) {
          picker.cols[i].calcSize();
          picker.cols[i].setValue(picker.cols[i].value, 0, false);
        }
      }
    }

    isPopover() {
      const picker = this;
      const { app, modal, params } = picker;
      if (params.openIn === 'sheet') return false;
      if (modal && modal.type !== 'popover') return false;

      if (!picker.inline && picker.inputEl) {
        if (params.openIn === 'popover') return true;
        if (app.device.ios) {
          return !!app.device.ipad;
        }
        if (app.width >= 768) {
          return true;
        }
        if (app.device.desktop && app.theme === 'aurora') {
          return true;
        }
      }
      return false;
    }

    formatValue() {
      const picker = this;
      const { value, displayValue } = picker;
      if (picker.params.formatValue) {
        return picker.params.formatValue.call(picker, value, displayValue);
      }
      return value.join(' ');
    }

    setValue(values, transition) {
      const picker = this;
      let valueIndex = 0;
      if (picker.cols.length === 0) {
        picker.value = values;
        picker.updateValue(values);
        return;
      }
      for (let i = 0; i < picker.cols.length; i += 1) {
        if (picker.cols[i] && !picker.cols[i].divider) {
          picker.cols[i].setValue(values[valueIndex], transition);
          valueIndex += 1;
        }
      }
    }

    getValue() {
      const picker = this;
      return picker.value;
    }

    updateValue(forceValues) {
      const picker = this;
      const newValue = forceValues || [];
      const newDisplayValue = [];
      let column;
      if (picker.cols.length === 0) {
        const noDividerColumns = picker.params.cols.filter(c => !c.divider);
        for (let i = 0; i < noDividerColumns.length; i += 1) {
          column = noDividerColumns[i];
          if (column.displayValues !== undefined && column.values !== undefined && column.values.indexOf(newValue[i]) !== -1) {
            newDisplayValue.push(column.displayValues[column.values.indexOf(newValue[i])]);
          } else {
            newDisplayValue.push(newValue[i]);
          }
        }
      } else {
        for (let i = 0; i < picker.cols.length; i += 1) {
          if (!picker.cols[i].divider) {
            newValue.push(picker.cols[i].value);
            newDisplayValue.push(picker.cols[i].displayValue);
          }
        }
      }

      if (newValue.indexOf(undefined) >= 0) {
        return;
      }
      picker.value = newValue;
      picker.displayValue = newDisplayValue;
      picker.emit('local::change pickerChange', picker, picker.value, picker.displayValue);
      if (picker.inputEl) {
        picker.$inputEl.val(picker.formatValue());
        picker.$inputEl.trigger('change');
      }
    }

    initColumn(colEl, updateItems) {
      const picker = this;
      pickerColumn.call(picker, colEl, updateItems);
    }
    // eslint-disable-next-line
    destroyColumn(colEl) {
      const picker = this;
      const $colEl = $(colEl);
      const index = $colEl.index();
      if (picker.cols[index] && picker.cols[index].destroy) {
        picker.cols[index].destroy();
      }
    }

    renderToolbar() {
      const picker = this;
      if (picker.params.renderToolbar) return picker.params.renderToolbar.call(picker, picker);
      return `
      <div class="toolbar toolbar-top no-shadow">
        <div class="toolbar-inner">
          <div class="left"></div>
          <div class="right">
            <a class="link sheet-close popover-close">${picker.params.toolbarCloseText}</a>
          </div>
        </div>
      </div>
    `.trim();
    }
    // eslint-disable-next-line
    renderColumn(col, onlyItems) {
      const colClasses = `picker-column ${col.textAlign ? `picker-column-${col.textAlign}` : ''} ${col.cssClass || ''}`;
      let columnHtml;
      let columnItemsHtml;

      if (col.divider) {
        columnHtml = `
        <div class="${colClasses} picker-column-divider">${col.content}</div>
      `;
      } else {
        columnItemsHtml = col.values.map((value, index) => `
        <div class="picker-item" data-picker-value="${value}">
          <span>${col.displayValues ? col.displayValues[index] : value}</span>
        </div>
      `).join('');
        columnHtml = `
        <div class="${colClasses}">
          <div class="picker-items">${columnItemsHtml}</div>
        </div>
      `;
      }

      return onlyItems ? columnItemsHtml.trim() : columnHtml.trim();
    }

    renderInline() {
      const picker = this;
      const { rotateEffect, cssClass, toolbar } = picker.params;
      const inlineHtml = `
      <div class="picker picker-inline ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
        ${toolbar ? picker.renderToolbar() : ''}
        <div class="picker-columns">
          ${picker.cols.map(col => picker.renderColumn(col)).join('')}
          <div class="picker-center-highlight"></div>
        </div>
      </div>
    `.trim();

      return inlineHtml;
    }

    renderSheet() {
      const picker = this;
      const { rotateEffect, cssClass, toolbar } = picker.params;
      const sheetHtml = `
      <div class="sheet-modal picker picker-sheet ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
        ${toolbar ? picker.renderToolbar() : ''}
        <div class="sheet-modal-inner picker-columns">
          ${picker.cols.map(col => picker.renderColumn(col)).join('')}
          <div class="picker-center-highlight"></div>
        </div>
      </div>
    `.trim();

      return sheetHtml;
    }

    renderPopover() {
      const picker = this;
      const { rotateEffect, cssClass, toolbar } = picker.params;
      const popoverHtml = `
      <div class="popover picker-popover">
        <div class="popover-inner">
          <div class="picker ${rotateEffect ? 'picker-3d' : ''} ${cssClass || ''}">
            ${toolbar ? picker.renderToolbar() : ''}
            <div class="picker-columns">
              ${picker.cols.map(col => picker.renderColumn(col)).join('')}
              <div class="picker-center-highlight"></div>
            </div>
          </div>
        </div>
      </div>
    `.trim();

      return popoverHtml;
    }

    render() {
      const picker = this;
      if (picker.params.render) return picker.params.render.call(picker);
      if (!picker.inline) {
        if (picker.isPopover()) return picker.renderPopover();
        return picker.renderSheet();
      }
      return picker.renderInline();
    }

    onOpen() {
      const picker = this;
      const { initialized, $el, app, $inputEl, inline, value, params } = picker;
      picker.opened = true;
      picker.closing = false;
      picker.opening = true;

      // Init main events
      picker.attachResizeEvent();

      // Init cols
      $el.find('.picker-column').each((index, colEl) => {
        let updateItems = true;
        if (
          (!initialized && params.value)
          || (initialized && value)
        ) {
          updateItems = false;
        }
        picker.initColumn(colEl, updateItems);
      });

      // Set value
      if (!initialized) {
        if (value) picker.setValue(value, 0);
        else if (params.value) {
          picker.setValue(params.value, 0);
        }
      } else if (value) {
        picker.setValue(value, 0);
      }

      // Extra focus
      if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
        $inputEl.trigger('focus');
      }

      picker.initialized = true;

      // Trigger events
      if ($el) {
        $el.trigger('picker:open');
      }
      if ($inputEl) {
        $inputEl.trigger('picker:open');
      }
      picker.emit('local::open pickerOpen', picker);
    }

    onOpened() {
      const picker = this;
      picker.opening = false;

      if (picker.$el) {
        picker.$el.trigger('picker:opened');
      }
      if (picker.$inputEl) {
        picker.$inputEl.trigger('picker:opened');
      }
      picker.emit('local::opened pickerOpened', picker);
    }

    onClose() {
      const picker = this;
      const app = picker.app;
      picker.opening = false;
      picker.closing = true;

      // Detach events
      picker.detachResizeEvent();

      picker.cols.forEach((col) => {
        if (col.destroy) col.destroy();
      });
      if (picker.$inputEl && app.theme === 'md') {
        picker.$inputEl.trigger('blur');
      }

      if (picker.$el) {
        picker.$el.trigger('picker:close');
      }
      if (picker.$inputEl) {
        picker.$inputEl.trigger('picker:close');
      }
      picker.emit('local::close pickerClose', picker);
    }

    onClosed() {
      const picker = this;
      picker.opened = false;
      picker.closing = false;

      if (!picker.inline) {
        Utils.nextTick(() => {
          if (picker.modal && picker.modal.el && picker.modal.destroy) {
            if (!picker.params.routableModals) {
              picker.modal.destroy();
            }
          }
          delete picker.modal;
        });
      }

      if (picker.$el) {
        picker.$el.trigger('picker:closed');
      }
      if (picker.$inputEl) {
        picker.$inputEl.trigger('picker:closed');
      }
      picker.emit('local::closed pickerClosed', picker);
    }

    open() {
      const picker = this;
      const { app, opened, inline, $inputEl, $scrollToEl, params } = picker;
      if (opened) return;
      if (picker.cols.length === 0 && params.cols.length) {
        params.cols.forEach((col) => {
          picker.cols.push(col);
        });
      }
      if (inline) {
        picker.$el = $(picker.render());
        picker.$el[0].f7Picker = picker;
        picker.$containerEl.append(picker.$el);
        picker.onOpen();
        picker.onOpened();
        return;
      }
      const isPopover = picker.isPopover();
      const modalType = isPopover ? 'popover' : 'sheet';
      const modalParams = {
        targetEl: $inputEl,
        scrollToEl: $scrollToEl,
        content: picker.render(),
        backdrop: typeof params.backdrop !== 'undefined' ? params.backdrop : isPopover,
        on: {
          open() {
            const modal = this;
            picker.modal = modal;
            picker.$el = isPopover ? modal.$el.find('.picker') : modal.$el;
            picker.$el[0].f7Picker = picker;
            picker.onOpen();
          },
          opened() { picker.onOpened(); },
          close() { picker.onClose(); },
          closed() { picker.onClosed(); },
        },
      };
      if (modalType === 'sheet') {
        modalParams.push = params.sheetPush;
        modalParams.swipeToClose = params.sheetSwipeToClose;
      }
      if (params.routableModals && picker.view) {
        picker.view.router.navigate({
          url: picker.url,
          route: {
            path: picker.url,
            [modalType]: modalParams,
          },
        });
      } else {
        picker.modal = app[modalType].create(modalParams);
        picker.modal.open();
      }
    }

    close() {
      const picker = this;
      const { opened, inline } = picker;
      if (!opened) return;
      if (inline) {
        picker.onClose();
        picker.onClosed();
        return;
      }
      if (picker.params.routableModals && picker.view) {
        picker.view.router.back();
      } else {
        picker.modal.close();
      }
    }

    init() {
      const picker = this;

      picker.initInput();

      if (picker.inline) {
        picker.open();
        picker.emit('local::init pickerInit', picker);
        return;
      }

      if (!picker.initialized && picker.params.value) {
        picker.setValue(picker.params.value);
      }

      // Attach input Events
      if (picker.$inputEl) {
        picker.attachInputEvents();
      }
      if (picker.params.closeByOutsideClick) {
        picker.attachHtmlEvents();
      }
      picker.emit('local::init pickerInit', picker);
    }

    destroy() {
      const picker = this;
      if (picker.destroyed) return;
      const { $el } = picker;
      picker.emit('local::beforeDestroy pickerBeforeDestroy', picker);
      if ($el) $el.trigger('picker:beforedestroy');

      picker.close();

      // Detach Events
      if (picker.$inputEl) {
        picker.detachInputEvents();
      }
      if (picker.params.closeByOutsideClick) {
        picker.detachHtmlEvents();
      }

      if ($el && $el.length) delete picker.$el[0].f7Picker;
      Utils.deleteProps(picker);
      picker.destroyed = true;
    }
  }

  var Picker$1 = {
    name: 'picker',
    static: {
      Picker,
    },
    create() {
      const app = this;
      app.picker = ConstructorMethods({
        defaultSelector: '.picker',
        constructor: Picker,
        app,
        domProp: 'f7Picker',
      });
      app.picker.close = function close(el = '.picker') {
        const $el = $(el);
        if ($el.length === 0) return;
        const picker = $el[0].f7Picker;
        if (!picker || (picker && !picker.opened)) return;
        picker.close();
      };
    },
    params: {
      picker: {
        // Picker settings
        updateValuesOnMomentum: false,
        updateValuesOnTouchmove: true,
        updateValuesOnMousewheel: true,
        mousewheel: true,
        rotateEffect: false,
        momentumRatio: 7,
        freeMode: false,
        cols: [],
        // Common opener settings
        containerEl: null,
        openIn: 'auto', // or 'popover' or 'sheet'
        sheetPush: false,
        sheetSwipeToClose: undefined,
        backdrop: undefined, // uses Popover or Sheet defaults
        formatValue: null,
        inputEl: null,
        inputReadOnly: true,
        closeByOutsideClick: true,
        scrollToInput: true,
        scrollToEl: undefined,
        toolbar: true,
        toolbarCloseText: 'Done',
        cssClass: null,
        routableModals: true,
        view: null,
        url: 'select/',
        // Render functions
        renderToolbar: null,
        render: null,
      },
    },
  };

  const InfiniteScroll = {
    handleScroll(el, e) {
      const app = this;
      const $el = $(el);
      const scrollTop = $el[0].scrollTop;
      const scrollHeight = $el[0].scrollHeight;
      const height = $el[0].offsetHeight;
      let distance = $el[0].getAttribute('data-infinite-distance');

      const virtualListContainer = $el.find('.virtual-list');
      let virtualList;

      const onTop = $el.hasClass('infinite-scroll-top');
      if (!distance) distance = 50;
      if (typeof distance === 'string' && distance.indexOf('%') >= 0) {
        distance = (parseInt(distance, 10) / 100) * height;
      }
      if (distance > height) distance = height;
      if (onTop) {
        if (scrollTop < distance) {
          $el.trigger('infinite', e);
          app.emit('infinite', $el[0], e);
        }
      } else if (scrollTop + height >= scrollHeight - distance) {
        if (virtualListContainer.length > 0) {
          virtualList = virtualListContainer.eq(-1)[0].f7VirtualList;
          if (virtualList && !virtualList.reachEnd && !virtualList.params.updatableScroll) {
            return;
          }
        }
        $el.trigger('infinite', e);
        app.emit('infinite', $el[0], e);
      }
    },
    create(el) {
      const $el = $(el);
      const app = this;
      function scrollHandler(e) {
        app.infiniteScroll.handle(this, e);
      }
      $el.each((index, element) => {
        element.f7InfiniteScrollHandler = scrollHandler;
        element.addEventListener('scroll', element.f7InfiniteScrollHandler);
      });
    },
    destroy(el) {
      const $el = $(el);
      $el.each((index, element) => {
        element.removeEventListener('scroll', element.f7InfiniteScrollHandler);
        delete element.f7InfiniteScrollHandler;
      });
    },
  };
  var InfiniteScroll$1 = {
    name: 'infiniteScroll',
    create() {
      const app = this;
      Utils.extend(app, {
        infiniteScroll: {
          handle: InfiniteScroll.handleScroll.bind(app),
          create: InfiniteScroll.create.bind(app),
          destroy: InfiniteScroll.destroy.bind(app),
        },
      });
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        const $tabEl = $(tabEl);
        const $isEls = $tabEl.find('.infinite-scroll-content');
        if ($tabEl.is('.infinite-scroll-content')) $isEls.add($tabEl);
        $isEls.each((index, el) => {
          app.infiniteScroll.create(el);
        });
      },
      tabBeforeRemove(tabEl) {
        const $tabEl = $(tabEl);
        const app = this;
        const $isEls = $tabEl.find('.infinite-scroll-content');
        if ($tabEl.is('.infinite-scroll-content')) $isEls.add($tabEl);
        $isEls.each((index, el) => {
          app.infiniteScroll.destroy(el);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.infinite-scroll-content').each((index, el) => {
          app.infiniteScroll.create(el);
        });
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.infinite-scroll-content').each((index, el) => {
          app.infiniteScroll.destroy(el);
        });
      },
    },
  };

  class PullToRefresh extends Framework7Class {
    constructor(app, el) {
      super({}, [app]);
      const ptr = this;
      const $el = $(el);
      const $preloaderEl = $el.find('.ptr-preloader');

      ptr.$el = $el;
      ptr.el = $el[0];
      ptr.app = app;

      ptr.bottom = ptr.$el.hasClass('ptr-bottom');

      // Extend defaults with modules params
      ptr.useModulesParams({});

      const isMaterial = app.theme === 'md';
      const isIos = app.theme === 'ios';
      const isAurora = app.theme === 'aurora';

      // Done
      ptr.done = function done() {
        const $transitionTarget = isMaterial ? $preloaderEl : $el;
        $transitionTarget.transitionEnd(() => {
          $el.removeClass('ptr-transitioning ptr-pull-up ptr-pull-down ptr-closing');
          $el.trigger('ptr:done');
          ptr.emit('local::done ptrDone', $el[0]);
        });
        $el.removeClass('ptr-refreshing').addClass('ptr-transitioning ptr-closing');
        return ptr;
      };

      ptr.refresh = function refresh() {
        if ($el.hasClass('ptr-refreshing')) return ptr;
        $el.addClass('ptr-transitioning ptr-refreshing');
        $el.trigger('ptr:refresh', ptr.done);
        ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
        return ptr;
      };

      // Mousewheel
      ptr.mousewheel = $el.attr('data-ptr-mousewheel') === 'true';

      // Events handling
      let touchId;
      let isTouched;
      let isMoved;
      const touchesStart = {};
      let isScrolling;
      let touchesDiff;
      let refresh = false;
      let useTranslate = false;
      let forceUseTranslate = false;
      let startTranslate = 0;
      let translate;
      let scrollTop;
      let wasScrolled;
      let triggerDistance;
      let dynamicTriggerDistance;
      let pullStarted;
      let hasNavbar = false;
      let scrollHeight;
      let offsetHeight;
      let maxScrollTop;
      const $pageEl = $el.parents('.page');

      if ($pageEl.find('.navbar').length > 0 || $pageEl.parents('.view').children('.navbars').length > 0) hasNavbar = true;
      if ($pageEl.hasClass('no-navbar')) hasNavbar = false;
      if (!ptr.bottom) {
        const pageNavbarEl = app.navbar.getElByPage($pageEl[0]);
        if (pageNavbarEl) {
          const $pageNavbarEl = $(pageNavbarEl);
          const isLargeTransparent = $pageNavbarEl.hasClass('navbar-large-transparent')
            || (
              $pageNavbarEl.hasClass('navbar-large')
              && $pageNavbarEl.hasClass('navbar-transparent')
            );
          const isTransparent = $pageNavbarEl.hasClass('navbar-transparent') && !$pageNavbarEl.hasClass('navbar-large');
          if (isLargeTransparent) {
            $el.addClass('ptr-with-navbar-large-transparent');
          } else if (isTransparent) {
            $el.addClass('ptr-with-navbar-transparent');
          }
        }
      }
      if (!hasNavbar && !ptr.bottom) $el.addClass('ptr-no-navbar');

      // Define trigger distance
      if ($el.attr('data-ptr-distance')) {
        dynamicTriggerDistance = true;
      } else if (isMaterial) {
        triggerDistance = 66;
      } else if (isIos) {
        triggerDistance = 44;
      } else if (isAurora) {
        triggerDistance = 38;
      }

      function handleTouchStart(e) {
        if (isTouched) {
          if (Device.os === 'android') {
            if ('targetTouches' in e && e.targetTouches.length > 1) return;
          } else return;
        }

        if ($el.hasClass('ptr-refreshing')) {
          return;
        }
        if ($(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) return;

        isMoved = false;
        pullStarted = false;
        isTouched = true;
        isScrolling = undefined;
        wasScrolled = undefined;
        if (e.type === 'touchstart') touchId = e.targetTouches[0].identifier;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      }

      function handleTouchMove(e) {
        if (!isTouched) return;
        let pageX;
        let pageY;
        let touch;
        if (e.type === 'touchmove') {
          if (touchId && e.touches) {
            for (let i = 0; i < e.touches.length; i += 1) {
              if (e.touches[i].identifier === touchId) {
                touch = e.touches[i];
              }
            }
          }
          if (!touch) touch = e.targetTouches[0];
          pageX = touch.pageX;
          pageY = touch.pageY;
        } else {
          pageX = e.pageX;
          pageY = e.pageY;
        }
        if (!pageX || !pageY) return;


        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) > Math.abs(pageX - touchesStart.x));
        }
        if (!isScrolling) {
          isTouched = false;
          return;
        }

        scrollTop = $el[0].scrollTop;

        if (!isMoved) {
          $el.removeClass('ptr-transitioning');
          let targetIsScrollable;
          scrollHeight = $el[0].scrollHeight;
          offsetHeight = $el[0].offsetHeight;
          if (ptr.bottom) {
            maxScrollTop = scrollHeight - offsetHeight;
          }
          if (scrollTop > scrollHeight) {
            isTouched = false;
            return;
          }
          const $ptrWatchScrollable = $(e.target).closest('.ptr-watch-scroll');
          if ($ptrWatchScrollable.length) {
            $ptrWatchScrollable.each((ptrScrollableIndex, ptrScrollableEl) => {
              if (ptrScrollableEl === el) return;
              if (
                (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight)
                && $(ptrScrollableEl).css('overflow') === 'auto'
                && (
                  (!ptr.bottom && ptrScrollableEl.scrollTop > 0)
                  || (ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)
                )
              ) {
                targetIsScrollable = true;
              }
            });
          }
          if (targetIsScrollable) {
            isTouched = false;
            return;
          }
          if (dynamicTriggerDistance) {
            triggerDistance = $el.attr('data-ptr-distance');
            if (triggerDistance.indexOf('%') >= 0) triggerDistance = (scrollHeight * parseInt(triggerDistance, 10)) / 100;
          }
          startTranslate = $el.hasClass('ptr-refreshing') ? triggerDistance : 0;
          if (scrollHeight === offsetHeight || Device.os !== 'ios' || isMaterial) {
            useTranslate = true;
          } else {
            useTranslate = false;
          }
          forceUseTranslate = false;
        }
        isMoved = true;
        touchesDiff = pageY - touchesStart.y;

        if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) wasScrolled = true;

        const ptrStarted = ptr.bottom
          ? (touchesDiff < 0 && scrollTop >= maxScrollTop) || scrollTop > maxScrollTop
          : (touchesDiff > 0 && scrollTop <= 0) || scrollTop < 0;

        if (ptrStarted) {
          // iOS 8 fix
          if (Device.os === 'ios' && parseInt(Device.osVersion.split('.')[0], 10) > 7) {
            if (!ptr.bottom && scrollTop === 0 && !wasScrolled) useTranslate = true;
            if (ptr.bottom && scrollTop === maxScrollTop && !wasScrolled) useTranslate = true;
          }

          if (!useTranslate && ptr.bottom && !isMaterial) {
            $el.css('-webkit-overflow-scrolling', 'auto');
            $el.scrollTop(maxScrollTop);
            forceUseTranslate = true;
          }

          if (useTranslate || forceUseTranslate) {
            if (e.cancelable) {
              e.preventDefault();
            }
            translate = (ptr.bottom ? -1 * (Math.abs(touchesDiff) ** 0.85) : touchesDiff ** 0.85) + startTranslate;
            if (isMaterial) {
              $preloaderEl.transform(`translate3d(0,${translate}px,0)`)
                .find('.ptr-arrow').transform(`rotate(${(180 * (Math.abs(touchesDiff) / 66)) + 100}deg)`);
            } else {
              // eslint-disable-next-line
              if (ptr.bottom) {
                $el.children().transform(`translate3d(0,${translate}px,0)`);
              } else {
                $el.transform(`translate3d(0,${translate}px,0)`);
              }
            }
          }

          if (((useTranslate || forceUseTranslate) && (Math.abs(touchesDiff) ** 0.85) > triggerDistance) || (!useTranslate && Math.abs(touchesDiff) >= triggerDistance * 2)) {
            refresh = true;
            $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
          } else {
            refresh = false;
            $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
          }
          if (!pullStarted) {
            $el.trigger('ptr:pullstart');
            ptr.emit('local::pullStart ptrPullStart', $el[0]);
            pullStarted = true;
          }
          $el.trigger('ptr:pullmove', {
            event: e,
            scrollTop,
            translate,
            touchesDiff,
          });
          ptr.emit('local::pullMove ptrPullMove', $el[0], {
            event: e,
            scrollTop,
            translate,
            touchesDiff,
          });
        } else {
          pullStarted = false;
          $el.removeClass('ptr-pull-up ptr-pull-down');
          refresh = false;
        }
      }
      function handleTouchEnd(e) {
        if (e.type === 'touchend' && e.changedTouches && e.changedTouches.length > 0 && touchId) {
          if (e.changedTouches[0].identifier !== touchId) {
            isTouched = false;
            isScrolling = false;
            isMoved = false;
            touchId = null;
            return;
          }
        }
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }
        if (translate) {
          $el.addClass('ptr-transitioning');
          translate = 0;
        }
        if (isMaterial) {
          $preloaderEl.transform('')
            .find('.ptr-arrow').transform('');
        } else {
          // eslint-disable-next-line
          if (ptr.bottom) {
            $el.children().transform('');
          } else {
            $el.transform('');
          }
        }

        if (!useTranslate && ptr.bottom && !isMaterial) {
          $el.css('-webkit-overflow-scrolling', '');
        }

        if (refresh) {
          $el.addClass('ptr-refreshing');
          $el.trigger('ptr:refresh', ptr.done);
          ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
        } else {
          $el.removeClass('ptr-pull-down');
        }
        isTouched = false;
        isMoved = false;
        if (pullStarted) {
          $el.trigger('ptr:pullend');
          ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
        }
      }

      let mousewheelTimeout;
      let mousewheelMoved;
      let mousewheelAllow = true;
      let mousewheelTranslate = 0;

      function handleMouseWheelRelease() {
        mousewheelAllow = true;
        mousewheelMoved = false;
        mousewheelTranslate = 0;
        if (translate) {
          $el.addClass('ptr-transitioning');
          translate = 0;
        }
        if (isMaterial) {
          $preloaderEl.transform('')
            .find('.ptr-arrow').transform('');
        } else {
          // eslint-disable-next-line
          if (ptr.bottom) {
            $el.children().transform('');
          } else {
            $el.transform('');
          }
        }

        if (refresh) {
          $el.addClass('ptr-refreshing');
          $el.trigger('ptr:refresh', ptr.done);
          ptr.emit('local::refresh ptrRefresh', $el[0], ptr.done);
        } else {
          $el.removeClass('ptr-pull-down');
        }
        if (pullStarted) {
          $el.trigger('ptr:pullend');
          ptr.emit('local::pullEnd ptrPullEnd', $el[0]);
        }
      }
      function handleMouseWheel(e) {
        if (!mousewheelAllow) return;
        const { deltaX, deltaY } = e;
        if (Math.abs(deltaX) > Math.abs(deltaY)) return;
        if ($el.hasClass('ptr-refreshing')) {
          return;
        }
        if ($(e.target).closest('.sortable-handler, .ptr-ignore, .card-expandable.card-opened').length) return;

        clearTimeout(mousewheelTimeout);

        scrollTop = $el[0].scrollTop;

        if (!mousewheelMoved) {
          $el.removeClass('ptr-transitioning');
          let targetIsScrollable;
          scrollHeight = $el[0].scrollHeight;
          offsetHeight = $el[0].offsetHeight;
          if (ptr.bottom) {
            maxScrollTop = scrollHeight - offsetHeight;
          }
          if (scrollTop > scrollHeight) {
            mousewheelAllow = false;
            return;
          }
          const $ptrWatchScrollable = $(e.target).closest('.ptr-watch-scroll');
          if ($ptrWatchScrollable.length) {
            $ptrWatchScrollable.each((ptrScrollableIndex, ptrScrollableEl) => {
              if (ptrScrollableEl === el) return;
              if (
                (ptrScrollableEl.scrollHeight > ptrScrollableEl.offsetHeight)
                && $(ptrScrollableEl).css('overflow') === 'auto'
                && (
                  (!ptr.bottom && ptrScrollableEl.scrollTop > 0)
                  || (ptr.bottom && ptrScrollableEl.scrollTop < ptrScrollableEl.scrollHeight - ptrScrollableEl.offsetHeight)
                )
              ) {
                targetIsScrollable = true;
              }
            });
          }
          if (targetIsScrollable) {
            mousewheelAllow = false;
            return;
          }
          if (dynamicTriggerDistance) {
            triggerDistance = $el.attr('data-ptr-distance');
            if (triggerDistance.indexOf('%') >= 0) triggerDistance = (scrollHeight * parseInt(triggerDistance, 10)) / 100;
          }
        }
        isMoved = true;
        mousewheelTranslate -= deltaY;
        touchesDiff = mousewheelTranslate; // pageY - touchesStart.y;

        if (typeof wasScrolled === 'undefined' && (ptr.bottom ? scrollTop !== maxScrollTop : scrollTop !== 0)) wasScrolled = true;

        const ptrStarted = ptr.bottom
          ? (touchesDiff < 0 && scrollTop >= maxScrollTop) || scrollTop > maxScrollTop
          : (touchesDiff > 0 && scrollTop <= 0) || scrollTop < 0;

        if (ptrStarted) {
          if (e.cancelable) {
            e.preventDefault();
          }

          translate = touchesDiff;
          if (Math.abs(translate) > triggerDistance) {
            translate = triggerDistance + ((Math.abs(translate) - triggerDistance) ** 0.7);
            if (ptr.bottom) translate = -translate;
          }

          if (isMaterial) {
            $preloaderEl.transform(`translate3d(0,${translate}px,0)`)
              .find('.ptr-arrow').transform(`rotate(${(180 * (Math.abs(touchesDiff) / 66)) + 100}deg)`);
          } else {
            // eslint-disable-next-line
            if (ptr.bottom) {
              $el.children().transform(`translate3d(0,${translate}px,0)`);
            } else {
              $el.transform(`translate3d(0,${translate}px,0)`);
            }
          }

          if (Math.abs(translate) > triggerDistance) {
            refresh = true;
            $el.addClass('ptr-pull-up').removeClass('ptr-pull-down');
          } else {
            refresh = false;
            $el.removeClass('ptr-pull-up').addClass('ptr-pull-down');
          }
          if (!pullStarted) {
            $el.trigger('ptr:pullstart');
            ptr.emit('local::pullStart ptrPullStart', $el[0]);
            pullStarted = true;
          }
          $el.trigger('ptr:pullmove', {
            event: e,
            scrollTop,
            translate,
            touchesDiff,
          });
          ptr.emit('local::pullMove ptrPullMove', $el[0], {
            event: e,
            scrollTop,
            translate,
            touchesDiff,
          });
        } else {
          pullStarted = false;
          $el.removeClass('ptr-pull-up ptr-pull-down');
          refresh = false;
        }

        mousewheelTimeout = setTimeout(handleMouseWheelRelease, 300);
      }

      if (!$pageEl.length || !$el.length) return ptr;

      $el[0].f7PullToRefresh = ptr;

      // Events
      ptr.attachEvents = function attachEvents() {
        const passive = Support.passiveListener ? { passive: true } : false;
        $el.on(app.touchEvents.start, handleTouchStart, passive);
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
        if (ptr.mousewheel && !ptr.bottom) {
          $el.on('wheel', handleMouseWheel);
        }
      };
      ptr.detachEvents = function detachEvents() {
        const passive = Support.passiveListener ? { passive: true } : false;
        $el.off(app.touchEvents.start, handleTouchStart, passive);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        if (ptr.mousewheel && !ptr.bottom) {
          $el.off('wheel', handleMouseWheel);
        }
      };

      // Install Modules
      ptr.useModules();

      // Init
      ptr.init();

      return ptr;
    }

    init() {
      const ptr = this;
      ptr.attachEvents();
    }

    destroy() {
      let ptr = this;
      ptr.emit('local::beforeDestroy ptrBeforeDestroy', ptr);
      ptr.$el.trigger('ptr:beforedestroy');
      delete ptr.el.f7PullToRefresh;
      ptr.detachEvents();
      Utils.deleteProps(ptr);
      ptr = null;
    }
  }

  var PullToRefresh$1 = {
    name: 'pullToRefresh',
    create() {
      const app = this;
      app.ptr = Utils.extend(
        ConstructorMethods({
          defaultSelector: '.ptr-content',
          constructor: PullToRefresh,
          app,
          domProp: 'f7PullToRefresh',
        }),
        {
          done(el) {
            const ptr = app.ptr.get(el);
            if (ptr) return ptr.done();
            return undefined;
          },
          refresh(el) {
            const ptr = app.ptr.get(el);
            if (ptr) return ptr.refresh();
            return undefined;
          },
        }
      );
    },
    static: {
      PullToRefresh,
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        const $tabEl = $(tabEl);
        const $ptrEls = $tabEl.find('.ptr-content');
        if ($tabEl.is('.ptr-content')) $ptrEls.add($tabEl);
        $ptrEls.each((index, el) => {
          app.ptr.create(el);
        });
      },
      tabBeforeRemove(tabEl) {
        const $tabEl = $(tabEl);
        const app = this;
        const $ptrEls = $tabEl.find('.ptr-content');
        if ($tabEl.is('.ptr-content')) $ptrEls.add($tabEl);
        $ptrEls.each((index, el) => {
          app.ptr.destroy(el);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.ptr-content').each((index, el) => {
          app.ptr.create(el);
        });
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.ptr-content').each((index, el) => {
          app.ptr.destroy(el);
        });
      },
    },
  };

  const Lazy = {
    destroy(pageEl) {
      const $pageEl = $(pageEl).closest('.page');
      if (!$pageEl.length) return;
      if ($pageEl[0].f7LazyDestroy) {
        $pageEl[0].f7LazyDestroy();
      }
    },
    create(pageEl) {
      const app = this;
      const $pageEl = $(pageEl).closest('.page').eq(0);

      // Lazy images
      const $lazyLoadImages = $pageEl.find('.lazy');
      if ($lazyLoadImages.length === 0 && !$pageEl.hasClass('lazy')) return;

      // Placeholder
      const placeholderSrc = app.params.lazy.placeholder;

      if (placeholderSrc !== false) {
        $lazyLoadImages.each((index, lazyEl) => {
          if ($(lazyEl).attr('data-src') && !$(lazyEl).attr('src')) $(lazyEl).attr('src', placeholderSrc);
        });
      }

      // load image
      const imagesSequence = [];
      let imageIsLoading = false;

      function onImageComplete(lazyEl) {
        if (imagesSequence.indexOf(lazyEl) >= 0) {
          imagesSequence.splice(imagesSequence.indexOf(lazyEl), 1);
        }
        imageIsLoading = false;
        if (app.params.lazy.sequential && imagesSequence.length > 0) {
          imageIsLoading = true;
          app.lazy.loadImage(imagesSequence[0], onImageComplete);
        }
      }

      function observerCallback(entries, observer) {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            if (app.params.lazy.sequential && imageIsLoading) {
              if (imagesSequence.indexOf(entry.target) < 0) imagesSequence.push(entry.target);
              return;
            }
            // Load image
            imageIsLoading = true;
            app.lazy.loadImage(entry.target, onImageComplete);
            // Detach
            observer.unobserve(entry.target);
          }
        });
      }
      if (app.params.lazy.observer && Support.intersectionObserver) {
        let observer = $pageEl[0].f7LazyObserver;
        if (!observer) {
          observer = new win.IntersectionObserver(observerCallback, {
            root: $pageEl[0],
          });
        }
        $lazyLoadImages.each((index, el) => {
          if (el.f7LazyObserverAdded) return;
          el.f7LazyObserverAdded = true;
          observer.observe(el);
        });
        if (!$pageEl[0].f7LazyDestroy) {
          $pageEl[0].f7LazyDestroy = () => {
            observer.disconnect();
            delete $pageEl[0].f7LazyDestroy;
            delete $pageEl[0].f7LazyObserver;
          };
        }
        return;
      }

      function lazyHandler() {
        app.lazy.load($pageEl, (lazyEl) => {
          if (app.params.lazy.sequential && imageIsLoading) {
            if (imagesSequence.indexOf(lazyEl) < 0) imagesSequence.push(lazyEl);
            return;
          }
          imageIsLoading = true;
          app.lazy.loadImage(lazyEl, onImageComplete);
        });
      }

      function attachEvents() {
        $pageEl[0].f7LazyAttached = true;
        $pageEl.on('lazy', lazyHandler);
        $pageEl.on('scroll', lazyHandler, true);
        $pageEl.find('.tab').on('tab:mounted tab:show', lazyHandler);
        app.on('resize', lazyHandler);
      }
      function detachEvents() {
        $pageEl[0].f7LazyAttached = false;
        delete $pageEl[0].f7LazyAttached;
        $pageEl.off('lazy', lazyHandler);
        $pageEl.off('scroll', lazyHandler, true);
        $pageEl.find('.tab').off('tab:mounted tab:show', lazyHandler);
        app.off('resize', lazyHandler);
      }

      // Store detach function
      if (!$pageEl[0].f7LazyDestroy) {
        $pageEl[0].f7LazyDestroy = detachEvents;
      }

      // Attach events
      if (!$pageEl[0].f7LazyAttached) {
        attachEvents();
      }

      // Run loader on page load/init
      lazyHandler();
    },
    isInViewport(lazyEl) {
      const app = this;
      const rect = lazyEl.getBoundingClientRect();
      const threshold = app.params.lazy.threshold || 0;

      return (
        rect.top >= (0 - threshold)
        && rect.left >= (0 - threshold)
        && rect.top <= (app.height + threshold)
        && rect.left <= (app.width + threshold)
      );
    },
    loadImage(imageEl, callback) {
      const app = this;
      const $imageEl = $(imageEl);

      const bg = $imageEl.attr('data-background');
      const src = bg || $imageEl.attr('data-src');

      function onLoad() {
        $imageEl.removeClass('lazy').addClass('lazy-loaded');
        if (bg) {
          $imageEl.css('background-image', `url(${src})`);
        } else if (src) {
          $imageEl.attr('src', src);
        }
        if (callback) callback(imageEl);
        $imageEl.trigger('lazy:loaded');
        app.emit('lazyLoaded', $imageEl[0]);
      }

      if (!src) {
        $imageEl.trigger('lazy:load');
        app.emit('lazyLoad', $imageEl[0]);
        onLoad();
        return;
      }
      function onError() {
        $imageEl.removeClass('lazy').addClass('lazy-loaded');
        if (bg) {
          $imageEl.css('background-image', `url(${app.params.lazy.placeholder || ''})`);
        } else {
          $imageEl.attr('src', app.params.lazy.placeholder || '');
        }
        if (callback) callback(imageEl);
        $imageEl.trigger('lazy:error');
        app.emit('lazyError', $imageEl[0]);
      }
      const image = new win.Image();
      image.onload = onLoad;
      image.onerror = onError;
      image.src = src;

      $imageEl.removeAttr('data-src').removeAttr('data-background');

      // Add loaded callback and events
      $imageEl.trigger('lazy:load');
      app.emit('lazyLoad', $imageEl[0]);
    },
    load(pageEl, callback) {
      const app = this;
      let $pageEl = $(pageEl);
      if (!$pageEl.hasClass('page')) $pageEl = $pageEl.parents('.page').eq(0);
      if ($pageEl.length === 0) {
        return;
      }
      $pageEl.find('.lazy').each((index, lazyEl) => {
        const $lazyEl = $(lazyEl);
        if ($lazyEl.parents('.tab:not(.tab-active)').length > 0) {
          return;
        }
        if (app.lazy.isInViewport(lazyEl)) {
          if (callback) callback(lazyEl);
          else app.lazy.loadImage(lazyEl);
        }
      });
    },

  };
  var Lazy$1 = {
    name: 'lazy',
    params: {
      lazy: {
        placeholder: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAA1BMVEXCwsK592mkAAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==',
        threshold: 0,
        sequential: true,
        observer: true,
      },
    },
    create() {
      const app = this;
      Utils.extend(app, {
        lazy: {
          create: Lazy.create.bind(app),
          destroy: Lazy.destroy.bind(app),
          loadImage: Lazy.loadImage.bind(app),
          load: Lazy.load.bind(app),
          isInViewport: Lazy.isInViewport.bind(app),
        },
      });
    },
    on: {
      pageInit(page) {
        const app = this;
        if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
          app.lazy.create(page.$el);
        }
      },
      pageAfterIn(page) {
        const app = this;
        if (app.params.lazy.observer && Support.intersectionObserver) return;
        if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
          app.lazy.create(page.$el);
        }
      },
      pageBeforeRemove(page) {
        const app = this;
        if (page.$el.find('.lazy').length > 0 || page.$el.hasClass('lazy')) {
          app.lazy.destroy(page.$el);
        }
      },
      tabMounted(tabEl) {
        const app = this;
        const $tabEl = $(tabEl);
        if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
          app.lazy.create($tabEl);
        }
      },
      tabBeforeRemove(tabEl) {
        const app = this;
        if (app.params.lazy.observer && Support.intersectionObserver) return;
        const $tabEl = $(tabEl);
        if ($tabEl.find('.lazy').length > 0 || $tabEl.hasClass('lazy')) {
          app.lazy.destroy($tabEl);
        }
      },
    },
  };

  class DataTable extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);

      const table = this;

      const defaults = {

      };

      // Extend defaults with modules params
      table.useModulesParams(defaults);

      table.params = Utils.extend(defaults, params);

      // El
      const $el = $(table.params.el);
      if ($el.length === 0) return undefined;

      table.$el = $el;
      table.el = $el[0];

      if (table.$el[0].f7DataTable) {
        const instance = table.$el[0].f7DataTable;
        table.destroy();
        return instance;
      }

      table.$el[0].f7DataTable = table;

      Utils.extend(table, {
        collapsible: $el.hasClass('data-table-collapsible'),
        // Headers
        $headerEl: $el.find('.data-table-header'),
        $headerSelectedEl: $el.find('.data-table-header-selected'),
      });

      // Events
      function handleChange(e) {
        if (e.detail && e.detail.sentByF7DataTable) {
          // Scripted event, don't do anything
          return;
        }
        const $inputEl = $(this);
        const checked = $inputEl[0].checked;
        const columnIndex = $inputEl.parents('td,th').index();

        if ($inputEl.parents('thead').length > 0) {
          if (columnIndex === 0) {
            $el
              .find('tbody tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
          }
          $el
            .find(`tbody tr td:nth-child(${columnIndex + 1}) input`)
            .prop('checked', checked)
            .trigger('change', { sentByF7DataTable: true });
          $inputEl.prop('indeterminate', false);
        } else {
          if (columnIndex === 0) {
            $inputEl.parents('tr')[checked ? 'addClass' : 'removeClass']('data-table-row-selected');
          }
          const checkedRows = $el.find(`tbody .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]:checked`).length;
          const totalRows = $el.find('tbody tr').length;
          const $headCheckboxEl = $el.find(`thead .checkbox-cell:nth-child(${columnIndex + 1}) input[type="checkbox"]`);
          if (!checked) {
            $headCheckboxEl.prop('checked', false);
          } else if (checkedRows === totalRows) {
            $headCheckboxEl.prop('checked', true).trigger('change', { sentByF7DataTable: true });
          }
          $headCheckboxEl.prop('indeterminate', checkedRows > 0 && checkedRows < totalRows);
        }
        table.checkSelectedHeader();
      }
      function handleSortableClick() {
        const $cellEl = $(this);
        const isActive = $cellEl.hasClass('sortable-cell-active');
        const currentSort = $cellEl.hasClass('sortable-desc') ? 'desc' : 'asc';
        let newSort;
        if (isActive) {
          newSort = currentSort === 'desc' ? 'asc' : 'desc';
          $cellEl.removeClass('sortable-desc sortable-asc').addClass(`sortable-${newSort}`);
        } else {
          $el.find('thead .sortable-cell-active').removeClass('sortable-cell-active');
          $cellEl.addClass('sortable-cell-active');
          newSort = currentSort;
        }
        $cellEl.trigger('datatable:sort', newSort);
        table.emit('local::sort dataTableSort', table, newSort);
      }
      table.attachEvents = function attachEvents() {
        table.$el.on('change', '.checkbox-cell input[type="checkbox"]', handleChange);
        table.$el.find('thead .sortable-cell').on('click', handleSortableClick);
      };
      table.detachEvents = function detachEvents() {
        table.$el.off('change', '.checkbox-cell input[type="checkbox"]', handleChange);
        table.$el.find('thead .sortable-cell').off('click', handleSortableClick);
      };

      // Install Modules
      table.useModules();

      // Init
      table.init();

      return table;
    }

    setCollapsibleLabels() {
      const table = this;
      if (!table.collapsible) return;
      table.$el.find('tbody td:not(.checkbox-cell)').each((index, el) => {
        const $el = $(el);
        const elIndex = $el.index();
        const collpsibleTitle = $el.attr('data-collapsible-title');
        if (!collpsibleTitle && collpsibleTitle !== '') {
          $el.attr('data-collapsible-title', table.$el.find('thead th').eq(elIndex).text());
        }
      });
    }

    checkSelectedHeader() {
      const table = this;
      if (table.$headerEl.length > 0 && table.$headerSelectedEl.length > 0) {
        const checkedItems = table.$el.find('tbody .checkbox-cell input:checked').length;
        table.$el[checkedItems > 0 ? 'addClass' : 'removeClass']('data-table-has-checked');
        table.$headerSelectedEl.find('.data-table-selected-count').text(checkedItems);
      }
    }

    init() {
      const table = this;
      table.attachEvents();
      table.setCollapsibleLabels();
      table.checkSelectedHeader();
    }

    destroy() {
      let table = this;

      table.$el.trigger('datatable:beforedestroy');
      table.emit('local::beforeDestroy dataTableBeforeDestroy', table);

      table.attachEvents();

      if (table.$el[0]) {
        table.$el[0].f7DataTable = null;
        delete table.$el[0].f7DataTable;
      }
      Utils.deleteProps(table);
      table = null;
    }
  }

  var DataTable$1 = {
    name: 'dataTable',
    static: {
      DataTable,
    },
    create() {
      const app = this;
      app.dataTable = ConstructorMethods({
        defaultSelector: '.data-table',
        constructor: DataTable,
        app,
        domProp: 'f7DataTable',
      });
    },
    on: {
      tabBeforeRemove(tabEl) {
        const app = this;
        $(tabEl).find('.data-table-init').each((index, tableEl) => {
          app.dataTable.destroy(tableEl);
        });
      },
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.data-table-init').each((index, tableEl) => {
          app.dataTable.create({ el: tableEl });
        });
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.data-table-init').each((index, tableEl) => {
          app.dataTable.destroy(tableEl);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.data-table-init').each((index, tableEl) => {
          app.dataTable.create({ el: tableEl });
        });
      },
    },
    vnode: {
      'data-table-init': {
        insert(vnode) {
          const app = this;
          const tableEl = vnode.elm;
          app.dataTable.create({ el: tableEl });
        },
        destroy(vnode) {
          const app = this;
          const tableEl = vnode.elm;
          app.dataTable.destroy(tableEl);
        },
      },
    },
  };

  const Fab = {
    morphOpen(fabEl, targetEl) {
      const app = this;
      const $fabEl = $(fabEl);
      const $targetEl = $(targetEl);
      if ($targetEl.length === 0) return;

      $targetEl.transition(0).addClass('fab-morph-target-visible');
      const target = {
        width: $targetEl[0].offsetWidth,
        height: $targetEl[0].offsetHeight,
        offset: $targetEl.offset(),
        borderRadius: $targetEl.css('border-radius'),
        zIndex: $targetEl.css('z-index'),
      };
      const fab = {
        width: $fabEl[0].offsetWidth,
        height: $fabEl[0].offsetHeight,
        offset: $fabEl.offset(),
        translateX: Utils.getTranslate($fabEl[0], 'x'),
        translateY: Utils.getTranslate($fabEl[0], 'y'),
      };

      $fabEl[0].f7FabMorphData = {
        $targetEl,
        target,
        fab,
      };

      const diffX = (fab.offset.left + (fab.width / 2))
                    - (target.offset.left + (target.width / 2))
                    - fab.translateX;
      const diffY = (fab.offset.top + (fab.height / 2))
                    - (target.offset.top + (target.height / 2))
                    - fab.translateY;
      const scaleX = target.width / fab.width;
      const scaleY = target.height / fab.height;

      let borderRadius = Math.ceil(parseInt(target.borderRadius, 10) / Math.max(scaleX, scaleY));
      if (borderRadius > 0) borderRadius += 2;

      $fabEl[0].f7FabMorphResizeHandler = function resizeHandler() {
        $fabEl.transition(0).transform('');
        $targetEl.transition(0);
        target.width = $targetEl[0].offsetWidth;
        target.height = $targetEl[0].offsetHeight;
        target.offset = $targetEl.offset();
        fab.offset = $fabEl.offset();

        const diffXNew = (fab.offset.left + (fab.width / 2))
                        - (target.offset.left + (target.width / 2))
                        - fab.translateX;
        const diffYNew = (fab.offset.top + (fab.height / 2))
                        - (target.offset.top + (target.height / 2))
                        - fab.translateY;
        const scaleXNew = target.width / fab.width;
        const scaleYNew = target.height / fab.height;

        $fabEl.transform(`translate3d(${-diffXNew}px, ${-diffYNew}px, 0) scale(${scaleXNew}, ${scaleYNew})`);
      };

      $targetEl
        .css('opacity', 0)
        .transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
      $fabEl
        .addClass('fab-opened')
        .css('z-index', target.zIndex - 1)
        .transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
      $fabEl.transitionEnd(() => {
        $targetEl.transition('');
        Utils.nextFrame(() => {
          $targetEl.css('opacity', 1).transform('scale(1,1)');
          $fabEl
            .transform(`translate3d(${-diffX}px, ${-diffY}px, 0) scale(${scaleX}, ${scaleY})`)
            .css('border-radius', `${borderRadius}px`)
            .css('box-shadow', 'none')
            .css('opacity', '0');
        });
        app.on('resize', $fabEl[0].f7FabMorphResizeHandler);
        if ($targetEl.parents('.page-content').length > 0) {
          $targetEl.parents('.page-content').on('scroll', $fabEl[0].f7FabMorphResizeHandler);
        }
      });
    },
    morphClose(fabEl) {
      const app = this;
      const $fabEl = $(fabEl);
      const morphData = $fabEl[0].f7FabMorphData;
      if (!morphData) return;
      const { $targetEl, target, fab } = morphData;
      if ($targetEl.length === 0) return;

      const diffX = (fab.offset.left + (fab.width / 2))
                    - (target.offset.left + (target.width / 2))
                    - fab.translateX;
      const diffY = (fab.offset.top + (fab.height / 2))
                    - (target.offset.top + (target.height / 2))
                    - fab.translateY;
      const scaleX = target.width / fab.width;
      const scaleY = target.height / fab.height;

      app.off('resize', $fabEl[0].f7FabMorphResizeHandler);
      if ($targetEl.parents('.page-content').length > 0) {
        $targetEl.parents('.page-content').off('scroll', $fabEl[0].f7FabMorphResizeHandler);
      }

      $targetEl
        .css('opacity', 0)
        .transform(`scale(${1 / scaleX}, ${1 / scaleY})`);
      $fabEl
        .transition('')
        .css('box-shadow', '')
        .css('border-radius', '')
        .css('opacity', '1')
        .transform(`translate3d(${-diffX}px, ${-diffY}px, 0)`);
      $fabEl.transitionEnd(() => {
        $fabEl
          .css('z-index', '')
          .removeClass('fab-opened')
          .transform('');
        Utils.nextFrame(() => {
          $fabEl.transitionEnd(() => {
            $targetEl
              .removeClass('fab-morph-target-visible')
              .css('opacity', '')
              .transform('')
              .transition('');
          });
        });
      });
    },
    open(fabEl, targetEl) {
      const app = this;
      const $fabEl = $(fabEl).eq(0);
      const $buttonsEl = $fabEl.find('.fab-buttons');
      if (!$fabEl.length) return;
      if ($fabEl.hasClass('fab-opened')) return;
      if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;

      if (app.fab.openedEl) {
        if (app.fab.openedEl === $fabEl[0]) return;
        app.fab.close(app.fab.openedEl);
      }
      app.fab.openedEl = $fabEl[0];
      if ($fabEl.hasClass('fab-morph')) {
        app.fab.morphOpen($fabEl, targetEl || $fabEl.attr('data-morph-to'));
      } else {
        $fabEl.addClass('fab-opened');
      }
      $fabEl.siblings('.fab-backdrop').addClass('backdrop-in');
      $fabEl.trigger('fab:open');
    },
    close(fabEl = '.fab-opened') {
      const app = this;
      const $fabEl = $(fabEl).eq(0);
      const $buttonsEl = $fabEl.find('.fab-buttons');
      if (!$fabEl.length) return;
      if (!$fabEl.hasClass('fab-opened')) return;
      if (!$buttonsEl.length && !$fabEl.hasClass('fab-morph')) return;
      app.fab.openedEl = null;
      if ($fabEl.hasClass('fab-morph')) {
        app.fab.morphClose($fabEl);
      } else {
        $fabEl.removeClass('fab-opened');
      }
      $fabEl.siblings('.fab-backdrop').removeClass('backdrop-in');
      $fabEl.trigger('fab:close');
    },
    toggle(fabEl) {
      const app = this;
      const $fabEl = $(fabEl);
      if (!$fabEl.hasClass('fab-opened')) app.fab.open(fabEl);
      else app.fab.close(fabEl);
    },
  };

  var Fab$1 = {
    name: 'fab',
    create() {
      const app = this;
      Utils.extend(app, {
        fab: {
          openedEl: null,
          morphOpen: Fab.morphOpen.bind(app),
          morphClose: Fab.morphClose.bind(app),
          open: Fab.open.bind(app),
          close: Fab.close.bind(app),
          toggle: Fab.toggle.bind(app),
        },
      });
    },
    clicks: {
      '.fab > a': function open($clickedEl) {
        const app = this;
        app.fab.toggle($clickedEl.parents('.fab'));
      },
      '.fab-open': function open($clickedEl, data = {}) {
        const app = this;
        app.fab.open(data.fab);
      },
      '.fab-close': function close($clickedEl, data = {}) {
        const app = this;
        app.fab.close(data.fab);
      },
      '.fab-backdrop': function close() {
        const app = this;
        app.fab.close();
      },
    },
  };

  class Searchbar extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);

      const sb = this;

      const defaults = {
        el: undefined,
        inputEl: undefined,
        inputEvents: 'change input compositionend',
        disableButton: true,
        disableButtonEl: undefined,
        backdropEl: undefined,
        searchContainer: undefined, // container to search, HTMLElement or CSS selector
        searchItem: 'li', // single item selector, CSS selector
        searchIn: undefined, // where to search in item, CSS selector
        searchGroup: '.list-group',
        searchGroupTitle: '.item-divider, .list-group-title',
        ignore: '.searchbar-ignore',
        foundEl: '.searchbar-found',
        notFoundEl: '.searchbar-not-found',
        hideOnEnableEl: '.searchbar-hide-on-enable',
        hideOnSearchEl: '.searchbar-hide-on-search',
        backdrop: undefined,
        removeDiacritics: true,
        customSearch: false,
        hideDividers: true,
        hideGroups: true,
        disableOnBackdropClick: true,
        expandable: false,
        inline: false,
      };

      // Extend defaults with modules params
      sb.useModulesParams(defaults);

      sb.params = Utils.extend(defaults, params);

      const $el = $(sb.params.el);
      if ($el.length === 0) return sb;

      if ($el[0].f7Searchbar) return $el[0].f7Searchbar;

      $el[0].f7Searchbar = sb;

      let $pageEl;
      const $navbarEl = $el.parents('.navbar');
      if ($el.parents('.page').length > 0) {
        $pageEl = $el.parents('.page');
      } else if ($navbarEl.length > 0) {
        $pageEl = $(app.navbar.getPageByEl($navbarEl[0]));
        if (!$pageEl.length) {
          const $currentPageEl = $el.parents('.view').find('.page-current');
          if ($currentPageEl[0] && $currentPageEl[0].f7Page && $currentPageEl[0].f7Page.navbarEl === $navbarEl[0]) {
            $pageEl = $currentPageEl;
          }
        }
      }

      let $foundEl;
      if (params.foundEl) {
        $foundEl = $(params.foundEl);
      } else if (typeof sb.params.foundEl === 'string' && $pageEl) {
        $foundEl = $pageEl.find(sb.params.foundEl);
      }

      let $notFoundEl;
      if (params.notFoundEl) {
        $notFoundEl = $(params.notFoundEl);
      } else if (typeof sb.params.notFoundEl === 'string' && $pageEl) {
        $notFoundEl = $pageEl.find(sb.params.notFoundEl);
      }

      let $hideOnEnableEl;
      if (params.hideOnEnableEl) {
        $hideOnEnableEl = $(params.hideOnEnableEl);
      } else if (typeof sb.params.hideOnEnableEl === 'string' && $pageEl) {
        $hideOnEnableEl = $pageEl.find(sb.params.hideOnEnableEl);
      }

      let $hideOnSearchEl;
      if (params.hideOnSearchEl) {
        $hideOnSearchEl = $(params.hideOnSearchEl);
      } else if (typeof sb.params.hideOnSearchEl === 'string' && $pageEl) {
        $hideOnSearchEl = $pageEl.find(sb.params.hideOnSearchEl);
      }


      const expandable = sb.params.expandable || $el.hasClass('searchbar-expandable');
      const inline = sb.params.inline || $el.hasClass('searchbar-inline');

      if (typeof sb.params.backdrop === 'undefined') {
        if (!inline) sb.params.backdrop = app.theme !== 'aurora';
        else sb.params.backdrop = false;
      }

      let $backdropEl;
      if (sb.params.backdrop) {
        if (sb.params.backdropEl) {
          $backdropEl = $(sb.params.backdropEl);
        } else if ($pageEl && $pageEl.length > 0) {
          $backdropEl = $pageEl.find('.searchbar-backdrop');
        } else {
          $backdropEl = $el.siblings('.searchbar-backdrop');
        }
        if ($backdropEl.length === 0) {
          $backdropEl = $('<div class="searchbar-backdrop"></div>');
          if ($pageEl && $pageEl.length) {
            if ($el.parents($pageEl).length > 0 && $navbarEl && $el.parents($navbarEl).length === 0) {
              $backdropEl.insertBefore($el);
            } else {
              $backdropEl.insertBefore($pageEl.find('.page-content').eq(0));
            }
          } else {
            $backdropEl.insertBefore($el);
          }
        }
      }

      let $searchContainer;
      if (sb.params.searchContainer) {
        $searchContainer = $(sb.params.searchContainer);
      }

      let $inputEl;
      if (sb.params.inputEl) {
        $inputEl = $(sb.params.inputEl);
      } else {
        $inputEl = $el.find('input[type="search"]').eq(0);
      }

      let $disableButtonEl;
      if (sb.params.disableButton) {
        if (sb.params.disableButtonEl) {
          $disableButtonEl = $(sb.params.disableButtonEl);
        } else {
          $disableButtonEl = $el.find('.searchbar-disable-button');
        }
      }

      Utils.extend(sb, {
        app,
        view: app.views.get($el.parents('.view')),
        $el,
        el: $el[0],
        $backdropEl,
        backdropEl: $backdropEl && $backdropEl[0],
        $searchContainer,
        searchContainer: $searchContainer && $searchContainer[0],
        $inputEl,
        inputEl: $inputEl[0],
        $disableButtonEl,
        disableButtonEl: $disableButtonEl && $disableButtonEl[0],
        disableButtonHasMargin: false,
        $pageEl,
        pageEl: $pageEl && $pageEl[0],
        $navbarEl,
        navbarEl: $navbarEl && $navbarEl[0],
        $foundEl,
        foundEl: $foundEl && $foundEl[0],
        $notFoundEl,
        notFoundEl: $notFoundEl && $notFoundEl[0],
        $hideOnEnableEl,
        hideOnEnableEl: $hideOnEnableEl && $hideOnEnableEl[0],
        $hideOnSearchEl,
        hideOnSearchEl: $hideOnSearchEl && $hideOnSearchEl[0],
        previousQuery: '',
        query: '',
        isVirtualList: $searchContainer && $searchContainer.hasClass('virtual-list'),
        virtualList: undefined,
        enabled: false,
        expandable,
        inline,
      });

      // Events
      function preventSubmit(e) {
        e.preventDefault();
      }
      function onInputFocus(e) {
        sb.enable(e);
        sb.$el.addClass('searchbar-focused');
      }
      function onInputBlur() {
        sb.$el.removeClass('searchbar-focused');
        if (app.theme === 'aurora' && (!$disableButtonEl || !$disableButtonEl.length || !sb.params.disableButton) && !sb.query) {
          sb.disable();
        }
      }
      function onInputChange() {
        const value = sb.$inputEl.val().trim();
        if (
          (
            (sb.$searchContainer && sb.$searchContainer.length > 0)
            && (sb.params.searchIn || sb.isVirtualList || sb.params.searchIn === sb.params.searchItem)
          )
          || sb.params.customSearch
        ) {
          sb.search(value, true);
        }
      }
      function onInputClear(e, previousValue) {
        sb.$el.trigger('searchbar:clear', previousValue);
        sb.emit('local::clear searchbarClear', sb, previousValue);
      }
      function disableOnClick(e) {
        sb.disable(e);
      }
      function onPageBeforeOut() {
        if (!sb || (sb && !sb.$el)) return;
        if (sb.enabled) {
          sb.$el.removeClass('searchbar-enabled');
          if (sb.expandable) {
            sb.$el.parents('.navbar').removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition');
          }
        }
      }
      function onPageBeforeIn() {
        if (!sb || (sb && !sb.$el)) return;
        if (sb.enabled) {
          sb.$el.addClass('searchbar-enabled');
          if (sb.expandable) {
            sb.$el.parents('.navbar').addClass('with-searchbar-expandable-enabled-no-transition');
          }
        }
      }
      sb.attachEvents = function attachEvents() {
        $el.on('submit', preventSubmit);
        if (sb.params.disableButton) {
          sb.$disableButtonEl.on('click', disableOnClick);
        }
        if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
          sb.$backdropEl.on('click', disableOnClick);
        }
        if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
          sb.$pageEl.on('page:beforeout', onPageBeforeOut);
          sb.$pageEl.on('page:beforein', onPageBeforeIn);
        }
        sb.$inputEl.on('focus', onInputFocus);
        sb.$inputEl.on('blur', onInputBlur);
        sb.$inputEl.on(sb.params.inputEvents, onInputChange);
        sb.$inputEl.on('input:clear', onInputClear);
      };
      sb.detachEvents = function detachEvents() {
        $el.off('submit', preventSubmit);
        if (sb.params.disableButton) {
          sb.$disableButtonEl.off('click', disableOnClick);
        }
        if (sb.params.disableOnBackdropClick && sb.$backdropEl) {
          sb.$backdropEl.off('click', disableOnClick);
        }
        if (sb.expandable && app.theme === 'ios' && sb.view && $navbarEl.length && sb.$pageEl) {
          sb.$pageEl.off('page:beforeout', onPageBeforeOut);
          sb.$pageEl.off('page:beforein', onPageBeforeIn);
        }
        sb.$inputEl.off('focus', onInputFocus);
        sb.$inputEl.off('blur', onInputBlur);
        sb.$inputEl.off(sb.params.inputEvents, onInputChange);
        sb.$inputEl.off('input:clear', onInputClear);
      };

      // Install Modules
      sb.useModules();

      // Init
      sb.init();

      return sb;
    }

    clear(e) {
      const sb = this;
      if (!sb.query && e && $(e.target).hasClass('searchbar-clear')) {
        sb.disable();
        return sb;
      }
      const previousQuery = sb.value;
      sb.$inputEl.val('').trigger('change').focus();
      sb.$el.trigger('searchbar:clear', previousQuery);
      sb.emit('local::clear searchbarClear', sb, previousQuery);
      return sb;
    }

    setDisableButtonMargin() {
      const sb = this;
      if (sb.expandable) return;
      const app = sb.app;
      sb.$disableButtonEl.transition(0).show();
      sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, `${-sb.disableButtonEl.offsetWidth}px`);
      /* eslint no-underscore-dangle: ["error", { "allow": ["_clientLeft"] }] */
      sb._clientLeft = sb.$disableButtonEl[0].clientLeft;
      sb.$disableButtonEl.transition('');
      sb.disableButtonHasMargin = true;
    }

    enable(setFocus) {
      const sb = this;
      if (sb.enabled) return sb;
      const app = sb.app;
      sb.enabled = true;
      function enable() {
        if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch) && !sb.$el.hasClass('searchbar-enabled') && !sb.query) {
          sb.backdropShow();
        }
        sb.$el.addClass('searchbar-enabled');
        if (!sb.$disableButtonEl || (sb.$disableButtonEl && sb.$disableButtonEl.length === 0)) {
          sb.$el.addClass('searchbar-enabled-no-disable-button');
        }
        if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
          if (!sb.disableButtonHasMargin) {
            sb.setDisableButtonMargin();
          }
          sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, '0px');
        }
        if (sb.expandable) {
          if (sb.$el.parents('.navbar').hasClass('navbar-large') && sb.$pageEl) {
            sb.$pageEl.find('.page-content').addClass('with-searchbar-expandable-enabled');
          }
          if (app.theme === 'md' && sb.$el.parents('.navbar').length) {
            sb.$el.parents('.navbar').addClass('with-searchbar-expandable-enabled');
          } else {
            sb.$el.parents('.navbar').addClass('with-searchbar-expandable-enabled');
            sb.$el.parents('.navbar-large').addClass('navbar-large-collapsed');
          }
        }
        if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.addClass('hidden-by-searchbar');
        sb.$el.trigger('searchbar:enable');
        sb.emit('local::enable searchbarEnable', sb);
      }
      let needsFocus = false;
      if (setFocus === true) {
        if (doc.activeElement !== sb.inputEl) {
          needsFocus = true;
        }
      }
      const isIos = app.device.ios && app.theme === 'ios';
      if (isIos) {
        if (sb.expandable) {
          if (needsFocus) sb.$inputEl.focus();
          enable();
        } else {
          if (needsFocus) sb.$inputEl.focus();
          if (setFocus && (setFocus.type === 'focus' || setFocus === true)) {
            Utils.nextTick(() => {
              enable();
            }, 400);
          } else {
            enable();
          }
        }
      } else {
        if (needsFocus) sb.$inputEl.focus();
        if (app.theme === 'md' && sb.expandable) {
          sb.$el.parents('.page, .view, .navbar-inner, .navbar').scrollLeft(app.rtl ? 100 : 0);
        }
        enable();
      }
      return sb;
    }

    disable() {
      const sb = this;
      if (!sb.enabled) return sb;
      const app = sb.app;
      sb.$inputEl.val('').trigger('change');
      sb.$el.removeClass('searchbar-enabled searchbar-focused searchbar-enabled-no-disable-button');
      if (sb.expandable) {
        if (sb.$el.parents('.navbar').hasClass('navbar-large') && sb.$pageEl) {
          sb.$pageEl.find('.page-content').removeClass('with-searchbar-expandable-enabled').addClass('with-searchbar-expandable-closing');
          sb.$el.transitionEnd(() => {
            sb.$pageEl.find('.page-content').removeClass('with-searchbar-expandable-closing');
          });
        }
        if (app.theme === 'md' && sb.$el.parents('.navbar').length) {
          sb.$el.parents('.navbar')
            .removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition')
            .addClass('with-searchbar-expandable-closing');
          sb.$el.transitionEnd(() => {
            sb.$el.parents('.navbar').removeClass('with-searchbar-expandable-closing');
          });
        } else {
          sb.$el.parents('.navbar')
            .removeClass('with-searchbar-expandable-enabled with-searchbar-expandable-enabled-no-transition')
            .addClass('with-searchbar-expandable-closing');
          sb.$el.transitionEnd(() => {
            sb.$el.parents('.navbar').removeClass('with-searchbar-expandable-closing');
          });
          if (sb.$pageEl) {
            sb.$pageEl.find('.page-content').trigger('scroll');
          }
        }
      }
      if (!sb.expandable && sb.$disableButtonEl && sb.$disableButtonEl.length > 0 && app.theme !== 'md') {
        sb.$disableButtonEl.css(`margin-${app.rtl ? 'left' : 'right'}`, `${-sb.disableButtonEl.offsetWidth}px`);
      }
      if (sb.$backdropEl && ((sb.$searchContainer && sb.$searchContainer.length) || sb.params.customSearch)) {
        sb.backdropHide();
      }

      sb.enabled = false;

      sb.$inputEl.blur();

      if (sb.$hideOnEnableEl) sb.$hideOnEnableEl.removeClass('hidden-by-searchbar');

      sb.$el.trigger('searchbar:disable');
      sb.emit('local::disable searchbarDisable', sb);
      return sb;
    }

    toggle() {
      const sb = this;
      if (sb.enabled) sb.disable();
      else sb.enable(true);
      return sb;
    }

    backdropShow() {
      const sb = this;
      if (sb.$backdropEl) {
        sb.$backdropEl.addClass('searchbar-backdrop-in');
      }
      return sb;
    }

    backdropHide() {
      const sb = this;
      if (sb.$backdropEl) {
        sb.$backdropEl.removeClass('searchbar-backdrop-in');
      }
      return sb;
    }

    search(query, internal) {
      const sb = this;
      sb.previousQuery = sb.query || '';
      if (query === sb.previousQuery) return sb;

      if (!internal) {
        if (!sb.enabled) {
          sb.enable();
        }
        sb.$inputEl.val(query);
        sb.$inputEl.trigger('input');
      }
      sb.query = query;
      sb.value = query;

      const { $searchContainer, $el, $foundEl, $notFoundEl, $hideOnSearchEl, isVirtualList } = sb;

      // Hide on search element
      if (query.length > 0 && $hideOnSearchEl) {
        $hideOnSearchEl.addClass('hidden-by-searchbar');
      } else if ($hideOnSearchEl) {
        $hideOnSearchEl.removeClass('hidden-by-searchbar');
      }
      // Add active/inactive classes on overlay
      if (
        ($searchContainer && $searchContainer.length && $el.hasClass('searchbar-enabled'))
        || (sb.params.customSearch && $el.hasClass('searchbar-enabled'))
      ) {
        if (query.length === 0) {
          sb.backdropShow();
        } else {
          sb.backdropHide();
        }
      }

      if (sb.params.customSearch) {
        $el.trigger('searchbar:search', { query, previousQuery: sb.previousQuery });
        sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
        return sb;
      }

      let foundItems = [];
      let vlQuery;
      if (isVirtualList) {
        sb.virtualList = $searchContainer[0].f7VirtualList;
        if (query.trim() === '') {
          sb.virtualList.resetFilter();
          if ($notFoundEl) $notFoundEl.hide();
          if ($foundEl) $foundEl.show();
          $el.trigger('searchbar:search', { query, previousQuery: sb.previousQuery });
          sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery);
          return sb;
        }
        vlQuery = sb.params.removeDiacritics ? Utils.removeDiacritics(query) : query;
        if (sb.virtualList.params.searchAll) {
          foundItems = sb.virtualList.params.searchAll(vlQuery, sb.virtualList.items) || [];
        } else if (sb.virtualList.params.searchByItem) {
          for (let i = 0; i < sb.virtualList.items.length; i += 1) {
            if (sb.virtualList.params.searchByItem(vlQuery, sb.virtualList.params.items[i], i)) {
              foundItems.push(i);
            }
          }
        }
      } else {
        let values;
        if (sb.params.removeDiacritics) values = Utils.removeDiacritics(query.trim().toLowerCase()).split(' ');
        else {
          values = query.trim().toLowerCase().split(' ');
        }
        $searchContainer.find(sb.params.searchItem).removeClass('hidden-by-searchbar').each((itemIndex, itemEl) => {
          const $itemEl = $(itemEl);
          let compareWithText = [];
          let $searchIn = sb.params.searchIn ? $itemEl.find(sb.params.searchIn) : $itemEl;
          if (sb.params.searchIn === sb.params.searchItem) {
            $searchIn = $itemEl;
          }
          $searchIn.each((searchInIndex, searchInEl) => {
            let itemText = $(searchInEl).text().trim().toLowerCase();
            if (sb.params.removeDiacritics) itemText = Utils.removeDiacritics(itemText);
            compareWithText.push(itemText);
          });
          compareWithText = compareWithText.join(' ');
          let wordsMatch = 0;
          for (let i = 0; i < values.length; i += 1) {
            if (compareWithText.indexOf(values[i]) >= 0) wordsMatch += 1;
          }
          if (wordsMatch !== values.length && !(sb.params.ignore && $itemEl.is(sb.params.ignore))) {
            $itemEl.addClass('hidden-by-searchbar');
          } else {
            foundItems.push($itemEl[0]);
          }
        });

        if (sb.params.hideDividers) {
          $searchContainer.find(sb.params.searchGroupTitle).each((titleIndex, titleEl) => {
            const $titleEl = $(titleEl);
            const $nextElements = $titleEl.nextAll(sb.params.searchItem);
            let hide = true;
            for (let i = 0; i < $nextElements.length; i += 1) {
              const $nextEl = $nextElements.eq(i);
              if ($nextEl.is(sb.params.searchGroupTitle)) break;
              if (!$nextEl.hasClass('hidden-by-searchbar')) {
                hide = false;
              }
            }
            const ignore = sb.params.ignore && $titleEl.is(sb.params.ignore);
            if (hide && !ignore) $titleEl.addClass('hidden-by-searchbar');
            else $titleEl.removeClass('hidden-by-searchbar');
          });
        }
        if (sb.params.hideGroups) {
          $searchContainer.find(sb.params.searchGroup).each((groupIndex, groupEl) => {
            const $groupEl = $(groupEl);
            const ignore = sb.params.ignore && $groupEl.is(sb.params.ignore);
            // eslint-disable-next-line
            const notHidden = $groupEl.find(sb.params.searchItem).filter((index, el) => {
              return !$(el).hasClass('hidden-by-searchbar');
            });
            if (notHidden.length === 0 && !ignore) {
              $groupEl.addClass('hidden-by-searchbar');
            } else {
              $groupEl.removeClass('hidden-by-searchbar');
            }
          });
        }
      }

      if (foundItems.length === 0) {
        if ($notFoundEl) $notFoundEl.show();
        if ($foundEl) $foundEl.hide();
      } else {
        if ($notFoundEl) $notFoundEl.hide();
        if ($foundEl) $foundEl.show();
      }
      if (isVirtualList && sb.virtualList) {
        sb.virtualList.filterItems(foundItems);
      }

      $el.trigger('searchbar:search', { query, previousQuery: sb.previousQuery, foundItems });
      sb.emit('local::search searchbarSearch', sb, query, sb.previousQuery, foundItems);

      return sb;
    }

    init() {
      const sb = this;
      if (sb.expandable && sb.$el) sb.$el.addClass('searchbar-expandable');
      if (sb.inline && sb.$el) sb.$el.addClass('searchbar-inline');
      sb.attachEvents();
    }

    destroy() {
      const sb = this;
      sb.emit('local::beforeDestroy searchbarBeforeDestroy', sb);
      sb.$el.trigger('searchbar:beforedestroy');
      sb.detachEvents();
      if (sb.$el[0]) {
        sb.$el[0].f7Searchbar = null;
        delete sb.$el[0].f7Searchbar;
      }
      Utils.deleteProps(sb);
    }
  }

  var Searchbar$1 = {
    name: 'searchbar',
    static: {
      Searchbar,
    },
    create() {
      const app = this;
      app.searchbar = ConstructorMethods({
        defaultSelector: '.searchbar',
        constructor: Searchbar,
        app,
        domProp: 'f7Searchbar',
        addMethods: 'clear enable disable toggle search'.split(' '),
      });
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.searchbar-init').each((index, searchbarEl) => {
          const $searchbarEl = $(searchbarEl);
          app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
        });
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.searchbar-init').each((index, searchbarEl) => {
          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
            searchbarEl.f7Searchbar.destroy();
          }
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.searchbar-init').each((index, searchbarEl) => {
          const $searchbarEl = $(searchbarEl);
          app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
        });
        if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
          page.$navbarEl.find('.searchbar-init').each((index, searchbarEl) => {
            const $searchbarEl = $(searchbarEl);
            app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
          });
        }
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.searchbar-init').each((index, searchbarEl) => {
          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
            searchbarEl.f7Searchbar.destroy();
          }
        });
        if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
          page.$navbarEl.find('.searchbar-init').each((index, searchbarEl) => {
            if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
              searchbarEl.f7Searchbar.destroy();
            }
          });
        }
      },
    },
    clicks: {
      '.searchbar-clear': function clear($clickedEl, data = {}) {
        const app = this;
        const sb = app.searchbar.get(data.searchbar);
        if (sb) sb.clear();
      },
      '.searchbar-enable': function enable($clickedEl, data = {}) {
        const app = this;
        const sb = app.searchbar.get(data.searchbar);
        if (sb) sb.enable(true);
      },
      '.searchbar-disable': function disable($clickedEl, data = {}) {
        const app = this;
        const sb = app.searchbar.get(data.searchbar);
        if (sb) sb.disable();
      },
      '.searchbar-toggle': function toggle($clickedEl, data = {}) {
        const app = this;
        const sb = app.searchbar.get(data.searchbar);
        if (sb) sb.toggle();
      },
    },
    vnode: {
      'searchbar-init': {
        insert(vnode) {
          const app = this;
          const searchbarEl = vnode.elm;
          const $searchbarEl = $(searchbarEl);
          app.searchbar.create(Utils.extend($searchbarEl.dataset(), { el: searchbarEl }));
        },
        destroy(vnode) {
          const searchbarEl = vnode.elm;
          if (searchbarEl.f7Searchbar && searchbarEl.f7Searchbar.destroy) {
            searchbarEl.f7Searchbar.destroy();
          }
        },
      },
    },
  };

  class Messages extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);

      const m = this;

      const defaults = {
        autoLayout: true,
        messages: [],
        newMessagesFirst: false,
        scrollMessages: true,
        scrollMessagesOnEdge: true,
        firstMessageRule: undefined,
        lastMessageRule: undefined,
        tailMessageRule: undefined,
        sameNameMessageRule: undefined,
        sameHeaderMessageRule: undefined,
        sameFooterMessageRule: undefined,
        sameAvatarMessageRule: undefined,
        customClassMessageRule: undefined,
        renderMessage: undefined,
      };

      // Extend defaults with modules params
      m.useModulesParams(defaults);

      m.params = Utils.extend(defaults, params);

      const $el = $(params.el).eq(0);
      if ($el.length === 0) return m;

      if ($el[0].f7Messages) return $el[0].f7Messages;

      $el[0].f7Messages = m;

      const $pageContentEl = $el.closest('.page-content').eq(0);

      Utils.extend(m, {
        messages: m.params.messages,
        $el,
        el: $el[0],
        $pageContentEl,
        pageContentEl: $pageContentEl[0],

      });
      // Install Modules
      m.useModules();

      // Init
      m.init();

      return m;
    }
    // eslint-disable-next-line
    getMessageData(messageEl) {
      const $messageEl = $(messageEl);
      const data = {
        name: $messageEl.find('.message-name').html(),
        header: $messageEl.find('.message-header').html(),
        textHeader: $messageEl.find('.message-text-header').html(),
        textFooter: $messageEl.find('.message-text-footer').html(),
        footer: $messageEl.find('.message-footer').html(),
        isTitle: $messageEl.hasClass('messages-title'),
        type: $messageEl.hasClass('message-sent') ? 'sent' : 'received',
        text: $messageEl.find('.message-text').html(),
        image: $messageEl.find('.message-image').html(),
        imageSrc: $messageEl.find('.message-image img').attr('src'),
        typing: $messageEl.hasClass('message-typing'),
      };
      if (data.isTitle) {
        data.text = $messageEl.html();
      }
      if (data.text && data.textHeader) {
        data.text = data.text.replace(`<div class="message-text-header">${data.textHeader}</div>`, '');
      }
      if (data.text && data.textFooter) {
        data.text = data.text.replace(`<div class="message-text-footer">${data.textFooter}</div>`, '');
      }
      let avatar = $messageEl.find('.message-avatar').css('background-image');
      if (avatar === 'none' || avatar === '') avatar = undefined;
      if (avatar && typeof avatar === 'string') {
        avatar = avatar.replace('url(', '').replace(')', '').replace(/"/g, '').replace(/'/g, '');
      } else {
        avatar = undefined;
      }
      data.avatar = avatar;

      return data;
    }

    getMessagesData() {
      const m = this;
      const data = [];
      m.$el.find('.message, .messages-title').each((index, messageEl) => {
        data.push(m.getMessageData(messageEl));
      });
      return data;
    }

    renderMessage(messageToRender) {
      const m = this;
      const message = Utils.extend({
        type: 'sent',
        attrs: {},
      }, messageToRender);
      if (m.params.renderMessage) {
        return m.params.renderMessage.call(m, message);
      }
      if (message.isTitle) {
        return `<div class="messages-title">${message.text}</div>`;
      }
      const attrs = Object.keys(message.attrs).map(attr => `${attr}="${message.attrs[attr]}"`).join(' ');
      return `
      <div class="message message-${message.type} ${message.isTyping ? 'message-typing' : ''} ${message.cssClass || ''}" ${attrs}>
        ${message.avatar ? `
        <div class="message-avatar" style="background-image:url(${message.avatar})"></div>
        ` : ''}
        <div class="message-content">
          ${message.name ? `<div class="message-name">${message.name}</div>` : ''}
          ${message.header ? `<div class="message-header">${message.header}</div>` : ''}
          <div class="message-bubble">
            ${message.textHeader ? `<div class="message-text-header">${message.textHeader}</div>` : ''}
            ${message.image ? `<div class="message-image">${message.image}</div>` : ''}
            ${message.imageSrc && !message.image ? `<div class="message-image"><img src="${message.imageSrc}"></div>` : ''}
            ${message.text || message.isTyping ? `<div class="message-text">${message.text || ''}${message.isTyping ? '<div class="message-typing-indicator"><div></div><div></div><div></div></div>' : ''}</div>` : ''}
            ${message.textFooter ? `<div class="message-text-footer">${message.textFooter}</div>` : ''}
          </div>
          ${message.footer ? `<div class="message-footer">${message.footer}</div>` : ''}
        </div>
      </div>
    `;
    }

    renderMessages(messagesToRender = this.messages, method = this.params.newMessagesFirst ? 'prepend' : 'append') {
      const m = this;
      const html = messagesToRender.map(message => m.renderMessage(message)).join('');
      m.$el[method](html);
    }

    isFirstMessage(...args) {
      const m = this;
      if (m.params.firstMessageRule) return m.params.firstMessageRule(...args);
      return false;
    }

    isLastMessage(...args) {
      const m = this;
      if (m.params.lastMessageRule) return m.params.lastMessageRule(...args);
      return false;
    }

    isTailMessage(...args) {
      const m = this;
      if (m.params.tailMessageRule) return m.params.tailMessageRule(...args);
      return false;
    }

    isSameNameMessage(...args) {
      const m = this;
      if (m.params.sameNameMessageRule) return m.params.sameNameMessageRule(...args);
      return false;
    }

    isSameHeaderMessage(...args) {
      const m = this;
      if (m.params.sameHeaderMessageRule) return m.params.sameHeaderMessageRule(...args);
      return false;
    }

    isSameFooterMessage(...args) {
      const m = this;
      if (m.params.sameFooterMessageRule) return m.params.sameFooterMessageRule(...args);
      return false;
    }

    isSameAvatarMessage(...args) {
      const m = this;
      if (m.params.sameAvatarMessageRule) return m.params.sameAvatarMessageRule(...args);
      return false;
    }

    isCustomClassMessage(...args) {
      const m = this;
      if (m.params.customClassMessageRule) return m.params.customClassMessageRule(...args);
      return undefined;
    }

    layout() {
      const m = this;
      m.$el.find('.message, .messages-title').each((index, messageEl) => {
        const $messageEl = $(messageEl);
        if (!m.messages) {
          m.messages = m.getMessagesData();
        }
        const classes = [];
        const message = m.messages[index];
        const previousMessage = m.messages[index - 1];
        const nextMessage = m.messages[index + 1];
        if (m.isFirstMessage(message, previousMessage, nextMessage)) {
          classes.push('message-first');
        }
        if (m.isLastMessage(message, previousMessage, nextMessage)) {
          classes.push('message-last');
        }
        if (m.isTailMessage(message, previousMessage, nextMessage)) {
          classes.push('message-tail');
        }
        if (m.isSameNameMessage(message, previousMessage, nextMessage)) {
          classes.push('message-same-name');
        }
        if (m.isSameHeaderMessage(message, previousMessage, nextMessage)) {
          classes.push('message-same-header');
        }
        if (m.isSameFooterMessage(message, previousMessage, nextMessage)) {
          classes.push('message-same-footer');
        }
        if (m.isSameAvatarMessage(message, previousMessage, nextMessage)) {
          classes.push('message-same-avatar');
        }
        let customMessageClasses = m.isCustomClassMessage(message, previousMessage, nextMessage);
        if (customMessageClasses && customMessageClasses.length) {
          if (typeof customMessageClasses === 'string') {
            customMessageClasses = customMessageClasses.split(' ');
          }
          customMessageClasses.forEach((customClass) => {
            classes.push(customClass);
          });
        }
        $messageEl.removeClass('message-first message-last message-tail message-same-name message-same-header message-same-footer message-same-avatar');
        classes.forEach((className) => {
          $messageEl.addClass(className);
        });
      });
    }

    clear() {
      const m = this;
      m.messages = [];
      m.$el.html('');
    }

    removeMessage(messageToRemove, layout = true) {
      const m = this;
      // Index or El
      let index;
      let $el;
      if (typeof messageToRemove === 'number') {
        index = messageToRemove;
        $el = m.$el.find('.message, .messages-title').eq(index);
      } else if (m.messages && m.messages.indexOf(messageToRemove) >= 0) {
        index = m.messages.indexOf(messageToRemove);
        $el = m.$el.children().eq(index);
      } else {
        $el = $(messageToRemove);
        index = $el.index();
      }
      if ($el.length === 0) {
        return m;
      }
      $el.remove();
      m.messages.splice(index, 1);
      if (m.params.autoLayout && layout) m.layout();
      return m;
    }

    removeMessages(messagesToRemove, layout = true) {
      const m = this;
      if (Array.isArray(messagesToRemove)) {
        const messagesToRemoveEls = [];
        messagesToRemove.forEach((messageToRemoveIndex) => {
          messagesToRemoveEls.push(m.$el.find('.message, .messages-title').eq(messageToRemoveIndex));
        });
        messagesToRemoveEls.forEach((messageToRemove) => {
          m.removeMessage(messageToRemove, false);
        });
      } else {
        $(messagesToRemove).each((index, messageToRemove) => {
          m.removeMessage(messageToRemove, false);
        });
      }
      if (m.params.autoLayout && layout) m.layout();
      return m;
    }

    addMessage(...args) {
      const m = this;
      let messageToAdd;
      let animate;
      let method;
      if (typeof args[1] === 'boolean') {
        [messageToAdd, animate, method] = args;
      } else {
        [messageToAdd, method, animate] = args;
      }
      if (typeof animate === 'undefined') {
        animate = true;
      }
      if (typeof method === 'undefined') {
        method = m.params.newMessagesFirst ? 'prepend' : 'append';
      }

      return m.addMessages([messageToAdd], animate, method);
    }

    addMessages(...args) {
      const m = this;
      let messagesToAdd;
      let animate;
      let method;
      if (typeof args[1] === 'boolean') {
        [messagesToAdd, animate, method] = args;
      } else {
        [messagesToAdd, method, animate] = args;
      }
      if (typeof animate === 'undefined') {
        animate = true;
      }
      if (typeof method === 'undefined') {
        method = m.params.newMessagesFirst ? 'prepend' : 'append';
      }

      // Define scroll positions before new messages added
      const scrollHeightBefore = m.pageContentEl.scrollHeight;
      const heightBefore = m.pageContentEl.offsetHeight;
      const scrollBefore = m.pageContentEl.scrollTop;

      // Add message to DOM and data
      let messagesHTML = '';
      const typingMessage = m.messages.filter(el => el.isTyping)[0];
      messagesToAdd.forEach((messageToAdd) => {
        if (typingMessage) {
          if (method === 'append') {
            m.messages.splice(m.messages.indexOf(typingMessage), 0, messageToAdd);
          } else {
            m.messages.splice(m.messages.indexOf(typingMessage) + 1, 0, messageToAdd);
          }
        } else {
          m.messages[method === 'append' ? 'push' : 'unshift'](messageToAdd);
        }
        messagesHTML += m.renderMessage(messageToAdd);
      });
      const $messagesEls = $(messagesHTML);
      if (animate) {
        if (method === 'append' && !m.params.newMessagesFirst) {
          $messagesEls.addClass('message-appear-from-bottom');
        }
        if (method === 'prepend' && m.params.newMessagesFirst) {
          $messagesEls.addClass('message-appear-from-top');
        }
      }
      if (typingMessage) {
        if (method === 'append') {
          $messagesEls.insertBefore(m.$el.find('.message-typing'));
        } else {
          $messagesEls.insertAfter(m.$el.find('.message-typing'));
        }
      } else {
        m.$el[method]($messagesEls);
      }

      // Layout
      if (m.params.autoLayout) m.layout();

      if (method === 'prepend' && !typingMessage) {
        m.pageContentEl.scrollTop = scrollBefore + (m.pageContentEl.scrollHeight - scrollHeightBefore);
      }

      if (m.params.scrollMessages && ((method === 'append' && !m.params.newMessagesFirst) || (method === 'prepend' && m.params.newMessagesFirst && !typingMessage))) {
        if (m.params.scrollMessagesOnEdge) {
          let onEdge = false;
          if (m.params.newMessagesFirst && scrollBefore === 0) {
            onEdge = true;
          }
          if (!m.params.newMessagesFirst && (scrollBefore - (scrollHeightBefore - heightBefore) >= -10)) {
            onEdge = true;
          }
          if (onEdge) m.scroll(animate ? undefined : 0);
        } else {
          m.scroll(animate ? undefined : 0);
        }
      }

      return m;
    }

    showTyping(message = {}) {
      const m = this;
      const typingMessage = m.messages.filter(el => el.isTyping)[0];
      if (typingMessage) {
        m.removeMessage(m.messages.indexOf(typingMessage));
      }
      m.addMessage(Utils.extend({
        type: 'received',
        isTyping: true,
      }, message));
      return m;
    }

    hideTyping() {
      const m = this;
      let typingMessageIndex;
      let typingFound;
      m.messages.forEach((message, index) => {
        if (message.isTyping) typingMessageIndex = index;
      });
      if (typeof typingMessageIndex !== 'undefined') {
        if (m.$el.find('.message').eq(typingMessageIndex).hasClass('message-typing')) {
          typingFound = true;
          m.removeMessage(typingMessageIndex);
        }
      }
      if (!typingFound) {
        const $typingMessageEl = m.$el.find('.message-typing');
        if ($typingMessageEl.length) {
          m.removeMessage($typingMessageEl);
        }
      }
      return m;
    }

    scroll(duration = 300, scrollTop) {
      const m = this;
      const currentScroll = m.pageContentEl.scrollTop;
      let newScrollTop;
      if (typeof scrollTop !== 'undefined') newScrollTop = scrollTop;
      else {
        newScrollTop = m.params.newMessagesFirst ? 0 : m.pageContentEl.scrollHeight - m.pageContentEl.offsetHeight;
        if (newScrollTop === currentScroll) return m;
      }
      m.$pageContentEl.scrollTop(newScrollTop, duration);
      return m;
    }

    init() {
      const m = this;
      if (!m.messages || m.messages.length === 0) {
        m.messages = m.getMessagesData();
      }
      if (m.params.messages && m.params.messages.length) {
        m.renderMessages();
      }
      if (m.params.autoLayout) m.layout();
      if (m.params.scrollMessages) m.scroll(0);
    }

    destroy() {
      const m = this;
      m.emit('local::beforeDestroy messagesBeforeDestroy', m);
      m.$el.trigger('messages:beforedestroy');
      if (m.$el[0]) {
        m.$el[0].f7Messages = null;
        delete m.$el[0].f7Messages;
      }
      Utils.deleteProps(m);
    }
  }

  var Messages$1 = {
    name: 'messages',
    static: {
      Messages,
    },
    create() {
      const app = this;
      app.messages = ConstructorMethods({
        defaultSelector: '.messages',
        constructor: Messages,
        app,
        domProp: 'f7Messages',
        addMethods: 'renderMessages layout scroll clear removeMessage removeMessages addMessage addMessages'.split(' '),
      });
    },
    on: {
      tabBeforeRemove(tabEl) {
        const app = this;
        $(tabEl).find('.messages-init').each((index, messagesEl) => {
          app.messages.destroy(messagesEl);
        });
      },
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.messages-init').each((index, messagesEl) => {
          app.messages.create({ el: messagesEl });
        });
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.messages-init').each((index, messagesEl) => {
          app.messages.destroy(messagesEl);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.messages-init').each((index, messagesEl) => {
          app.messages.create({ el: messagesEl });
        });
      },
    },
    vnode: {
      'messages-init': {
        insert(vnode) {
          const app = this;
          const messagesEl = vnode.elm;
          app.messages.create({ el: messagesEl });
        },
        destroy(vnode) {
          const app = this;
          const messagesEl = vnode.elm;
          app.messages.destroy(messagesEl);
        },
      },
    },
  };

  class Messagebar extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);

      const messagebar = this;

      const defaults = {
        top: false,
        topOffset: 0,
        bottomOffset: 0,
        attachments: [],
        renderAttachments: undefined,
        renderAttachment: undefined,
        maxHeight: null,
        resizePage: true,
      };

      // Extend defaults with modules params
      messagebar.useModulesParams(defaults);

      messagebar.params = Utils.extend(defaults, params);

      // El
      const $el = $(messagebar.params.el);
      if ($el.length === 0) return messagebar;

      if ($el[0].f7Messagebar) return $el[0].f7Messagebar;

      $el[0].f7Messagebar = messagebar;

      // Page and PageContent
      const $pageEl = $el.parents('.page').eq(0);
      const $pageContentEl = $pageEl.find('.page-content').eq(0);

      // Area
      const $areaEl = $el.find('.messagebar-area');

      // Textarea
      let $textareaEl;
      if (messagebar.params.textareaEl) {
        $textareaEl = $(messagebar.params.textareaEl);
      } else {
        $textareaEl = $el.find('textarea');
      }

      // Attachments & Library
      const $attachmentsEl = $el.find('.messagebar-attachments');
      const $sheetEl = $el.find('.messagebar-sheet');

      if (messagebar.params.top) {
        $el.addClass('messagebar-top');
      }

      Utils.extend(messagebar, {
        $el,
        el: $el[0],
        $areaEl,
        areaEl: $areaEl[0],
        $textareaEl,
        textareaEl: $textareaEl[0],
        $attachmentsEl,
        attachmentsEl: $attachmentsEl[0],
        attachmentsVisible: $attachmentsEl.hasClass('messagebar-attachments-visible'),
        $sheetEl,
        sheetEl: $sheetEl[0],
        sheetVisible: $sheetEl.hasClass('messagebar-sheet-visible'),
        $pageEl,
        pageEl: $pageEl[0],
        $pageContentEl,
        pageContentEl: $pageContentEl,
        top: $el.hasClass('messagebar-top') || messagebar.params.top,
        attachments: [],
      });

      // Events
      function onAppResize() {
        if (messagebar.params.resizePage) {
          messagebar.resizePage();
        }
      }
      function onSubmit(e) {
        e.preventDefault();
      }
      function onAttachmentClick(e) {
        const index = $(this).index();
        if ($(e.target).closest('.messagebar-attachment-delete').length) {
          $(this).trigger('messagebar:attachmentdelete', index);
          messagebar.emit('local::attachmentDelete messagebarAttachmentDelete', messagebar, this, index);
        } else {
          $(this).trigger('messagebar:attachmentclick', index);
          messagebar.emit('local::attachmentClick messagebarAttachmentClick', messagebar, this, index);
        }
      }
      function onTextareaChange() {
        messagebar.checkEmptyState();
        messagebar.$el.trigger('messagebar:change');
        messagebar.emit('local::change messagebarChange', messagebar);
      }
      function onTextareaFocus() {
        messagebar.sheetHide();
        messagebar.$el.addClass('messagebar-focused');
        messagebar.$el.trigger('messagebar:focus');
        messagebar.emit('local::focus messagebarFocus', messagebar);
      }
      function onTextareaBlur() {
        messagebar.$el.removeClass('messagebar-focused');
        messagebar.$el.trigger('messagebar:blur');
        messagebar.emit('local::blur messagebarBlur', messagebar);
      }

      messagebar.attachEvents = function attachEvents() {
        $el.on('textarea:resize', onAppResize);
        $el.on('submit', onSubmit);
        $el.on('click', '.messagebar-attachment', onAttachmentClick);
        $textareaEl.on('change input', onTextareaChange);
        $textareaEl.on('focus', onTextareaFocus);
        $textareaEl.on('blur', onTextareaBlur);
        app.on('resize', onAppResize);
      };
      messagebar.detachEvents = function detachEvents() {
        $el.off('textarea:resize', onAppResize);
        $el.off('submit', onSubmit);
        $el.off('click', '.messagebar-attachment', onAttachmentClick);
        $textareaEl.off('change input', onTextareaChange);
        $textareaEl.off('focus', onTextareaFocus);
        $textareaEl.off('blur', onTextareaBlur);
        app.off('resize', onAppResize);
      };


      // Install Modules
      messagebar.useModules();

      // Init
      messagebar.init();

      return messagebar;
    }

    focus() {
      const messagebar = this;
      messagebar.$textareaEl.focus();
      return messagebar;
    }

    blur() {
      const messagebar = this;
      messagebar.$textareaEl.blur();
      return messagebar;
    }

    clear() {
      const messagebar = this;
      messagebar.$textareaEl.val('').trigger('change');
      return messagebar;
    }

    getValue() {
      const messagebar = this;
      return messagebar.$textareaEl.val().trim();
    }

    setValue(value) {
      const messagebar = this;
      messagebar.$textareaEl.val(value).trigger('change');
      return messagebar;
    }

    setPlaceholder(placeholder) {
      const messagebar = this;
      messagebar.$textareaEl.attr('placeholder', placeholder);
      return messagebar;
    }

    resizePage() {
      const messagebar = this;
      const {
        params,
        $el,
        top,
        $pageEl,
        $pageContentEl,
        $areaEl,
        $textareaEl,
        $sheetEl,
        $attachmentsEl,
      } = messagebar;
      const elHeight = $el[0].offsetHeight;
      let maxHeight = params.maxHeight;
      if (top) ; else {
        const currentPaddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
        const requiredPaddingBottom = elHeight + params.bottomOffset;
        if (requiredPaddingBottom !== currentPaddingBottom && $pageContentEl.length) {
          const currentPaddingTop = parseInt($pageContentEl.css('padding-top'), 10);
          const pageScrollHeight = $pageContentEl[0].scrollHeight;
          const pageOffsetHeight = $pageContentEl[0].offsetHeight;
          const pageScrollTop = $pageContentEl[0].scrollTop;
          const scrollOnBottom = (pageScrollTop === pageScrollHeight - pageOffsetHeight);
          if (!maxHeight) {
            maxHeight = $pageEl[0].offsetHeight - currentPaddingTop - $sheetEl.outerHeight() - $attachmentsEl.outerHeight() - parseInt($areaEl.css('margin-top'), 10) - parseInt($areaEl.css('margin-bottom'), 10);
          }
          $textareaEl.css('max-height', `${maxHeight}px`);
          $pageContentEl.css('padding-bottom', `${requiredPaddingBottom}px`);
          if (scrollOnBottom) {
            $pageContentEl.scrollTop($pageContentEl[0].scrollHeight - pageOffsetHeight);
          }
          $el.trigger('messagebar:resizepage');
          messagebar.emit('local::resizePage messagebarResizePage', messagebar);
        }
      }
    }

    checkEmptyState() {
      const messagebar = this;
      const { $el, $textareaEl } = messagebar;
      const value = $textareaEl.val().trim();
      if (value && value.length) {
        $el.addClass('messagebar-with-value');
      } else {
        $el.removeClass('messagebar-with-value');
      }
    }

    attachmentsCreate(innerHTML = '') {
      const messagebar = this;
      const $attachmentsEl = $(`<div class="messagebar-attachments">${innerHTML}</div>`);
      $attachmentsEl.insertBefore(messagebar.$textareaEl);
      Utils.extend(messagebar, {
        $attachmentsEl,
        attachmentsEl: $attachmentsEl[0],
      });
      return messagebar;
    }

    attachmentsShow(innerHTML = '') {
      const messagebar = this;
      messagebar.$attachmentsEl = messagebar.$el.find('.messagebar-attachments');
      if (messagebar.$attachmentsEl.length === 0) {
        messagebar.attachmentsCreate(innerHTML);
      }
      messagebar.$el.addClass('messagebar-attachments-visible');
      messagebar.attachmentsVisible = true;
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
      return messagebar;
    }

    attachmentsHide() {
      const messagebar = this;
      messagebar.$el.removeClass('messagebar-attachments-visible');
      messagebar.attachmentsVisible = false;
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
      return messagebar;
    }

    attachmentsToggle() {
      const messagebar = this;
      if (messagebar.attachmentsVisible) {
        messagebar.attachmentsHide();
      } else {
        messagebar.attachmentsShow();
      }
      return messagebar;
    }

    renderAttachment(attachment) {
      const messagebar = this;
      if (messagebar.params.renderAttachment) {
        return messagebar.params.renderAttachment.call(messagebar, attachment);
      }
      return `
      <div class="messagebar-attachment">
        <img src="${attachment}">
        <span class="messagebar-attachment-delete"></span>
      </div>
    `;
    }

    renderAttachments() {
      const messagebar = this;
      let html;
      if (messagebar.params.renderAttachments) {
        html = messagebar.params.renderAttachments.call(messagebar, messagebar.attachments);
      } else {
        html = `${messagebar.attachments.map(attachment => messagebar.renderAttachment(attachment)).join('')}`;
      }
      if (messagebar.$attachmentsEl.length === 0) {
        messagebar.attachmentsCreate(html);
      } else {
        messagebar.$attachmentsEl.html(html);
      }
    }

    sheetCreate(innerHTML = '') {
      const messagebar = this;
      const $sheetEl = $(`<div class="messagebar-sheet">${innerHTML}</div>`);
      messagebar.$el.append($sheetEl);
      Utils.extend(messagebar, {
        $sheetEl,
        sheetEl: $sheetEl[0],
      });
      return messagebar;
    }

    sheetShow(innerHTML = '') {
      const messagebar = this;
      messagebar.$sheetEl = messagebar.$el.find('.messagebar-sheet');
      if (messagebar.$sheetEl.length === 0) {
        messagebar.sheetCreate(innerHTML);
      }
      messagebar.$el.addClass('messagebar-sheet-visible');
      messagebar.sheetVisible = true;
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
      return messagebar;
    }

    sheetHide() {
      const messagebar = this;
      messagebar.$el.removeClass('messagebar-sheet-visible');
      messagebar.sheetVisible = false;
      if (messagebar.params.resizePage) {
        messagebar.resizePage();
      }
      return messagebar;
    }

    sheetToggle() {
      const messagebar = this;
      if (messagebar.sheetVisible) {
        messagebar.sheetHide();
      } else {
        messagebar.sheetShow();
      }
      return messagebar;
    }

    init() {
      const messagebar = this;
      messagebar.attachEvents();
      messagebar.checkEmptyState();
      return messagebar;
    }

    destroy() {
      const messagebar = this;
      messagebar.emit('local::beforeDestroy messagebarBeforeDestroy', messagebar);
      messagebar.$el.trigger('messagebar:beforedestroy');
      messagebar.detachEvents();
      if (messagebar.$el[0]) {
        messagebar.$el[0].f7Messagebar = null;
        delete messagebar.$el[0].f7Messagebar;
      }
      Utils.deleteProps(messagebar);
    }
  }

  var Messagebar$1 = {
    name: 'messagebar',
    static: {
      Messagebar,
    },
    create() {
      const app = this;
      app.messagebar = ConstructorMethods({
        defaultSelector: '.messagebar',
        constructor: Messagebar,
        app,
        domProp: 'f7Messagebar',
        addMethods: 'clear getValue setValue setPlaceholder resizePage focus blur attachmentsCreate attachmentsShow attachmentsHide attachmentsToggle renderAttachments sheetCreate sheetShow sheetHide sheetToggle'.split(' '),
      });
    },
    on: {
      tabBeforeRemove(tabEl) {
        const app = this;
        $(tabEl).find('.messagebar-init').each((index, messagebarEl) => {
          app.messagebar.destroy(messagebarEl);
        });
      },
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.messagebar-init').each((index, messagebarEl) => {
          app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
        });
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.messagebar-init').each((index, messagebarEl) => {
          app.messagebar.destroy(messagebarEl);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.messagebar-init').each((index, messagebarEl) => {
          app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
        });
      },
    },
    vnode: {
      'messagebar-init': {
        insert(vnode) {
          const app = this;
          const messagebarEl = vnode.elm;
          app.messagebar.create(Utils.extend({ el: messagebarEl }, $(messagebarEl).dataset()));
        },
        destroy(vnode) {
          const app = this;
          const messagebarEl = vnode.elm;
          app.messagebar.destroy(messagebarEl);
        },
      },
    },
  };

  function updateSize () {
    const swiper = this;
    let width;
    let height;
    const $el = swiper.$el;
    if (typeof swiper.params.width !== 'undefined') {
      width = swiper.params.width;
    } else {
      width = $el[0].clientWidth;
    }
    if (typeof swiper.params.height !== 'undefined') {
      height = swiper.params.height;
    } else {
      height = $el[0].clientHeight;
    }
    if ((width === 0 && swiper.isHorizontal()) || (height === 0 && swiper.isVertical())) {
      return;
    }

    // Subtract paddings
    width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
    height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);

    Utils.extend(swiper, {
      width,
      height,
      size: swiper.isHorizontal() ? width : height,
    });
  }

  function updateSlides () {
    const swiper = this;
    const params = swiper.params;

    const {
      $wrapperEl, size: swiperSize, rtlTranslate: rtl, wrongRTL,
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;
    const previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    const slides = $wrapperEl.children(`.${swiper.params.slideClass}`);
    const slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    let snapGrid = [];
    const slidesGrid = [];
    const slidesSizesGrid = [];

    function slidesForMargin(slideIndex) {
      if (!params.cssMode) return true;
      if (slideIndex === slides.length - 1) {
        return false;
      }
      return true;
    }

    let offsetBefore = params.slidesOffsetBefore;
    if (typeof offsetBefore === 'function') {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }

    let offsetAfter = params.slidesOffsetAfter;
    if (typeof offsetAfter === 'function') {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }

    const previousSnapGridLength = swiper.snapGrid.length;
    const previousSlidesGridLength = swiper.snapGrid.length;

    let spaceBetween = params.spaceBetween;
    let slidePosition = -offsetBefore;
    let prevSlideSize = 0;
    let index = 0;
    if (typeof swiperSize === 'undefined') {
      return;
    }
    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = (parseFloat(spaceBetween.replace('%', '')) / 100) * swiperSize;
    }

    swiper.virtualSize = -spaceBetween;

    // reset margins
    if (rtl) slides.css({ marginLeft: '', marginTop: '' });
    else slides.css({ marginRight: '', marginBottom: '' });

    let slidesNumberEvenToRows;
    if (params.slidesPerColumn > 1) {
      if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
        slidesNumberEvenToRows = slidesLength;
      } else {
        slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
      }
      if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
      }
    }

    // Calc slides
    let slideSize;
    const slidesPerColumn = params.slidesPerColumn;
    const slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
    const numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);
    for (let i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      const slide = slides.eq(i);
      if (params.slidesPerColumn > 1) {
        // Set slides order
        let newSlideOrderIndex;
        let column;
        let row;
        if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
          const groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
          const slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
          const columnsInGroup = groupIndex === 0
            ? params.slidesPerGroup
            : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
          row = Math.floor(slideIndexInGroup / columnsInGroup);
          column = (slideIndexInGroup - row * columnsInGroup) + groupIndex * params.slidesPerGroup;

          newSlideOrderIndex = column + ((row * slidesNumberEvenToRows) / slidesPerColumn);
          slide
            .css({
              '-webkit-box-ordinal-group': newSlideOrderIndex,
              '-moz-box-ordinal-group': newSlideOrderIndex,
              '-ms-flex-order': newSlideOrderIndex,
              '-webkit-order': newSlideOrderIndex,
              order: newSlideOrderIndex,
            });
        } else if (params.slidesPerColumnFill === 'column') {
          column = Math.floor(i / slidesPerColumn);
          row = i - (column * slidesPerColumn);
          if (column > numFullColumns || (column === numFullColumns && row === slidesPerColumn - 1)) {
            row += 1;
            if (row >= slidesPerColumn) {
              row = 0;
              column += 1;
            }
          }
        } else {
          row = Math.floor(i / slidesPerRow);
          column = i - (row * slidesPerRow);
        }
        slide.css(
          `margin-${swiper.isHorizontal() ? 'top' : 'left'}`,
          (row !== 0 && params.spaceBetween) && (`${params.spaceBetween}px`)
        );
      }
      if (slide.css('display') === 'none') continue; // eslint-disable-line

      if (params.slidesPerView === 'auto') {
        const slideStyles = win.getComputedStyle(slide[0], null);
        const currentTransform = slide[0].style.transform;
        const currentWebKitTransform = slide[0].style.webkitTransform;
        if (currentTransform) {
          slide[0].style.transform = 'none';
        }
        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = 'none';
        }
        if (params.roundLengths) {
          slideSize = swiper.isHorizontal()
            ? slide.outerWidth(true)
            : slide.outerHeight(true);
        } else {
          // eslint-disable-next-line
          if (swiper.isHorizontal()) {
            const width = parseFloat(slideStyles.getPropertyValue('width'));
            const paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
            const paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
            const marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
            const marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
            const boxSizing = slideStyles.getPropertyValue('box-sizing');
            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
            }
          } else {
            const height = parseFloat(slideStyles.getPropertyValue('height'));
            const paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
            const paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
            const marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
            const marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
            const boxSizing = slideStyles.getPropertyValue('box-sizing');
            if (boxSizing && boxSizing === 'border-box') {
              slideSize = height + marginTop + marginBottom;
            } else {
              slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
            }
          }
        }
        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }
        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }
        if (params.roundLengths) slideSize = Math.floor(slideSize);
      } else {
        slideSize = (swiperSize - ((params.slidesPerView - 1) * spaceBetween)) / params.slidesPerView;
        if (params.roundLengths) slideSize = Math.floor(slideSize);

        if (slides[i]) {
          if (swiper.isHorizontal()) {
            slides[i].style.width = `${slideSize}px`;
          } else {
            slides[i].style.height = `${slideSize}px`;
          }
        }
      }
      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }
      slidesSizesGrid.push(slideSize);


      if (params.centeredSlides) {
        slidePosition = slidePosition + (slideSize / 2) + (prevSlideSize / 2) + spaceBetween;
        if (prevSlideSize === 0 && i !== 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
        if (i === 0) slidePosition = slidePosition - (swiperSize / 2) - spaceBetween;
        if (Math.abs(slidePosition) < 1 / 1000) slidePosition = 0;
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index) % params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) slidePosition = Math.floor(slidePosition);
        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) snapGrid.push(slidePosition);
        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }

      swiper.virtualSize += slideSize + spaceBetween;

      prevSlideSize = slideSize;

      index += 1;
    }
    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    let newSlidesGrid;

    if (
      rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
      $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
    }
    if (params.setWrapperSize) {
      if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
      else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
    }

    if (params.slidesPerColumn > 1) {
      swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
      swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;
      if (swiper.isHorizontal()) $wrapperEl.css({ width: `${swiper.virtualSize + params.spaceBetween}px` });
      else $wrapperEl.css({ height: `${swiper.virtualSize + params.spaceBetween}px` });
      if (params.centeredSlides) {
        newSlidesGrid = [];
        for (let i = 0; i < snapGrid.length; i += 1) {
          let slidesGridItem = snapGrid[i];
          if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
          if (snapGrid[i] < swiper.virtualSize + snapGrid[0]) newSlidesGrid.push(slidesGridItem);
        }
        snapGrid = newSlidesGrid;
      }
    }

    // Remove last grid elements depending on width
    if (!params.centeredSlides) {
      newSlidesGrid = [];
      for (let i = 0; i < snapGrid.length; i += 1) {
        let slidesGridItem = snapGrid[i];
        if (params.roundLengths) slidesGridItem = Math.floor(slidesGridItem);
        if (snapGrid[i] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem);
        }
      }
      snapGrid = newSlidesGrid;
      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }
    if (snapGrid.length === 0) snapGrid = [0];

    if (params.spaceBetween !== 0) {
      if (swiper.isHorizontal()) {
        if (rtl) slides.filter(slidesForMargin).css({ marginLeft: `${spaceBetween}px` });
        else slides.filter(slidesForMargin).css({ marginRight: `${spaceBetween}px` });
      } else slides.filter(slidesForMargin).css({ marginBottom: `${spaceBetween}px` });
    }

    if (params.centeredSlides && params.centeredSlidesBounds) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      const maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map((snap) => {
        if (snap < 0) return -offsetBefore;
        if (snap > maxSnap) return maxSnap + offsetAfter;
        return snap;
      });
    }

    if (params.centerInsufficientSlides) {
      let allSlidesSize = 0;
      slidesSizesGrid.forEach((slideSizeValue) => {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      if (allSlidesSize < swiperSize) {
        const allSlidesOffset = (swiperSize - allSlidesSize) / 2;
        snapGrid.forEach((snap, snapIndex) => {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach((snap, snapIndex) => {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }

    Utils.extend(swiper, {
      slides,
      snapGrid,
      slidesGrid,
      slidesSizesGrid,
    });

    if (slidesLength !== previousSlidesLength) {
      swiper.emit('slidesLengthChange');
    }
    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) swiper.checkOverflow();
      swiper.emit('snapGridLengthChange');
    }
    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit('slidesGridLengthChange');
    }

    if (params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateSlidesOffset();
    }
  }

  function updateAutoHeight (speed) {
    const swiper = this;
    const activeSlides = [];
    let newHeight = 0;
    let i;
    if (typeof speed === 'number') {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    }
    // Find slides currently in view
    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        swiper.visibleSlides.each((index, slide) => {
          activeSlides.push(slide);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
          const index = swiper.activeIndex + i;
          if (index > swiper.slides.length) break;
          activeSlides.push(swiper.slides.eq(index)[0]);
        }
      }
    } else {
      activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
    }

    // Find new height from highest slide in view
    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== 'undefined') {
        const height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    }

    // Update Height
    if (newHeight) swiper.$wrapperEl.css('height', `${newHeight}px`);
  }

  function updateSlidesOffset () {
    const swiper = this;
    const slides = swiper.slides;
    for (let i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
    }
  }

  function updateSlidesProgress (translate = (this && this.translate) || 0) {
    const swiper = this;
    const params = swiper.params;

    const { slides, rtlTranslate: rtl } = swiper;

    if (slides.length === 0) return;
    if (typeof slides[0].swiperSlideOffset === 'undefined') swiper.updateSlidesOffset();

    let offsetCenter = -translate;
    if (rtl) offsetCenter = translate;

    // Visible Slides
    slides.removeClass(params.slideVisibleClass);

    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];

    for (let i = 0; i < slides.length; i += 1) {
      const slide = slides[i];
      const slideProgress = (
        (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0)) - slide.swiperSlideOffset
      ) / (slide.swiperSlideSize + params.spaceBetween);
      if (params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) {
        const slideBefore = -(offsetCenter - slide.swiperSlideOffset);
        const slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        const isVisible = (slideBefore >= 0 && slideBefore < swiper.size - 1)
                  || (slideAfter > 1 && slideAfter <= swiper.size)
                  || (slideBefore <= 0 && slideAfter >= swiper.size);
        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }
      }
      slide.progress = rtl ? -slideProgress : slideProgress;
    }
    swiper.visibleSlides = $(swiper.visibleSlides);
  }

  function updateProgress (translate) {
    const swiper = this;
    if (typeof translate === 'undefined') {
      const multiplier = swiper.rtlTranslate ? -1 : 1;
      // eslint-disable-next-line
      translate = (swiper && swiper.translate && (swiper.translate * multiplier)) || 0;
    }
    const params = swiper.params;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    let { progress, isBeginning, isEnd } = swiper;
    const wasBeginning = isBeginning;
    const wasEnd = isEnd;
    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper.minTranslate()) / (translatesDiff);
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }
    Utils.extend(swiper, {
      progress,
      isBeginning,
      isEnd,
    });

    if (params.watchSlidesProgress || params.watchSlidesVisibility || (params.centeredSlides && params.autoHeight)) swiper.updateSlidesProgress(translate);

    if (isBeginning && !wasBeginning) {
      swiper.emit('reachBeginning toEdge');
    }
    if (isEnd && !wasEnd) {
      swiper.emit('reachEnd toEdge');
    }
    if ((wasBeginning && !isBeginning) || (wasEnd && !isEnd)) {
      swiper.emit('fromEdge');
    }

    swiper.emit('progress', progress);
  }

  function updateSlidesClasses () {
    const swiper = this;

    const {
      slides, params, $wrapperEl, activeIndex, realIndex,
    } = swiper;
    const isVirtual = swiper.virtual && params.virtual.enabled;

    slides.removeClass(`${params.slideActiveClass} ${params.slideNextClass} ${params.slidePrevClass} ${params.slideDuplicateActiveClass} ${params.slideDuplicateNextClass} ${params.slideDuplicatePrevClass}`);

    let activeSlide;
    if (isVirtual) {
      activeSlide = swiper.$wrapperEl.find(`.${params.slideClass}[data-swiper-slide-index="${activeIndex}"]`);
    } else {
      activeSlide = slides.eq(activeIndex);
    }

    // Active classes
    activeSlide.addClass(params.slideActiveClass);

    if (params.loop) {
      // Duplicate to all looped slides
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl
          .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${realIndex}"]`)
          .addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl
          .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${realIndex}"]`)
          .addClass(params.slideDuplicateActiveClass);
      }
    }
    // Next Slide
    let nextSlide = activeSlide.nextAll(`.${params.slideClass}`).eq(0).addClass(params.slideNextClass);
    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    }
    // Prev Slide
    let prevSlide = activeSlide.prevAll(`.${params.slideClass}`).eq(0).addClass(params.slidePrevClass);
    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }
    if (params.loop) {
      // Duplicate to all looped slides
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl
          .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
          .addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl
          .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${nextSlide.attr('data-swiper-slide-index')}"]`)
          .addClass(params.slideDuplicateNextClass);
      }
      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl
          .children(`.${params.slideClass}:not(.${params.slideDuplicateClass})[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
          .addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl
          .children(`.${params.slideClass}.${params.slideDuplicateClass}[data-swiper-slide-index="${prevSlide.attr('data-swiper-slide-index')}"]`)
          .addClass(params.slideDuplicatePrevClass);
      }
    }
  }

  function updateActiveIndex (newActiveIndex) {
    const swiper = this;
    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    const {
      slidesGrid, snapGrid, params, activeIndex: previousIndex, realIndex: previousRealIndex, snapIndex: previousSnapIndex,
    } = swiper;
    let activeIndex = newActiveIndex;
    let snapIndex;
    if (typeof activeIndex === 'undefined') {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - ((slidesGrid[i + 1] - slidesGrid[i]) / 2)) {
            activeIndex = i;
          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
            activeIndex = i + 1;
          }
        } else if (translate >= slidesGrid[i]) {
          activeIndex = i;
        }
      }
      // Normalize slideIndex
      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === 'undefined') activeIndex = 0;
      }
    }
    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      const skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;
    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit('snapIndexChange');
      }
      return;
    }

    // Get real index
    const realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);

    Utils.extend(swiper, {
      snapIndex,
      realIndex,
      previousIndex,
      activeIndex,
    });
    swiper.emit('activeIndexChange');
    swiper.emit('snapIndexChange');
    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }
    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      swiper.emit('slideChange');
    }
  }

  function updateClickedSlide (e) {
    const swiper = this;
    const params = swiper.params;
    const slide = $(e.target).closest(`.${params.slideClass}`)[0];
    let slideFound = false;
    if (slide) {
      for (let i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide) slideFound = true;
      }
    }

    if (slide && slideFound) {
      swiper.clickedSlide = slide;
      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
      } else {
        swiper.clickedIndex = $(slide).index();
      }
    } else {
      swiper.clickedSlide = undefined;
      swiper.clickedIndex = undefined;
      return;
    }
    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }

  var update = {
    updateSize,
    updateSlides,
    updateAutoHeight,
    updateSlidesOffset,
    updateSlidesProgress,
    updateProgress,
    updateSlidesClasses,
    updateActiveIndex,
    updateClickedSlide,
  };

  function getTranslate (axis = this.isHorizontal() ? 'x' : 'y') {
    const swiper = this;

    const {
      params, rtlTranslate: rtl, translate, $wrapperEl,
    } = swiper;

    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }
    if (params.cssMode) {
      return translate;
    }

    let currentTranslate = Utils.getTranslate($wrapperEl[0], axis);
    if (rtl) currentTranslate = -currentTranslate;

    return currentTranslate || 0;
  }

  function setTranslate (translate, byController) {
    const swiper = this;
    const {
      rtlTranslate: rtl, params, $wrapperEl, wrapperEl, progress,
    } = swiper;
    let x = 0;
    let y = 0;
    const z = 0;

    if (swiper.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }

    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }

    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      $wrapperEl.transform(`translate3d(${x}px, ${y}px, ${z}px)`);
    }
    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y;

    // Check if we need to update progress
    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper.minTranslate()) / (translatesDiff);
    }
    if (newProgress !== progress) {
      swiper.updateProgress(translate);
    }

    swiper.emit('setTranslate', swiper.translate, byController);
  }

  function minTranslate () {
    return (-this.snapGrid[0]);
  }

  function maxTranslate () {
    return (-this.snapGrid[this.snapGrid.length - 1]);
  }

  function translateTo (translate = 0, speed = this.params.speed, runCallbacks = true, translateBounds = true, internal) {
    const swiper = this;

    const {
      params,
      wrapperEl,
    } = swiper;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    const minTranslate = swiper.minTranslate();
    const maxTranslate = swiper.maxTranslate();
    let newTranslate;
    if (translateBounds && translate > minTranslate) newTranslate = minTranslate;
    else if (translateBounds && translate < maxTranslate) newTranslate = maxTranslate;
    else newTranslate = translate;

    // Update progress
    swiper.updateProgress(newTranslate);

    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      } else {
        // eslint-disable-next-line
        if (wrapperEl.scrollTo) {
          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: -newTranslate,
            behavior: 'smooth',
          });
        } else {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        }
      }
      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionEnd');
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);
      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionStart');
      }
      if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;
            if (runCallbacks) {
              swiper.emit('transitionEnd');
            }
          };
        }
        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
      }
    }

    return true;
  }

  var translate = {
    getTranslate,
    setTranslate,
    minTranslate,
    maxTranslate,
    translateTo,
  };

  function setTransition (duration, byController) {
    const swiper = this;

    if (!swiper.params.cssMode) {
      swiper.$wrapperEl.transition(duration);
    }

    swiper.emit('setTransition', duration, byController);
  }

  function transitionStart (runCallbacks = true, direction) {
    const swiper = this;
    const { activeIndex, params, previousIndex } = swiper;
    if (params.cssMode) return;
    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex) dir = 'next';
      else if (activeIndex < previousIndex) dir = 'prev';
      else dir = 'reset';
    }

    swiper.emit('transitionStart');

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit('slideResetTransitionStart');
        return;
      }
      swiper.emit('slideChangeTransitionStart');
      if (dir === 'next') {
        swiper.emit('slideNextTransitionStart');
      } else {
        swiper.emit('slidePrevTransitionStart');
      }
    }
  }

  function transitionEnd$1 (runCallbacks = true, direction) {
    const swiper = this;
    const { activeIndex, previousIndex, params } = swiper;
    swiper.animating = false;
    if (params.cssMode) return;
    swiper.setTransition(0);

    let dir = direction;
    if (!dir) {
      if (activeIndex > previousIndex) dir = 'next';
      else if (activeIndex < previousIndex) dir = 'prev';
      else dir = 'reset';
    }

    swiper.emit('transitionEnd');

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit('slideResetTransitionEnd');
        return;
      }
      swiper.emit('slideChangeTransitionEnd');
      if (dir === 'next') {
        swiper.emit('slideNextTransitionEnd');
      } else {
        swiper.emit('slidePrevTransitionEnd');
      }
    }
  }

  var transition$1 = {
    setTransition,
    transitionStart,
    transitionEnd: transitionEnd$1,
  };

  function slideTo (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    let slideIndex = index;
    if (slideIndex < 0) slideIndex = 0;

    const {
      params, snapGrid, slidesGrid, previousIndex, activeIndex, rtlTranslate: rtl, wrapperEl,
    } = swiper;
    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    const skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    let snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);
    if (snapIndex >= snapGrid.length) snapIndex = snapGrid.length - 1;

    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
      swiper.emit('beforeSlideChangeStart');
    }

    const translate = -snapGrid[snapIndex];

    // Update progress
    swiper.updateProgress(translate);

    // Normalize slideIndex
    if (params.normalizeSlideIndex) {
      for (let i = 0; i < slidesGrid.length; i += 1) {
        if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
          slideIndex = i;
        }
      }
    }
    // Directions locks
    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
        return false;
      }
      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) return false;
      }
    }

    let direction;
    if (slideIndex > activeIndex) direction = 'next';
    else if (slideIndex < activeIndex) direction = 'prev';
    else direction = 'reset';


    // Update Index
    if ((rtl && -translate === swiper.translate) || (!rtl && translate === swiper.translate)) {
      swiper.updateActiveIndex(slideIndex);
      // Update Height
      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }
      swiper.updateSlidesClasses();
      if (params.effect !== 'slide') {
        swiper.setTranslate(translate);
      }
      if (direction !== 'reset') {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }
      return false;
    }
    if (params.cssMode) {
      const isH = swiper.isHorizontal();
      let t = -translate;
      if (rtl) {
        t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
      }
      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      } else {
        // eslint-disable-next-line
        if (wrapperEl.scrollTo) {
          wrapperEl.scrollTo({
            [isH ? 'left' : 'top']: t,
            behavior: 'smooth',
          });
        } else {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        }
      }
      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      if (!swiper.animating) {
        swiper.animating = true;
        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }
        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
      }
    }

    return true;
  }

  function slideToLoop (index = 0, speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    let newIndex = index;
    if (swiper.params.loop) {
      newIndex += swiper.loopedSlides;
    }

    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideNext (speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const { params, animating } = swiper;
    const increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;
    if (params.loop) {
      if (animating) return false;
      swiper.loopFix();
      // eslint-disable-next-line
      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }
    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slidePrev (speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    const {
      params, animating, snapGrid, slidesGrid, rtlTranslate,
    } = swiper;

    if (params.loop) {
      if (animating) return false;
      swiper.loopFix();
      // eslint-disable-next-line
      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }
    const translate = rtlTranslate ? swiper.translate : -swiper.translate;
    function normalize(val) {
      if (val < 0) return -Math.floor(Math.abs(val));
      return Math.floor(val);
    }
    const normalizedTranslate = normalize(translate);
    const normalizedSnapGrid = snapGrid.map((val) => normalize(val));
    const normalizedSlidesGrid = slidesGrid.map((val) => normalize(val));

    const currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
    let prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];
    if (typeof prevSnap === 'undefined' && params.cssMode) {
      snapGrid.forEach((snap) => {
        if (!prevSnap && normalizedTranslate >= snap) prevSnap = snap;
      });
    }
    let prevIndex;
    if (typeof prevSnap !== 'undefined') {
      prevIndex = slidesGrid.indexOf(prevSnap);
      if (prevIndex < 0) prevIndex = swiper.activeIndex - 1;
    }
    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideReset (speed = this.params.speed, runCallbacks = true, internal) {
    const swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }

  /* eslint no-unused-vars: "off" */
  function slideToClosest (speed = this.params.speed, runCallbacks = true, internal, threshold = 0.5) {
    const swiper = this;
    let index = swiper.activeIndex;
    const skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    const snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);

    const translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

    if (translate >= swiper.snapGrid[snapIndex]) {
      // The current translate is on or after the current snap index, so the choice
      // is between the current index and the one after it.
      const currentSnap = swiper.snapGrid[snapIndex];
      const nextSnap = swiper.snapGrid[snapIndex + 1];
      if ((translate - currentSnap) > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      // The current translate is before the current snap index, so the choice
      // is between the current index and the one before it.
      const prevSnap = swiper.snapGrid[snapIndex - 1];
      const currentSnap = swiper.snapGrid[snapIndex];
      if ((translate - prevSnap) <= (currentSnap - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }
    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);

    return swiper.slideTo(index, speed, runCallbacks, internal);
  }

  function slideToClickedSlide () {
    const swiper = this;
    const { params, $wrapperEl } = swiper;

    const slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    let slideToIndex = swiper.clickedIndex;
    let realIndex;
    if (params.loop) {
      if (swiper.animating) return;
      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);
      if (params.centeredSlides) {
        if (
          (slideToIndex < swiper.loopedSlides - (slidesPerView / 2))
          || (slideToIndex > (swiper.slides.length - swiper.loopedSlides) + (slidesPerView / 2))
        ) {
          swiper.loopFix();
          slideToIndex = $wrapperEl
            .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
            .eq(0)
            .index();

          Utils.nextTick(() => {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = $wrapperEl
          .children(`.${params.slideClass}[data-swiper-slide-index="${realIndex}"]:not(.${params.slideDuplicateClass})`)
          .eq(0)
          .index();

        Utils.nextTick(() => {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }

  var slide = {
    slideTo,
    slideToLoop,
    slideNext,
    slidePrev,
    slideReset,
    slideToClosest,
    slideToClickedSlide,
  };

  function loopCreate () {
    const swiper = this;
    const { params, $wrapperEl } = swiper;
    // Remove duplicated slides
    $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass}`).remove();

    let slides = $wrapperEl.children(`.${params.slideClass}`);

    if (params.loopFillGroupWithBlank) {
      const blankSlidesNum = params.slidesPerGroup - (slides.length % params.slidesPerGroup);
      if (blankSlidesNum !== params.slidesPerGroup) {
        for (let i = 0; i < blankSlidesNum; i += 1) {
          const blankNode = $(doc.createElement('div')).addClass(`${params.slideClass} ${params.slideBlankClass}`);
          $wrapperEl.append(blankNode);
        }
        slides = $wrapperEl.children(`.${params.slideClass}`);
      }
    }

    if (params.slidesPerView === 'auto' && !params.loopedSlides) params.loopedSlides = slides.length;

    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper.loopedSlides += params.loopAdditionalSlides;
    if (swiper.loopedSlides > slides.length) {
      swiper.loopedSlides = slides.length;
    }

    const prependSlides = [];
    const appendSlides = [];
    slides.each((index, el) => {
      const slide = $(el);
      if (index < swiper.loopedSlides) appendSlides.push(el);
      if (index < slides.length && index >= slides.length - swiper.loopedSlides) prependSlides.push(el);
      slide.attr('data-swiper-slide-index', index);
    });
    for (let i = 0; i < appendSlides.length; i += 1) {
      $wrapperEl.append($(appendSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
    for (let i = prependSlides.length - 1; i >= 0; i -= 1) {
      $wrapperEl.prepend($(prependSlides[i].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  function loopFix () {
    const swiper = this;

    swiper.emit('beforeLoopFix');

    const {
      activeIndex, slides, loopedSlides, allowSlidePrev, allowSlideNext, snapGrid, rtlTranslate: rtl,
    } = swiper;
    let newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;

    const snapTranslate = -snapGrid[activeIndex];
    const diff = snapTranslate - swiper.getTranslate();

    // Fix For Negative Oversliding
    if (activeIndex < loopedSlides) {
      newIndex = (slides.length - (loopedSlides * 3)) + activeIndex;
      newIndex += loopedSlides;
      const slideChanged = swiper.slideTo(newIndex, 0, false, true);
      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    } else if (activeIndex >= slides.length - loopedSlides) {
      // Fix For Positive Oversliding
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;
      const slideChanged = swiper.slideTo(newIndex, 0, false, true);
      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    }
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;

    swiper.emit('loopFix');
  }

  function loopDestroy () {
    const swiper = this;
    const { $wrapperEl, params, slides } = swiper;
    $wrapperEl.children(`.${params.slideClass}.${params.slideDuplicateClass},.${params.slideClass}.${params.slideBlankClass}`).remove();
    slides.removeAttr('data-swiper-slide-index');
  }

  var loop = {
    loopCreate,
    loopFix,
    loopDestroy,
  };

  function setGrabCursor (moving) {
    const swiper = this;
    if (Support.touch || !swiper.params.simulateTouch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
    const el = swiper.el;
    el.style.cursor = 'move';
    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
    el.style.cursor = moving ? 'grabbing' : 'grab';
  }

  function unsetGrabCursor () {
    const swiper = this;
    if (Support.touch || (swiper.params.watchOverflow && swiper.isLocked) || swiper.params.cssMode) return;
    swiper.el.style.cursor = '';
  }

  var grabCursor = {
    setGrabCursor,
    unsetGrabCursor,
  };

  function appendSlide (slides) {
    const swiper = this;
    const { $wrapperEl, params } = swiper;
    if (params.loop) {
      swiper.loopDestroy();
    }
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) $wrapperEl.append(slides[i]);
      }
    } else {
      $wrapperEl.append(slides);
    }
    if (params.loop) {
      swiper.loopCreate();
    }
    if (!(params.observer && Support.observer)) {
      swiper.update();
    }
  }

  function prependSlide (slides) {
    const swiper = this;
    const { params, $wrapperEl, activeIndex } = swiper;

    if (params.loop) {
      swiper.loopDestroy();
    }
    let newActiveIndex = activeIndex + 1;
    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) $wrapperEl.prepend(slides[i]);
      }
      newActiveIndex = activeIndex + slides.length;
    } else {
      $wrapperEl.prepend(slides);
    }
    if (params.loop) {
      swiper.loopCreate();
    }
    if (!(params.observer && Support.observer)) {
      swiper.update();
    }
    swiper.slideTo(newActiveIndex, 0, false);
  }

  function addSlide (index, slides) {
    const swiper = this;
    const { $wrapperEl, params, activeIndex } = swiper;
    let activeIndexBuffer = activeIndex;
    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
    }
    const baseLength = swiper.slides.length;
    if (index <= 0) {
      swiper.prependSlide(slides);
      return;
    }
    if (index >= baseLength) {
      swiper.appendSlide(slides);
      return;
    }
    let newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;

    const slidesBuffer = [];
    for (let i = baseLength - 1; i >= index; i -= 1) {
      const currentSlide = swiper.slides.eq(i);
      currentSlide.remove();
      slidesBuffer.unshift(currentSlide);
    }

    if (typeof slides === 'object' && 'length' in slides) {
      for (let i = 0; i < slides.length; i += 1) {
        if (slides[i]) $wrapperEl.append(slides[i]);
      }
      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
      $wrapperEl.append(slides);
    }

    for (let i = 0; i < slidesBuffer.length; i += 1) {
      $wrapperEl.append(slidesBuffer[i]);
    }

    if (params.loop) {
      swiper.loopCreate();
    }
    if (!(params.observer && Support.observer)) {
      swiper.update();
    }
    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeSlide (slidesIndexes) {
    const swiper = this;
    const { params, $wrapperEl, activeIndex } = swiper;

    let activeIndexBuffer = activeIndex;
    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children(`.${params.slideClass}`);
    }
    let newActiveIndex = activeIndexBuffer;
    let indexToRemove;

    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
      for (let i = 0; i < slidesIndexes.length; i += 1) {
        indexToRemove = slidesIndexes[i];
        if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
        if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
      }
      newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
      indexToRemove = slidesIndexes;
      if (swiper.slides[indexToRemove]) swiper.slides.eq(indexToRemove).remove();
      if (indexToRemove < newActiveIndex) newActiveIndex -= 1;
      newActiveIndex = Math.max(newActiveIndex, 0);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }
    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeAllSlides () {
    const swiper = this;

    const slidesIndexes = [];
    for (let i = 0; i < swiper.slides.length; i += 1) {
      slidesIndexes.push(i);
    }
    swiper.removeSlide(slidesIndexes);
  }

  var manipulation = {
    appendSlide,
    prependSlide,
    addSlide,
    removeSlide,
    removeAllSlides,
  };

  function onTouchStart (event) {
    const swiper = this;
    const data = swiper.touchEventsData;
    const { params, touches } = swiper;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    const $targetEl = $(e.target);

    if (params.touchEventsTarget === 'wrapper') {
      if (!$targetEl.closest(swiper.wrapperEl).length) return;
    }
    data.isTouchEvent = e.type === 'touchstart';
    if (!data.isTouchEvent && 'which' in e && e.which === 3) return;
    if (!data.isTouchEvent && 'button' in e && e.button > 0) return;
    if (data.isTouched && data.isMoved) return;
    if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : `.${params.noSwipingClass}`)[0]) {
      swiper.allowClick = true;
      return;
    }
    if (params.swipeHandler) {
      if (!$targetEl.closest(params.swipeHandler)[0]) return;
    }

    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    const startX = touches.currentX;
    const startY = touches.currentY;

    // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

    const edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    const edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;
    if (
      edgeSwipeDetection
      && ((startX <= edgeSwipeThreshold)
      || (startX >= win.screen.width - edgeSwipeThreshold))
    ) {
      return;
    }

    Utils.extend(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: undefined,
      startMoving: undefined,
    });

    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = Utils.now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = undefined;
    if (params.threshold > 0) data.allowThresholdMove = false;
    if (e.type !== 'touchstart') {
      let preventDefault = true;
      if ($targetEl.is(data.formElements)) preventDefault = false;
      if (
        doc.activeElement
        && $(doc.activeElement).is(data.formElements)
        && doc.activeElement !== $targetEl[0]
      ) {
        doc.activeElement.blur();
      }

      const shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;
      if (params.touchStartForcePreventDefault || shouldPreventDefault) {
        e.preventDefault();
      }
    }
    swiper.emit('touchStart', e);
  }

  function onTouchMove (event) {
    const swiper = this;
    const data = swiper.touchEventsData;
    const { params, touches, rtlTranslate: rtl } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }
      return;
    }
    if (data.isTouchEvent && e.type === 'mousemove') return;
    const targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
    const pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
    const pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;
    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }
    if (!swiper.allowTouchMove) {
      // isMoved = true;
      swiper.allowClick = false;
      if (data.isTouched) {
        Utils.extend(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY,
        });
        data.touchStartTime = Utils.now();
      }
      return;
    }
    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        // Vertical
        if (
          (pageY < touches.startY && swiper.translate <= swiper.maxTranslate())
          || (pageY > touches.startY && swiper.translate >= swiper.minTranslate())
        ) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (
        (pageX < touches.startX && swiper.translate <= swiper.maxTranslate())
        || (pageX > touches.startX && swiper.translate >= swiper.minTranslate())
      ) {
        return;
      }
    }
    if (data.isTouchEvent && doc.activeElement) {
      if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }
    if (data.allowTouchCallbacks) {
      swiper.emit('touchMove', e);
    }
    if (e.targetTouches && e.targetTouches.length > 1) return;

    touches.currentX = pageX;
    touches.currentY = pageY;

    const diffX = touches.currentX - touches.startX;
    const diffY = touches.currentY - touches.startY;
    if (swiper.params.threshold && Math.sqrt((diffX ** 2) + (diffY ** 2)) < swiper.params.threshold) return;

    if (typeof data.isScrolling === 'undefined') {
      let touchAngle;
      if ((swiper.isHorizontal() && touches.currentY === touches.startY) || (swiper.isVertical() && touches.currentX === touches.startX)) {
        data.isScrolling = false;
      } else {
        // eslint-disable-next-line
        if ((diffX * diffX) + (diffY * diffY) >= 25) {
          touchAngle = (Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180) / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : (90 - touchAngle > params.touchAngle);
        }
      }
    }
    if (data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }
    if (typeof data.startMoving === 'undefined') {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }
    if (data.isScrolling) {
      data.isTouched = false;
      return;
    }
    if (!data.startMoving) {
      return;
    }
    swiper.allowClick = false;
    if (!params.cssMode) {
      e.preventDefault();
    }
    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }

    if (!data.isMoved) {
      if (params.loop) {
        swiper.loopFix();
      }
      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);
      if (swiper.animating) {
        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
      }
      data.allowMomentumBounce = false;
      // Grab Cursor
      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }
      swiper.emit('sliderFirstMove', e);
    }
    swiper.emit('sliderMove', e);
    data.isMoved = true;

    let diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;

    diff *= params.touchRatio;
    if (rtl) diff = -diff;

    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
    data.currentTranslate = diff + data.startTranslate;

    let disableParentSwiper = true;
    let resistanceRatio = params.resistanceRatio;
    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }
    if ((diff > 0 && data.currentTranslate > swiper.minTranslate())) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = (swiper.minTranslate() - 1) + ((-swiper.minTranslate() + data.startTranslate + diff) ** resistanceRatio);
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;
      if (params.resistance) data.currentTranslate = (swiper.maxTranslate() + 1) - ((swiper.maxTranslate() - data.startTranslate - diff) ** resistanceRatio);
    }

    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    }

    // Directions locks
    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }
    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }


    // Threshold
    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }

    if (!params.followFinger || params.cssMode) return;

    // Update active index in free mode
    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }
    if (params.freeMode) {
      // Velocity
      if (data.velocities.length === 0) {
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
          time: data.touchStartTime,
        });
      }
      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
        time: Utils.now(),
      });
    }
    // Update progress
    swiper.updateProgress(data.currentTranslate);
    // Update translate
    swiper.setTranslate(data.currentTranslate);
  }

  function onTouchEnd (event) {
    const swiper = this;
    const data = swiper.touchEventsData;

    const {
      params, touches, rtlTranslate: rtl, $wrapperEl, slidesGrid, snapGrid,
    } = swiper;
    let e = event;
    if (e.originalEvent) e = e.originalEvent;
    if (data.allowTouchCallbacks) {
      swiper.emit('touchEnd', e);
    }
    data.allowTouchCallbacks = false;
    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    // Return Grab Cursor
    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    }

    // Time diff
    const touchEndTime = Utils.now();
    const timeDiff = touchEndTime - data.touchStartTime;

    // Tap, doubleTap, Click
    if (swiper.allowClick) {
      swiper.updateClickedSlide(e);
      swiper.emit('tap click', e);
      if (timeDiff < 300 && (touchEndTime - data.lastClickTime) < 300) {
        swiper.emit('doubleTap doubleClick', e);
      }
    }

    data.lastClickTime = Utils.now();
    Utils.nextTick(() => {
      if (!swiper.destroyed) swiper.allowClick = true;
    });

    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }
    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;

    let currentPos;
    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }

    if (params.cssMode) {
      return;
    }

    if (params.freeMode) {
      if (currentPos < -swiper.minTranslate()) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (currentPos > -swiper.maxTranslate()) {
        if (swiper.slides.length < snapGrid.length) {
          swiper.slideTo(snapGrid.length - 1);
        } else {
          swiper.slideTo(swiper.slides.length - 1);
        }
        return;
      }

      if (params.freeModeMomentum) {
        if (data.velocities.length > 1) {
          const lastMoveEvent = data.velocities.pop();
          const velocityEvent = data.velocities.pop();

          const distance = lastMoveEvent.position - velocityEvent.position;
          const time = lastMoveEvent.time - velocityEvent.time;
          swiper.velocity = distance / time;
          swiper.velocity /= 2;
          if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
            swiper.velocity = 0;
          }
          // this implies that the user stopped moving a finger then released.
          // There would be no events with distance zero, so the last event is stale.
          if (time > 150 || (Utils.now() - lastMoveEvent.time) > 300) {
            swiper.velocity = 0;
          }
        } else {
          swiper.velocity = 0;
        }
        swiper.velocity *= params.freeModeMomentumVelocityRatio;

        data.velocities.length = 0;
        let momentumDuration = 1000 * params.freeModeMomentumRatio;
        const momentumDistance = swiper.velocity * momentumDuration;

        let newPosition = swiper.translate + momentumDistance;
        if (rtl) newPosition = -newPosition;

        let doBounce = false;
        let afterBouncePosition;
        const bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
        let needsLoopFix;
        if (newPosition < swiper.maxTranslate()) {
          if (params.freeModeMomentumBounce) {
            if (newPosition + swiper.maxTranslate() < -bounceAmount) {
              newPosition = swiper.maxTranslate() - bounceAmount;
            }
            afterBouncePosition = swiper.maxTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.maxTranslate();
          }
          if (params.loop && params.centeredSlides) needsLoopFix = true;
        } else if (newPosition > swiper.minTranslate()) {
          if (params.freeModeMomentumBounce) {
            if (newPosition - swiper.minTranslate() > bounceAmount) {
              newPosition = swiper.minTranslate() + bounceAmount;
            }
            afterBouncePosition = swiper.minTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.minTranslate();
          }
          if (params.loop && params.centeredSlides) needsLoopFix = true;
        } else if (params.freeModeSticky) {
          let nextSlide;
          for (let j = 0; j < snapGrid.length; j += 1) {
            if (snapGrid[j] > -newPosition) {
              nextSlide = j;
              break;
            }
          }

          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
            newPosition = snapGrid[nextSlide];
          } else {
            newPosition = snapGrid[nextSlide - 1];
          }
          newPosition = -newPosition;
        }
        if (needsLoopFix) {
          swiper.once('transitionEnd', () => {
            swiper.loopFix();
          });
        }
        // Fix duration
        if (swiper.velocity !== 0) {
          if (rtl) {
            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
          } else {
            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
          }
          if (params.freeModeSticky) {
            // If freeModeSticky is active and the user ends a swipe with a slow-velocity
            // event, then durations can be 20+ seconds to slide one (or zero!) slides.
            // It's easy to see this when simulating touch with mouse events. To fix this,
            // limit single-slide swipes to the default slide duration. This also has the
            // nice side effect of matching slide speed if the user stopped moving before
            // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
            // For faster swipes, also apply limits (albeit higher ones).
            const moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
            const currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];
            if (moveDistance < currentSlideSize) {
              momentumDuration = params.speed;
            } else if (moveDistance < 2 * currentSlideSize) {
              momentumDuration = params.speed * 1.5;
            } else {
              momentumDuration = params.speed * 2.5;
            }
          }
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        }

        if (params.freeModeMomentumBounce && doBounce) {
          swiper.updateProgress(afterBouncePosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);
          swiper.animating = true;
          $wrapperEl.transitionEnd(() => {
            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) return;
            swiper.emit('momentumBounce');
            swiper.setTransition(params.speed);
            setTimeout(() => {
              swiper.setTranslate(afterBouncePosition);
              $wrapperEl.transitionEnd(() => {
                if (!swiper || swiper.destroyed) return;
                swiper.transitionEnd();
              });
            }, 0);
          });
        } else if (swiper.velocity) {
          swiper.updateProgress(newPosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);
          if (!swiper.animating) {
            swiper.animating = true;
            $wrapperEl.transitionEnd(() => {
              if (!swiper || swiper.destroyed) return;
              swiper.transitionEnd();
            });
          }
        } else {
          swiper.updateProgress(newPosition);
        }

        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      return;
    }

    // Find current slide
    let stopIndex = 0;
    let groupSize = swiper.slidesSizesGrid[0];
    for (let i = 0; i < slidesGrid.length; i += (i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup)) {
      const increment = (i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);
      if (typeof slidesGrid[i + increment] !== 'undefined') {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    }

    // Find current slide size
    const ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    const increment = (stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup);

    if (timeDiff > params.longSwipesMs) {
      // Long touches
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      if (swiper.swipeDirection === 'next') {
        if (ratio >= params.longSwipesRatio) swiper.slideTo(stopIndex + increment);
        else swiper.slideTo(stopIndex);
      }
      if (swiper.swipeDirection === 'prev') {
        if (ratio > (1 - params.longSwipesRatio)) swiper.slideTo(stopIndex + increment);
        else swiper.slideTo(stopIndex);
      }
    } else {
      // Short swipes
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }
      const isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);
      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === 'next') {
          swiper.slideTo(stopIndex + increment);
        }
        if (swiper.swipeDirection === 'prev') {
          swiper.slideTo(stopIndex);
        }
      } else if (e.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }

  function onResize () {
    const swiper = this;

    const { params, el } = swiper;

    if (el && el.offsetWidth === 0) return;

    // Breakpoints
    if (params.breakpoints) {
      swiper.setBreakpoint();
    }

    // Save locks
    const { allowSlideNext, allowSlidePrev, snapGrid } = swiper;

    // Disable locks on resize
    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;

    swiper.updateSize();
    swiper.updateSlides();

    swiper.updateSlidesClasses();
    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }

    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      swiper.autoplay.run();
    }
    // Return locks after resize
    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;

    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }

  function onClick (e) {
    const swiper = this;
    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) e.preventDefault();
      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }

  function onScroll () {
    const swiper = this;
    const { wrapperEl, rtlTranslate } = swiper;
    swiper.previousTranslate = swiper.translate;
    if (swiper.isHorizontal()) {
      if (rtlTranslate) {
        swiper.translate = ((wrapperEl.scrollWidth - wrapperEl.offsetWidth) - wrapperEl.scrollLeft);
      } else {
        swiper.translate = -wrapperEl.scrollLeft;
      }
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    }
    // eslint-disable-next-line
    if (swiper.translate === -0) swiper.translate = 0;

    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();

    let newProgress;
    const translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / (translatesDiff);
    }
    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }

    swiper.emit('setTranslate', swiper.translate, false);
  }

  let dummyEventAttached = false;
  function dummyEventListener() {}

  function attachEvents() {
    const swiper = this;
    const {
      params, touchEvents, el, wrapperEl,
    } = swiper;

    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);
    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }

    swiper.onClick = onClick.bind(swiper);

    const capture = !!params.nested;

    // Touch Events
    if (!Support.touch && Support.pointerEvents) {
      el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
      doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
      doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        const passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? { passive: false, capture } : capture);
        el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
        if (touchEvents.cancel) {
          el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
        if (!dummyEventAttached) {
          doc.addEventListener('touchstart', dummyEventListener);
          dummyEventAttached = true;
        }
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        el.addEventListener('mousedown', swiper.onTouchStart, false);
        doc.addEventListener('mousemove', swiper.onTouchMove, capture);
        doc.addEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      el.addEventListener('click', swiper.onClick, true);
    }
    if (params.cssMode) {
      wrapperEl.addEventListener('scroll', swiper.onScroll);
    }

    // Resize handler
    if (params.updateOnWindowResize) {
      swiper.on((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize, true);
    } else {
      swiper.on('observerUpdate', onResize, true);
    }
  }

  function detachEvents() {
    const swiper = this;

    const {
      params, touchEvents, el, wrapperEl,
    } = swiper;

    const capture = !!params.nested;

    // Touch Events
    if (!Support.touch && Support.pointerEvents) {
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
      doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        const passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);
        if (touchEvents.cancel) {
          el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      }
      if ((params.simulateTouch && !Device.ios && !Device.android) || (params.simulateTouch && !Support.touch && Device.ios)) {
        el.removeEventListener('mousedown', swiper.onTouchStart, false);
        doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
        doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
      }
    }
    // Prevent Links Clicks
    if (params.preventClicks || params.preventClicksPropagation) {
      el.removeEventListener('click', swiper.onClick, true);
    }

    if (params.cssMode) {
      wrapperEl.removeEventListener('scroll', swiper.onScroll);
    }

    // Resize handler
    swiper.off((Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate'), onResize);
  }

  var events = {
    attachEvents,
    detachEvents,
  };

  function setBreakpoint () {
    const swiper = this;
    const {
      activeIndex, initialized, loopedSlides = 0, params, $el,
    } = swiper;
    const breakpoints = params.breakpoints;
    if (!breakpoints || (breakpoints && Object.keys(breakpoints).length === 0)) return;

    // Get breakpoint for window width and update parameters
    const breakpoint = swiper.getBreakpoint(breakpoints);

    if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
      const breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;
      if (breakpointOnlyParams) {
        ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach((param) => {
          const paramValue = breakpointOnlyParams[param];
          if (typeof paramValue === 'undefined') return;
          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
            breakpointOnlyParams[param] = 'auto';
          } else if (param === 'slidesPerView') {
            breakpointOnlyParams[param] = parseFloat(paramValue);
          } else {
            breakpointOnlyParams[param] = parseInt(paramValue, 10);
          }
        });
      }

      const breakpointParams = breakpointOnlyParams || swiper.originalParams;
      const wasMultiRow = params.slidesPerColumn > 1;
      const isMultiRow = breakpointParams.slidesPerColumn > 1;
      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(`${params.containerModifierClass}multirow ${params.containerModifierClass}multirow-column`);
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(`${params.containerModifierClass}multirow`);
        if (breakpointParams.slidesPerColumnFill === 'column') {
          $el.addClass(`${params.containerModifierClass}multirow-column`);
        }
      }

      const directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      const needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      Utils.extend(swiper.params, breakpointParams);

      Utils.extend(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
      });

      swiper.currentBreakpoint = breakpoint;

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo((activeIndex - loopedSlides) + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }
  }

  function getBreakpoint (breakpoints) {
    // Get breakpoint for window width
    if (!breakpoints) return undefined;
    let breakpoint = false;

    const points = Object.keys(breakpoints).map((point) => {
      if (typeof point === 'string' && point.indexOf('@') === 0) {
        const minRatio = parseFloat(point.substr(1));
        const value = win.innerHeight * minRatio;
        return { value, point };
      }
      return { value: point, point };
    });

    points.sort((a, b) => parseInt(a.value, 10) - parseInt(b.value, 10));
    for (let i = 0; i < points.length; i += 1) {
      const { point, value } = points[i];
      if (value <= win.innerWidth) {
        breakpoint = point;
      }
    }
    return breakpoint || 'max';
  }

  var breakpoints = { setBreakpoint, getBreakpoint };

  function addClasses () {
    const swiper = this;
    const {
      classNames, params, rtl, $el,
    } = swiper;
    const suffixes = [];

    suffixes.push('initialized');
    suffixes.push(params.direction);

    if (params.freeMode) {
      suffixes.push('free-mode');
    }
    if (params.autoHeight) {
      suffixes.push('autoheight');
    }
    if (rtl) {
      suffixes.push('rtl');
    }
    if (params.slidesPerColumn > 1) {
      suffixes.push('multirow');
      if (params.slidesPerColumnFill === 'column') {
        suffixes.push('multirow-column');
      }
    }
    if (Device.android) {
      suffixes.push('android');
    }
    if (Device.ios) {
      suffixes.push('ios');
    }

    if (params.cssMode) {
      suffixes.push('css-mode');
    }

    suffixes.forEach((suffix) => {
      classNames.push(params.containerModifierClass + suffix);
    });

    $el.addClass(classNames.join(' '));
  }

  function removeClasses () {
    const swiper = this;
    const { $el, classNames } = swiper;

    $el.removeClass(classNames.join(' '));
  }

  var classes = { addClasses, removeClasses };

  function loadImage (imageEl, src, srcset, sizes, checkForComplete, callback) {
    let image;
    function onReady() {
      if (callback) callback();
    }
    if (!imageEl.complete || !checkForComplete) {
      if (src) {
        image = new win.Image();
        image.onload = onReady;
        image.onerror = onReady;
        if (sizes) {
          image.sizes = sizes;
        }
        if (srcset) {
          image.srcset = srcset;
        }
        if (src) {
          image.src = src;
        }
      } else {
        onReady();
      }
    } else {
      // image already loaded...
      onReady();
    }
  }

  function preloadImages () {
    const swiper = this;
    swiper.imagesToLoad = swiper.$el.find('img');
    function onReady() {
      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) return;
      if (swiper.imagesLoaded !== undefined) swiper.imagesLoaded += 1;
      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
        if (swiper.params.updateOnImagesReady) swiper.update();
        swiper.emit('imagesReady');
      }
    }
    for (let i = 0; i < swiper.imagesToLoad.length; i += 1) {
      const imageEl = swiper.imagesToLoad[i];
      swiper.loadImage(
        imageEl,
        imageEl.currentSrc || imageEl.getAttribute('src'),
        imageEl.srcset || imageEl.getAttribute('srcset'),
        imageEl.sizes || imageEl.getAttribute('sizes'),
        true,
        onReady
      );
    }
  }

  var images = {
    loadImage,
    preloadImages,
  };

  function checkOverflow() {
    const swiper = this;
    const params = swiper.params;
    const wasLocked = swiper.isLocked;
    const lastSlidePosition = swiper.slides.length > 0 && (params.slidesOffsetBefore + (params.spaceBetween * (swiper.slides.length - 1)) + ((swiper.slides[0]).offsetWidth) * swiper.slides.length);

    if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
      swiper.isLocked = lastSlidePosition <= swiper.size;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }

    swiper.allowSlideNext = !swiper.isLocked;
    swiper.allowSlidePrev = !swiper.isLocked;

    // events
    if (wasLocked !== swiper.isLocked) swiper.emit(swiper.isLocked ? 'lock' : 'unlock');

    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
      swiper.navigation.update();
    }
  }

  var checkOverflow$1 = { checkOverflow };

  var defaults = {
    init: true,
    direction: 'horizontal',
    touchEventsTarget: 'container',
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    //
    preventInteractionOnTransition: false,

    // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,

    // Free mode
    freeMode: false,
    freeModeMomentum: true,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: true,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: false,
    freeModeMinimumVelocity: 0.02,

    // Autoheight
    autoHeight: false,

    // Set wrapper width
    setWrapperSize: false,

    // Virtual Translate
    virtualTranslate: false,

    // Effects
    effect: 'slide', // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'

    // Breakpoints
    breakpoints: undefined,

    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerColumn: 1,
    slidesPerColumnFill: 'column',
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0, // in px
    slidesOffsetAfter: 0, // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,

    // Disable swiper and hide navigation when container not overflow
    watchOverflow: false,

    // Round length
    roundLengths: false,

    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,

    // Unique Navigation Elements
    uniqueNavElements: true,

    // Resistance
    resistance: true,
    resistanceRatio: 0.85,

    // Progress
    watchSlidesProgress: false,
    watchSlidesVisibility: false,

    // Cursor
    grabCursor: false,

    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,

    // Images
    preloadImages: true,
    updateOnImagesReady: true,

    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: false,

    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null, // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,

    // Passive Listeners
    passiveListeners: true,

    // NS
    containerModifierClass: 'swiper-container-', // NEW
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-invisible-blank',
    slideActiveClass: 'swiper-slide-active',
    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideDuplicateClass: 'swiper-slide-duplicate',
    slideNextClass: 'swiper-slide-next',
    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
    slidePrevClass: 'swiper-slide-prev',
    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
    wrapperClass: 'swiper-wrapper',

    // Callbacks
    runCallbacksOnInit: true,
  };

  /* eslint no-param-reassign: "off" */

  const prototypes = {
    update,
    translate,
    transition: transition$1,
    slide,
    loop,
    grabCursor,
    manipulation,
    events,
    breakpoints,
    checkOverflow: checkOverflow$1,
    classes,
    images,
  };

  const extendedDefaults = {};

  class Swiper extends Framework7Class {
    constructor(...args) {
      let el;
      let params;
      if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
        params = args[0];
      } else {
        [el, params] = args;
      }
      if (!params) params = {};

      params = Utils.extend({}, params);
      if (el && !params.el) params.el = el;

      super(params);

      Object.keys(prototypes).forEach((prototypeGroup) => {
        Object.keys(prototypes[prototypeGroup]).forEach((protoMethod) => {
          if (!Swiper.prototype[protoMethod]) {
            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
          }
        });
      });

      // Swiper Instance
      const swiper = this;
      if (typeof swiper.modules === 'undefined') {
        swiper.modules = {};
      }
      Object.keys(swiper.modules).forEach((moduleName) => {
        const module = swiper.modules[moduleName];
        if (module.params) {
          const moduleParamName = Object.keys(module.params)[0];
          const moduleParams = module.params[moduleParamName];
          if (typeof moduleParams !== 'object' || moduleParams === null) return;
          if (!(moduleParamName in params && 'enabled' in moduleParams)) return;
          if (params[moduleParamName] === true) {
            params[moduleParamName] = { enabled: true };
          }
          if (
            typeof params[moduleParamName] === 'object'
            && !('enabled' in params[moduleParamName])
          ) {
            params[moduleParamName].enabled = true;
          }
          if (!params[moduleParamName]) params[moduleParamName] = { enabled: false };
        }
      });

      // Extend defaults with modules params
      const swiperParams = Utils.extend({}, defaults);
      swiper.useModulesParams(swiperParams);

      // Extend defaults with passed params
      swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = Utils.extend({}, swiper.params);
      swiper.passedParams = Utils.extend({}, params);

      // Save Dom lib
      swiper.$ = $;

      // Find el
      const $el = $(swiper.params.el);
      el = $el[0];

      if (!el) {
        return undefined;
      }

      if ($el.length > 1) {
        const swipers = [];
        $el.each((index, containerEl) => {
          const newParams = Utils.extend({}, params, { el: containerEl });
          swipers.push(new Swiper(newParams));
        });
        return swipers;
      }

      el.swiper = swiper;
      $el.data('swiper', swiper);

      // Find Wrapper
      let $wrapperEl;
      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        $wrapperEl = $(el.shadowRoot.querySelector(`.${swiper.params.wrapperClass}`));
        // Children needs to return slot items
        $wrapperEl.children = (options) => $el.children(options);
      } else {
        $wrapperEl = $el.children(`.${swiper.params.wrapperClass}`);
      }
      // Extend Swiper
      Utils.extend(swiper, {
        $el,
        el,
        $wrapperEl,
        wrapperEl: $wrapperEl[0],

        // Classes
        classNames: [],

        // Slides
        slides: $(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],

        // isDirection
        isHorizontal() {
          return swiper.params.direction === 'horizontal';
        },
        isVertical() {
          return swiper.params.direction === 'vertical';
        },
        // RTL
        rtl: (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
        wrongRTL: $wrapperEl.css('display') === '-webkit-box',

        // Indexes
        activeIndex: 0,
        realIndex: 0,

        //
        isBeginning: true,
        isEnd: false,

        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,

        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,

        // Touch Events
        touchEvents: (function touchEvents() {
          const touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
          let desktop = ['mousedown', 'mousemove', 'mouseup'];
          if (Support.pointerEvents) {
            desktop = ['pointerdown', 'pointermove', 'pointerup'];
          }
          swiper.touchEventsTouch = {
            start: touch[0],
            move: touch[1],
            end: touch[2],
            cancel: touch[3],
          };
          swiper.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2],
          };
          return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
        }()),
        touchEventsData: {
          isTouched: undefined,
          isMoved: undefined,
          allowTouchCallbacks: undefined,
          touchStartTime: undefined,
          isScrolling: undefined,
          currentTranslate: undefined,
          startTranslate: undefined,
          allowThresholdMove: undefined,
          // Form elements to match
          formElements: 'input, select, option, textarea, button, video, label',
          // Last click time
          lastClickTime: Utils.now(),
          clickTimeout: undefined,
          // Velocities
          velocities: [],
          allowMomentumBounce: undefined,
          isTouchEvent: undefined,
          startMoving: undefined,
        },

        // Clicks
        allowClick: true,

        // Touches
        allowTouchMove: swiper.params.allowTouchMove,

        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0,
        },

        // Images
        imagesToLoad: [],
        imagesLoaded: 0,

      });

      // Install Modules
      swiper.useModules();

      // Init
      if (swiper.params.init) {
        swiper.init();
      }

      // Return app instance
      return swiper;
    }

    slidesPerViewDynamic() {
      const swiper = this;
      const {
        params, slides, slidesGrid, size: swiperSize, activeIndex,
      } = swiper;
      let spv = 1;
      if (params.centeredSlides) {
        let slideSize = slides[activeIndex].swiperSlideSize;
        let breakLoop;
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
        for (let i = activeIndex - 1; i >= 0; i -= 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;
            if (slideSize > swiperSize) breakLoop = true;
          }
        }
      } else {
        for (let i = activeIndex + 1; i < slides.length; i += 1) {
          if (slidesGrid[i] - slidesGrid[activeIndex] < swiperSize) {
            spv += 1;
          }
        }
      }
      return spv;
    }

    update() {
      const swiper = this;
      if (!swiper || swiper.destroyed) return;
      const { snapGrid, params } = swiper;
      // Breakpoints
      if (params.breakpoints) {
        swiper.setBreakpoint();
      }
      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      function setTranslate() {
        const translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        const newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }
      let translated;
      if (swiper.params.freeMode) {
        setTranslate();
        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }
        if (!translated) {
          setTranslate();
        }
      }
      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }
      swiper.emit('update');
    }

    changeDirection(newDirection, needUpdate = true) {
      const swiper = this;
      const currentDirection = swiper.params.direction;
      if (!newDirection) {
        // eslint-disable-next-line
        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
      }
      if ((newDirection === currentDirection) || (newDirection !== 'horizontal' && newDirection !== 'vertical')) {
        return swiper;
      }

      swiper.$el
        .removeClass(`${swiper.params.containerModifierClass}${currentDirection}`)
        .addClass(`${swiper.params.containerModifierClass}${newDirection}`);

      swiper.params.direction = newDirection;

      swiper.slides.each((slideIndex, slideEl) => {
        if (newDirection === 'vertical') {
          slideEl.style.width = '';
        } else {
          slideEl.style.height = '';
        }
      });

      swiper.emit('changeDirection');
      if (needUpdate) swiper.update();

      return swiper;
    }

    init() {
      const swiper = this;
      if (swiper.initialized) return;

      swiper.emit('beforeInit');

      // Set breakpoint
      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      }

      // Add Classes
      swiper.addClasses();

      // Create loop
      if (swiper.params.loop) {
        swiper.loopCreate();
      }

      // Update size
      swiper.updateSize();

      // Update slides
      swiper.updateSlides();

      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }

      // Set Grab Cursor
      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }

      if (swiper.params.preloadImages) {
        swiper.preloadImages();
      }

      // Slide To Initial Slide
      if (swiper.params.loop) {
        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
      }

      // Attach events
      swiper.attachEvents();

      // Init Flag
      swiper.initialized = true;

      // Emit
      swiper.emit('init');
    }

    destroy(deleteInstance = true, cleanStyles = true) {
      const swiper = this;
      const {
        params, $el, $wrapperEl, slides,
      } = swiper;

      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
        return null;
      }

      swiper.emit('beforeDestroy');

      // Init Flag
      swiper.initialized = false;

      // Detach events
      swiper.detachEvents();

      // Destroy loop
      if (params.loop) {
        swiper.loopDestroy();
      }

      // Cleanup styles
      if (cleanStyles) {
        swiper.removeClasses();
        $el.removeAttr('style');
        $wrapperEl.removeAttr('style');
        if (slides && slides.length) {
          slides
            .removeClass([
              params.slideVisibleClass,
              params.slideActiveClass,
              params.slideNextClass,
              params.slidePrevClass,
            ].join(' '))
            .removeAttr('style')
            .removeAttr('data-swiper-slide-index');
        }
      }

      swiper.emit('destroy');

      // Detach emitter events
      Object.keys(swiper.eventsListeners).forEach((eventName) => {
        swiper.off(eventName);
      });

      if (deleteInstance !== false) {
        swiper.$el[0].swiper = null;
        swiper.$el.data('swiper', null);
        Utils.deleteProps(swiper);
      }
      swiper.destroyed = true;

      return null;
    }

    static extendDefaults(newDefaults) {
      Utils.extend(extendedDefaults, newDefaults);
    }

    static get extendedDefaults() {
      return extendedDefaults;
    }

    static get defaults() {
      return defaults;
    }

    static get Class() {
      return Framework7Class;
    }

    static get $() {
      return $;
    }
  }

  var Device$1 = {
    name: 'device',
    proto: {
      device: Device,
    },
    static: {
      device: Device,
    },
  };

  var Support$1 = {
    name: 'support',
    proto: {
      support: Support,
    },
    static: {
      support: Support,
    },
  };

  const Browser = (function Browser() {
    function isSafari() {
      const ua = win.navigator.userAgent.toLowerCase();
      return (ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0);
    }
    return {
      isEdge: !!win.navigator.userAgent.match(/Edge/g),
      isSafari: isSafari(),
      isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent),
    };
  }());

  var Browser$1 = {
    name: 'browser',
    proto: {
      browser: Browser,
    },
    static: {
      browser: Browser,
    },
  };

  var Resize = {
    name: 'resize',
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        resize: {
          resizeHandler() {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            swiper.emit('beforeResize');
            swiper.emit('resize');
          },
          orientationChangeHandler() {
            if (!swiper || swiper.destroyed || !swiper.initialized) return;
            swiper.emit('orientationchange');
          },
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        // Emit resize
        win.addEventListener('resize', swiper.resize.resizeHandler);

        // Emit orientationchange
        win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
      },
      destroy() {
        const swiper = this;
        win.removeEventListener('resize', swiper.resize.resizeHandler);
        win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
      },
    },
  };

  const Observer = {
    func: win.MutationObserver || win.WebkitMutationObserver,
    attach(target, options = {}) {
      const swiper = this;

      const ObserverFunc = Observer.func;
      const observer = new ObserverFunc((mutations) => {
        // The observerUpdate event should only be triggered
        // once despite the number of mutations.  Additional
        // triggers are redundant and are very costly
        if (mutations.length === 1) {
          swiper.emit('observerUpdate', mutations[0]);
          return;
        }
        const observerUpdate = function observerUpdate() {
          swiper.emit('observerUpdate', mutations[0]);
        };

        if (win.requestAnimationFrame) {
          win.requestAnimationFrame(observerUpdate);
        } else {
          win.setTimeout(observerUpdate, 0);
        }
      });

      observer.observe(target, {
        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
        childList: typeof options.childList === 'undefined' ? true : options.childList,
        characterData: typeof options.characterData === 'undefined' ? true : options.characterData,
      });

      swiper.observer.observers.push(observer);
    },
    init() {
      const swiper = this;
      if (!Support.observer || !swiper.params.observer) return;
      if (swiper.params.observeParents) {
        const containerParents = swiper.$el.parents();
        for (let i = 0; i < containerParents.length; i += 1) {
          swiper.observer.attach(containerParents[i]);
        }
      }
      // Observe container
      swiper.observer.attach(swiper.$el[0], { childList: swiper.params.observeSlideChildren });

      // Observe wrapper
      swiper.observer.attach(swiper.$wrapperEl[0], { attributes: false });
    },
    destroy() {
      const swiper = this;
      swiper.observer.observers.forEach((observer) => {
        observer.disconnect();
      });
      swiper.observer.observers = [];
    },
  };

  var Observer$1 = {
    name: 'observer',
    params: {
      observer: false,
      observeParents: false,
      observeSlideChildren: false,
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        observer: {
          init: Observer.init.bind(swiper),
          attach: Observer.attach.bind(swiper),
          destroy: Observer.destroy.bind(swiper),
          observers: [],
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        swiper.observer.init();
      },
      destroy() {
        const swiper = this;
        swiper.observer.destroy();
      },
    },
  };

  const Virtual = {
    update(force) {
      const swiper = this;
      const { slidesPerView, slidesPerGroup, centeredSlides } = swiper.params;
      const { addSlidesBefore, addSlidesAfter } = swiper.params.virtual;
      const {
        from: previousFrom,
        to: previousTo,
        slides,
        slidesGrid: previousSlidesGrid,
        renderSlide,
        offset: previousOffset,
      } = swiper.virtual;
      swiper.updateActiveIndex();
      const activeIndex = swiper.activeIndex || 0;

      let offsetProp;
      if (swiper.rtlTranslate) offsetProp = 'right';
      else offsetProp = swiper.isHorizontal() ? 'left' : 'top';

      let slidesAfter;
      let slidesBefore;
      if (centeredSlides) {
        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      } else {
        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
        slidesBefore = slidesPerGroup + addSlidesAfter;
      }
      const from = Math.max((activeIndex || 0) - slidesBefore, 0);
      const to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
      const offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);

      Utils.extend(swiper.virtual, {
        from,
        to,
        offset,
        slidesGrid: swiper.slidesGrid,
      });

      function onRendered() {
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();
        if (swiper.lazy && swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      }

      if (previousFrom === from && previousTo === to && !force) {
        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
          swiper.slides.css(offsetProp, `${offset}px`);
        }
        swiper.updateProgress();
        return;
      }
      if (swiper.params.virtual.renderExternal) {
        swiper.params.virtual.renderExternal.call(swiper, {
          offset,
          from,
          to,
          slides: (function getSlides() {
            const slidesToRender = [];
            for (let i = from; i <= to; i += 1) {
              slidesToRender.push(slides[i]);
            }
            return slidesToRender;
          }()),
        });
        onRendered();
        return;
      }
      const prependIndexes = [];
      const appendIndexes = [];
      if (force) {
        swiper.$wrapperEl.find(`.${swiper.params.slideClass}`).remove();
      } else {
        for (let i = previousFrom; i <= previousTo; i += 1) {
          if (i < from || i > to) {
            swiper.$wrapperEl.find(`.${swiper.params.slideClass}[data-swiper-slide-index="${i}"]`).remove();
          }
        }
      }
      for (let i = 0; i < slides.length; i += 1) {
        if (i >= from && i <= to) {
          if (typeof previousTo === 'undefined' || force) {
            appendIndexes.push(i);
          } else {
            if (i > previousTo) appendIndexes.push(i);
            if (i < previousFrom) prependIndexes.push(i);
          }
        }
      }
      appendIndexes.forEach((index) => {
        swiper.$wrapperEl.append(renderSlide(slides[index], index));
      });
      prependIndexes.sort((a, b) => b - a).forEach((index) => {
        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
      });
      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, `${offset}px`);
      onRendered();
    },
    renderSlide(slide, index) {
      const swiper = this;
      const params = swiper.params.virtual;
      if (params.cache && swiper.virtual.cache[index]) {
        return swiper.virtual.cache[index];
      }
      const $slideEl = params.renderSlide
        ? $(params.renderSlide.call(swiper, slide, index))
        : $(`<div class="${swiper.params.slideClass}" data-swiper-slide-index="${index}">${slide}</div>`);
      if (!$slideEl.attr('data-swiper-slide-index')) $slideEl.attr('data-swiper-slide-index', index);
      if (params.cache) swiper.virtual.cache[index] = $slideEl;
      return $slideEl;
    },
    appendSlide(slides) {
      const swiper = this;
      if (typeof slides === 'object' && 'length' in slides) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) swiper.virtual.slides.push(slides[i]);
        }
      } else {
        swiper.virtual.slides.push(slides);
      }
      swiper.virtual.update(true);
    },
    prependSlide(slides) {
      const swiper = this;
      const activeIndex = swiper.activeIndex;
      let newActiveIndex = activeIndex + 1;
      let numberOfNewSlides = 1;

      if (Array.isArray(slides)) {
        for (let i = 0; i < slides.length; i += 1) {
          if (slides[i]) swiper.virtual.slides.unshift(slides[i]);
        }
        newActiveIndex = activeIndex + slides.length;
        numberOfNewSlides = slides.length;
      } else {
        swiper.virtual.slides.unshift(slides);
      }
      if (swiper.params.virtual.cache) {
        const cache = swiper.virtual.cache;
        const newCache = {};
        Object.keys(cache).forEach((cachedIndex) => {
          const $cachedEl = cache[cachedIndex];
          const cachedElIndex = $cachedEl.attr('data-swiper-slide-index');
          if (cachedElIndex) {
            $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
          }
          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
        });
        swiper.virtual.cache = newCache;
      }
      swiper.virtual.update(true);
      swiper.slideTo(newActiveIndex, 0);
    },
    removeSlide(slidesIndexes) {
      const swiper = this;
      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) return;
      let activeIndex = swiper.activeIndex;
      if (Array.isArray(slidesIndexes)) {
        for (let i = slidesIndexes.length - 1; i >= 0; i -= 1) {
          swiper.virtual.slides.splice(slidesIndexes[i], 1);
          if (swiper.params.virtual.cache) {
            delete swiper.virtual.cache[slidesIndexes[i]];
          }
          if (slidesIndexes[i] < activeIndex) activeIndex -= 1;
          activeIndex = Math.max(activeIndex, 0);
        }
      } else {
        swiper.virtual.slides.splice(slidesIndexes, 1);
        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes];
        }
        if (slidesIndexes < activeIndex) activeIndex -= 1;
        activeIndex = Math.max(activeIndex, 0);
      }
      swiper.virtual.update(true);
      swiper.slideTo(activeIndex, 0);
    },
    removeAllSlides() {
      const swiper = this;
      swiper.virtual.slides = [];
      if (swiper.params.virtual.cache) {
        swiper.virtual.cache = {};
      }
      swiper.virtual.update(true);
      swiper.slideTo(0, 0);
    },
  };

  var Virtual$1 = {
    name: 'virtual',
    params: {
      virtual: {
        enabled: false,
        slides: [],
        cache: true,
        renderSlide: null,
        renderExternal: null,
        addSlidesBefore: 0,
        addSlidesAfter: 0,
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        virtual: {
          update: Virtual.update.bind(swiper),
          appendSlide: Virtual.appendSlide.bind(swiper),
          prependSlide: Virtual.prependSlide.bind(swiper),
          removeSlide: Virtual.removeSlide.bind(swiper),
          removeAllSlides: Virtual.removeAllSlides.bind(swiper),
          renderSlide: Virtual.renderSlide.bind(swiper),
          slides: swiper.params.virtual.slides,
          cache: {},
        },
      });
    },
    on: {
      beforeInit() {
        const swiper = this;
        if (!swiper.params.virtual.enabled) return;
        swiper.classNames.push(`${swiper.params.containerModifierClass}virtual`);
        const overwriteParams = {
          watchSlidesProgress: true,
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);

        if (!swiper.params.initialSlide) {
          swiper.virtual.update();
        }
      },
      setTranslate() {
        const swiper = this;
        if (!swiper.params.virtual.enabled) return;
        swiper.virtual.update();
      },
    },
  };

  const Keyboard = {
    handle(event) {
      const swiper = this;
      const { rtlTranslate: rtl } = swiper;
      let e = event;
      if (e.originalEvent) e = e.originalEvent; // jquery fix
      const kc = e.keyCode || e.charCode;
      // Directions locks
      if (!swiper.allowSlideNext && ((swiper.isHorizontal() && kc === 39) || (swiper.isVertical() && kc === 40) || kc === 34)) {
        return false;
      }
      if (!swiper.allowSlidePrev && ((swiper.isHorizontal() && kc === 37) || (swiper.isVertical() && kc === 38) || kc === 33)) {
        return false;
      }
      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
        return undefined;
      }
      if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
        return undefined;
      }
      if (swiper.params.keyboard.onlyInViewport && (kc === 33 || kc === 34 || kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
        let inView = false;
        // Check that swiper should be inside of visible area of window
        if (swiper.$el.parents(`.${swiper.params.slideClass}`).length > 0 && swiper.$el.parents(`.${swiper.params.slideActiveClass}`).length === 0) {
          return undefined;
        }
        const windowWidth = win.innerWidth;
        const windowHeight = win.innerHeight;
        const swiperOffset = swiper.$el.offset();
        if (rtl) swiperOffset.left -= swiper.$el[0].scrollLeft;
        const swiperCoord = [
          [swiperOffset.left, swiperOffset.top],
          [swiperOffset.left + swiper.width, swiperOffset.top],
          [swiperOffset.left, swiperOffset.top + swiper.height],
          [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height],
        ];
        for (let i = 0; i < swiperCoord.length; i += 1) {
          const point = swiperCoord[i];
          if (
            point[0] >= 0 && point[0] <= windowWidth
            && point[1] >= 0 && point[1] <= windowHeight
          ) {
            inView = true;
          }
        }
        if (!inView) return undefined;
      }
      if (swiper.isHorizontal()) {
        if (kc === 33 || kc === 34 || kc === 37 || kc === 39) {
          if (e.preventDefault) e.preventDefault();
          else e.returnValue = false;
        }
        if (((kc === 34 || kc === 39) && !rtl) || ((kc === 33 || kc === 37) && rtl)) swiper.slideNext();
        if (((kc === 33 || kc === 37) && !rtl) || ((kc === 34 || kc === 39) && rtl)) swiper.slidePrev();
      } else {
        if (kc === 33 || kc === 34 || kc === 38 || kc === 40) {
          if (e.preventDefault) e.preventDefault();
          else e.returnValue = false;
        }
        if (kc === 34 || kc === 40) swiper.slideNext();
        if (kc === 33 || kc === 38) swiper.slidePrev();
      }
      swiper.emit('keyPress', kc);
      return undefined;
    },
    enable() {
      const swiper = this;
      if (swiper.keyboard.enabled) return;
      $(doc).on('keydown', swiper.keyboard.handle);
      swiper.keyboard.enabled = true;
    },
    disable() {
      const swiper = this;
      if (!swiper.keyboard.enabled) return;
      $(doc).off('keydown', swiper.keyboard.handle);
      swiper.keyboard.enabled = false;
    },
  };

  var Keyboard$1 = {
    name: 'keyboard',
    params: {
      keyboard: {
        enabled: false,
        onlyInViewport: true,
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        keyboard: {
          enabled: false,
          enable: Keyboard.enable.bind(swiper),
          disable: Keyboard.disable.bind(swiper),
          handle: Keyboard.handle.bind(swiper),
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        if (swiper.params.keyboard.enabled) {
          swiper.keyboard.enable();
        }
      },
      destroy() {
        const swiper = this;
        if (swiper.keyboard.enabled) {
          swiper.keyboard.disable();
        }
      },
    },
  };

  function isEventSupported() {
    const eventName = 'onwheel';
    let isSupported = eventName in doc;

    if (!isSupported) {
      const element = doc.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }

    if (!isSupported
      && doc.implementation
      && doc.implementation.hasFeature
      // always returns true in newer browsers as per the standard.
      // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
      && doc.implementation.hasFeature('', '') !== true
    ) {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
    }

    return isSupported;
  }
  const Mousewheel = {
    lastScrollTime: Utils.now(),
    lastEventBeforeSnap: undefined,
    recentWheelEvents: [],
    event() {
      if (win.navigator.userAgent.indexOf('firefox') > -1) return 'DOMMouseScroll';
      return isEventSupported() ? 'wheel' : 'mousewheel';
    },
    normalize(e) {
      // Reasonable defaults
      const PIXEL_STEP = 10;
      const LINE_HEIGHT = 40;
      const PAGE_HEIGHT = 800;

      let sX = 0;
      let sY = 0; // spinX, spinY
      let pX = 0;
      let pY = 0; // pixelX, pixelY

      // Legacy
      if ('detail' in e) {
        sY = e.detail;
      }
      if ('wheelDelta' in e) {
        sY = -e.wheelDelta / 120;
      }
      if ('wheelDeltaY' in e) {
        sY = -e.wheelDeltaY / 120;
      }
      if ('wheelDeltaX' in e) {
        sX = -e.wheelDeltaX / 120;
      }

      // side scrolling on FF with DOMMouseScroll
      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
      }

      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;

      if ('deltaY' in e) {
        pY = e.deltaY;
      }
      if ('deltaX' in e) {
        pX = e.deltaX;
      }

      if (e.shiftKey && !pX) { // if user scrolls with shift he wants horizontal scroll
        pX = pY;
        pY = 0;
      }

      if ((pX || pY) && e.deltaMode) {
        if (e.deltaMode === 1) { // delta in LINE units
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else { // delta in PAGE units
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      }

      // Fall-back if spin cannot be determined
      if (pX && !sX) {
        sX = (pX < 1) ? -1 : 1;
      }
      if (pY && !sY) {
        sY = (pY < 1) ? -1 : 1;
      }

      return {
        spinX: sX,
        spinY: sY,
        pixelX: pX,
        pixelY: pY,
      };
    },
    handleMouseEnter() {
      const swiper = this;
      swiper.mouseEntered = true;
    },
    handleMouseLeave() {
      const swiper = this;
      swiper.mouseEntered = false;
    },
    handle(event) {
      let e = event;
      const swiper = this;
      const params = swiper.params.mousewheel;

      if (swiper.params.cssMode) {
        e.preventDefault();
      }

      let target = swiper.$el;
      if (swiper.params.mousewheel.eventsTarged !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarged);
      }
      if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;

      if (e.originalEvent) e = e.originalEvent; // jquery fix
      let delta = 0;
      const rtlFactor = swiper.rtlTranslate ? -1 : 1;

      const data = Mousewheel.normalize(e);

      if (params.forceToAxis) {
        if (swiper.isHorizontal()) {
          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = data.pixelX * rtlFactor;
          else return true;
        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = data.pixelY;
        else return true;
      } else {
        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
      }

      if (delta === 0) return true;

      if (params.invert) delta = -delta;

      if (!swiper.params.freeMode) {
        // Register the new event in a variable which stores the relevant data
        const newEvent = {
          time: Utils.now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta),
          raw: event,
        };

        // Keep the most recent events
        const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
        if (recentWheelEvents.length >= 2) {
          recentWheelEvents.shift(); // only store the last N events
        }
        const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
        recentWheelEvents.push(newEvent);

        // If there is at least one previous recorded event:
        //   If direction has changed or
        //   if the scroll is quicker than the previous one:
        //     Animate the slider.
        // Else (this is the first time the wheel is moved):
        //     Animate the slider.
        if (prevEvent) {
          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta) {
            swiper.mousewheel.animateSlider(newEvent);
          }
        } else {
          swiper.mousewheel.animateSlider(newEvent);
        }

        // If it's time to release the scroll:
        //   Return now so you don't hit the preventDefault.
        if (swiper.mousewheel.releaseScroll(newEvent)) {
          return true;
        }
      } else {
        // Freemode or scrollContainer:

        // If we recently snapped after a momentum scroll, then ignore wheel events
        // to give time for the deceleration to finish. Stop ignoring after 500 msecs
        // or if it's a new scroll (larger delta or inverse sign as last event before
        // an end-of-momentum snap).
        const newEvent = { time: Utils.now(), delta: Math.abs(delta), direction: Math.sign(delta) };
        const { lastEventBeforeSnap } = swiper.mousewheel;
        const ignoreWheelEvents = lastEventBeforeSnap
          && newEvent.time < lastEventBeforeSnap.time + 500
          && newEvent.delta <= lastEventBeforeSnap.delta
          && newEvent.direction === lastEventBeforeSnap.direction;
        if (!ignoreWheelEvents) {
          swiper.mousewheel.lastEventBeforeSnap = undefined;

          if (swiper.params.loop) {
            swiper.loopFix();
          }
          let position = swiper.getTranslate() + (delta * params.sensitivity);
          const wasBeginning = swiper.isBeginning;
          const wasEnd = swiper.isEnd;

          if (position >= swiper.minTranslate()) position = swiper.minTranslate();
          if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();

          swiper.setTransition(0);
          swiper.setTranslate(position);
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();

          if ((!wasBeginning && swiper.isBeginning) || (!wasEnd && swiper.isEnd)) {
            swiper.updateSlidesClasses();
          }

          if (swiper.params.freeModeSticky) {
            // When wheel scrolling starts with sticky (aka snap) enabled, then detect
            // the end of a momentum scroll by storing recent (N=15?) wheel events.
            // 1. do all N events have decreasing or same (absolute value) delta?
            // 2. did all N events arrive in the last M (M=500?) msecs?
            // 3. does the earliest event have an (absolute value) delta that's
            //    at least P (P=1?) larger than the most recent event's delta?
            // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
            // If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
            // Snap immediately and ignore remaining wheel events in this scroll.
            // See comment above for "remaining wheel events in this scroll" determination.
            // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
            clearTimeout(swiper.mousewheel.timeout);
            swiper.mousewheel.timeout = undefined;
            const recentWheelEvents = swiper.mousewheel.recentWheelEvents;
            if (recentWheelEvents.length >= 15) {
              recentWheelEvents.shift(); // only store the last N events
            }
            const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
            const firstEvent = recentWheelEvents[0];
            recentWheelEvents.push(newEvent);
            if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {
              // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
              recentWheelEvents.splice(0);
            } else if (recentWheelEvents.length >= 15
                && newEvent.time - firstEvent.time < 500
                && firstEvent.delta - newEvent.delta >= 1
                && newEvent.delta <= 6
            ) {
              // We're at the end of the deceleration of a momentum scroll, so there's no need
              // to wait for more events. Snap ASAP on the next tick.
              // Also, because there's some remaining momentum we'll bias the snap in the
              // direction of the ongoing scroll because it's better UX for the scroll to snap
              // in the same direction as the scroll instead of reversing to snap.  Therefore,
              // if it's already scrolled more than 20% in the current direction, keep going.
              const snapToThreshold = delta > 0 ? 0.8 : 0.2;
              swiper.mousewheel.lastEventBeforeSnap = newEvent;
              recentWheelEvents.splice(0);
              swiper.mousewheel.timeout = Utils.nextTick(() => {
                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
              }, 0); // no delay; move on next tick
            }
            if (!swiper.mousewheel.timeout) {
              // if we get here, then we haven't detected the end of a momentum scroll, so
              // we'll consider a scroll "complete" when there haven't been any wheel events
              // for 500ms.
              swiper.mousewheel.timeout = Utils.nextTick(() => {
                const snapToThreshold = 0.5;
                swiper.mousewheel.lastEventBeforeSnap = newEvent;
                recentWheelEvents.splice(0);
                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
              }, 500);
            }
          }

          // Emit event
          if (!ignoreWheelEvents) swiper.emit('scroll', e);

          // Stop autoplay
          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop();
          // Return page scroll on edge positions
          if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;
        }
      }

      if (e.preventDefault) e.preventDefault();
      else e.returnValue = false;
      return false;
    },
    animateSlider(newEvent) {
      const swiper = this;
      // If the movement is NOT big enough and
      // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
      //   Don't go any further (avoid insignificant scroll movement).
      if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {
        // Return false as a default
        return true;
      }
      // If user is scrolling towards the end:
      //   If the slider hasn't hit the latest slide or
      //   if the slider is a loop and
      //   if the slider isn't moving right now:
      //     Go to next slide and
      //     emit a scroll event.
      // Else (the user is scrolling towards the beginning) and
      // if the slider hasn't hit the first slide or
      // if the slider is a loop and
      // if the slider isn't moving right now:
      //   Go to prev slide and
      //   emit a scroll event.
      if (newEvent.direction < 0) {
        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
          swiper.slideNext();
          swiper.emit('scroll', newEvent.raw);
        }
      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
        swiper.slidePrev();
        swiper.emit('scroll', newEvent.raw);
      }
      // If you got here is because an animation has been triggered so store the current time
      swiper.mousewheel.lastScrollTime = (new win.Date()).getTime();
      // Return false as a default
      return false;
    },
    releaseScroll(newEvent) {
      const swiper = this;
      const params = swiper.params.mousewheel;
      if (newEvent.direction < 0) {
        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }
      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }
      return false;
    },
    enable() {
      const swiper = this;
      const event = Mousewheel.event();
      if (swiper.params.cssMode) {
        swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
        return true;
      }
      if (!event) return false;
      if (swiper.mousewheel.enabled) return false;
      let target = swiper.$el;
      if (swiper.params.mousewheel.eventsTarged !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarged);
      }
      target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
      target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
      target.on(event, swiper.mousewheel.handle);
      swiper.mousewheel.enabled = true;
      return true;
    },
    disable() {
      const swiper = this;
      const event = Mousewheel.event();
      if (swiper.params.cssMode) {
        swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
        return true;
      }
      if (!event) return false;
      if (!swiper.mousewheel.enabled) return false;
      let target = swiper.$el;
      if (swiper.params.mousewheel.eventsTarged !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarged);
      }
      target.off(event, swiper.mousewheel.handle);
      swiper.mousewheel.enabled = false;
      return true;
    },
  };

  var Mousewheel$1 = {
    name: 'mousewheel',
    params: {
      mousewheel: {
        enabled: false,
        releaseOnEdges: false,
        invert: false,
        forceToAxis: false,
        sensitivity: 1,
        eventsTarged: 'container',
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        mousewheel: {
          enabled: false,
          enable: Mousewheel.enable.bind(swiper),
          disable: Mousewheel.disable.bind(swiper),
          handle: Mousewheel.handle.bind(swiper),
          handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
          handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
          animateSlider: Mousewheel.animateSlider.bind(swiper),
          releaseScroll: Mousewheel.releaseScroll.bind(swiper),
          lastScrollTime: Utils.now(),
          lastEventBeforeSnap: undefined,
          recentWheelEvents: [],
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
          swiper.mousewheel.disable();
        }
        if (swiper.params.mousewheel.enabled) swiper.mousewheel.enable();
      },
      destroy() {
        const swiper = this;
        if (swiper.params.cssMode) {
          swiper.mousewheel.enable();
        }
        if (swiper.mousewheel.enabled) swiper.mousewheel.disable();
      },
    },
  };

  const Navigation = {
    update() {
      // Update Navigation Buttons
      const swiper = this;
      const params = swiper.params.navigation;

      if (swiper.params.loop) return;
      const { $nextEl, $prevEl } = swiper.navigation;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          $prevEl.addClass(params.disabledClass);
        } else {
          $prevEl.removeClass(params.disabledClass);
        }
        $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          $nextEl.addClass(params.disabledClass);
        } else {
          $nextEl.removeClass(params.disabledClass);
        }
        $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    },
    onPrevClick(e) {
      const swiper = this;
      e.preventDefault();
      if (swiper.isBeginning && !swiper.params.loop) return;
      swiper.slidePrev();
    },
    onNextClick(e) {
      const swiper = this;
      e.preventDefault();
      if (swiper.isEnd && !swiper.params.loop) return;
      swiper.slideNext();
    },
    init() {
      const swiper = this;
      const params = swiper.params.navigation;
      if (!(params.nextEl || params.prevEl)) return;

      let $nextEl;
      let $prevEl;
      if (params.nextEl) {
        $nextEl = $(params.nextEl);
        if (
          swiper.params.uniqueNavElements
          && typeof params.nextEl === 'string'
          && $nextEl.length > 1
          && swiper.$el.find(params.nextEl).length === 1
        ) {
          $nextEl = swiper.$el.find(params.nextEl);
        }
      }
      if (params.prevEl) {
        $prevEl = $(params.prevEl);
        if (
          swiper.params.uniqueNavElements
          && typeof params.prevEl === 'string'
          && $prevEl.length > 1
          && swiper.$el.find(params.prevEl).length === 1
        ) {
          $prevEl = swiper.$el.find(params.prevEl);
        }
      }

      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on('click', swiper.navigation.onNextClick);
      }
      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on('click', swiper.navigation.onPrevClick);
      }

      Utils.extend(swiper.navigation, {
        $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl,
        prevEl: $prevEl && $prevEl[0],
      });
    },
    destroy() {
      const swiper = this;
      const { $nextEl, $prevEl } = swiper.navigation;
      if ($nextEl && $nextEl.length) {
        $nextEl.off('click', swiper.navigation.onNextClick);
        $nextEl.removeClass(swiper.params.navigation.disabledClass);
      }
      if ($prevEl && $prevEl.length) {
        $prevEl.off('click', swiper.navigation.onPrevClick);
        $prevEl.removeClass(swiper.params.navigation.disabledClass);
      }
    },
  };

  var Navigation$1 = {
    name: 'navigation',
    params: {
      navigation: {
        nextEl: null,
        prevEl: null,

        hideOnClick: false,
        disabledClass: 'swiper-button-disabled',
        hiddenClass: 'swiper-button-hidden',
        lockClass: 'swiper-button-lock',
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        navigation: {
          init: Navigation.init.bind(swiper),
          update: Navigation.update.bind(swiper),
          destroy: Navigation.destroy.bind(swiper),
          onNextClick: Navigation.onNextClick.bind(swiper),
          onPrevClick: Navigation.onPrevClick.bind(swiper),
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        swiper.navigation.init();
        swiper.navigation.update();
      },
      toEdge() {
        const swiper = this;
        swiper.navigation.update();
      },
      fromEdge() {
        const swiper = this;
        swiper.navigation.update();
      },
      destroy() {
        const swiper = this;
        swiper.navigation.destroy();
      },
      click(e) {
        const swiper = this;
        const { $nextEl, $prevEl } = swiper.navigation;
        if (
          swiper.params.navigation.hideOnClick
          && !$(e.target).is($prevEl)
          && !$(e.target).is($nextEl)
        ) {
          let isHidden;
          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }
          if (isHidden === true) {
            swiper.emit('navigationShow', swiper);
          } else {
            swiper.emit('navigationHide', swiper);
          }
          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      },
    },
  };

  const Pagination = {
    update() {
      // Render || Update Pagination bullets/items
      const swiper = this;
      const rtl = swiper.rtl;
      const params = swiper.params.pagination;
      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      const $el = swiper.pagination.$el;
      // Current/Total
      let current;
      const total = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
      if (swiper.params.loop) {
        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);
        if (current > slidesLength - 1 - (swiper.loopedSlides * 2)) {
          current -= (slidesLength - (swiper.loopedSlides * 2));
        }
        if (current > total - 1) current -= total;
        if (current < 0 && swiper.params.paginationType !== 'bullets') current = total + current;
      } else if (typeof swiper.snapIndex !== 'undefined') {
        current = swiper.snapIndex;
      } else {
        current = swiper.activeIndex || 0;
      }
      // Types
      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        const bullets = swiper.pagination.bullets;
        let firstIndex;
        let lastIndex;
        let midIndex;
        if (params.dynamicBullets) {
          swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
          $el.css(swiper.isHorizontal() ? 'width' : 'height', `${swiper.pagination.bulletSize * (params.dynamicMainBullets + 4)}px`);
          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
            swiper.pagination.dynamicBulletIndex += (current - swiper.previousIndex);
            if (swiper.pagination.dynamicBulletIndex > (params.dynamicMainBullets - 1)) {
              swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (swiper.pagination.dynamicBulletIndex < 0) {
              swiper.pagination.dynamicBulletIndex = 0;
            }
          }
          firstIndex = current - swiper.pagination.dynamicBulletIndex;
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }
        bullets.removeClass(`${params.bulletActiveClass} ${params.bulletActiveClass}-next ${params.bulletActiveClass}-next-next ${params.bulletActiveClass}-prev ${params.bulletActiveClass}-prev-prev ${params.bulletActiveClass}-main`);
        if ($el.length > 1) {
          bullets.each((index, bullet) => {
            const $bullet = $(bullet);
            const bulletIndex = $bullet.index();
            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }
            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(`${params.bulletActiveClass}-main`);
              }
              if (bulletIndex === firstIndex) {
                $bullet
                  .prev()
                  .addClass(`${params.bulletActiveClass}-prev`)
                  .prev()
                  .addClass(`${params.bulletActiveClass}-prev-prev`);
              }
              if (bulletIndex === lastIndex) {
                $bullet
                  .next()
                  .addClass(`${params.bulletActiveClass}-next`)
                  .next()
                  .addClass(`${params.bulletActiveClass}-next-next`);
              }
            }
          });
        } else {
          const $bullet = bullets.eq(current);
          const bulletIndex = $bullet.index();
          $bullet.addClass(params.bulletActiveClass);
          if (params.dynamicBullets) {
            const $firstDisplayedBullet = bullets.eq(firstIndex);
            const $lastDisplayedBullet = bullets.eq(lastIndex);
            for (let i = firstIndex; i <= lastIndex; i += 1) {
              bullets.eq(i).addClass(`${params.bulletActiveClass}-main`);
            }
            if (swiper.params.loop) {
              if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                for (let i = params.dynamicMainBullets; i >= 0; i -= 1) {
                  bullets.eq(bullets.length - i).addClass(`${params.bulletActiveClass}-main`);
                }
                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(`${params.bulletActiveClass}-prev`);
              } else {
                $firstDisplayedBullet
                  .prev()
                  .addClass(`${params.bulletActiveClass}-prev`)
                  .prev()
                  .addClass(`${params.bulletActiveClass}-prev-prev`);
                $lastDisplayedBullet
                  .next()
                  .addClass(`${params.bulletActiveClass}-next`)
                  .next()
                  .addClass(`${params.bulletActiveClass}-next-next`);
              }
            } else {
              $firstDisplayedBullet
                .prev()
                .addClass(`${params.bulletActiveClass}-prev`)
                .prev()
                .addClass(`${params.bulletActiveClass}-prev-prev`);
              $lastDisplayedBullet
                .next()
                .addClass(`${params.bulletActiveClass}-next`)
                .next()
                .addClass(`${params.bulletActiveClass}-next-next`);
            }
          }
        }
        if (params.dynamicBullets) {
          const dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          const bulletsOffset = (((swiper.pagination.bulletSize * dynamicBulletsLength) - (swiper.pagination.bulletSize)) / 2) - (midIndex * swiper.pagination.bulletSize);
          const offsetProp = rtl ? 'right' : 'left';
          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', `${bulletsOffset}px`);
        }
      }
      if (params.type === 'fraction') {
        $el.find(`.${params.currentClass}`).text(params.formatFractionCurrent(current + 1));
        $el.find(`.${params.totalClass}`).text(params.formatFractionTotal(total));
      }
      if (params.type === 'progressbar') {
        let progressbarDirection;
        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }
        const scale = (current + 1) / total;
        let scaleX = 1;
        let scaleY = 1;
        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }
        $el.find(`.${params.progressbarFillClass}`).transform(`translate3d(0,0,0) scaleX(${scaleX}) scaleY(${scaleY})`).transition(swiper.params.speed);
      }
      if (params.type === 'custom' && params.renderCustom) {
        $el.html(params.renderCustom(swiper, current + 1, total));
        swiper.emit('paginationRender', swiper, $el[0]);
      } else {
        swiper.emit('paginationUpdate', swiper, $el[0]);
      }
      $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    },
    render() {
      // Render Container
      const swiper = this;
      const params = swiper.params.pagination;
      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
      const slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;

      const $el = swiper.pagination.$el;
      let paginationHTML = '';
      if (params.type === 'bullets') {
        const numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - (swiper.loopedSlides * 2)) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;
        for (let i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
          } else {
            paginationHTML += `<${params.bulletElement} class="${params.bulletClass}"></${params.bulletElement}>`;
          }
        }
        $el.html(paginationHTML);
        swiper.pagination.bullets = $el.find(`.${params.bulletClass}`);
      }
      if (params.type === 'fraction') {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = `<span class="${params.currentClass}"></span>`
          + ' / '
          + `<span class="${params.totalClass}"></span>`;
        }
        $el.html(paginationHTML);
      }
      if (params.type === 'progressbar') {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = `<span class="${params.progressbarFillClass}"></span>`;
        }
        $el.html(paginationHTML);
      }
      if (params.type !== 'custom') {
        swiper.emit('paginationRender', swiper.pagination.$el[0]);
      }
    },
    init() {
      const swiper = this;
      const params = swiper.params.pagination;
      if (!params.el) return;

      let $el = $(params.el);
      if ($el.length === 0) return;

      if (
        swiper.params.uniqueNavElements
        && typeof params.el === 'string'
        && $el.length > 1
        && swiper.$el.find(params.el).length === 1
      ) {
        $el = swiper.$el.find(params.el);
      }

      if (params.type === 'bullets' && params.clickable) {
        $el.addClass(params.clickableClass);
      }

      $el.addClass(params.modifierClass + params.type);

      if (params.type === 'bullets' && params.dynamicBullets) {
        $el.addClass(`${params.modifierClass}${params.type}-dynamic`);
        swiper.pagination.dynamicBulletIndex = 0;
        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }
      if (params.type === 'progressbar' && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }

      if (params.clickable) {
        $el.on('click', `.${params.bulletClass}`, function onClick(e) {
          e.preventDefault();
          let index = $(this).index() * swiper.params.slidesPerGroup;
          if (swiper.params.loop) index += swiper.loopedSlides;
          swiper.slideTo(index);
        });
      }

      Utils.extend(swiper.pagination, {
        $el,
        el: $el[0],
      });
    },
    destroy() {
      const swiper = this;
      const params = swiper.params.pagination;
      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) return;
      const $el = swiper.pagination.$el;

      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);
      if (swiper.pagination.bullets) swiper.pagination.bullets.removeClass(params.bulletActiveClass);
      if (params.clickable) {
        $el.off('click', `.${params.bulletClass}`);
      }
    },
  };

  var Pagination$1 = {
    name: 'pagination',
    params: {
      pagination: {
        el: null,
        bulletElement: 'span',
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: 'bullets', // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: (number) => number,
        formatFractionTotal: (number) => number,
        bulletClass: 'swiper-pagination-bullet',
        bulletActiveClass: 'swiper-pagination-bullet-active',
        modifierClass: 'swiper-pagination-', // NEW
        currentClass: 'swiper-pagination-current',
        totalClass: 'swiper-pagination-total',
        hiddenClass: 'swiper-pagination-hidden',
        progressbarFillClass: 'swiper-pagination-progressbar-fill',
        progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
        clickableClass: 'swiper-pagination-clickable', // NEW
        lockClass: 'swiper-pagination-lock',
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        pagination: {
          init: Pagination.init.bind(swiper),
          render: Pagination.render.bind(swiper),
          update: Pagination.update.bind(swiper),
          destroy: Pagination.destroy.bind(swiper),
          dynamicBulletIndex: 0,
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        swiper.pagination.init();
        swiper.pagination.render();
        swiper.pagination.update();
      },
      activeIndexChange() {
        const swiper = this;
        if (swiper.params.loop) {
          swiper.pagination.update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          swiper.pagination.update();
        }
      },
      snapIndexChange() {
        const swiper = this;
        if (!swiper.params.loop) {
          swiper.pagination.update();
        }
      },
      slidesLengthChange() {
        const swiper = this;
        if (swiper.params.loop) {
          swiper.pagination.render();
          swiper.pagination.update();
        }
      },
      snapGridLengthChange() {
        const swiper = this;
        if (!swiper.params.loop) {
          swiper.pagination.render();
          swiper.pagination.update();
        }
      },
      destroy() {
        const swiper = this;
        swiper.pagination.destroy();
      },
      click(e) {
        const swiper = this;
        if (
          swiper.params.pagination.el
          && swiper.params.pagination.hideOnClick
          && swiper.pagination.$el.length > 0
          && !$(e.target).hasClass(swiper.params.pagination.bulletClass)
        ) {
          const isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);
          if (isHidden === true) {
            swiper.emit('paginationShow', swiper);
          } else {
            swiper.emit('paginationHide', swiper);
          }
          swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      },
    },
  };

  const Scrollbar = {
    setTranslate() {
      const swiper = this;
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      const { scrollbar, rtlTranslate: rtl, progress } = swiper;
      const {
        dragSize, trackSize, $dragEl, $el,
      } = scrollbar;
      const params = swiper.params.scrollbar;

      let newSize = dragSize;
      let newPos = (trackSize - dragSize) * progress;
      if (rtl) {
        newPos = -newPos;
        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }
      if (swiper.isHorizontal()) {
        $dragEl.transform(`translate3d(${newPos}px, 0, 0)`);
        $dragEl[0].style.width = `${newSize}px`;
      } else {
        $dragEl.transform(`translate3d(0px, ${newPos}px, 0)`);
        $dragEl[0].style.height = `${newSize}px`;
      }
      if (params.hide) {
        clearTimeout(swiper.scrollbar.timeout);
        $el[0].style.opacity = 1;
        swiper.scrollbar.timeout = setTimeout(() => {
          $el[0].style.opacity = 0;
          $el.transition(400);
        }, 1000);
      }
    },
    setTransition(duration) {
      const swiper = this;
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;
      swiper.scrollbar.$dragEl.transition(duration);
    },
    updateSize() {
      const swiper = this;
      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) return;

      const { scrollbar } = swiper;
      const { $dragEl, $el } = scrollbar;

      $dragEl[0].style.width = '';
      $dragEl[0].style.height = '';
      const trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;

      const divider = swiper.size / swiper.virtualSize;
      const moveDivider = divider * (trackSize / swiper.size);
      let dragSize;
      if (swiper.params.scrollbar.dragSize === 'auto') {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
      }

      if (swiper.isHorizontal()) {
        $dragEl[0].style.width = `${dragSize}px`;
      } else {
        $dragEl[0].style.height = `${dragSize}px`;
      }

      if (divider >= 1) {
        $el[0].style.display = 'none';
      } else {
        $el[0].style.display = '';
      }
      if (swiper.params.scrollbar.hide) {
        $el[0].style.opacity = 0;
      }
      Utils.extend(scrollbar, {
        trackSize,
        divider,
        moveDivider,
        dragSize,
      });
      scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
    },
    getPointerPosition(e) {
      const swiper = this;
      if (swiper.isHorizontal()) {
        return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientX : e.clientX);
      }
      return ((e.type === 'touchstart' || e.type === 'touchmove') ? e.targetTouches[0].clientY : e.clientY);
    },
    setDragPosition(e) {
      const swiper = this;
      const { scrollbar, rtlTranslate: rtl } = swiper;
      const {
        $el,
        dragSize,
        trackSize,
        dragStartPos,
      } = scrollbar;

      let positionRatio;
      positionRatio = ((scrollbar.getPointerPosition(e)) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top']
        - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);
      if (rtl) {
        positionRatio = 1 - positionRatio;
      }

      const position = swiper.minTranslate() + ((swiper.maxTranslate() - swiper.minTranslate()) * positionRatio);

      swiper.updateProgress(position);
      swiper.setTranslate(position);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    },
    onDragStart(e) {
      const swiper = this;
      const params = swiper.params.scrollbar;
      const { scrollbar, $wrapperEl } = swiper;
      const { $el, $dragEl } = scrollbar;
      swiper.scrollbar.isTouched = true;
      swiper.scrollbar.dragStartPos = (e.target === $dragEl[0] || e.target === $dragEl)
        ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
      e.preventDefault();
      e.stopPropagation();

      $wrapperEl.transition(100);
      $dragEl.transition(100);
      scrollbar.setDragPosition(e);

      clearTimeout(swiper.scrollbar.dragTimeout);

      $el.transition(0);
      if (params.hide) {
        $el.css('opacity', 1);
      }
      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', 'none');
      }
      swiper.emit('scrollbarDragStart', e);
    },
    onDragMove(e) {
      const swiper = this;
      const { scrollbar, $wrapperEl } = swiper;
      const { $el, $dragEl } = scrollbar;

      if (!swiper.scrollbar.isTouched) return;
      if (e.preventDefault) e.preventDefault();
      else e.returnValue = false;
      scrollbar.setDragPosition(e);
      $wrapperEl.transition(0);
      $el.transition(0);
      $dragEl.transition(0);
      swiper.emit('scrollbarDragMove', e);
    },
    onDragEnd(e) {
      const swiper = this;

      const params = swiper.params.scrollbar;
      const { scrollbar, $wrapperEl } = swiper;
      const { $el } = scrollbar;

      if (!swiper.scrollbar.isTouched) return;
      swiper.scrollbar.isTouched = false;
      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', '');
        $wrapperEl.transition('');
      }
      if (params.hide) {
        clearTimeout(swiper.scrollbar.dragTimeout);
        swiper.scrollbar.dragTimeout = Utils.nextTick(() => {
          $el.css('opacity', 0);
          $el.transition(400);
        }, 1000);
      }
      swiper.emit('scrollbarDragEnd', e);
      if (params.snapOnRelease) {
        swiper.slideToClosest();
      }
    },
    enableDraggable() {
      const swiper = this;
      if (!swiper.params.scrollbar.el) return;
      const {
        scrollbar, touchEventsTouch, touchEventsDesktop, params,
      } = swiper;
      const $el = scrollbar.$el;
      const target = $el[0];
      const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
      const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
      if (!Support.touch) {
        target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
        doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
        doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
      } else {
        target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
        target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
        target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
    },
    disableDraggable() {
      const swiper = this;
      if (!swiper.params.scrollbar.el) return;
      const {
        scrollbar, touchEventsTouch, touchEventsDesktop, params,
      } = swiper;
      const $el = scrollbar.$el;
      const target = $el[0];
      const activeListener = Support.passiveListener && params.passiveListeners ? { passive: false, capture: false } : false;
      const passiveListener = Support.passiveListener && params.passiveListeners ? { passive: true, capture: false } : false;
      if (!Support.touch) {
        target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
        doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
        doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
      } else {
        target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
        target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
        target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
    },
    init() {
      const swiper = this;
      if (!swiper.params.scrollbar.el) return;
      const { scrollbar, $el: $swiperEl } = swiper;
      const params = swiper.params.scrollbar;

      let $el = $(params.el);
      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
        $el = $swiperEl.find(params.el);
      }

      let $dragEl = $el.find(`.${swiper.params.scrollbar.dragClass}`);
      if ($dragEl.length === 0) {
        $dragEl = $(`<div class="${swiper.params.scrollbar.dragClass}"></div>`);
        $el.append($dragEl);
      }

      Utils.extend(scrollbar, {
        $el,
        el: $el[0],
        $dragEl,
        dragEl: $dragEl[0],
      });

      if (params.draggable) {
        scrollbar.enableDraggable();
      }
    },
    destroy() {
      const swiper = this;
      swiper.scrollbar.disableDraggable();
    },
  };

  var Scrollbar$1 = {
    name: 'scrollbar',
    params: {
      scrollbar: {
        el: null,
        dragSize: 'auto',
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: 'swiper-scrollbar-lock',
        dragClass: 'swiper-scrollbar-drag',
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        scrollbar: {
          init: Scrollbar.init.bind(swiper),
          destroy: Scrollbar.destroy.bind(swiper),
          updateSize: Scrollbar.updateSize.bind(swiper),
          setTranslate: Scrollbar.setTranslate.bind(swiper),
          setTransition: Scrollbar.setTransition.bind(swiper),
          enableDraggable: Scrollbar.enableDraggable.bind(swiper),
          disableDraggable: Scrollbar.disableDraggable.bind(swiper),
          setDragPosition: Scrollbar.setDragPosition.bind(swiper),
          getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
          onDragStart: Scrollbar.onDragStart.bind(swiper),
          onDragMove: Scrollbar.onDragMove.bind(swiper),
          onDragEnd: Scrollbar.onDragEnd.bind(swiper),
          isTouched: false,
          timeout: null,
          dragTimeout: null,
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        swiper.scrollbar.init();
        swiper.scrollbar.updateSize();
        swiper.scrollbar.setTranslate();
      },
      update() {
        const swiper = this;
        swiper.scrollbar.updateSize();
      },
      resize() {
        const swiper = this;
        swiper.scrollbar.updateSize();
      },
      observerUpdate() {
        const swiper = this;
        swiper.scrollbar.updateSize();
      },
      setTranslate() {
        const swiper = this;
        swiper.scrollbar.setTranslate();
      },
      setTransition(duration) {
        const swiper = this;
        swiper.scrollbar.setTransition(duration);
      },
      destroy() {
        const swiper = this;
        swiper.scrollbar.destroy();
      },
    },
  };

  const Parallax = {
    setTransform(el, progress) {
      const swiper = this;
      const { rtl } = swiper;

      const $el = $(el);
      const rtlFactor = rtl ? -1 : 1;

      const p = $el.attr('data-swiper-parallax') || '0';
      let x = $el.attr('data-swiper-parallax-x');
      let y = $el.attr('data-swiper-parallax-y');
      const scale = $el.attr('data-swiper-parallax-scale');
      const opacity = $el.attr('data-swiper-parallax-opacity');

      if (x || y) {
        x = x || '0';
        y = y || '0';
      } else if (swiper.isHorizontal()) {
        x = p;
        y = '0';
      } else {
        y = p;
        x = '0';
      }

      if ((x).indexOf('%') >= 0) {
        x = `${parseInt(x, 10) * progress * rtlFactor}%`;
      } else {
        x = `${x * progress * rtlFactor}px`;
      }
      if ((y).indexOf('%') >= 0) {
        y = `${parseInt(y, 10) * progress}%`;
      } else {
        y = `${y * progress}px`;
      }

      if (typeof opacity !== 'undefined' && opacity !== null) {
        const currentOpacity = opacity - ((opacity - 1) * (1 - Math.abs(progress)));
        $el[0].style.opacity = currentOpacity;
      }
      if (typeof scale === 'undefined' || scale === null) {
        $el.transform(`translate3d(${x}, ${y}, 0px)`);
      } else {
        const currentScale = scale - ((scale - 1) * (1 - Math.abs(progress)));
        $el.transform(`translate3d(${x}, ${y}, 0px) scale(${currentScale})`);
      }
    },
    setTranslate() {
      const swiper = this;
      const {
        $el, slides, progress, snapGrid,
      } = swiper;
      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
        .each((index, el) => {
          swiper.parallax.setTransform(el, progress);
        });
      slides.each((slideIndex, slideEl) => {
        let slideProgress = slideEl.progress;
        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
          slideProgress += Math.ceil(slideIndex / 2) - (progress * (snapGrid.length - 1));
        }
        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
          .each((index, el) => {
            swiper.parallax.setTransform(el, slideProgress);
          });
      });
    },
    setTransition(duration = this.params.speed) {
      const swiper = this;
      const { $el } = swiper;
      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]')
        .each((index, parallaxEl) => {
          const $parallaxEl = $(parallaxEl);
          let parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;
          if (duration === 0) parallaxDuration = 0;
          $parallaxEl.transition(parallaxDuration);
        });
    },
  };

  var Parallax$1 = {
    name: 'parallax',
    params: {
      parallax: {
        enabled: false,
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        parallax: {
          setTransform: Parallax.setTransform.bind(swiper),
          setTranslate: Parallax.setTranslate.bind(swiper),
          setTransition: Parallax.setTransition.bind(swiper),
        },
      });
    },
    on: {
      beforeInit() {
        const swiper = this;
        if (!swiper.params.parallax.enabled) return;
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      },
      init() {
        const swiper = this;
        if (!swiper.params.parallax.enabled) return;
        swiper.parallax.setTranslate();
      },
      setTranslate() {
        const swiper = this;
        if (!swiper.params.parallax.enabled) return;
        swiper.parallax.setTranslate();
      },
      setTransition(duration) {
        const swiper = this;
        if (!swiper.params.parallax.enabled) return;
        swiper.parallax.setTransition(duration);
      },
    },
  };

  const Zoom = {
    // Calc Scale From Multi-touches
    getDistanceBetweenTouches(e) {
      if (e.targetTouches.length < 2) return 1;
      const x1 = e.targetTouches[0].pageX;
      const y1 = e.targetTouches[0].pageY;
      const x2 = e.targetTouches[1].pageX;
      const y2 = e.targetTouches[1].pageY;
      const distance = Math.sqrt(((x2 - x1) ** 2) + ((y2 - y1) ** 2));
      return distance;
    },
    // Events
    onGestureStart(e) {
      const swiper = this;
      const params = swiper.params.zoom;
      const zoom = swiper.zoom;
      const { gesture } = zoom;
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;
      if (!Support.gestures) {
        if (e.type !== 'touchstart' || (e.type === 'touchstart' && e.targetTouches.length < 2)) {
          return;
        }
        zoom.fakeGestureTouched = true;
        gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
      }
      if (!gesture.$slideEl || !gesture.$slideEl.length) {
        gesture.$slideEl = $(e.target).closest(`.${swiper.params.slideClass}`);
        if (gesture.$slideEl.length === 0) gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
        if (gesture.$imageWrapEl.length === 0) {
          gesture.$imageEl = undefined;
          return;
        }
      }
      if (gesture.$imageEl) {
        gesture.$imageEl.transition(0);
      }
      swiper.zoom.isScaling = true;
    },
    onGestureChange(e) {
      const swiper = this;
      const params = swiper.params.zoom;
      const zoom = swiper.zoom;
      const { gesture } = zoom;
      if (!Support.gestures) {
        if (e.type !== 'touchmove' || (e.type === 'touchmove' && e.targetTouches.length < 2)) {
          return;
        }
        zoom.fakeGestureMoved = true;
        gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
      }
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      if (Support.gestures) {
        zoom.scale = e.scale * zoom.currentScale;
      } else {
        zoom.scale = (gesture.scaleMove / gesture.scaleStart) * zoom.currentScale;
      }
      if (zoom.scale > gesture.maxRatio) {
        zoom.scale = (gesture.maxRatio - 1) + (((zoom.scale - gesture.maxRatio) + 1) ** 0.5);
      }
      if (zoom.scale < params.minRatio) {
        zoom.scale = (params.minRatio + 1) - (((params.minRatio - zoom.scale) + 1) ** 0.5);
      }
      gesture.$imageEl.transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    },
    onGestureEnd(e) {
      const swiper = this;
      const params = swiper.params.zoom;
      const zoom = swiper.zoom;
      const { gesture } = zoom;
      if (!Support.gestures) {
        if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
          return;
        }
        if (e.type !== 'touchend' || (e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android)) {
          return;
        }
        zoom.fakeGestureTouched = false;
        zoom.fakeGestureMoved = false;
      }
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
      gesture.$imageEl.transition(swiper.params.speed).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
      zoom.currentScale = zoom.scale;
      zoom.isScaling = false;
      if (zoom.scale === 1) gesture.$slideEl = undefined;
    },
    onTouchStart(e) {
      const swiper = this;
      const zoom = swiper.zoom;
      const { gesture, image } = zoom;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      if (image.isTouched) return;
      if (Device.android) e.preventDefault();
      image.isTouched = true;
      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    },
    onTouchMove(e) {
      const swiper = this;
      const zoom = swiper.zoom;
      const { gesture, image, velocity } = zoom;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      swiper.allowClick = false;
      if (!image.isTouched || !gesture.$slideEl) return;

      if (!image.isMoved) {
        image.width = gesture.$imageEl[0].offsetWidth;
        image.height = gesture.$imageEl[0].offsetHeight;
        image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
        image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
        gesture.$imageWrapEl.transition(0);
        if (swiper.rtl) {
          image.startX = -image.startX;
          image.startY = -image.startY;
        }
      }
      // Define if we need image drag
      const scaledWidth = image.width * zoom.scale;
      const scaledHeight = image.height * zoom.scale;

      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) return;

      image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
      image.maxX = -image.minX;
      image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
      image.maxY = -image.minY;

      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (!image.isMoved && !zoom.isScaling) {
        if (
          swiper.isHorizontal()
          && (
            (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x)
            || (Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)
          )
        ) {
          image.isTouched = false;
          return;
        } if (
          !swiper.isHorizontal()
          && (
            (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y)
            || (Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)
          )
        ) {
          image.isTouched = false;
          return;
        }
      }
      e.preventDefault();
      e.stopPropagation();

      image.isMoved = true;
      image.currentX = (image.touchesCurrent.x - image.touchesStart.x) + image.startX;
      image.currentY = (image.touchesCurrent.y - image.touchesStart.y) + image.startY;

      if (image.currentX < image.minX) {
        image.currentX = (image.minX + 1) - (((image.minX - image.currentX) + 1) ** 0.8);
      }
      if (image.currentX > image.maxX) {
        image.currentX = (image.maxX - 1) + (((image.currentX - image.maxX) + 1) ** 0.8);
      }

      if (image.currentY < image.minY) {
        image.currentY = (image.minY + 1) - (((image.minY - image.currentY) + 1) ** 0.8);
      }
      if (image.currentY > image.maxY) {
        image.currentY = (image.maxY - 1) + (((image.currentY - image.maxY) + 1) ** 0.8);
      }

      // Velocity
      if (!velocity.prevPositionX) velocity.prevPositionX = image.touchesCurrent.x;
      if (!velocity.prevPositionY) velocity.prevPositionY = image.touchesCurrent.y;
      if (!velocity.prevTime) velocity.prevTime = Date.now();
      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;
      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) velocity.x = 0;
      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) velocity.y = 0;
      velocity.prevPositionX = image.touchesCurrent.x;
      velocity.prevPositionY = image.touchesCurrent.y;
      velocity.prevTime = Date.now();

      gesture.$imageWrapEl.transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
    },
    onTouchEnd() {
      const swiper = this;
      const zoom = swiper.zoom;
      const { gesture, image, velocity } = zoom;
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;
      if (!image.isTouched || !image.isMoved) {
        image.isTouched = false;
        image.isMoved = false;
        return;
      }
      image.isTouched = false;
      image.isMoved = false;
      let momentumDurationX = 300;
      let momentumDurationY = 300;
      const momentumDistanceX = velocity.x * momentumDurationX;
      const newPositionX = image.currentX + momentumDistanceX;
      const momentumDistanceY = velocity.y * momentumDurationY;
      const newPositionY = image.currentY + momentumDistanceY;

      // Fix duration
      if (velocity.x !== 0) momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
      if (velocity.y !== 0) momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
      const momentumDuration = Math.max(momentumDurationX, momentumDurationY);

      image.currentX = newPositionX;
      image.currentY = newPositionY;

      // Define if we need image drag
      const scaledWidth = image.width * zoom.scale;
      const scaledHeight = image.height * zoom.scale;
      image.minX = Math.min(((gesture.slideWidth / 2) - (scaledWidth / 2)), 0);
      image.maxX = -image.minX;
      image.minY = Math.min(((gesture.slideHeight / 2) - (scaledHeight / 2)), 0);
      image.maxY = -image.minY;
      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);

      gesture.$imageWrapEl.transition(momentumDuration).transform(`translate3d(${image.currentX}px, ${image.currentY}px,0)`);
    },
    onTransitionEnd() {
      const swiper = this;
      const zoom = swiper.zoom;
      const { gesture } = zoom;
      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
        if (gesture.$imageEl) {
          gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
        }
        if (gesture.$imageWrapEl) {
          gesture.$imageWrapEl.transform('translate3d(0,0,0)');
        }

        zoom.scale = 1;
        zoom.currentScale = 1;

        gesture.$slideEl = undefined;
        gesture.$imageEl = undefined;
        gesture.$imageWrapEl = undefined;
      }
    },
    // Toggle Zoom
    toggle(e) {
      const swiper = this;
      const zoom = swiper.zoom;

      if (zoom.scale && zoom.scale !== 1) {
        // Zoom Out
        zoom.out();
      } else {
        // Zoom In
        zoom.in(e);
      }
    },
    in(e) {
      const swiper = this;

      const zoom = swiper.zoom;
      const params = swiper.params.zoom;
      const { gesture, image } = zoom;

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }
        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      }
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

      gesture.$slideEl.addClass(`${params.zoomedSlideClass}`);

      let touchX;
      let touchY;
      let offsetX;
      let offsetY;
      let diffX;
      let diffY;
      let translateX;
      let translateY;
      let imageWidth;
      let imageHeight;
      let scaledWidth;
      let scaledHeight;
      let translateMinX;
      let translateMinY;
      let translateMaxX;
      let translateMaxY;
      let slideWidth;
      let slideHeight;

      if (typeof image.touchesStart.x === 'undefined' && e) {
        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
      } else {
        touchX = image.touchesStart.x;
        touchY = image.touchesStart.y;
      }

      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      if (e) {
        slideWidth = gesture.$slideEl[0].offsetWidth;
        slideHeight = gesture.$slideEl[0].offsetHeight;
        offsetX = gesture.$slideEl.offset().left;
        offsetY = gesture.$slideEl.offset().top;
        diffX = (offsetX + (slideWidth / 2)) - touchX;
        diffY = (offsetY + (slideHeight / 2)) - touchY;

        imageWidth = gesture.$imageEl[0].offsetWidth;
        imageHeight = gesture.$imageEl[0].offsetHeight;
        scaledWidth = imageWidth * zoom.scale;
        scaledHeight = imageHeight * zoom.scale;

        translateMinX = Math.min(((slideWidth / 2) - (scaledWidth / 2)), 0);
        translateMinY = Math.min(((slideHeight / 2) - (scaledHeight / 2)), 0);
        translateMaxX = -translateMinX;
        translateMaxY = -translateMinY;

        translateX = diffX * zoom.scale;
        translateY = diffY * zoom.scale;

        if (translateX < translateMinX) {
          translateX = translateMinX;
        }
        if (translateX > translateMaxX) {
          translateX = translateMaxX;
        }

        if (translateY < translateMinY) {
          translateY = translateMinY;
        }
        if (translateY > translateMaxY) {
          translateY = translateMaxY;
        }
      } else {
        translateX = 0;
        translateY = 0;
      }
      gesture.$imageWrapEl.transition(300).transform(`translate3d(${translateX}px, ${translateY}px,0)`);
      gesture.$imageEl.transition(300).transform(`translate3d(0,0,0) scale(${zoom.scale})`);
    },
    out() {
      const swiper = this;

      const zoom = swiper.zoom;
      const params = swiper.params.zoom;
      const { gesture } = zoom;

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children(`.${swiper.params.slideActiveClass}`);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }
        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent(`.${params.containerClass}`);
      }
      if (!gesture.$imageEl || gesture.$imageEl.length === 0) return;

      zoom.scale = 1;
      zoom.currentScale = 1;
      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
      gesture.$slideEl.removeClass(`${params.zoomedSlideClass}`);
      gesture.$slideEl = undefined;
    },
    // Attach/Detach Events
    enable() {
      const swiper = this;
      const zoom = swiper.zoom;
      if (zoom.enabled) return;
      zoom.enabled = true;

      const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
      const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

      const slideSelector = `.${swiper.params.slideClass}`;

      // Scale image
      if (Support.gestures) {
        swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
        swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
        swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
        if (swiper.touchEvents.cancel) {
          swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
        }
      }

      // Move image
      swiper.$wrapperEl.on(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
    },
    disable() {
      const swiper = this;
      const zoom = swiper.zoom;
      if (!zoom.enabled) return;

      swiper.zoom.enabled = false;

      const passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? { passive: true, capture: false } : false;
      const activeListenerWithCapture = Support.passiveListener ? { passive: false, capture: true } : true;

      const slideSelector = `.${swiper.params.slideClass}`;

      // Scale image
      if (Support.gestures) {
        swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
        swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
        swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);
        if (swiper.touchEvents.cancel) {
          swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
        }
      }

      // Move image
      swiper.$wrapperEl.off(swiper.touchEvents.move, `.${swiper.params.zoom.containerClass}`, zoom.onTouchMove, activeListenerWithCapture);
    },
  };

  var Zoom$1 = {
    name: 'zoom',
    params: {
      zoom: {
        enabled: false,
        maxRatio: 3,
        minRatio: 1,
        toggle: true,
        containerClass: 'swiper-zoom-container',
        zoomedSlideClass: 'swiper-slide-zoomed',
      },
    },
    create() {
      const swiper = this;
      const zoom = {
        enabled: false,
        scale: 1,
        currentScale: 1,
        isScaling: false,
        gesture: {
          $slideEl: undefined,
          slideWidth: undefined,
          slideHeight: undefined,
          $imageEl: undefined,
          $imageWrapEl: undefined,
          maxRatio: 3,
        },
        image: {
          isTouched: undefined,
          isMoved: undefined,
          currentX: undefined,
          currentY: undefined,
          minX: undefined,
          minY: undefined,
          maxX: undefined,
          maxY: undefined,
          width: undefined,
          height: undefined,
          startX: undefined,
          startY: undefined,
          touchesStart: {},
          touchesCurrent: {},
        },
        velocity: {
          x: undefined,
          y: undefined,
          prevPositionX: undefined,
          prevPositionY: undefined,
          prevTime: undefined,
        },
      };

      ('onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out').split(' ').forEach((methodName) => {
        zoom[methodName] = Zoom[methodName].bind(swiper);
      });
      Utils.extend(swiper, {
        zoom,
      });

      let scale = 1;
      Object.defineProperty(swiper.zoom, 'scale', {
        get() {
          return scale;
        },
        set(value) {
          if (scale !== value) {
            const imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
            const slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
            swiper.emit('zoomChange', value, imageEl, slideEl);
          }
          scale = value;
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        if (swiper.params.zoom.enabled) {
          swiper.zoom.enable();
        }
      },
      destroy() {
        const swiper = this;
        swiper.zoom.disable();
      },
      touchStart(e) {
        const swiper = this;
        if (!swiper.zoom.enabled) return;
        swiper.zoom.onTouchStart(e);
      },
      touchEnd(e) {
        const swiper = this;
        if (!swiper.zoom.enabled) return;
        swiper.zoom.onTouchEnd(e);
      },
      doubleTap(e) {
        const swiper = this;
        if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
          swiper.zoom.toggle(e);
        }
      },
      transitionEnd() {
        const swiper = this;
        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
          swiper.zoom.onTransitionEnd();
        }
      },
      slideChange() {
        const swiper = this;
        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
          swiper.zoom.onTransitionEnd();
        }
      },
    },
  };

  const Lazy$2 = {
    loadInSlide(index, loadInDuplicate = true) {
      const swiper = this;
      const params = swiper.params.lazy;
      if (typeof index === 'undefined') return;
      if (swiper.slides.length === 0) return;
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;

      const $slideEl = isVirtual
        ? swiper.$wrapperEl.children(`.${swiper.params.slideClass}[data-swiper-slide-index="${index}"]`)
        : swiper.slides.eq(index);

      let $images = $slideEl.find(`.${params.elementClass}:not(.${params.loadedClass}):not(.${params.loadingClass})`);
      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
        $images = $images.add($slideEl[0]);
      }
      if ($images.length === 0) return;

      $images.each((imageIndex, imageEl) => {
        const $imageEl = $(imageEl);
        $imageEl.addClass(params.loadingClass);

        const background = $imageEl.attr('data-background');
        const src = $imageEl.attr('data-src');
        const srcset = $imageEl.attr('data-srcset');
        const sizes = $imageEl.attr('data-sizes');

        swiper.loadImage($imageEl[0], (src || background), srcset, sizes, false, () => {
          if (typeof swiper === 'undefined' || swiper === null || !swiper || (swiper && !swiper.params) || swiper.destroyed) return;
          if (background) {
            $imageEl.css('background-image', `url("${background}")`);
            $imageEl.removeAttr('data-background');
          } else {
            if (srcset) {
              $imageEl.attr('srcset', srcset);
              $imageEl.removeAttr('data-srcset');
            }
            if (sizes) {
              $imageEl.attr('sizes', sizes);
              $imageEl.removeAttr('data-sizes');
            }
            if (src) {
              $imageEl.attr('src', src);
              $imageEl.removeAttr('data-src');
            }
          }

          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
          $slideEl.find(`.${params.preloaderClass}`).remove();
          if (swiper.params.loop && loadInDuplicate) {
            const slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');
            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
              const originalSlide = swiper.$wrapperEl.children(`[data-swiper-slide-index="${slideOriginalIndex}"]:not(.${swiper.params.slideDuplicateClass})`);
              swiper.lazy.loadInSlide(originalSlide.index(), false);
            } else {
              const duplicatedSlide = swiper.$wrapperEl.children(`.${swiper.params.slideDuplicateClass}[data-swiper-slide-index="${slideOriginalIndex}"]`);
              swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
            }
          }
          swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);
          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        });

        swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
      });
    },
    load() {
      const swiper = this;
      const {
        $wrapperEl, params: swiperParams, slides, activeIndex,
      } = swiper;
      const isVirtual = swiper.virtual && swiperParams.virtual.enabled;
      const params = swiperParams.lazy;

      let slidesPerView = swiperParams.slidesPerView;
      if (slidesPerView === 'auto') {
        slidesPerView = 0;
      }

      function slideExist(index) {
        if (isVirtual) {
          if ($wrapperEl.children(`.${swiperParams.slideClass}[data-swiper-slide-index="${index}"]`).length) {
            return true;
          }
        } else if (slides[index]) return true;
        return false;
      }
      function slideIndex(slideEl) {
        if (isVirtual) {
          return $(slideEl).attr('data-swiper-slide-index');
        }
        return $(slideEl).index();
      }

      if (!swiper.lazy.initialImageLoaded) swiper.lazy.initialImageLoaded = true;
      if (swiper.params.watchSlidesVisibility) {
        $wrapperEl.children(`.${swiperParams.slideVisibleClass}`).each((elIndex, slideEl) => {
          const index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
          swiper.lazy.loadInSlide(index);
        });
      } else if (slidesPerView > 1) {
        for (let i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
          if (slideExist(i)) swiper.lazy.loadInSlide(i);
        }
      } else {
        swiper.lazy.loadInSlide(activeIndex);
      }
      if (params.loadPrevNext) {
        if (slidesPerView > 1 || (params.loadPrevNextAmount && params.loadPrevNextAmount > 1)) {
          const amount = params.loadPrevNextAmount;
          const spv = slidesPerView;
          const maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
          const minIndex = Math.max(activeIndex - Math.max(spv, amount), 0);
          // Next Slides
          for (let i = activeIndex + slidesPerView; i < maxIndex; i += 1) {
            if (slideExist(i)) swiper.lazy.loadInSlide(i);
          }
          // Prev Slides
          for (let i = minIndex; i < activeIndex; i += 1) {
            if (slideExist(i)) swiper.lazy.loadInSlide(i);
          }
        } else {
          const nextSlide = $wrapperEl.children(`.${swiperParams.slideNextClass}`);
          if (nextSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(nextSlide));

          const prevSlide = $wrapperEl.children(`.${swiperParams.slidePrevClass}`);
          if (prevSlide.length > 0) swiper.lazy.loadInSlide(slideIndex(prevSlide));
        }
      }
    },
  };

  var Lazy$3 = {
    name: 'lazy',
    params: {
      lazy: {
        enabled: false,
        loadPrevNext: false,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: false,

        elementClass: 'swiper-lazy',
        loadingClass: 'swiper-lazy-loading',
        loadedClass: 'swiper-lazy-loaded',
        preloaderClass: 'swiper-lazy-preloader',
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        lazy: {
          initialImageLoaded: false,
          load: Lazy$2.load.bind(swiper),
          loadInSlide: Lazy$2.loadInSlide.bind(swiper),
        },
      });
    },
    on: {
      beforeInit() {
        const swiper = this;
        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
          swiper.params.preloadImages = false;
        }
      },
      init() {
        const swiper = this;
        if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
          swiper.lazy.load();
        }
      },
      scroll() {
        const swiper = this;
        if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
          swiper.lazy.load();
        }
      },
      resize() {
        const swiper = this;
        if (swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      },
      scrollbarDragMove() {
        const swiper = this;
        if (swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      },
      transitionStart() {
        const swiper = this;
        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.loadOnTransitionStart || (!swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded)) {
            swiper.lazy.load();
          }
        }
      },
      transitionEnd() {
        const swiper = this;
        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
          swiper.lazy.load();
        }
      },
      slideChange() {
        const swiper = this;
        if (swiper.params.lazy.enabled && swiper.params.cssMode) {
          swiper.lazy.load();
        }
      },
    },
  };

  /* eslint no-bitwise: ["error", { "allow": [">>"] }] */

  const Controller = {
    LinearSpline: function LinearSpline(x, y) {
      const binarySearch = (function search() {
        let maxIndex;
        let minIndex;
        let guess;
        return (array, val) => {
          minIndex = -1;
          maxIndex = array.length;
          while (maxIndex - minIndex > 1) {
            guess = maxIndex + minIndex >> 1;
            if (array[guess] <= val) {
              minIndex = guess;
            } else {
              maxIndex = guess;
            }
          }
          return maxIndex;
        };
      }());
      this.x = x;
      this.y = y;
      this.lastIndex = x.length - 1;
      // Given an x value (x2), return the expected y2 value:
      // (x1,y1) is the known point before given value,
      // (x3,y3) is the known point after given value.
      let i1;
      let i3;

      this.interpolate = function interpolate(x2) {
        if (!x2) return 0;

        // Get the indexes of x1 and x3 (the array indexes before and after given x2):
        i3 = binarySearch(this.x, x2);
        i1 = i3 - 1;

        // We have our indexes i1 & i3, so we can calculate already:
        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1
        return (((x2 - this.x[i1]) * (this.y[i3] - this.y[i1])) / (this.x[i3] - this.x[i1])) + this.y[i1];
      };
      return this;
    },
    // xxx: for now i will just save one spline function to to
    getInterpolateFunction(c) {
      const swiper = this;
      if (!swiper.controller.spline) {
        swiper.controller.spline = swiper.params.loop
          ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid)
          : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
      }
    },
    setTranslate(setTranslate, byController) {
      const swiper = this;
      const controlled = swiper.controller.control;
      let multiplier;
      let controlledTranslate;
      function setControlledTranslate(c) {
        // this will create an Interpolate function based on the snapGrids
        // x is the Grid of the scrolled scroller and y will be the controlled scroller
        // it makes sense to create this only once and recall it for the interpolation
        // the function does a lot of value caching for performance
        const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;
        if (swiper.params.controller.by === 'slide') {
          swiper.controller.getInterpolateFunction(c);
          // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
          // but it did not work out
          controlledTranslate = -swiper.controller.spline.interpolate(-translate);
        }

        if (!controlledTranslate || swiper.params.controller.by === 'container') {
          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
          controlledTranslate = ((translate - swiper.minTranslate()) * multiplier) + c.minTranslate();
        }

        if (swiper.params.controller.inverse) {
          controlledTranslate = c.maxTranslate() - controlledTranslate;
        }
        c.updateProgress(controlledTranslate);
        c.setTranslate(controlledTranslate, swiper);
        c.updateActiveIndex();
        c.updateSlidesClasses();
      }
      if (Array.isArray(controlled)) {
        for (let i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTranslate(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTranslate(controlled);
      }
    },
    setTransition(duration, byController) {
      const swiper = this;
      const controlled = swiper.controller.control;
      let i;
      function setControlledTransition(c) {
        c.setTransition(duration, swiper);
        if (duration !== 0) {
          c.transitionStart();
          if (c.params.autoHeight) {
            Utils.nextTick(() => {
              c.updateAutoHeight();
            });
          }
          c.$wrapperEl.transitionEnd(() => {
            if (!controlled) return;
            if (c.params.loop && swiper.params.controller.by === 'slide') {
              c.loopFix();
            }
            c.transitionEnd();
          });
        }
      }
      if (Array.isArray(controlled)) {
        for (i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTransition(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTransition(controlled);
      }
    },
  };
  var Controller$1 = {
    name: 'controller',
    params: {
      controller: {
        control: undefined,
        inverse: false,
        by: 'slide', // or 'container'
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        controller: {
          control: swiper.params.controller.control,
          getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
          setTranslate: Controller.setTranslate.bind(swiper),
          setTransition: Controller.setTransition.bind(swiper),
        },
      });
    },
    on: {
      update() {
        const swiper = this;
        if (!swiper.controller.control) return;
        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      resize() {
        const swiper = this;
        if (!swiper.controller.control) return;
        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      observerUpdate() {
        const swiper = this;
        if (!swiper.controller.control) return;
        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      setTranslate(translate, byController) {
        const swiper = this;
        if (!swiper.controller.control) return;
        swiper.controller.setTranslate(translate, byController);
      },
      setTransition(duration, byController) {
        const swiper = this;
        if (!swiper.controller.control) return;
        swiper.controller.setTransition(duration, byController);
      },
    },
  };

  const a11y = {
    makeElFocusable($el) {
      $el.attr('tabIndex', '0');
      return $el;
    },
    addElRole($el, role) {
      $el.attr('role', role);
      return $el;
    },
    addElLabel($el, label) {
      $el.attr('aria-label', label);
      return $el;
    },
    disableEl($el) {
      $el.attr('aria-disabled', true);
      return $el;
    },
    enableEl($el) {
      $el.attr('aria-disabled', false);
      return $el;
    },
    onEnterKey(e) {
      const swiper = this;
      const params = swiper.params.a11y;
      if (e.keyCode !== 13) return;
      const $targetEl = $(e.target);
      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }
        if (swiper.isEnd) {
          swiper.a11y.notify(params.lastSlideMessage);
        } else {
          swiper.a11y.notify(params.nextSlideMessage);
        }
      }
      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }
        if (swiper.isBeginning) {
          swiper.a11y.notify(params.firstSlideMessage);
        } else {
          swiper.a11y.notify(params.prevSlideMessage);
        }
      }
      if (swiper.pagination && $targetEl.is(`.${swiper.params.pagination.bulletClass}`)) {
        $targetEl[0].click();
      }
    },
    notify(message) {
      const swiper = this;
      const notification = swiper.a11y.liveRegion;
      if (notification.length === 0) return;
      notification.html('');
      notification.html(message);
    },
    updateNavigation() {
      const swiper = this;

      if (swiper.params.loop || !swiper.navigation) return;
      const { $nextEl, $prevEl } = swiper.navigation;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          swiper.a11y.disableEl($prevEl);
        } else {
          swiper.a11y.enableEl($prevEl);
        }
      }
      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          swiper.a11y.disableEl($nextEl);
        } else {
          swiper.a11y.enableEl($nextEl);
        }
      }
    },
    updatePagination() {
      const swiper = this;
      const params = swiper.params.a11y;
      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.bullets.each((bulletIndex, bulletEl) => {
          const $bulletEl = $(bulletEl);
          swiper.a11y.makeElFocusable($bulletEl);
          swiper.a11y.addElRole($bulletEl, 'button');
          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/\{\{index\}\}/, $bulletEl.index() + 1));
        });
      }
    },
    init() {
      const swiper = this;

      swiper.$el.append(swiper.a11y.liveRegion);

      // Navigation
      const params = swiper.params.a11y;
      let $nextEl;
      let $prevEl;
      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }
      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }
      if ($nextEl) {
        swiper.a11y.makeElFocusable($nextEl);
        swiper.a11y.addElRole($nextEl, 'button');
        swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
        $nextEl.on('keydown', swiper.a11y.onEnterKey);
      }
      if ($prevEl) {
        swiper.a11y.makeElFocusable($prevEl);
        swiper.a11y.addElRole($prevEl, 'button');
        swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
        $prevEl.on('keydown', swiper.a11y.onEnterKey);
      }

      // Pagination
      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.$el.on('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
      }
    },
    destroy() {
      const swiper = this;
      if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) swiper.a11y.liveRegion.remove();

      let $nextEl;
      let $prevEl;
      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }
      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }
      if ($nextEl) {
        $nextEl.off('keydown', swiper.a11y.onEnterKey);
      }
      if ($prevEl) {
        $prevEl.off('keydown', swiper.a11y.onEnterKey);
      }

      // Pagination
      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.$el.off('keydown', `.${swiper.params.pagination.bulletClass}`, swiper.a11y.onEnterKey);
      }
    },
  };
  var A11y = {
    name: 'a11y',
    params: {
      a11y: {
        enabled: true,
        notificationClass: 'swiper-notification',
        prevSlideMessage: 'Previous slide',
        nextSlideMessage: 'Next slide',
        firstSlideMessage: 'This is the first slide',
        lastSlideMessage: 'This is the last slide',
        paginationBulletMessage: 'Go to slide {{index}}',
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        a11y: {
          liveRegion: $(`<span class="${swiper.params.a11y.notificationClass}" aria-live="assertive" aria-atomic="true"></span>`),
        },
      });
      Object.keys(a11y).forEach((methodName) => {
        swiper.a11y[methodName] = a11y[methodName].bind(swiper);
      });
    },
    on: {
      init() {
        const swiper = this;
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.init();
        swiper.a11y.updateNavigation();
      },
      toEdge() {
        const swiper = this;
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.updateNavigation();
      },
      fromEdge() {
        const swiper = this;
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.updateNavigation();
      },
      paginationUpdate() {
        const swiper = this;
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.updatePagination();
      },
      destroy() {
        const swiper = this;
        if (!swiper.params.a11y.enabled) return;
        swiper.a11y.destroy();
      },
    },
  };

  /* eslint no-underscore-dangle: "off" */

  const Autoplay = {
    run() {
      const swiper = this;
      const $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
      let delay = swiper.params.autoplay.delay;
      if ($activeSlideEl.attr('data-swiper-autoplay')) {
        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
      }
      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = Utils.nextTick(() => {
        if (swiper.params.autoplay.reverseDirection) {
          if (swiper.params.loop) {
            swiper.loopFix();
            swiper.slidePrev(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.isBeginning) {
            swiper.slidePrev(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else {
            swiper.autoplay.stop();
          }
        } else if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slideNext(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isEnd) {
          swiper.slideNext(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }
        if (swiper.params.cssMode && swiper.autoplay.running) swiper.autoplay.run();
      }, delay);
    },
    start() {
      const swiper = this;
      if (typeof swiper.autoplay.timeout !== 'undefined') return false;
      if (swiper.autoplay.running) return false;
      swiper.autoplay.running = true;
      swiper.emit('autoplayStart');
      swiper.autoplay.run();
      return true;
    },
    stop() {
      const swiper = this;
      if (!swiper.autoplay.running) return false;
      if (typeof swiper.autoplay.timeout === 'undefined') return false;

      if (swiper.autoplay.timeout) {
        clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.timeout = undefined;
      }
      swiper.autoplay.running = false;
      swiper.emit('autoplayStop');
      return true;
    },
    pause(speed) {
      const swiper = this;
      if (!swiper.autoplay.running) return;
      if (swiper.autoplay.paused) return;
      if (swiper.autoplay.timeout) clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.paused = true;
      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
        swiper.autoplay.paused = false;
        swiper.autoplay.run();
      } else {
        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
      }
    },
  };

  var Autoplay$1 = {
    name: 'autoplay',
    params: {
      autoplay: {
        enabled: false,
        delay: 3000,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false,
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        autoplay: {
          running: false,
          paused: false,
          run: Autoplay.run.bind(swiper),
          start: Autoplay.start.bind(swiper),
          stop: Autoplay.stop.bind(swiper),
          pause: Autoplay.pause.bind(swiper),
          onVisibilityChange() {
            if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
              swiper.autoplay.pause();
            }
            if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
              swiper.autoplay.run();
              swiper.autoplay.paused = false;
            }
          },
          onTransitionEnd(e) {
            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) return;
            if (e.target !== this) return;
            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
            swiper.autoplay.paused = false;
            if (!swiper.autoplay.running) {
              swiper.autoplay.stop();
            } else {
              swiper.autoplay.run();
            }
          },
        },
      });
    },
    on: {
      init() {
        const swiper = this;
        if (swiper.params.autoplay.enabled) {
          swiper.autoplay.start();
          document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
        }
      },
      beforeTransitionStart(speed, internal) {
        const swiper = this;
        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            swiper.autoplay.stop();
          }
        }
      },
      sliderFirstMove() {
        const swiper = this;
        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.pause();
          }
        }
      },
      touchEnd() {
        const swiper = this;
        if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.run();
        }
      },
      destroy() {
        const swiper = this;
        if (swiper.autoplay.running) {
          swiper.autoplay.stop();
        }
        document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
      },
    },
  };

  const Fade = {
    setTranslate() {
      const swiper = this;
      const { slides } = swiper;
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = swiper.slides.eq(i);
        const offset = $slideEl[0].swiperSlideOffset;
        let tx = -offset;
        if (!swiper.params.virtualTranslate) tx -= swiper.translate;
        let ty = 0;
        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
        }
        const slideOpacity = swiper.params.fadeEffect.crossFade
          ? Math.max(1 - Math.abs($slideEl[0].progress), 0)
          : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
        $slideEl
          .css({
            opacity: slideOpacity,
          })
          .transform(`translate3d(${tx}px, ${ty}px, 0px)`);
      }
    },
    setTransition(duration) {
      const swiper = this;
      const { slides, $wrapperEl } = swiper;
      slides.transition(duration);
      if (swiper.params.virtualTranslate && duration !== 0) {
        let eventTriggered = false;
        slides.transitionEnd(() => {
          if (eventTriggered) return;
          if (!swiper || swiper.destroyed) return;
          eventTriggered = true;
          swiper.animating = false;
          const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
          for (let i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    },
  };

  var EffectFade = {
    name: 'effect-fade',
    params: {
      fadeEffect: {
        crossFade: false,
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        fadeEffect: {
          setTranslate: Fade.setTranslate.bind(swiper),
          setTransition: Fade.setTransition.bind(swiper),
        },
      });
    },
    on: {
      beforeInit() {
        const swiper = this;
        if (swiper.params.effect !== 'fade') return;
        swiper.classNames.push(`${swiper.params.containerModifierClass}fade`);
        const overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: true,
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate() {
        const swiper = this;
        if (swiper.params.effect !== 'fade') return;
        swiper.fadeEffect.setTranslate();
      },
      setTransition(duration) {
        const swiper = this;
        if (swiper.params.effect !== 'fade') return;
        swiper.fadeEffect.setTransition(duration);
      },
    },
  };

  const Cube = {
    setTranslate() {
      const swiper = this;
      const {
        $el, $wrapperEl, slides, width: swiperWidth, height: swiperHeight, rtlTranslate: rtl, size: swiperSize,
      } = swiper;
      const params = swiper.params.cubeEffect;
      const isHorizontal = swiper.isHorizontal();
      const isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      let wrapperRotate = 0;
      let $cubeShadowEl;
      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');
          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $wrapperEl.append($cubeShadowEl);
          }
          $cubeShadowEl.css({ height: `${swiperWidth}px` });
        } else {
          $cubeShadowEl = $el.find('.swiper-cube-shadow');
          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $el.append($cubeShadowEl);
          }
        }
      }
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        let slideIndex = i;
        if (isVirtual) {
          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
        }
        let slideAngle = slideIndex * 90;
        let round = Math.floor(slideAngle / 360);
        if (rtl) {
          slideAngle = -slideAngle;
          round = Math.floor(-slideAngle / 360);
        }
        const progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        let tx = 0;
        let ty = 0;
        let tz = 0;
        if (slideIndex % 4 === 0) {
          tx = -round * 4 * swiperSize;
          tz = 0;
        } else if ((slideIndex - 1) % 4 === 0) {
          tx = 0;
          tz = -round * 4 * swiperSize;
        } else if ((slideIndex - 2) % 4 === 0) {
          tx = swiperSize + (round * 4 * swiperSize);
          tz = swiperSize;
        } else if ((slideIndex - 3) % 4 === 0) {
          tx = -swiperSize;
          tz = (3 * swiperSize) + (swiperSize * 4 * round);
        }
        if (rtl) {
          tx = -tx;
        }

        if (!isHorizontal) {
          ty = tx;
          tx = 0;
        }

        const transform = `rotateX(${isHorizontal ? 0 : -slideAngle}deg) rotateY(${isHorizontal ? slideAngle : 0}deg) translate3d(${tx}px, ${ty}px, ${tz}px)`;
        if (progress <= 1 && progress > -1) {
          wrapperRotate = (slideIndex * 90) + (progress * 90);
          if (rtl) wrapperRotate = (-slideIndex * 90) - (progress * 90);
        }
        $slideEl.transform(transform);
        if (params.slideShadows) {
          // Set shadows
          let shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          let shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
          if (shadowBefore.length === 0) {
            shadowBefore = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
            $slideEl.append(shadowBefore);
          }
          if (shadowAfter.length === 0) {
            shadowAfter = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
            $slideEl.append(shadowAfter);
          }
          if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
          if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        }
      }
      $wrapperEl.css({
        '-webkit-transform-origin': `50% 50% -${swiperSize / 2}px`,
        '-moz-transform-origin': `50% 50% -${swiperSize / 2}px`,
        '-ms-transform-origin': `50% 50% -${swiperSize / 2}px`,
        'transform-origin': `50% 50% -${swiperSize / 2}px`,
      });

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl.transform(`translate3d(0px, ${(swiperWidth / 2) + params.shadowOffset}px, ${-swiperWidth / 2}px) rotateX(90deg) rotateZ(0deg) scale(${params.shadowScale})`);
        } else {
          const shadowAngle = Math.abs(wrapperRotate) - (Math.floor(Math.abs(wrapperRotate) / 90) * 90);
          const multiplier = 1.5 - (
            (Math.sin((shadowAngle * 2 * Math.PI) / 360) / 2)
            + (Math.cos((shadowAngle * 2 * Math.PI) / 360) / 2)
          );
          const scale1 = params.shadowScale;
          const scale2 = params.shadowScale / multiplier;
          const offset = params.shadowOffset;
          $cubeShadowEl.transform(`scale3d(${scale1}, 1, ${scale2}) translate3d(0px, ${(swiperHeight / 2) + offset}px, ${-swiperHeight / 2 / scale2}px) rotateX(-90deg)`);
        }
      }
      const zFactor = (Browser.isSafari || Browser.isUiWebView) ? (-swiperSize / 2) : 0;
      $wrapperEl
        .transform(`translate3d(0px,0,${zFactor}px) rotateX(${swiper.isHorizontal() ? 0 : wrapperRotate}deg) rotateY(${swiper.isHorizontal() ? -wrapperRotate : 0}deg)`);
    },
    setTransition(duration) {
      const swiper = this;
      const { $el, slides } = swiper;
      slides
        .transition(duration)
        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
        .transition(duration);
      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
        $el.find('.swiper-cube-shadow').transition(duration);
      }
    },
  };

  var EffectCube = {
    name: 'effect-cube',
    params: {
      cubeEffect: {
        slideShadows: true,
        shadow: true,
        shadowOffset: 20,
        shadowScale: 0.94,
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        cubeEffect: {
          setTranslate: Cube.setTranslate.bind(swiper),
          setTransition: Cube.setTransition.bind(swiper),
        },
      });
    },
    on: {
      beforeInit() {
        const swiper = this;
        if (swiper.params.effect !== 'cube') return;
        swiper.classNames.push(`${swiper.params.containerModifierClass}cube`);
        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
        const overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          resistanceRatio: 0,
          spaceBetween: 0,
          centeredSlides: false,
          virtualTranslate: true,
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate() {
        const swiper = this;
        if (swiper.params.effect !== 'cube') return;
        swiper.cubeEffect.setTranslate();
      },
      setTransition(duration) {
        const swiper = this;
        if (swiper.params.effect !== 'cube') return;
        swiper.cubeEffect.setTransition(duration);
      },
    },
  };

  const Flip = {
    setTranslate() {
      const swiper = this;
      const { slides, rtlTranslate: rtl } = swiper;
      for (let i = 0; i < slides.length; i += 1) {
        const $slideEl = slides.eq(i);
        let progress = $slideEl[0].progress;
        if (swiper.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        }
        const offset = $slideEl[0].swiperSlideOffset;
        const rotate = -180 * progress;
        let rotateY = rotate;
        let rotateX = 0;
        let tx = -offset;
        let ty = 0;
        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
          rotateX = -rotateY;
          rotateY = 0;
        } else if (rtl) {
          rotateY = -rotateY;
        }

        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

        if (swiper.params.flipEffect.slideShadows) {
          // Set shadows
          let shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          let shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
          if (shadowBefore.length === 0) {
            shadowBefore = $(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'left' : 'top'}"></div>`);
            $slideEl.append(shadowBefore);
          }
          if (shadowAfter.length === 0) {
            shadowAfter = $(`<div class="swiper-slide-shadow-${swiper.isHorizontal() ? 'right' : 'bottom'}"></div>`);
            $slideEl.append(shadowAfter);
          }
          if (shadowBefore.length) shadowBefore[0].style.opacity = Math.max(-progress, 0);
          if (shadowAfter.length) shadowAfter[0].style.opacity = Math.max(progress, 0);
        }
        $slideEl
          .transform(`translate3d(${tx}px, ${ty}px, 0px) rotateX(${rotateX}deg) rotateY(${rotateY}deg)`);
      }
    },
    setTransition(duration) {
      const swiper = this;
      const { slides, activeIndex, $wrapperEl } = swiper;
      slides
        .transition(duration)
        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
        .transition(duration);
      if (swiper.params.virtualTranslate && duration !== 0) {
        let eventTriggered = false;
        // eslint-disable-next-line
        slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
          if (eventTriggered) return;
          if (!swiper || swiper.destroyed) return;
          // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;
          eventTriggered = true;
          swiper.animating = false;
          const triggerEvents = ['webkitTransitionEnd', 'transitionend'];
          for (let i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    },
  };

  var EffectFlip = {
    name: 'effect-flip',
    params: {
      flipEffect: {
        slideShadows: true,
        limitRotation: true,
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        flipEffect: {
          setTranslate: Flip.setTranslate.bind(swiper),
          setTransition: Flip.setTransition.bind(swiper),
        },
      });
    },
    on: {
      beforeInit() {
        const swiper = this;
        if (swiper.params.effect !== 'flip') return;
        swiper.classNames.push(`${swiper.params.containerModifierClass}flip`);
        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);
        const overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: true,
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate() {
        const swiper = this;
        if (swiper.params.effect !== 'flip') return;
        swiper.flipEffect.setTranslate();
      },
      setTransition(duration) {
        const swiper = this;
        if (swiper.params.effect !== 'flip') return;
        swiper.flipEffect.setTransition(duration);
      },
    },
  };

  const Coverflow = {
    setTranslate() {
      const swiper = this;
      const {
        width: swiperWidth, height: swiperHeight, slides, $wrapperEl, slidesSizesGrid,
      } = swiper;
      const params = swiper.params.coverflowEffect;
      const isHorizontal = swiper.isHorizontal();
      const transform = swiper.translate;
      const center = isHorizontal ? -transform + (swiperWidth / 2) : -transform + (swiperHeight / 2);
      const rotate = isHorizontal ? params.rotate : -params.rotate;
      const translate = params.depth;
      // Each slide offset from center
      for (let i = 0, length = slides.length; i < length; i += 1) {
        const $slideEl = slides.eq(i);
        const slideSize = slidesSizesGrid[i];
        const slideOffset = $slideEl[0].swiperSlideOffset;
        const offsetMultiplier = ((center - slideOffset - (slideSize / 2)) / slideSize) * params.modifier;

        let rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
        let rotateX = isHorizontal ? 0 : rotate * offsetMultiplier;
        // var rotateZ = 0
        let translateZ = -translate * Math.abs(offsetMultiplier);

        let stretch = params.stretch;
        // Allow percentage to make a relative stretch for responsive sliders
        if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
          stretch = ((parseFloat(params.stretch) / 100) * slideSize);
        }
        let translateY = isHorizontal ? 0 : stretch * (offsetMultiplier);
        let translateX = isHorizontal ? stretch * (offsetMultiplier) : 0;

        // Fix for ultra small values
        if (Math.abs(translateX) < 0.001) translateX = 0;
        if (Math.abs(translateY) < 0.001) translateY = 0;
        if (Math.abs(translateZ) < 0.001) translateZ = 0;
        if (Math.abs(rotateY) < 0.001) rotateY = 0;
        if (Math.abs(rotateX) < 0.001) rotateX = 0;

        const slideTransform = `translate3d(${translateX}px,${translateY}px,${translateZ}px)  rotateX(${rotateX}deg) rotateY(${rotateY}deg)`;

        $slideEl.transform(slideTransform);
        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;
        if (params.slideShadows) {
          // Set shadows
          let $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          let $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');
          if ($shadowBeforeEl.length === 0) {
            $shadowBeforeEl = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'left' : 'top'}"></div>`);
            $slideEl.append($shadowBeforeEl);
          }
          if ($shadowAfterEl.length === 0) {
            $shadowAfterEl = $(`<div class="swiper-slide-shadow-${isHorizontal ? 'right' : 'bottom'}"></div>`);
            $slideEl.append($shadowAfterEl);
          }
          if ($shadowBeforeEl.length) $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
          if ($shadowAfterEl.length) $shadowAfterEl[0].style.opacity = (-offsetMultiplier) > 0 ? -offsetMultiplier : 0;
        }
      }

      // Set correct perspective for IE10
      if (Support.pointerEvents || Support.prefixedPointerEvents) {
        const ws = $wrapperEl[0].style;
        ws.perspectiveOrigin = `${center}px 50%`;
      }
    },
    setTransition(duration) {
      const swiper = this;
      swiper.slides
        .transition(duration)
        .find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left')
        .transition(duration);
    },
  };

  var EffectCoverflow = {
    name: 'effect-coverflow',
    params: {
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        modifier: 1,
        slideShadows: true,
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        coverflowEffect: {
          setTranslate: Coverflow.setTranslate.bind(swiper),
          setTransition: Coverflow.setTransition.bind(swiper),
        },
      });
    },
    on: {
      beforeInit() {
        const swiper = this;
        if (swiper.params.effect !== 'coverflow') return;

        swiper.classNames.push(`${swiper.params.containerModifierClass}coverflow`);
        swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);

        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      },
      setTranslate() {
        const swiper = this;
        if (swiper.params.effect !== 'coverflow') return;
        swiper.coverflowEffect.setTranslate();
      },
      setTransition(duration) {
        const swiper = this;
        if (swiper.params.effect !== 'coverflow') return;
        swiper.coverflowEffect.setTransition(duration);
      },
    },
  };

  const Thumbs = {
    init() {
      const swiper = this;
      const { thumbs: thumbsParams } = swiper.params;
      const SwiperClass = swiper.constructor;
      if (thumbsParams.swiper instanceof SwiperClass) {
        swiper.thumbs.swiper = thumbsParams.swiper;
        Utils.extend(swiper.thumbs.swiper.originalParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false,
        });
        Utils.extend(swiper.thumbs.swiper.params, {
          watchSlidesProgress: true,
          slideToClickedSlide: false,
        });
      } else if (Utils.isObject(thumbsParams.swiper)) {
        swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
          watchSlidesVisibility: true,
          watchSlidesProgress: true,
          slideToClickedSlide: false,
        }));
        swiper.thumbs.swiperCreated = true;
      }
      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
      swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
    },
    onThumbClick() {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;
      const clickedIndex = thumbsSwiper.clickedIndex;
      const clickedSlide = thumbsSwiper.clickedSlide;
      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) return;
      if (typeof clickedIndex === 'undefined' || clickedIndex === null) return;
      let slideToIndex;
      if (thumbsSwiper.params.loop) {
        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
      } else {
        slideToIndex = clickedIndex;
      }
      if (swiper.params.loop) {
        let currentIndex = swiper.activeIndex;
        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
          swiper.loopFix();
          // eslint-disable-next-line
          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
          currentIndex = swiper.activeIndex;
        }
        const prevIndex = swiper.slides.eq(currentIndex).prevAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
        const nextIndex = swiper.slides.eq(currentIndex).nextAll(`[data-swiper-slide-index="${slideToIndex}"]`).eq(0).index();
        if (typeof prevIndex === 'undefined') slideToIndex = nextIndex;
        else if (typeof nextIndex === 'undefined') slideToIndex = prevIndex;
        else if (nextIndex - currentIndex < currentIndex - prevIndex) slideToIndex = nextIndex;
        else slideToIndex = prevIndex;
      }
      swiper.slideTo(slideToIndex);
    },
    update(initial) {
      const swiper = this;
      const thumbsSwiper = swiper.thumbs.swiper;
      if (!thumbsSwiper) return;

      const slidesPerView = thumbsSwiper.params.slidesPerView === 'auto'
        ? thumbsSwiper.slidesPerViewDynamic()
        : thumbsSwiper.params.slidesPerView;

      const autoScrollOffset = swiper.params.thumbs.autoScrollOffset;
      const useOffset = autoScrollOffset && !thumbsSwiper.params.loop;
      if (swiper.realIndex !== thumbsSwiper.realIndex || useOffset) {
        let currentThumbsIndex = thumbsSwiper.activeIndex;
        let newThumbsIndex;
        let direction;
        if (thumbsSwiper.params.loop) {
          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
            thumbsSwiper.loopFix();
            // eslint-disable-next-line
            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
            currentThumbsIndex = thumbsSwiper.activeIndex;
          }
          // Find actual thumbs index to slide to
          const prevThumbsIndex = thumbsSwiper.slides
            .eq(currentThumbsIndex)
            .prevAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0)
            .index();
          const nextThumbsIndex = thumbsSwiper.slides
            .eq(currentThumbsIndex)
            .nextAll(`[data-swiper-slide-index="${swiper.realIndex}"]`).eq(0)
            .index();
          if (typeof prevThumbsIndex === 'undefined') newThumbsIndex = nextThumbsIndex;
          else if (typeof nextThumbsIndex === 'undefined') newThumbsIndex = prevThumbsIndex;
          else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) newThumbsIndex = currentThumbsIndex;
          else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) newThumbsIndex = nextThumbsIndex;
          else newThumbsIndex = prevThumbsIndex;
          direction = swiper.activeIndex > swiper.previousIndex ? 'next' : 'prev';
        } else {
          newThumbsIndex = swiper.realIndex;
          direction = newThumbsIndex > swiper.previousIndex ? 'next' : 'prev';
        }
        if (useOffset) {
          newThumbsIndex += direction === 'next' ? autoScrollOffset : -1 * autoScrollOffset;
        }

        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
          if (thumbsSwiper.params.centeredSlides) {
            if (newThumbsIndex > currentThumbsIndex) {
              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
            } else {
              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
            }
          } else if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - slidesPerView + 1;
          }
          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
        }
      }

      // Activate thumbs
      let thumbsToActivate = 1;
      const thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
        thumbsToActivate = swiper.params.slidesPerView;
      }

      if (!swiper.params.thumbs.multipleActiveThumbs) {
        thumbsToActivate = 1;
      }

      thumbsToActivate = Math.floor(thumbsToActivate);

      thumbsSwiper.slides.removeClass(thumbActiveClass);
      if (thumbsSwiper.params.loop || (thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled)) {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.$wrapperEl.children(`[data-swiper-slide-index="${swiper.realIndex + i}"]`).addClass(thumbActiveClass);
        }
      } else {
        for (let i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.slides.eq(swiper.realIndex + i).addClass(thumbActiveClass);
        }
      }
    },
  };
  var Thumbs$1 = {
    name: 'thumbs',
    params: {
      thumbs: {
        swiper: null,
        multipleActiveThumbs: true,
        autoScrollOffset: 0,
        slideThumbActiveClass: 'swiper-slide-thumb-active',
        thumbsContainerClass: 'swiper-container-thumbs',
      },
    },
    create() {
      const swiper = this;
      Utils.extend(swiper, {
        thumbs: {
          swiper: null,
          init: Thumbs.init.bind(swiper),
          update: Thumbs.update.bind(swiper),
          onThumbClick: Thumbs.onThumbClick.bind(swiper),
        },
      });
    },
    on: {
      beforeInit() {
        const swiper = this;
        const { thumbs } = swiper.params;
        if (!thumbs || !thumbs.swiper) return;
        swiper.thumbs.init();
        swiper.thumbs.update(true);
      },
      slideChange() {
        const swiper = this;
        if (!swiper.thumbs.swiper) return;
        swiper.thumbs.update();
      },
      update() {
        const swiper = this;
        if (!swiper.thumbs.swiper) return;
        swiper.thumbs.update();
      },
      resize() {
        const swiper = this;
        if (!swiper.thumbs.swiper) return;
        swiper.thumbs.update();
      },
      observerUpdate() {
        const swiper = this;
        if (!swiper.thumbs.swiper) return;
        swiper.thumbs.update();
      },
      setTransition(duration) {
        const swiper = this;
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        thumbsSwiper.setTransition(duration);
      },
      beforeDestroy() {
        const swiper = this;
        const thumbsSwiper = swiper.thumbs.swiper;
        if (!thumbsSwiper) return;
        if (swiper.thumbs.swiperCreated && thumbsSwiper) {
          thumbsSwiper.destroy();
        }
      },
    },
  };

  // Swiper Class

  Swiper.use([
    Device$1,
    Browser$1,
    Support$1,
    Resize,
    Observer$1,
    Virtual$1,
    Keyboard$1,
    Mousewheel$1,
    Navigation$1,
    Pagination$1,
    Scrollbar$1,
    Parallax$1,
    Zoom$1,
    Lazy$3,
    Controller$1,
    A11y,
    Autoplay$1,
    EffectFade,
    EffectCube,
    EffectFlip,
    EffectCoverflow,
    Thumbs$1,
  ]);

  function initSwiper(swiperEl) {
    const app = this;
    const $swiperEl = $(swiperEl);
    if ($swiperEl.length === 0) return;
    if ($swiperEl[0].swiper) return;
    let initialSlide;
    let params = {};
    let isTabs;
    let isRoutableTabs;
    if ($swiperEl.hasClass('tabs-swipeable-wrap')) {
      $swiperEl
        .addClass('swiper-container')
        .children('.tabs')
        .addClass('swiper-wrapper')
        .children('.tab')
        .addClass('swiper-slide');
      initialSlide = $swiperEl.children('.tabs').children('.tab-active').index();
      isTabs = true;
      isRoutableTabs = $swiperEl.find('.tabs-routable').length > 0;
    }
    if ($swiperEl.attr('data-swiper')) {
      params = JSON.parse($swiperEl.attr('data-swiper'));
    } else if ($swiperEl[0].f7SwiperParams) {
      params = $swiperEl[0].f7SwiperParams;
    } else {
      params = $swiperEl.dataset();
      Object.keys(params).forEach((key) => {
        const value = params[key];
        if (typeof value === 'string' && value.indexOf('{') === 0 && value.indexOf('}') > 0) {
          try {
            params[key] = JSON.parse(value);
          } catch (e) {
            // not JSON
          }
        }
      });
    }
    if (typeof params.initialSlide === 'undefined' && typeof initialSlide !== 'undefined') {
      params.initialSlide = initialSlide;
    }

    const swiper = app.swiper.create($swiperEl[0], params);
    function updateSwiper() {
      swiper.update();
    }
    $swiperEl.parents('.popup, .login-screen, .sheet-modal, .popover').on('modal:open', updateSwiper);
    $swiperEl.parents('.panel').on('panel:open', updateSwiper);
    $swiperEl.parents('.tab').on('tab:show', updateSwiper);
    swiper.on('beforeDestroy', () => {
      $swiperEl.parents('.popup, .login-screen, .sheet-modal, .popover').off('modal:open', updateSwiper);
      $swiperEl.parents('.panel').off('panel:open', updateSwiper);
      $swiperEl.parents('.tab').off('tab:show', updateSwiper);
    });
    if (isTabs) {
      swiper.on('slideChange', () => {
        if (isRoutableTabs) {
          let view = app.views.get($swiperEl.parents('.view'));
          if (!view) view = app.views.main;
          const router = view.router;
          const tabRoute = router.findTabRoute(swiper.slides.eq(swiper.activeIndex)[0]);
          if (tabRoute) {
            setTimeout(() => {
              router.navigate(tabRoute.path);
            }, 0);
          }
        } else {
          app.tab.show({
            tabEl: swiper.slides.eq(swiper.activeIndex),
          });
        }
      });
    }
  }

  var Swiper$1 = {
    name: 'swiper',
    static: {
      Swiper,
    },
    create() {
      const app = this;
      app.swiper = ConstructorMethods({
        defaultSelector: '.swiper-container',
        constructor: Swiper,
        domProp: 'swiper',
      });
    },
    on: {
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
          app.swiper.destroy(swiperEl);
        });
      },
      pageMounted(page) {
        const app = this;
        page.$el.find('.tabs-swipeable-wrap').each((index, swiperEl) => {
          initSwiper.call(app, swiperEl);
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
          initSwiper.call(app, swiperEl);
        });
      },
      pageReinit(page) {
        const app = this;
        page.$el.find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
          const swiper = app.swiper.get(swiperEl);
          if (swiper && swiper.update) swiper.update();
        });
      },
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
          initSwiper.call(app, swiperEl);
        });
      },
      tabShow(tabEl) {
        const app = this;
        $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
          const swiper = app.swiper.get(swiperEl);
          if (swiper && swiper.update) swiper.update();
        });
      },
      tabBeforeRemove(tabEl) {
        const app = this;
        $(tabEl).find('.swiper-init, .tabs-swipeable-wrap').each((index, swiperEl) => {
          app.swiper.destroy(swiperEl);
        });
      },
    },
    vnode: {
      'swiper-init': {
        insert(vnode) {
          const app = this;
          const swiperEl = vnode.elm;
          initSwiper.call(app, swiperEl);
        },
        destroy(vnode) {
          const app = this;
          const swiperEl = vnode.elm;
          app.swiper.destroy(swiperEl);
        },
      },
      'tabs-swipeable-wrap': {
        insert(vnode) {
          const app = this;
          const swiperEl = vnode.elm;
          initSwiper.call(app, swiperEl);
        },
        destroy(vnode) {
          const app = this;
          const swiperEl = vnode.elm;
          app.swiper.destroy(swiperEl);
        },
      },
    },
  };

  /* eslint indent: ["off"] */

  class PhotoBrowser extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);

      const pb = this;
      pb.app = app;

      const defaults = Utils.extend({
        on: {},
      }, app.params.photoBrowser);

      // Extend defaults with modules params
      pb.useModulesParams(defaults);

      pb.params = Utils.extend(defaults, params);

      Utils.extend(pb, {
        exposed: false,
        opened: false,
        activeIndex: pb.params.swiper.initialSlide,
        url: pb.params.url,
        swipeToClose: {
          allow: true,
          isTouched: false,
          diff: undefined,
          start: undefined,
          current: undefined,
          started: false,
          activeSlide: undefined,
          timeStart: undefined,
        },
      });

      // Install Modules
      pb.useModules();

      // Init
      pb.init();
    }

    get view() {
      const { params, app } = this;
      return params.view || app.views.main;
    }

    onSlideChange(swiper) {
      const pb = this;
      pb.activeIndex = swiper.activeIndex;

      let current = swiper.activeIndex + 1;
      let total = pb.params.virtualSlides ? pb.params.photos.length : swiper.slides.length;
      if (swiper.params.loop) {
        total -= 2;
        current -= swiper.loopedSlides;
        if (current < 1) current = total + current;
        if (current > total) current -= total;
      }

      const $activeSlideEl = pb.params.virtualSlides
        ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.activeIndex}"]`)
        : swiper.slides.eq(swiper.activeIndex);
      const $previousSlideEl = pb.params.virtualSlides
        ? swiper.$wrapperEl.find(`.swiper-slide[data-swiper-slide-index="${swiper.previousIndex}"]`)
        : swiper.slides.eq(swiper.previousIndex);

      let $currentEl = pb.$el.find('.photo-browser-current');
      let $totalEl = pb.$el.find('.photo-browser-total');
      let navbarEl;
      if (pb.params.type === 'page' && pb.params.navbar && $currentEl.length === 0 && pb.app.theme === 'ios') {
        navbarEl = pb.app.navbar.getElByPage(pb.$el);
        if (navbarEl) {
          $currentEl = $(navbarEl).find('.photo-browser-current');
          $totalEl = $(navbarEl).find('.photo-browser-total');
        }
      }
      if ($currentEl.length && $totalEl.length) {
        $currentEl.text(current);
        $totalEl.text(total);
        if (!navbarEl) navbarEl = $currentEl.parents('.navbar')[0];
        if (navbarEl) {
          pb.app.navbar.size(navbarEl);
        }
      }

      // Update captions
      if (pb.captions.length > 0) {
        const captionIndex = swiper.params.loop ? $activeSlideEl.attr('data-swiper-slide-index') : pb.activeIndex;
        pb.$captionsContainerEl.find('.photo-browser-caption-active').removeClass('photo-browser-caption-active');
        pb.$captionsContainerEl.find(`[data-caption-index="${captionIndex}"]`).addClass('photo-browser-caption-active');
      }

      // Stop Video
      const previousSlideVideo = $previousSlideEl.find('video');
      if (previousSlideVideo.length > 0) {
        if ('pause' in previousSlideVideo[0]) previousSlideVideo[0].pause();
      }
    }

    onTouchStart() {
      const pb = this;
      const swipeToClose = pb.swipeToClose;
      if (!swipeToClose.allow) return;
      swipeToClose.isTouched = true;
    }

    onTouchMove(e) {
      const pb = this;
      const swipeToClose = pb.swipeToClose;

      if (!swipeToClose.isTouched) return;
      if (!swipeToClose.started) {
        swipeToClose.started = true;
        swipeToClose.start = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (pb.params.virtualSlides) {
          swipeToClose.activeSlide = pb.swiper.$wrapperEl.children('.swiper-slide-active');
        } else {
          swipeToClose.activeSlide = pb.swiper.slides.eq(pb.swiper.activeIndex);
        }
        swipeToClose.timeStart = Utils.now();
      }
      e.preventDefault();
      swipeToClose.current = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
      swipeToClose.diff = swipeToClose.start - swipeToClose.current;
      pb.$el.transition(0).transform(`translate3d(0,${-swipeToClose.diff}px,0)`);
    }

    onTouchEnd() {
      const pb = this;
      const swipeToClose = pb.swipeToClose;
      swipeToClose.isTouched = false;
      if (!swipeToClose.started) {
        swipeToClose.started = false;
        return;
      }
      swipeToClose.started = false;
      swipeToClose.allow = false;
      const diff = Math.abs(swipeToClose.diff);
      const timeDiff = (new Date()).getTime() - swipeToClose.timeStart;
      if ((timeDiff < 300 && diff > 20) || (timeDiff >= 300 && diff > 100)) {
        Utils.nextTick(() => {
          if (pb.$el) {
            if (swipeToClose.diff < 0) pb.$el.addClass('swipe-close-to-bottom');
            else pb.$el.addClass('swipe-close-to-top');
          }
          pb.emit('local::swipeToClose', pb);
          pb.$el.transform('').transition('');
          pb.close();
          swipeToClose.allow = true;
        });
        return;
      }
      if (diff !== 0) {
        pb.$el.addClass('photo-browser-transitioning').transitionEnd(() => {
          swipeToClose.allow = true;
          pb.$el.removeClass('photo-browser-transitioning');
        });
      } else {
        swipeToClose.allow = true;
      }
      Utils.nextTick(() => {
        pb.$el.transform('').transition('');
      });
    }

    // Render Functions
    renderNavbar() {
      const pb = this;
      if (pb.params.renderNavbar) return pb.params.renderNavbar.call(pb);

      let iconsColor = pb.params.iconsColor;
      if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';

      const pageBackLinkText = (pb.app.theme === 'ios' || pb.app.theme === 'aurora') && pb.params.pageBackLinkText ? pb.params.pageBackLinkText : '';

      const renderNavbarCount = typeof pb.params.navbarShowCount === 'undefined' ? pb.params.photos.length > 1 : pb.params.navbarShowCount;

      const isPopup = pb.params.type !== 'page';
      const navbarHtml = `
      <div class="navbar navbar-photo-browser ${pb.params.theme === 'dark' ? 'navbar-photo-browser-dark' : ''}">
        <div class="navbar-bg"></div>
        <div class="navbar-inner navbar-inner-centered-title sliding">
          ${!isPopup ? `
          <div class="left">
            <a class="link ${!pageBackLinkText ? 'icon-only' : ''} back">
              <i class="icon icon-back ${iconsColor ? `color-${iconsColor}` : ''}"></i>
              ${pageBackLinkText ? `<span>${pageBackLinkText}</span>` : ''}
            </a>
          </div>
          ` : ''}
          ${renderNavbarCount ? `
          <div class="title">
            <span class="photo-browser-current"></span>
            <span class="photo-browser-of">${pb.params.navbarOfText}</span>
            <span class="photo-browser-total"></span>
          </div>
          ` : ''}
          ${isPopup ? `
          <div class="right">
            <a class="link popup-close" data-popup=".photo-browser-popup">
              <span>${pb.params.popupCloseLinkText}</span>
            </a>
          </div>
          ` : ''}
        </div>
      </div>
    `.trim();
      return navbarHtml;
    }

    renderToolbar() {
      const pb = this;
      if (pb.params.renderToolbar) return pb.params.renderToolbar.call(pb);

      let iconsColor = pb.params.iconsColor;
      if (!pb.params.iconsColor && pb.params.theme === 'dark') iconsColor = 'white';

      const toolbarHtml = `
      <div class="toolbar toolbar-bottom tabbar">
        <div class="toolbar-inner">
          <a class="link photo-browser-prev">
            <i class="icon icon-back ${iconsColor ? `color-${iconsColor}` : ''}"></i>
          </a>
          <a class="link photo-browser-next">
            <i class="icon icon-forward ${iconsColor ? `color-${iconsColor}` : ''}"></i>
          </a>
        </div>
      </div>
    `.trim();
      return toolbarHtml;
    }

    renderCaption(caption, index) {
      const pb = this;
      if (pb.params.renderCaption) return pb.params.renderCaption.call(pb, caption, index);
      const captionHtml = `
      <div class="photo-browser-caption" data-caption-index="${index}">
        ${caption}
      </div>
    `.trim();
      return captionHtml;
    }

    renderObject(photo, index) {
      const pb = this;
      if (pb.params.renderObject) return pb.params.renderObject.call(pb, photo, index);
      const objHtml = `
      <div class="photo-browser-slide photo-browser-object-slide swiper-slide" data-swiper-slide-index="${index}">${photo.html ? photo.html : photo}</div>
    `;
      return objHtml;
    }

    renderLazyPhoto(photo, index) {
      const pb = this;
      if (pb.params.renderLazyPhoto) return pb.params.renderLazyPhoto.call(pb, photo, index);
      const photoHtml = `
      <div class="photo-browser-slide photo-browser-slide-lazy swiper-slide" data-swiper-slide-index="${index}">
          <div class="swiper-lazy-preloader"></div>
          <span class="swiper-zoom-container">
              <img data-src="${photo.url ? photo.url : photo}" class="swiper-lazy">
          </span>
      </div>
    `.trim();
      return photoHtml;
    }

    renderPhoto(photo, index) {
      const pb = this;
      if (pb.params.renderPhoto) return pb.params.renderPhoto.call(pb, photo, index);
      const photoHtml = `
      <div class="photo-browser-slide swiper-slide" data-swiper-slide-index="${index}">
        <span class="swiper-zoom-container">
          <img src="${photo.url ? photo.url : photo}">
        </span>
      </div>
    `.trim();
      return photoHtml;
    }

    render() {
      const pb = this;
      if (pb.params.render) return pb.params.render.call(pb, pb.params);
      const html = `
      <div class="photo-browser photo-browser-${pb.params.theme}">
        <div class="view">
          <div class="page photo-browser-page photo-browser-page-${pb.params.theme} no-toolbar ${!pb.params.navbar ? 'no-navbar' : ''}" data-name="photo-browser-page">
            ${pb.params.navbar ? pb.renderNavbar() : ''}
            ${pb.params.toolbar ? pb.renderToolbar() : ''}
            <div class="photo-browser-captions photo-browser-captions-${pb.params.captionsTheme || pb.params.theme}">
              ${pb.params.photos.map((photo, index) => {
                if (photo.caption) return pb.renderCaption(photo.caption, index);
                return '';
              }).join(' ')}
            </div>
            <div class="photo-browser-swiper-container swiper-container">
              <div class="photo-browser-swiper-wrapper swiper-wrapper">
                ${pb.params.virtualSlides ? '' : pb.params.photos.map((photo, index) => {
                  if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
                    return pb.renderObject(photo, index);
                  }
                  if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
                    return pb.renderLazyPhoto(photo, index);
                  }
                  return pb.renderPhoto(photo, index);
                }).join(' ')}
              </div>
            </div>
          </div>
        </div>
      </div>
    `.trim();
      return html;
    }

    renderStandalone() {
      const pb = this;
      if (pb.params.renderStandalone) return pb.params.renderStandalone.call(pb);
      const standaloneHtml = `<div class="popup photo-browser-popup photo-browser-standalone popup-tablet-fullscreen">${pb.render()}</div>`;
      return standaloneHtml;
    }

    renderPage() {
      const pb = this;
      if (pb.params.renderPage) return pb.params.renderPage.call(pb);
      const pageHtml = pb.render();

      return pageHtml;
    }

    renderPopup() {
      const pb = this;
      if (pb.params.renderPopup) return pb.params.renderPopup.call(pb);
      const popupHtml = `<div class="popup photo-browser-popup">${pb.render()}</div>`;

      return popupHtml;
    }

    // Callbacks
    onOpen(type, el) {
      const pb = this;
      const app = pb.app;
      const $el = $(el);

      $el[0].f7PhotoBrowser = pb;

      pb.$el = $el;
      pb.el = $el[0];
      pb.openedIn = type;
      pb.opened = true;

      pb.$swiperContainerEl = pb.$el.find('.photo-browser-swiper-container');
      pb.$swiperWrapperEl = pb.$el.find('.photo-browser-swiper-wrapper');
      pb.slides = pb.$el.find('.photo-browser-slide');
      pb.$captionsContainerEl = pb.$el.find('.photo-browser-captions');
      pb.captions = pb.$el.find('.photo-browser-caption');

      // Init Swiper
      let clickTimeout;

      const swiperParams = Utils.extend({}, pb.params.swiper, {
        initialSlide: pb.activeIndex,
        on: {
          click(e) {
            clearTimeout(clickTimeout);

            if (pb.params.exposition) {
              clickTimeout = setTimeout(() => {
                pb.expositionToggle();
              }, 350);
            }
            pb.emit('local::tap', e);
            pb.emit('local::click', e);
          },
          doubleClick(e) {
            clearTimeout(clickTimeout);
            pb.emit('local::doubleTap', e);
            pb.emit('local::doubleClick', e);
          },
          slideChange(...args) {
            const swiper = this;
            pb.onSlideChange(swiper);
            pb.emit('local::slideChange', ...args);
          },
          transitionStart(...args) {
            pb.emit('local::transitionStart', ...args);
          },
          transitionEnd(...args) {
            pb.emit('local::transitionEnd', ...args);
          },
          slideChangeTransitionStart(...args) {
            const swiper = this;
            pb.onSlideChange(swiper);
            pb.emit('local::slideChangeTransitionStart', ...args);
          },
          slideChangeTransitionEnd(...args) {
            pb.emit('local::slideChangeTransitionEnd', ...args);
          },
          lazyImageLoad(...args) {
            pb.emit('local::lazyImageLoad', ...args);
          },
          lazyImageReady(...args) {
            const slideEl = args[0];
            $(slideEl).removeClass('photo-browser-slide-lazy');
            pb.emit('local::lazyImageReady', ...args);
          },
        },
      });
      if (pb.params.swipeToClose && pb.params.type !== 'page') {
        Utils.extend(swiperParams.on, {
          touchStart(e) {
            pb.onTouchStart(e);
            pb.emit('local::touchStart', e);
          },
          touchMoveOpposite(e) {
            pb.onTouchMove(e);
            pb.emit('local::touchMoveOpposite', e);
          },
          touchEnd(e) {
            pb.onTouchEnd(e);
            pb.emit('local::touchEnd', e);
          },
        });
      }
      if (pb.params.virtualSlides) {
        Utils.extend(swiperParams, {
          virtual: {
            slides: pb.params.photos,
            renderSlide(photo, index) {
              if (photo.html || ((typeof photo === 'string' || photo instanceof String) && photo.indexOf('<') >= 0 && photo.indexOf('>') >= 0)) {
                return pb.renderObject(photo, index);
              }
              if (pb.params.swiper.lazy === true || (pb.params.swiper.lazy && pb.params.swiper.lazy.enabled)) {
                return pb.renderLazyPhoto(photo, index);
              }
              return pb.renderPhoto(photo, index);
            },
          },
        });
      }

      pb.swiper = app.swiper.create(pb.$swiperContainerEl, swiperParams);

      if (pb.activeIndex === 0) {
        pb.onSlideChange(pb.swiper);
      }
      if (pb.$el) {
        pb.$el.trigger('photobrowser:open');
      }
      pb.emit('local::open photoBrowserOpen', pb);
    }

    onOpened() {
      const pb = this;
      if (pb.$el && pb.params.type === 'standalone') {
        pb.$el.css('animation', 'none');
      }
      if (pb.$el) {
        pb.$el.trigger('photobrowser:opened');
      }
      pb.emit('local::opened photoBrowserOpened', pb);
    }

    onClose() {
      const pb = this;
      if (pb.destroyed) return;

      // Destroy Swiper
      if (pb.swiper && pb.swiper.destroy) {
        pb.swiper.destroy(true, false);
        pb.swiper = null;
        delete pb.swiper;
      }
      if (pb.$el) {
        pb.$el.trigger('photobrowser:close');
      }
      pb.emit('local::close photoBrowserClose', pb);
    }

    onClosed() {
      const pb = this;
      if (pb.destroyed) return;
      pb.opened = false;
      pb.$el = null;
      pb.el = null;
      delete pb.$el;
      delete pb.el;
      if (pb.$el) {
        pb.$el.trigger('photobrowser:closed');
      }
      pb.emit('local::closed photoBrowserClosed', pb);
    }

    // Open
    openPage() {
      const pb = this;
      if (pb.opened) return pb;

      const pageHtml = pb.renderPage();

      pb.view.router.navigate({
        url: pb.url,
        route: {
          content: pageHtml,
          path: pb.url,
          on: {
            pageBeforeIn(e, page) {
              pb.view.$el.addClass(`with-photo-browser-page with-photo-browser-page-${pb.params.theme}`);
              pb.onOpen('page', page.el);
            },
            pageAfterIn(e, page) {
              pb.onOpened('page', page.el);
            },
            pageBeforeOut(e, page) {
              pb.view.$el.removeClass(`with-photo-browser-page with-photo-browser-page-exposed with-photo-browser-page-${pb.params.theme}`);
              pb.onClose('page', page.el);
            },
            pageAfterOut(e, page) {
              pb.onClosed('page', page.el);
            },
          },
        },
      });
      return pb;
    }

    openStandalone() {
      const pb = this;
      if (pb.opened) return pb;

      const standaloneHtml = pb.renderStandalone();

      const popupParams = {
        backdrop: false,
        content: standaloneHtml,
        on: {
          popupOpen(popup) {
            pb.onOpen('popup', popup.el);
          },
          popupOpened(popup) {
            pb.onOpened('popup', popup.el);
          },
          popupClose(popup) {
            pb.onClose('popup', popup.el);
          },
          popupClosed(popup) {
            pb.onClosed('popup', popup.el);
          },
        },
      };

      if (pb.params.routableModals && pb.view) {
        pb.view.router.navigate({
          url: pb.url,
          route: {
            path: pb.url,
            popup: popupParams,
          },
        });
      } else {
        pb.modal = pb.app.popup.create(popupParams).open();
      }
      return pb;
    }

    openPopup() {
      const pb = this;
      if (pb.opened) return pb;

      const popupHtml = pb.renderPopup();

      const popupParams = {
        content: popupHtml,
        push: pb.params.popupPush,
        on: {
          popupOpen(popup) {
            pb.onOpen('popup', popup.el);
          },
          popupOpened(popup) {
            pb.onOpened('popup', popup.el);
          },
          popupClose(popup) {
            pb.onClose('popup', popup.el);
          },
          popupClosed(popup) {
            pb.onClosed('popup', popup.el);
          },
        },
      };

      if (pb.params.routableModals && pb.view) {
        pb.view.router.navigate({
          url: pb.url,
          route: {
            path: pb.url,
            popup: popupParams,
          },
        });
      } else {
        pb.modal = pb.app.popup.create(popupParams).open();
      }
      return pb;
    }

    // Exposition
    expositionEnable() {
      const pb = this;
      if (pb.params.type === 'page') {
        pb.view.$el.addClass('with-photo-browser-page-exposed');
      }
      if (pb.$el) pb.$el.addClass('photo-browser-exposed');
      if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.addClass('photo-browser-captions-exposed');
      pb.exposed = true;
      return pb;
    }

    expositionDisable() {
      const pb = this;
      if (pb.params.type === 'page') {
        pb.view.$el.removeClass('with-photo-browser-page-exposed');
      }
      if (pb.$el) pb.$el.removeClass('photo-browser-exposed');
      if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.removeClass('photo-browser-captions-exposed');
      pb.exposed = false;
      return pb;
    }

    expositionToggle() {
      const pb = this;
      if (pb.params.type === 'page') {
        pb.view.$el.toggleClass('with-photo-browser-page-exposed');
      }
      if (pb.$el) pb.$el.toggleClass('photo-browser-exposed');
      if (pb.params.expositionHideCaptions) pb.$captionsContainerEl.toggleClass('photo-browser-captions-exposed');
      pb.exposed = !pb.exposed;
      return pb;
    }

    open(index) {
      const pb = this;
      const type = pb.params.type;
      if (pb.opened) {
        if (pb.swiper && typeof index !== 'undefined') {
          pb.swiper.slideTo(parseInt(index, 10));
        }
        return pb;
      }
      if (typeof index !== 'undefined') {
        pb.activeIndex = index;
      }
      if (type === 'standalone') {
        pb.openStandalone();
      }
      if (type === 'page') {
        pb.openPage();
      }
      if (type === 'popup') {
        pb.openPopup();
      }
      return pb;
    }

    close() {
      const pb = this;
      if (!pb.opened) return pb;
      if ((pb.params.routableModals && pb.view) || pb.openedIn === 'page') {
        pb.view.router.back();
      } else {
        pb.modal.once('modalClosed', () => {
          Utils.nextTick(() => {
            if (pb.destroyed) return;
            pb.modal.destroy();
            delete pb.modal;
          });
        });
        pb.modal.close();
      }
      return pb;
    }
    // eslint-disable-next-line
    init() {}

    destroy() {
      let pb = this;
      pb.emit('local::beforeDestroy photoBrowserBeforeDestroy', pb);
      if (pb.$el) {
        pb.$el.trigger('photobrowser:beforedestroy');
        pb.$el[0].f7PhotoBrowser = null;
        delete pb.$el[0].f7PhotoBrowser;
      }
      Utils.deleteProps(pb);
      pb.destroyed = true;
      pb = null;
    }
  }

  var PhotoBrowser$1 = {
    name: 'photoBrowser',
    params: {
      photoBrowser: {
        photos: [],
        exposition: true,
        expositionHideCaptions: false,
        type: 'standalone',
        navbar: true,
        toolbar: true,
        theme: 'light',
        captionsTheme: undefined,
        iconsColor: undefined,
        popupPush: false,
        swipeToClose: true,
        pageBackLinkText: 'Back',
        popupCloseLinkText: 'Close',
        navbarOfText: 'of',
        navbarShowCount: undefined,
        view: undefined,
        url: 'photos/',
        routableModals: true,
        virtualSlides: true,

        renderNavbar: undefined,
        renderToolbar: undefined,
        renderCaption: undefined,
        renderObject: undefined,
        renderLazyPhoto: undefined,
        renderPhoto: undefined,
        renderPage: undefined,
        renderPopup: undefined,
        renderStandalone: undefined,

        swiper: {
          initialSlide: 0,
          spaceBetween: 20,
          speed: 300,
          loop: false,
          preloadImages: true,
          navigation: {
            nextEl: '.photo-browser-next',
            prevEl: '.photo-browser-prev',
          },
          zoom: {
            enabled: true,
            maxRatio: 3,
            minRatio: 1,
          },
          lazy: {
            enabled: true,
          },
        },
      },
    },
    create() {
      const app = this;
      app.photoBrowser = ConstructorMethods({
        defaultSelector: '.photo-browser-popup, .photo-browser-page',
        constructor: PhotoBrowser,
        app,
        domProp: 'f7PhotoBrowser',
      });
    },
    static: {
      PhotoBrowser,
    },
  };

  class Notification extends Modal {
    constructor(app, params) {
      const extendedParams = Utils.extend({
        on: {},
      }, app.params.notification, params);

      // Extends with open/close Modal methods;
      super(app, extendedParams);

      const notification = this;

      notification.app = app;

      notification.params = extendedParams;

      const {
        icon,
        title,
        titleRightText,
        subtitle,
        text,
        closeButton,
        closeTimeout,
        cssClass,
        closeOnClick,
      } = notification.params;

      let $el;
      if (!notification.params.el) {
        // Find Element
        const notificationHtml = notification.render({
          icon,
          title,
          titleRightText,
          subtitle,
          text,
          closeButton,
          cssClass,
        });

        $el = $(notificationHtml);
      } else {
        $el = $(notification.params.el);
      }

      if ($el && $el.length > 0 && $el[0].f7Modal) {
        return $el[0].f7Modal;
      }

      if ($el.length === 0) {
        return notification.destroy();
      }

      Utils.extend(notification, {
        $el,
        el: $el[0],
        type: 'notification',
      });

      $el[0].f7Modal = notification;

      if (closeButton) {
        $el.find('.notification-close-button').on('click', () => {
          notification.close();
        });
      }
      $el.on('click', (e) => {
        if (closeButton && $(e.target).closest('.notification-close-button').length) {
          return;
        }
        notification.emit('local::click notificationClick', notification);
        if (closeOnClick) notification.close();
      });

      notification.on('beforeDestroy', () => {
        $el.off('click');
      });

      /* Touch Events */
      let isTouched;
      let isMoved;
      let isScrolling;
      let touchesDiff;
      let touchStartTime;
      let notificationHeight;
      const touchesStart = {};
      function handleTouchStart(e) {
        if (isTouched) return;
        isTouched = true;
        isMoved = false;
        isScrolling = undefined;
        touchStartTime = Utils.now();
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        const pageX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        const pageY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        if (typeof isScrolling === 'undefined') {
          isScrolling = !!(isScrolling || Math.abs(pageY - touchesStart.y) < Math.abs(pageX - touchesStart.x));
        }
        if (isScrolling) {
          isTouched = false;
          return;
        }
        e.preventDefault();
        if (!isMoved) {
          notification.$el.removeClass('notification-transitioning');
          notification.$el.transition(0);
          notificationHeight = notification.$el[0].offsetHeight / 2;
        }
        isMoved = true;
        touchesDiff = (pageY - touchesStart.y);
        let newTranslate = touchesDiff;
        if (touchesDiff > 0) {
          newTranslate = touchesDiff ** 0.8;
        }
        notification.$el.transform(`translate3d(0, ${newTranslate}px, 0)`);
      }
      function handleTouchEnd() {
        if (!isTouched || !isMoved) {
          isTouched = false;
          isMoved = false;
          return;
        }
        isTouched = false;
        isMoved = false;
        if (touchesDiff === 0) {
          return;
        }

        const timeDiff = Utils.now() - touchStartTime;
        notification.$el.transition('');
        notification.$el.addClass('notification-transitioning');
        notification.$el.transform('');

        if (
          (touchesDiff < -10 && timeDiff < 300)
          || (-touchesDiff >= notificationHeight / 1)
        ) {
          notification.close();
        }
      }

      function attachTouchEvents() {
        notification.$el.on(app.touchEvents.start, handleTouchStart, { passive: true });
        app.on('touchmove:active', handleTouchMove);
        app.on('touchend:passive', handleTouchEnd);
      }
      function detachTouchEvents() {
        notification.$el.off(app.touchEvents.start, handleTouchStart, { passive: true });
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
      }

      let timeoutId;
      function closeOnTimeout() {
        timeoutId = Utils.nextTick(() => {
          if (isTouched && isMoved) {
            closeOnTimeout();
            return;
          }
          notification.close();
        }, closeTimeout);
      }
      notification.on('open', () => {
        if (notification.params.swipeToClose) {
          attachTouchEvents();
        }
        $('.notification.modal-in').each((index, openedEl) => {
          const notificationInstance = app.notification.get(openedEl);
          if (openedEl !== notification.el && notificationInstance) {
            notificationInstance.close();
          }
        });
        if (closeTimeout) {
          closeOnTimeout();
        }
      });
      notification.on('close beforeDestroy', () => {
        if (notification.params.swipeToClose) {
          detachTouchEvents();
        }
        win.clearTimeout(timeoutId);
      });

      return notification;
    }

    render() {
      const notification = this;
      if (notification.params.render) return notification.params.render.call(notification, notification);
      const { icon, title, titleRightText, subtitle, text, closeButton, cssClass } = notification.params;
      return `
      <div class="notification ${cssClass || ''}">
        <div class="notification-header">
          ${icon ? `<div class="notification-icon">${icon}</div>` : ''}
          ${title ? `<div class="notification-title">${title}</div>` : ''}
          ${titleRightText ? `<div class="notification-title-right-text">${titleRightText}</div>` : ''}
          ${closeButton ? '<span class="notification-close-button"></span>' : ''}
        </div>
        <div class="notification-content">
          ${subtitle ? `<div class="notification-subtitle">${subtitle}</div>` : ''}
          ${text ? `<div class="notification-text">${text}</div>` : ''}
        </div>
      </div>
    `.trim();
    }
  }

  var Notification$1 = {
    name: 'notification',
    static: {
      Notification,
    },
    create() {
      const app = this;
      app.notification = Utils.extend(
        {},
        ModalMethods({
          app,
          constructor: Notification,
          defaultSelector: '.notification.modal-in',
        })
      );
    },
    params: {
      notification: {
        icon: null,
        title: null,
        titleRightText: null,
        subtitle: null,
        text: null,
        closeButton: false,
        closeTimeout: null,
        closeOnClick: false,
        swipeToClose: true,
        cssClass: null,
        render: null,
      },
    },
  };

  /* eslint "no-useless-escape": "off" */

  class Autocomplete extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);

      const ac = this;
      ac.app = app;

      const defaults = Utils.extend({
        on: {},
      }, app.params.autocomplete);

      if (typeof defaults.searchbarDisableButton === 'undefined') {
        defaults.searchbarDisableButton = app.theme !== 'aurora';
      }

      // Extend defaults with modules params
      ac.useModulesParams(defaults);

      ac.params = Utils.extend(defaults, params);

      let $openerEl;
      if (ac.params.openerEl) {
        $openerEl = $(ac.params.openerEl);
        if ($openerEl.length) $openerEl[0].f7Autocomplete = ac;
      }

      let $inputEl;
      if (ac.params.inputEl) {
        $inputEl = $(ac.params.inputEl);
        if ($inputEl.length) $inputEl[0].f7Autocomplete = ac;
      }

      const id = Utils.id();

      let url = params.url;
      if (!url && $openerEl && $openerEl.length) {
        if ($openerEl.attr('href')) url = $openerEl.attr('href');
        else if ($openerEl.find('a').length > 0) {
          url = $openerEl.find('a').attr('href');
        }
      }
      if (!url || url === '#' || url === '') url = ac.params.url;

      const inputType = ac.params.multiple ? 'checkbox' : 'radio';

      Utils.extend(ac, {
        $openerEl,
        openerEl: $openerEl && $openerEl[0],
        $inputEl,
        inputEl: $inputEl && $inputEl[0],
        id,
        url,
        value: ac.params.value || [],
        inputType,
        inputName: `${inputType}-${id}`,
        $modalEl: undefined,
        $dropdownEl: undefined,
      });

      let previousQuery = '';
      function onInputChange() {
        let query = ac.$inputEl.val().trim();

        if (!ac.params.source) return;
        ac.params.source.call(ac, query, (items) => {
          let itemsHTML = '';
          const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
          ac.items = items;
          let regExp;
          if (ac.params.highlightMatches) {
            query = query.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            regExp = new RegExp(`(${query})`, 'i');
          }

          let firstValue;
          let firstItem;
          for (let i = 0; i < limit; i += 1) {
            const itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
            const itemText = typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i];
            if (i === 0) {
              firstValue = itemValue;
              firstItem = ac.items[i];
            }
            itemsHTML += ac.renderItem({
              value: itemValue,
              text: ac.params.highlightMatches ? itemText.replace(regExp, '<b>$1</b>') : itemText,
            }, i);
          }
          if (itemsHTML === '' && query === '' && ac.params.dropdownPlaceholderText) {
            itemsHTML += ac.renderItem({
              placeholder: true,
              text: ac.params.dropdownPlaceholderText,
            });
          }
          ac.$dropdownEl.find('ul').html(itemsHTML);
          if (ac.params.typeahead) {
            if (!firstValue || !firstItem) {
              return;
            }
            if (firstValue.toLowerCase().indexOf(query.toLowerCase()) !== 0) {
              return;
            }
            if (previousQuery.toLowerCase() === query.toLowerCase()) {
              ac.value = [];
              return;
            }

            if (previousQuery.toLowerCase().indexOf(query.toLowerCase()) === 0) {
              previousQuery = query;
              ac.value = [];
              return;
            }
            $inputEl.val(firstValue);
            $inputEl[0].setSelectionRange(query.length, firstValue.length);

            const previousValue = typeof ac.value[0] === 'object' ? ac.value[0][ac.params.valueProperty] : ac.value[0];
            if (!previousValue || firstValue.toLowerCase() !== previousValue.toLowerCase()) {
              ac.value = [firstItem];
              ac.emit('local::change autocompleteChange', [firstItem]);
            }
          }

          previousQuery = query;
        });
      }
      function onPageInputChange() {
        const input = this;
        const value = input.value;
        const isValues = $(input).parents('.autocomplete-values').length > 0;
        let item;
        let itemValue;
        let aValue;
        if (isValues) {
          if (ac.inputType === 'checkbox' && !input.checked) {
            for (let i = 0; i < ac.value.length; i += 1) {
              aValue = typeof ac.value[i] === 'string' ? ac.value[i] : ac.value[i][ac.params.valueProperty];
              if (aValue === value || aValue * 1 === value * 1) {
                ac.value.splice(i, 1);
              }
            }
            ac.updateValues();
            ac.emit('local::change autocompleteChange', ac.value);
          }
          return;
        }

        // Find Related Item
        for (let i = 0; i < ac.items.length; i += 1) {
          itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
          if (itemValue === value || itemValue * 1 === value * 1) item = ac.items[i];
        }
        if (ac.inputType === 'radio') {
          ac.value = [item];
        } else if (input.checked) {
          ac.value.push(item);
        } else {
          for (let i = 0; i < ac.value.length; i += 1) {
            aValue = typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i];
            if (aValue === value || aValue * 1 === value * 1) {
              ac.value.splice(i, 1);
            }
          }
        }

        // Update Values Block
        ac.updateValues();

        // On Select Callback
        if (((ac.inputType === 'radio' && input.checked) || ac.inputType === 'checkbox')) {
          ac.emit('local::change autocompleteChange', ac.value);
        }
      }
      function onHtmlClick(e) {
        const $targetEl = $(e.target);
        if ($targetEl.is(ac.$inputEl[0]) || (ac.$dropdownEl && $targetEl.closest(ac.$dropdownEl[0]).length)) return;
        ac.close();
      }
      function onOpenerClick() {
        ac.open();
      }
      function onInputFocus() {
        ac.open();
      }
      function onInputBlur() {
        if (ac.$dropdownEl.find('label.active-state').length > 0) return;
        setTimeout(() => {
          ac.close();
        }, 0);
      }
      function onResize() {
        ac.positionDropdown();
      }

      function onKeyDown(e) {
        if (!ac.opened) return;
        if (e.keyCode === 27) {
          // ESC
          e.preventDefault();
          ac.$inputEl.blur();
          return;
        }
        if (e.keyCode === 13) {
          // Enter
          const $selectedItemLabel = ac.$dropdownEl.find('.autocomplete-dropdown-selected label');
          if ($selectedItemLabel.length) {
            e.preventDefault();
            $selectedItemLabel.trigger('click');
            ac.$inputEl.blur();
            return;
          }
          if (ac.params.typeahead) {
            e.preventDefault();
            ac.$inputEl.blur();
          }
          return;
        }
        if (e.keyCode !== 40 && e.keyCode !== 38) return;
        e.preventDefault();
        const $selectedItem = ac.$dropdownEl.find('.autocomplete-dropdown-selected');
        let $newItem;
        if ($selectedItem.length) {
          $newItem = $selectedItem[e.keyCode === 40 ? 'next' : 'prev']('li');
          if (!$newItem.length) {
            $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
          }
        } else {
          $newItem = ac.$dropdownEl.find('li').eq(e.keyCode === 40 ? 0 : ac.$dropdownEl.find('li').length - 1);
        }
        if ($newItem.hasClass('autocomplete-dropdown-placeholder')) return;
        $selectedItem.removeClass('autocomplete-dropdown-selected');
        $newItem.addClass('autocomplete-dropdown-selected');
      }
      function onDropdownClick() {
        const $clickedEl = $(this);
        let clickedItem;
        for (let i = 0; i < ac.items.length; i += 1) {
          const itemValue = typeof ac.items[i] === 'object' ? ac.items[i][ac.params.valueProperty] : ac.items[i];
          const value = $clickedEl.attr('data-value');
          if (itemValue === value || itemValue * 1 === value * 1) {
            clickedItem = ac.items[i];
          }
        }
        if (ac.params.updateInputValueOnSelect) {
          ac.$inputEl.val(typeof clickedItem === 'object' ? clickedItem[ac.params.valueProperty] : clickedItem);
          ac.$inputEl.trigger('input change');
        }
        ac.value = [clickedItem];
        ac.emit('local::change autocompleteChange', [clickedItem]);
        ac.close();
      }

      ac.attachEvents = function attachEvents() {
        if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
          ac.$openerEl.on('click', onOpenerClick);
        }
        if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
          ac.$inputEl.on('focus', onInputFocus);
          ac.$inputEl.on(ac.params.inputEvents, onInputChange);
          if (app.device.android) {
            $('html').on('click', onHtmlClick);
          } else {
            ac.$inputEl.on('blur', onInputBlur);
          }
          ac.$inputEl.on('keydown', onKeyDown);
        }
      };
      ac.detachEvents = function attachEvents() {
        if (ac.params.openIn !== 'dropdown' && ac.$openerEl) {
          ac.$openerEl.off('click', onOpenerClick);
        }
        if (ac.params.openIn === 'dropdown' && ac.$inputEl) {
          ac.$inputEl.off('focus', onInputFocus);
          ac.$inputEl.off(ac.params.inputEvents, onInputChange);
          if (app.device.android) {
            $('html').off('click', onHtmlClick);
          } else {
            ac.$inputEl.off('blur', onInputBlur);
          }
          ac.$inputEl.off('keydown', onKeyDown);
        }
      };
      ac.attachDropdownEvents = function attachDropdownEvents() {
        ac.$dropdownEl.on('click', 'label', onDropdownClick);
        app.on('resize', onResize);
      };
      ac.detachDropdownEvents = function detachDropdownEvents() {
        ac.$dropdownEl.off('click', 'label', onDropdownClick);
        app.off('resize', onResize);
      };

      ac.attachPageEvents = function attachPageEvents() {
        ac.$el.on('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
        if (ac.params.closeOnSelect && !ac.params.multiple) {
          ac.$el.once('click', '.list label', () => {
            Utils.nextTick(() => {
              ac.close();
            });
          });
        }
      };
      ac.detachPageEvents = function detachPageEvents() {
        ac.$el.off('change', 'input[type="radio"], input[type="checkbox"]', onPageInputChange);
      };

      // Install Modules
      ac.useModules();

      // Init
      ac.init();

      return ac;
    }

    get view() {
      const ac = this;
      const { $openerEl, $inputEl, app } = ac;
      let view;
      if (ac.params.view) {
        view = ac.params.view;
      } else if ($openerEl || $inputEl) {
        const $el = $openerEl || $inputEl;
        view = $el.closest('.view').length && $el.closest('.view')[0].f7View;
      }
      if (!view) view = app.views.main;
      return view;
    }

    positionDropdown() {
      const ac = this;
      const { $inputEl, app, $dropdownEl } = ac;

      const $pageContentEl = $inputEl.parents('.page-content');
      if ($pageContentEl.length === 0) return;
      const inputOffset = $inputEl.offset();
      const inputOffsetWidth = $inputEl[0].offsetWidth;
      const inputOffsetHeight = $inputEl[0].offsetHeight;
      const $listEl = $inputEl.parents('.list');

      let $listParent;
      $listEl.parents().each((index, parentEl) => {
        if ($listParent) return;
        const $parentEl = $(parentEl);
        if ($parentEl.parent($pageContentEl).length) $listParent = $parentEl;
      });

      const listOffset = $listEl.offset();
      const paddingBottom = parseInt($pageContentEl.css('padding-bottom'), 10);
      const listOffsetLeft = $listEl.length > 0 ? listOffset.left - $pageContentEl.offset().left : 0;
      const inputOffsetLeft = inputOffset.left - ($listEl.length > 0 ? listOffset.left : 0) - (app.rtl ? 0 : 0);
      const inputOffsetTop = inputOffset.top - ($pageContentEl.offset().top - $pageContentEl[0].scrollTop);

      const maxHeight = $pageContentEl[0].scrollHeight - paddingBottom - (inputOffsetTop + $pageContentEl[0].scrollTop) - $inputEl[0].offsetHeight;

      const paddingProp = app.rtl ? 'padding-right' : 'padding-left';
      let paddingValue;
      if ($listEl.length && !ac.params.expandInput) {
        paddingValue = (app.rtl ? $listEl[0].offsetWidth - inputOffsetLeft - inputOffsetWidth : inputOffsetLeft) - (app.theme === 'md' ? 16 : 15);
      }

      $dropdownEl.css({
        left: `${$listEl.length > 0 ? listOffsetLeft : inputOffsetLeft}px`,
        top: `${inputOffsetTop + $pageContentEl[0].scrollTop + inputOffsetHeight}px`,
        width: `${$listEl.length > 0 ? $listEl[0].offsetWidth : inputOffsetWidth}px`,
      });
      $dropdownEl.children('.autocomplete-dropdown-inner').css({
        maxHeight: `${maxHeight}px`,
        [paddingProp]: $listEl.length > 0 && !ac.params.expandInput ? `${paddingValue}px` : '',
      });
    }

    focus() {
      const ac = this;
      ac.$el.find('input[type=search]').focus();
    }

    source(query) {
      const ac = this;
      if (!ac.params.source) return;

      const { $el } = ac;

      ac.params.source.call(ac, query, (items) => {
        let itemsHTML = '';
        const limit = ac.params.limit ? Math.min(ac.params.limit, items.length) : items.length;
        ac.items = items;
        for (let i = 0; i < limit; i += 1) {
          let selected = false;
          const itemValue = typeof items[i] === 'object' ? items[i][ac.params.valueProperty] : items[i];
          for (let j = 0; j < ac.value.length; j += 1) {
            const aValue = typeof ac.value[j] === 'object' ? ac.value[j][ac.params.valueProperty] : ac.value[j];
            if (aValue === itemValue || aValue * 1 === itemValue * 1) selected = true;
          }
          itemsHTML += ac.renderItem({
            value: itemValue,
            text: typeof items[i] === 'object' ? items[i][ac.params.textProperty] : items[i],
            inputType: ac.inputType,
            id: ac.id,
            inputName: ac.inputName,
            selected,
          }, i);
        }
        $el.find('.autocomplete-found ul').html(itemsHTML);
        if (items.length === 0) {
          if (query.length !== 0) {
            $el.find('.autocomplete-not-found').show();
            $el.find('.autocomplete-found, .autocomplete-values').hide();
          } else {
            $el.find('.autocomplete-values').show();
            $el.find('.autocomplete-found, .autocomplete-not-found').hide();
          }
        } else {
          $el.find('.autocomplete-found').show();
          $el.find('.autocomplete-not-found, .autocomplete-values').hide();
        }
      });
    }

    updateValues() {
      const ac = this;
      let valuesHTML = '';
      for (let i = 0; i < ac.value.length; i += 1) {
        valuesHTML += ac.renderItem({
          value: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.valueProperty] : ac.value[i],
          text: typeof ac.value[i] === 'object' ? ac.value[i][ac.params.textProperty] : ac.value[i],
          inputType: ac.inputType,
          id: ac.id,
          inputName: `${ac.inputName}-checked}`,
          selected: true,
        }, i);
      }
      ac.$el.find('.autocomplete-values ul').html(valuesHTML);
    }

    preloaderHide() {
      const ac = this;
      if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
        ac.$dropdownEl.find('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
      } else {
        $('.autocomplete-preloader').removeClass('autocomplete-preloader-visible');
      }
    }

    preloaderShow() {
      const ac = this;
      if (ac.params.openIn === 'dropdown' && ac.$dropdownEl) {
        ac.$dropdownEl.find('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
      } else {
        $('.autocomplete-preloader').addClass('autocomplete-preloader-visible');
      }
    }

    renderPreloader() {
      const ac = this;
      return `
      <div class="autocomplete-preloader preloader ${ac.params.preloaderColor ? `color-${ac.params.preloaderColor}` : ''}">${Utils[`${ac.app.theme}PreloaderContent`] || ''}</div>
    `.trim();
    }

    renderSearchbar() {
      const ac = this;
      if (ac.params.renderSearchbar) return ac.params.renderSearchbar.call(ac);
      const searchbarHTML = `
      <form class="searchbar">
        <div class="searchbar-inner">
          <div class="searchbar-input-wrap">
            <input type="search" placeholder="${ac.params.searchbarPlaceholder}"/>
            <i class="searchbar-icon"></i>
            <span class="input-clear-button"></span>
          </div>
          ${ac.params.searchbarDisableButton ? `
          <span class="searchbar-disable-button">${ac.params.searchbarDisableText}</span>
          ` : ''}
        </div>
      </form>
    `.trim();
      return searchbarHTML;
    }

    renderItem(item, index) {
      const ac = this;
      if (ac.params.renderItem) return ac.params.renderItem.call(ac, item, index);
      let itemHtml;
      const itemValue = item.value && typeof item.value === 'string' ? item.value.replace(/"/g, '&quot;') : item.value;
      if (ac.params.openIn !== 'dropdown') {
        itemHtml = `
        <li>
          <label class="item-${item.inputType} item-content">
            <input type="${item.inputType}" name="${item.inputName}" value="${itemValue}" ${item.selected ? 'checked' : ''}>
            <i class="icon icon-${item.inputType}"></i>
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
      } else if (!item.placeholder) {
        // Dropdown
        itemHtml = `
        <li>
          <label class="item-radio item-content" data-value="${itemValue}">
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
      } else {
        // Dropwdown placeholder
        itemHtml = `
        <li class="autocomplete-dropdown-placeholder">
          <label class="item-content">
            <div class="item-inner">
              <div class="item-title">${item.text}</div>
            </div>
          </label>
        </li>
      `;
      }
      return itemHtml.trim();
    }

    renderNavbar() {
      const ac = this;
      if (ac.params.renderNavbar) return ac.params.renderNavbar.call(ac);
      let pageTitle = ac.params.pageTitle;
      if (typeof pageTitle === 'undefined' && ac.$openerEl && ac.$openerEl.length) {
        pageTitle = ac.$openerEl.find('.item-title').text().trim();
      }
      const inPopup = ac.params.openIn === 'popup';
      const navbarLeft = inPopup
        ? `
        ${ac.params.preloader ? `
        <div class="left">
          ${ac.renderPreloader()}
        </div>
        ` : ''}
      `
        : `
        <div class="left sliding">
          <a class="link back">
            <i class="icon icon-back"></i>
            <span class="if-not-md">${ac.params.pageBackLinkText}</span>
          </a>
        </div>
      `;
      const navbarRight = inPopup
        ? `
        <div class="right">
          <a class="link popup-close" data-popup=".autocomplete-popup">
            ${ac.params.popupCloseLinkText}
          </a>
        </div>
      `
        : `
        ${ac.params.preloader ? `
        <div class="right">
          ${ac.renderPreloader()}
        </div>
        ` : ''}
      `;
      const navbarHtml = `
      <div class="navbar ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ''}">
        <div class="navbar-bg"></div>
        <div class="navbar-inner ${ac.params.navbarColorTheme ? `color-${ac.params.navbarColorTheme}` : ''}">
          ${navbarLeft}
          ${pageTitle ? `<div class="title sliding">${pageTitle}</div>` : ''}
          ${navbarRight}
          <div class="subnavbar sliding">${ac.renderSearchbar()}</div>
        </div>
      </div>
    `.trim();
      return navbarHtml;
    }

    renderDropdown() {
      const ac = this;
      if (ac.params.renderDropdown) return ac.params.renderDropdown.call(ac, ac.items);
      const dropdownHtml = `
      <div class="autocomplete-dropdown">
        <div class="autocomplete-dropdown-inner">
          <div class="list ${!ac.params.expandInput ? 'no-safe-areas' : ''}">
            <ul></ul>
          </div>
        </div>
        ${ac.params.preloader ? ac.renderPreloader() : ''}
      </div>
    `.trim();
      return dropdownHtml;
    }

    renderPage(inPopup) {
      const ac = this;
      if (ac.params.renderPage) return ac.params.renderPage.call(ac, ac.items);

      const pageHtml = `
      <div class="page page-with-subnavbar autocomplete-page" data-name="autocomplete-page">
        ${ac.renderNavbar(inPopup)}
        <div class="searchbar-backdrop"></div>
        <div class="page-content">
          <div class="list autocomplete-list autocomplete-found autocomplete-list-${ac.id} ${ac.params.formColorTheme ? `color-${ac.params.formColorTheme}` : ''}">
            <ul></ul>
          </div>
          <div class="list autocomplete-not-found">
            <ul>
              <li class="item-content"><div class="item-inner"><div class="item-title">${ac.params.notFoundText}</div></div></li>
            </ul>
          </div>
          <div class="list autocomplete-values">
            <ul></ul>
          </div>
        </div>
      </div>
    `.trim();
      return pageHtml;
    }

    renderPopup() {
      const ac = this;
      if (ac.params.renderPopup) return ac.params.renderPopup.call(ac, ac.items);
      const popupHtml = `
      <div class="popup autocomplete-popup">
        <div class="view">
          ${ac.renderPage(true)};
        </div>
      </div>
    `.trim();
      return popupHtml;
    }

    onOpen(type, el) {
      const ac = this;
      const app = ac.app;
      const $el = $(el);
      ac.$el = $el;
      ac.el = $el[0];
      ac.openedIn = type;
      ac.opened = true;

      if (ac.params.openIn === 'dropdown') {
        ac.attachDropdownEvents();

        ac.$dropdownEl.addClass('autocomplete-dropdown-in');
        ac.$inputEl.trigger('input');
      } else {
        // Init SB
        let $searchbarEl = $el.find('.searchbar');
        if (ac.params.openIn === 'page' && app.theme === 'ios' && $searchbarEl.length === 0) {
          $searchbarEl = $(app.navbar.getElByPage($el)).find('.searchbar');
        }
        ac.searchbar = app.searchbar.create({
          el: $searchbarEl,
          backdropEl: $el.find('.searchbar-backdrop'),
          customSearch: true,
          on: {
            search(sb, query) {
              if (query.length === 0 && ac.searchbar.enabled) {
                ac.searchbar.backdropShow();
              } else {
                ac.searchbar.backdropHide();
              }
              ac.source(query);
            },
          },
        });

        // Attach page events
        ac.attachPageEvents();

        // Update Values On Page Init
        ac.updateValues();

        // Source on load
        if (ac.params.requestSourceOnOpen) ac.source('');
      }

      ac.emit('local::open autocompleteOpen', ac);
    }

    autoFocus() {
      const ac = this;
      if (ac.searchbar && ac.searchbar.$inputEl) {
        ac.searchbar.$inputEl.focus();
      }
      return ac;
    }

    onOpened() {
      const ac = this;
      if (ac.params.openIn !== 'dropdown' && ac.params.autoFocus) {
        ac.autoFocus();
      }
      ac.emit('local::opened autocompleteOpened', ac);
    }

    onClose() {
      const ac = this;
      if (ac.destroyed) return;

      // Destroy SB
      if (ac.searchbar && ac.searchbar.destroy) {
        ac.searchbar.destroy();
        ac.searchbar = null;
        delete ac.searchbar;
      }

      if (ac.params.openIn === 'dropdown') {
        ac.detachDropdownEvents();
        ac.$dropdownEl.removeClass('autocomplete-dropdown-in').remove();
        ac.$inputEl.parents('.item-content-dropdown-expanded').removeClass('item-content-dropdown-expanded');
      } else {
        ac.detachPageEvents();
      }

      ac.emit('local::close autocompleteClose', ac);
    }

    onClosed() {
      const ac = this;
      if (ac.destroyed) return;
      ac.opened = false;
      ac.$el = null;
      ac.el = null;
      delete ac.$el;
      delete ac.el;

      ac.emit('local::closed autocompleteClosed', ac);
    }

    openPage() {
      const ac = this;
      if (ac.opened) return ac;
      const pageHtml = ac.renderPage();
      ac.view.router.navigate({
        url: ac.url,
        route: {
          content: pageHtml,
          path: ac.url,
          on: {
            pageBeforeIn(e, page) {
              ac.onOpen('page', page.el);
            },
            pageAfterIn(e, page) {
              ac.onOpened('page', page.el);
            },
            pageBeforeOut(e, page) {
              ac.onClose('page', page.el);
            },
            pageAfterOut(e, page) {
              ac.onClosed('page', page.el);
            },
          },
          options: {
            animate: ac.params.animate,
          },
        },
      });
      return ac;
    }

    openPopup() {
      const ac = this;
      if (ac.opened) return ac;
      const popupHtml = ac.renderPopup();

      const popupParams = {
        content: popupHtml,
        animate: ac.params.animate,
        push: ac.params.popupPush,
        swipeToClose: ac.params.popupSwipeToClose,
        on: {
          popupOpen(popup) {
            ac.onOpen('popup', popup.el);
          },
          popupOpened(popup) {
            ac.onOpened('popup', popup.el);
          },
          popupClose(popup) {
            ac.onClose('popup', popup.el);
          },
          popupClosed(popup) {
            ac.onClosed('popup', popup.el);
          },
        },
      };

      if (ac.params.routableModals && ac.view) {
        ac.view.router.navigate({
          url: ac.url,
          route: {
            path: ac.url,
            popup: popupParams,
          },
        });
      } else {
        ac.modal = ac.app.popup.create(popupParams).open(ac.params.animate);
      }
      return ac;
    }

    openDropdown() {
      const ac = this;

      if (!ac.$dropdownEl) {
        ac.$dropdownEl = $(ac.renderDropdown());
      }
      const $listEl = ac.$inputEl.parents('.list');
      if ($listEl.length && ac.$inputEl.parents('.item-content').length > 0 && ac.params.expandInput) {
        ac.$inputEl.parents('.item-content').addClass('item-content-dropdown-expanded');
      }

      const $pageContentEl = ac.$inputEl.parents('.page-content');
      if (ac.params.dropdownContainerEl) {
        $(ac.params.dropdownContainerEl).append(ac.$dropdownEl);
      } else if ($pageContentEl.length === 0) {
        ac.$dropdownEl.insertAfter(ac.$inputEl);
      } else {
        ac.positionDropdown();
        $pageContentEl.append(ac.$dropdownEl);
      }
      ac.onOpen('dropdown', ac.$dropdownEl);
      ac.onOpened('dropdown', ac.$dropdownEl);
    }

    open() {
      const ac = this;
      if (ac.opened) return ac;
      const openIn = ac.params.openIn;
      ac[`open${openIn.split('').map((el, index) => {
      if (index === 0) return el.toUpperCase();
      return el;
    }).join('')}`]();
      return ac;
    }

    close() {
      const ac = this;
      if (!ac.opened) return ac;
      if (ac.params.openIn === 'dropdown') {
        ac.onClose();
        ac.onClosed();
      } else if ((ac.params.routableModals && ac.view) || ac.openedIn === 'page') {
        ac.view.router.back({ animate: ac.params.animate });
      } else {
        ac.modal.once('modalClosed', () => {
          Utils.nextTick(() => {
            if (ac.destroyed) return;
            ac.modal.destroy();
            delete ac.modal;
          });
        });
        ac.modal.close();
      }
      return ac;
    }

    init() {
      const ac = this;
      ac.attachEvents();
    }

    destroy() {
      const ac = this;
      ac.emit('local::beforeDestroy autocompleteBeforeDestroy', ac);
      ac.detachEvents();
      if (ac.$inputEl && ac.$inputEl[0]) {
        delete ac.$inputEl[0].f7Autocomplete;
      }
      if (ac.$openerEl && ac.$openerEl[0]) {
        delete ac.$openerEl[0].f7Autocomplete;
      }
      Utils.deleteProps(ac);
      ac.destroyed = true;
    }
  }

  var Autocomplete$1 = {
    name: 'autocomplete',
    params: {
      autocomplete: {
        openerEl: undefined,
        inputEl: undefined,
        view: undefined,

        // DropDown
        dropdownContainerEl: undefined,
        dropdownPlaceholderText: undefined,
        typeahead: false,
        highlightMatches: true,
        expandInput: false,
        updateInputValueOnSelect: true,
        inputEvents: 'input',

        value: undefined,
        multiple: false,

        source: undefined,
        limit: undefined,
        valueProperty: 'id',
        textProperty: 'text',

        openIn: 'page', // or 'popup' or 'dropdown'
        pageBackLinkText: 'Back',
        popupCloseLinkText: 'Close',
        pageTitle: undefined,
        searchbarPlaceholder: 'Search...',
        searchbarDisableText: 'Cancel',
        searchbarDisableButton: undefined,

        popupPush: false,
        popupSwipeToClose: undefined,

        animate: true,

        autoFocus: false,
        closeOnSelect: false,
        notFoundText: 'Nothing found',
        requestSourceOnOpen: false,

        // Preloader
        preloaderColor: undefined,
        preloader: false,

        // Colors
        formColorTheme: undefined,
        navbarColorTheme: undefined,

        // Routing
        routableModals: true,
        url: 'select/',

        // Custom render functions
        renderDropdown: undefined,
        renderPage: undefined,
        renderPopup: undefined,
        renderItem: undefined,
        renderSearchbar: undefined,
        renderNavbar: undefined,

      },
    },
    static: {
      Autocomplete,
    },
    create() {
      const app = this;
      app.autocomplete = Utils.extend(
        ConstructorMethods({
          defaultSelector: undefined,
          constructor: Autocomplete,
          app,
          domProp: 'f7Autocomplete',
        }),
        {
          open(autocompleteEl) {
            const ac = app.autocomplete.get(autocompleteEl);
            if (ac && ac.open) return ac.open();
            return undefined;
          },
          close(autocompleteEl) {
            const ac = app.autocomplete.get(autocompleteEl);
            if (ac && ac.close) return ac.close();
            return undefined;
          },
        }
      );
    },
  };

  class Tooltip extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);

      const tooltip = this;

      const defaults = Utils.extend({}, app.params.tooltip);

      // Extend defaults with modules params
      tooltip.useModulesParams(defaults);

      tooltip.params = Utils.extend(defaults, params);

      const { targetEl } = tooltip.params;
      if (!targetEl) return tooltip;

      const $targetEl = $(targetEl);
      if ($targetEl.length === 0) return tooltip;

      if ($targetEl[0].f7Tooltip) return $targetEl[0].f7Tooltip;

      const $el = $(tooltip.render()).eq(0);

      Utils.extend(tooltip, {
        app,
        $targetEl,
        targetEl: $targetEl && $targetEl[0],
        $el,
        el: $el && $el[0],
        text: tooltip.params.text || '',
        visible: false,
        opened: false,
      });

      $targetEl[0].f7Tooltip = tooltip;

      const touchesStart = {};
      let isTouched;
      function handleClick() {
        if (tooltip.opened) tooltip.hide();
        else tooltip.show(this);
      }
      function handleClickOut(e) {
        if (tooltip.opened && (
          $(e.target).closest($targetEl).length
          || $(e.target).closest(tooltip.$el).length
        )) return;
        tooltip.hide();
      }
      function handleTouchStart(e) {
        if (isTouched) return;
        isTouched = true;
        touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        tooltip.show(this);
      }
      function handleTouchMove(e) {
        if (!isTouched) return;
        const x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        const y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        const distance = (
          ((x - touchesStart.x) ** 2)
          + ((y - touchesStart.y) ** 2)
        ) ** 0.5;
        if (distance > 50) {
          isTouched = false;
          tooltip.hide();
        }
      }
      function handleTouchEnd() {
        if (!isTouched) return;
        isTouched = false;
        tooltip.hide();
      }
      function handleMouseEnter() {
        tooltip.show(this);
      }
      function handleMouseLeave() {
        tooltip.hide();
      }
      function handleTransitionEnd() {
        if (!$el.hasClass('tooltip-in')) {
          $el.removeClass('tooltip-out').remove();
        }
      }

      tooltip.attachEvents = function attachEvents() {
        $el.on('transitionend', handleTransitionEnd);
        if (tooltip.params.trigger === 'click') {
          $targetEl.on('click', handleClick);
          $('html').on('click', handleClickOut);
          return;
        }
        if (Support.touch) {
          const passive = Support.passiveListener ? { passive: true } : false;
          $targetEl.on(app.touchEvents.start, handleTouchStart, passive);
          app.on('touchmove', handleTouchMove);
          app.on('touchend:passive', handleTouchEnd);
        } else {
          $targetEl.on((Support.pointerEvents ? 'pointerenter' : 'mouseenter'), handleMouseEnter);
          $targetEl.on((Support.pointerEvents ? 'pointerleave' : 'mouseleave'), handleMouseLeave);
        }
      };
      tooltip.detachEvents = function detachEvents() {
        $el.off('transitionend', handleTransitionEnd);
        if (tooltip.params.trigger === 'click') {
          $targetEl.off('click', handleClick);
          $('html').off('click', handleClickOut);
          return;
        }
        if (Support.touch) {
          const passive = Support.passiveListener ? { passive: true } : false;
          $targetEl.off(app.touchEvents.start, handleTouchStart, passive);
          app.off('touchmove', handleTouchMove);
          app.off('touchend:passive', handleTouchEnd);
        } else {
          $targetEl.off((Support.pointerEvents ? 'pointerenter' : 'mouseenter'), handleMouseEnter);
          $targetEl.off((Support.pointerEvents ? 'pointerleave' : 'mouseleave'), handleMouseLeave);
        }
      };

      // Install Modules
      tooltip.useModules();

      tooltip.init();

      return tooltip;
    }

    position(targetEl) {
      const tooltip = this;
      const { $el, app } = tooltip;
      const tooltipOffset = tooltip.params.offset || 0;
      $el.css({ left: '', top: '' });
      const $targetEl = $(targetEl || tooltip.targetEl);
      const [width, height] = [$el.width(), $el.height()];

      $el.css({ left: '', top: '' });

      let targetWidth;
      let targetHeight;
      let targetOffsetLeft;
      let targetOffsetTop;
      if ($targetEl && $targetEl.length > 0) {
        targetWidth = $targetEl.outerWidth();
        targetHeight = $targetEl.outerHeight();

        const targetOffset = $targetEl.offset();
        targetOffsetLeft = targetOffset.left - app.left;
        targetOffsetTop = targetOffset.top - app.top;

        const targetParentPage = $targetEl.parents('.page');
        if (targetParentPage.length > 0) {
          targetOffsetTop -= targetParentPage[0].scrollTop;
        }
      }
      let [left, top] = [0, 0, 0];

      // Top Position
      let position = 'top';

      if (height + tooltipOffset < targetOffsetTop) {
        // On top
        top = targetOffsetTop - height - tooltipOffset;
      } else if (height < app.height - targetOffsetTop - targetHeight) {
        // On bottom
        position = 'bottom';
        top = targetOffsetTop + targetHeight + tooltipOffset;
      } else {
        // On middle
        position = 'middle';
        top = ((targetHeight / 2) + targetOffsetTop) - (height / 2);
        if (top <= 0) {
          top = 8;
        } else if (top + height >= app.height) {
          top = app.height - height - 8;
        }
      }

      // Horizontal Position
      if (position === 'top' || position === 'bottom') {
        left = ((targetWidth / 2) + targetOffsetLeft) - (width / 2);
        if (left < 8) left = 8;
        if (left + width > app.width) left = app.width - width - 8;
        if (left < 0) left = 0;
      } else if (position === 'middle') {
        left = targetOffsetLeft - width;
        if (left < 8 || (left + width > app.width)) {
          if (left < 8) left = targetOffsetLeft + targetWidth;
          if (left + width > app.width) left = app.width - width - 8;
        }
      }

      // Apply Styles
      $el.css({ top: `${top}px`, left: `${left}px` });
    }

    show(aroundEl) {
      const tooltip = this;
      const { app, $el, $targetEl } = tooltip;
      app.root.append($el);
      tooltip.position(aroundEl);
      const $aroundEl = $(aroundEl);
      tooltip.visible = true;
      tooltip.opened = true;
      $targetEl.trigger('tooltip:show');
      $el.trigger('tooltip:show');
      if ($aroundEl.length && $aroundEl[0] !== $targetEl[0]) {
        $aroundEl.trigger('tooltip:show');
      }
      tooltip.emit('local::show tooltipShow', tooltip);
      $el.removeClass('tooltip-out').addClass('tooltip-in');
      return tooltip;
    }

    hide() {
      const tooltip = this;
      const { $el, $targetEl } = tooltip;
      tooltip.visible = false;
      tooltip.opened = false;
      $targetEl.trigger('tooltip:hide');
      $el.trigger('tooltip:hide');
      tooltip.emit('local::hide tooltipHide', tooltip);
      $el.addClass('tooltip-out').removeClass('tooltip-in');
      return tooltip;
    }

    render() {
      const tooltip = this;
      if (tooltip.params.render) return tooltip.params.render.call(tooltip, tooltip);
      const { cssClass, text } = tooltip.params;
      return `
      <div class="tooltip ${cssClass || ''}">
        <div class="tooltip-content">${text || ''}</div>
      </div>
    `.trim();
    }

    setText(newText) {
      const tooltip = this;
      if (typeof newText === 'undefined') {
        return tooltip;
      }
      tooltip.params.text = newText;
      tooltip.text = newText;
      if (tooltip.$el) {
        tooltip.$el.children('.tooltip-content').html(newText);
      }
      if (tooltip.opened) {
        tooltip.position();
      }
      return tooltip;
    }

    init() {
      const tooltip = this;
      tooltip.attachEvents();
    }

    destroy() {
      const tooltip = this;
      if (!tooltip.$targetEl || tooltip.destroyed) return;
      tooltip.$targetEl.trigger('tooltip:beforedestroy');
      tooltip.emit('local::beforeDestroy tooltipBeforeDestroy', tooltip);
      tooltip.$el.remove();
      delete tooltip.$targetEl[0].f7Tooltip;
      tooltip.detachEvents();
      Utils.deleteProps(tooltip);
      tooltip.destroyed = true;
    }
  }

  var Tooltip$1 = {
    name: 'tooltip',
    static: {
      Tooltip,
    },
    create() {
      const app = this;
      app.tooltip = ConstructorMethods({
        defaultSelector: '.tooltip',
        constructor: Tooltip,
        app,
        domProp: 'f7Tooltip',
      });
      app.tooltip.show = function show(el) {
        const $el = $(el);
        if ($el.length === 0) return undefined;
        const tooltip = $el[0].f7Tooltip;
        if (!tooltip) return undefined;
        tooltip.show($el[0]);
        return tooltip;
      };
      app.tooltip.hide = function hide(el) {
        const $el = $(el);
        if ($el.length === 0) return undefined;
        const tooltip = $el[0].f7Tooltip;
        if (!tooltip) return undefined;
        tooltip.hide();
        return tooltip;
      };
      app.tooltip.setText = function text(el, newText) {
        const $el = $(el);
        if ($el.length === 0) return undefined;
        const tooltip = $el[0].f7Tooltip;
        if (!tooltip) return undefined;
        tooltip.setText(newText);
        return tooltip;
      };
    },
    params: {
      tooltip: {
        targetEl: null,
        text: null,
        cssClass: null,
        render: null,
        offset: 0,
        trigger: 'hover',
      },
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.tooltip-init').each((index, el) => {
          const text = $(el).attr('data-tooltip');
          if (!text) return;
          app.tooltip.create({ targetEl: el, text });
        });
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.tooltip-init').each((index, el) => {
          if (el.f7Tooltip) el.f7Tooltip.destroy();
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.tooltip-init').each((index, el) => {
          const text = $(el).attr('data-tooltip');
          if (!text) return;
          app.tooltip.create({ targetEl: el, text });
        });
        if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
          page.$navbarEl.find('.tooltip-init').each((index, el) => {
            const text = $(el).attr('data-tooltip');
            if (!text) return;
            app.tooltip.create({ targetEl: el, text });
          });
        }
      },
      pageBeforeRemove(page) {
        const app = this;
        page.$el.find('.tooltip-init').each((index, el) => {
          if (el.f7Tooltip) el.f7Tooltip.destroy();
        });
        if (app.theme === 'ios' && page.view && page.view.router.dynamicNavbar && page.$navbarEl && page.$navbarEl.length > 0) {
          page.$navbarEl.find('.tooltip-init').each((index, el) => {
            if (el.f7Tooltip) el.f7Tooltip.destroy();
          });
        }
      },
    },
    vnode: {
      'tooltip-init': {
        insert(vnode) {
          const app = this;
          const el = vnode.elm;
          const text = $(el).attr('data-tooltip');
          if (!text) return;
          app.tooltip.create({ targetEl: el, text });
        },
        update(vnode) {
          const el = vnode.elm;
          if (!el.f7Tooltip) return;
          if (vnode && vnode.data && vnode.data.attrs && vnode.data.attrs['data-tooltip']) {
            el.f7Tooltip.setText(vnode.data.attrs['data-tooltip']);
          }
        },
        destroy(vnode) {
          const el = vnode.elm;
          if (el.f7Tooltip) el.f7Tooltip.destroy();
        },
      },
    },
  };

  /* eslint no-nested-ternary: off */

  class Gauge extends Framework7Class {
    constructor(app, params = {}) {
      // Extends with open/close Modal methods;
      super(params, [app]);

      const gauge = this;

      const defaults = Utils.extend({}, app.params.gauge);

      // Extend defaults with modules params
      gauge.useModulesParams(defaults);

      gauge.params = Utils.extend(defaults, params);

      const { el } = gauge.params;
      if (!el) return gauge;

      const $el = $(el);
      if ($el.length === 0) return gauge;

      if ($el[0].f7Gauge) return $el[0].f7Gauge;

      Utils.extend(gauge, {
        app,
        $el,
        el: $el && $el[0],
      });

      $el[0].f7Gauge = gauge;

      // Install Modules
      gauge.useModules();

      gauge.init();

      return gauge;
    }

    calcRadius() {
      const gauge = this;
      const { size, borderWidth } = gauge.params;
      return (size / 2) - (borderWidth / 2);
    }

    calcBorderLength() {
      const gauge = this;
      const radius = gauge.calcRadius();
      return 2 * Math.PI * radius;
    }

    render() {
      const gauge = this;
      if (gauge.params.render) return gauge.params.render.call(gauge, gauge);

      const {
        type,
        value,
        size,
        bgColor,
        borderBgColor,
        borderColor,
        borderWidth,
        valueText,
        valueTextColor,
        valueFontSize,
        valueFontWeight,
        labelText,
        labelTextColor,
        labelFontSize,
        labelFontWeight,
      } = gauge.params;

      const semiCircle = type === 'semicircle';
      const radius = gauge.calcRadius();
      const length = gauge.calcBorderLength();
      const progress = Math.max(Math.min(value, 1), 0);

      return `
      <svg class="gauge-svg" width="${size}px" height="${semiCircle ? size / 2 : size}px" viewBox="0 0 ${size} ${semiCircle ? size / 2 : size}">
        ${semiCircle ? `
          <path
            class="gauge-back-semi"
            d="M${size - (borderWidth / 2)},${size / 2} a1,1 0 0,0 -${size - borderWidth},0"
            stroke="${borderBgColor}"
            stroke-width="${borderWidth}"
            fill="${bgColor || 'none'}"
          />
          <path
            class="gauge-front-semi"
            d="M${size - (borderWidth / 2)},${size / 2} a1,1 0 0,0 -${size - borderWidth},0"
            stroke="${borderColor}"
            stroke-width="${borderWidth}"
            stroke-dasharray="${length / 2}"
            stroke-dashoffset="${(length / 2) * (1 + progress)}"
            fill="${borderBgColor ? 'none' : (bgColor || 'none')}"
          />
        ` : `
          ${borderBgColor ? `
            <circle
              class="gauge-back-circle"
              stroke="${borderBgColor}"
              stroke-width="${borderWidth}"
              fill="${bgColor || 'none'}"
              cx="${size / 2}"
              cy="${size / 2}"
              r="${radius}"
            ></circle>
          ` : ''}
          <circle
            class="gauge-front-circle"
            transform="${`rotate(-90 ${size / 2} ${size / 2})`}"
            stroke="${borderColor}"
            stroke-width="${borderWidth}"
            stroke-dasharray="${length}"
            stroke-dashoffset="${length * (1 - progress)}"
            fill="${borderBgColor ? 'none' : bgColor || 'none'}"
            cx="${size / 2}"
            cy="${size / 2}"
            r="${radius}"
          ></circle>
        `}
        ${valueText ? `
          <text
            class="gauge-value-text"
            x="50%"
            y="${semiCircle ? '100%' : '50%'}"
            font-weight="${valueFontWeight}"
            font-size="${valueFontSize}"
            fill="${valueTextColor}"
            dy="${semiCircle ? (labelText ? -labelFontSize - 15 : -5) : 0}"
            text-anchor="middle"
            dominant-baseline="${!semiCircle && 'middle'}"
          >${valueText}</text>
        ` : ''}
        ${labelText ? `
          <text
            class="gauge-label-text"
            x="50%"
            y="${semiCircle ? '100%' : '50%'}"
            font-weight="${labelFontWeight}"
            font-size="${labelFontSize}"
            fill="${labelTextColor}"
            dy="${semiCircle ? -5 : (valueText ? ((valueFontSize / 2) + 10) : 0)}"
            text-anchor="middle"
            dominant-baseline="${!semiCircle && 'middle'}"
          >${labelText}</text>
        ` : ''}
      </svg>
    `.trim();
    }

    update(newParams = {}) {
      const gauge = this;
      const { params, $gaugeSvgEl } = gauge;

      Object.keys(newParams).forEach((param) => {
        if (typeof newParams[param] !== 'undefined') {
          params[param] = newParams[param];
        }
      });
      if ($gaugeSvgEl.length === 0) return gauge;

      const {
        value,
        size,
        bgColor,
        borderBgColor,
        borderColor,
        borderWidth,
        valueText,
        valueTextColor,
        valueFontSize,
        valueFontWeight,
        labelText,
        labelTextColor,
        labelFontSize,
        labelFontWeight,
      } = params;

      const length = gauge.calcBorderLength();
      const progress = Math.max(Math.min(value, 1), 0);
      const radius = gauge.calcRadius();
      const semiCircle = params.type === 'semicircle';

      const svgAttrs = {
        width: `${size}px`,
        height: `${semiCircle ? size / 2 : size}px`,
        viewBox: `0 0 ${size} ${semiCircle ? size / 2 : size}`,
      };
      Object.keys(svgAttrs).forEach((attr) => {
        $gaugeSvgEl.attr(attr, svgAttrs[attr]);
      });
      if (semiCircle) {
        const backAttrs = {
          d: `M${size - (borderWidth / 2)},${size / 2} a1,1 0 0,0 -${size - borderWidth},0`,
          stroke: borderBgColor,
          'stroke-width': borderWidth,
          fill: bgColor || 'none',
        };
        const frontAttrs = {
          d: `M${size - (borderWidth / 2)},${size / 2} a1,1 0 0,0 -${size - borderWidth},0`,
          stroke: borderColor,
          'stroke-width': borderWidth,
          'stroke-dasharray': length / 2,
          'stroke-dashoffset': (length / 2) * (1 + progress),
          fill: borderBgColor ? 'none' : (bgColor || 'none'),
        };
        Object.keys(backAttrs).forEach((attr) => {
          $gaugeSvgEl.find('.gauge-back-semi').attr(attr, backAttrs[attr]);
        });
        Object.keys(frontAttrs).forEach((attr) => {
          $gaugeSvgEl.find('.gauge-front-semi').attr(attr, frontAttrs[attr]);
        });
      } else {
        const backAttrs = {
          stroke: borderBgColor,
          'stroke-width': borderWidth,
          fill: bgColor || 'none',
          cx: size / 2,
          cy: size / 2,
          r: radius,
        };
        const frontAttrs = {
          transform: `rotate(-90 ${size / 2} ${size / 2})`,
          stroke: borderColor,
          'stroke-width': borderWidth,
          'stroke-dasharray': length,
          'stroke-dashoffset': length * (1 - progress),
          fill: borderBgColor ? 'none' : bgColor || 'none',
          cx: size / 2,
          cy: size / 2,
          r: radius,
        };
        Object.keys(backAttrs).forEach((attr) => {
          $gaugeSvgEl.find('.gauge-back-circle').attr(attr, backAttrs[attr]);
        });
        Object.keys(frontAttrs).forEach((attr) => {
          $gaugeSvgEl.find('.gauge-front-circle').attr(attr, frontAttrs[attr]);
        });
      }
      if (valueText) {
        if (!$gaugeSvgEl.find('.gauge-value-text').length) {
          $gaugeSvgEl.append('<text class="gauge-value-text"></text>');
        }
        const textAttrs = {
          x: '50%',
          y: semiCircle ? '100%' : '50%',
          'font-weight': valueFontWeight,
          'font-size': valueFontSize,
          fill: valueTextColor,
          dy: semiCircle ? (labelText ? -labelFontSize - 15 : -5) : 0,
          'text-anchor': 'middle',
          'dominant-baseline': !semiCircle && 'middle',
        };
        Object.keys(textAttrs).forEach((attr) => {
          $gaugeSvgEl.find('.gauge-value-text').attr(attr, textAttrs[attr]);
        });
        $gaugeSvgEl.find('.gauge-value-text').text(valueText);
      } else {
        $gaugeSvgEl.find('.gauge-value-text').remove();
      }
      if (labelText) {
        if (!$gaugeSvgEl.find('.gauge-label-text').length) {
          $gaugeSvgEl.append('<text class="gauge-label-text"></text>');
        }
        const labelAttrs = {
          x: '50%',
          y: semiCircle ? '100%' : '50%',
          'font-weight': labelFontWeight,
          'font-size': labelFontSize,
          fill: labelTextColor,
          dy: semiCircle ? -5 : (valueText ? ((valueFontSize / 2) + 10) : 0),
          'text-anchor': 'middle',
          'dominant-baseline': !semiCircle && 'middle',
        };
        Object.keys(labelAttrs).forEach((attr) => {
          $gaugeSvgEl.find('.gauge-label-text').attr(attr, labelAttrs[attr]);
        });
        $gaugeSvgEl.find('.gauge-label-text').text(labelText);
      } else {
        $gaugeSvgEl.find('.gauge-label-text').remove();
      }
      return gauge;
    }

    init() {
      const gauge = this;
      const $gaugeSvgEl = $(gauge.render()).eq(0);
      $gaugeSvgEl.f7Gauge = gauge;
      Utils.extend(gauge, {
        $gaugeSvgEl,
        gaugeSvgEl: $gaugeSvgEl && $gaugeSvgEl[0],
      });
      gauge.$el.append($gaugeSvgEl);
      return gauge;
    }

    destroy() {
      const gauge = this;
      if (!gauge.$el || gauge.destroyed) return;
      gauge.$el.trigger('gauge:beforedestroy');
      gauge.emit('local::beforeDestroy gaugeBeforeDestroy', gauge);
      gauge.$gaugeSvgEl.remove();
      delete gauge.$el[0].f7Gauge;
      Utils.deleteProps(gauge);
      gauge.destroyed = true;
    }
  }

  var Gauge$1 = {
    name: 'gauge',
    static: {
      Gauge,
    },
    create() {
      const app = this;
      app.gauge = ConstructorMethods({
        defaultSelector: '.gauge',
        constructor: Gauge,
        app,
        domProp: 'f7Gauge',
      });
      app.gauge.update = function update(el, newParams) {
        const $el = $(el);
        if ($el.length === 0) return undefined;
        const gauge = app.gauge.get(el);
        if (!gauge) return undefined;
        gauge.update(newParams);
        return gauge;
      };
    },
    params: {
      gauge: {
        el: null,
        type: 'circle',
        value: 0,
        size: 200,
        bgColor: 'transparent',
        borderBgColor: '#eeeeee',
        borderColor: '#000000',
        borderWidth: 10,
        valueText: null,
        valueTextColor: '#000000',
        valueFontSize: 31,
        valueFontWeight: 500,
        labelText: null,
        labelTextColor: '#888888',
        labelFontSize: 14,
        labelFontWeight: 400,
      },
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.gauge-init').each((index, el) => {
          app.gauge.create(Utils.extend({ el }, $(el).dataset() || {}));
        });
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.gauge-init').each((index, el) => {
          if (el.f7Gauge) el.f7Gauge.destroy();
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.gauge-init').each((index, el) => {
          app.gauge.create(Utils.extend({ el }, $(el).dataset() || {}));
        });
      },
      pageBeforeRemove(page) {
        page.$el.find('.gauge-init').each((index, el) => {
          if (el.f7Gauge) el.f7Gauge.destroy();
        });
      },
    },
    vnode: {
      'gauge-init': {
        insert(vnode) {
          const app = this;
          const el = vnode.elm;
          app.gauge.create(Utils.extend({ el }, $(el).dataset() || {}));
        },
        destroy(vnode) {
          const el = vnode.elm;
          if (el.f7Gauge) el.f7Gauge.destroy();
        },
      },
    },
  };

  var Skeleton = {
    name: 'skeleton',
  };

  const Menu = {
    open(el = '.menu-item-dropdown') {
      const app = this;
      if (!el) return;
      const $el = $(el).closest('.menu-item-dropdown');
      if (!$el.length) return;
      const $menuEl = $el.closest('.menu').eq(0);
      if ($menuEl.length) {
        const zIndex = $menuEl.css('z-index');
        const originalZIndex = $menuEl[0].style.zIndex;
        $menuEl.css('z-index', parseInt(zIndex || 0, 0) + 1);
        $menuEl[0].f7MenuZIndex = originalZIndex;
      }
      $el.eq(0).addClass('menu-item-dropdown-opened').trigger('menu:opened');
      app.emit('menuOpened', $el.eq(0)[0]);
    },
    close(el = '.menu-item-dropdown-opened') {
      const app = this;
      if (!el) return;
      const $el = $(el).closest('.menu-item-dropdown-opened');
      if (!$el.length) return;
      const $menuEl = $el.closest('.menu').eq(0);
      if ($menuEl.length) {
        const zIndex = $menuEl[0].f7MenuZIndex;
        $menuEl.css('z-index', zIndex);
        delete $menuEl[0].f7MenuZIndex;
      }
      $el.eq(0).removeClass('menu-item-dropdown-opened').trigger('menu:closed');
      app.emit('menuClosed', $el.eq(0)[0]);
    },
  };

  var Menu$1 = {
    name: 'menu',
    create() {
      const app = this;
      app.menu = {
        open: Menu.open.bind(app),
        close: Menu.close.bind(app),
      };
    },
    on: {
      click(e) {
        const app = this;
        const openedMenus = $('.menu-item-dropdown-opened');
        if (!openedMenus.length) return;
        openedMenus.each((index, el) => {
          if (!$(e.target).closest('.menu-item-dropdown-opened').length) {
            app.menu.close(el);
          }
        });
      },
    },
    clicks: {
      '.menu-item-dropdown': function onClick($clickedEl, dataset, e) {
        const app = this;
        if ($clickedEl.hasClass('menu-item-dropdown-opened')) {
          if ($(e.target).closest('.menu-dropdown').length) return;
          app.menu.close($clickedEl);
        } else {
          app.menu.open($clickedEl);
        }
      },
      '.menu-close': function onClick() {
        const app = this;
        app.menu.close();
      },
    },
  };

  var moduleAlphaSlider = {
    render(self) {
      const { sliderLabel, sliderValue, sliderValueEditable, alphaLabelText } = self.params;
      return `
      <div class="color-picker-module color-picker-module-alpha-slider">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${alphaLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-alpha"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.01" min="0" max="1" class="color-picker-value-alpha">
              ` : `
                <span class="color-picker-value-alpha"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
    },
    init(self) {
      self.alphaRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-alpha'),
        min: 0,
        max: 1,
        step: 0.01,
        value: 1,
        on: {
          change(range, value) {
            const alpha = Math.floor(value * 100) / 100;
            self.setValue({ alpha });
          },
        },
      });
      function handleInputChange(e) {
        const alpha = self.value.alpha;
        let value = parseFloat(e.target.value);
        if (Number.isNaN(value)) {
          e.target.value = alpha;
          return;
        }
        value = Math.max(0, Math.min(1, value));
        self.setValue({ alpha: value });
      }

      self.$el.on('change', '.color-picker-module-alpha-slider input', handleInputChange);

      self.destroyAlphaSliderEvents = function destroyAlphaSliderEvents() {
        self.$el.off('change', '.color-picker-module-alpha-slider input', handleInputChange);
      };
    },
    update(self) {
      const {
        value,
      } = self;
      const { sliderValue, sliderValueEditable } = self.params;

      const { alpha } = value;
      self.alphaRangeSlider.value = alpha;
      self.alphaRangeSlider.layout();
      if (sliderValue && sliderValueEditable) {
        self.$el.find('input.color-picker-value-alpha').val(alpha);
      } else {
        self.$el.find('span.color-picker-value-alpha').text(alpha);
      }
    },
    destroy(self) {
      if (self.alphaRangeSlider && self.alphaRangeSlider.destroy) {
        self.alphaRangeSlider.destroy();
      }
      delete self.alphaRangeSlider;

      if (self.destroyAlphaSliderEvents) self.destroyAlphaSliderEvents();
      delete self.destroyAlphaSliderEvents;
    },
  };

  var moduleCurrentColor = {
    render() {
      return `
      <div class="color-picker-module color-picker-module-current-color">
        <div class="color-picker-current-color"></div>
      </div>
    `;
    },
    update(self) {
      self.$el.find('.color-picker-module-current-color .color-picker-current-color').css(
        'background-color',
        self.value.hex,
      );
    },
  };

  var moduleHex = {
    render(self) {
      const { hexLabel, hexLabelText, hexValueEditable } = self.params;
      return `
      <div class="color-picker-module color-picker-module-hex">
        <div class="color-picker-hex-wrap">
          ${hexLabel ? `
            <div class="color-picker-hex-label">${hexLabelText}</div>
          ` : ''}
          <div class="color-picker-hex-value">
            ${hexValueEditable ? `
              <input type="text" class="color-picker-value-hex">
            ` : `
              <span class="color-picker-value-hex"></span>
            `}
          </div>
        </div>
      </div>
    `;
    },
    init(self) {
      function handleInputChange(e) {
        const hex = self.value.hex;
        let value = e.target.value.replace(/#/g, '');
        if (Number.isNaN(value) || !value || (value.length !== 3 && value.length !== 6)) {
          e.target.value = hex;
          return;
        }
        const min = 0;
        const current = parseInt(value, 16);
        const max = parseInt('ffffff', 16); // eslint-disable-line
        if (current > max) {
          value = 'fff';
        }
        if (current < min) {
          value = '000';
        }
        self.setValue({ hex: value });
      }

      self.$el.on('change', '.color-picker-module-hex input', handleInputChange);

      self.destroyHexEvents = function destroyHexEvents() {
        self.$el.off('change', '.color-picker-module-hex input', handleInputChange);
      };
    },
    update(self) {
      const {
        value,
      } = self;

      const { hexValueEditable } = self.params;

      const { hex } = value;
      if (hexValueEditable) {
        self.$el.find('input.color-picker-value-hex').val(hex);
      } else {
        self.$el.find('span.color-picker-value-hex').text(hex);
      }
    },
    destroy(self) {
      if (self.destroyHexEvents) self.destroyHexEvents();
      delete self.destroyHexEvents;
    },
  };

  var moduleHsbSliders = {
    render(self) {
      const { sliderLabel, sliderValue, sliderValueEditable, hueLabelText, saturationLabelText, brightnessLabelText } = self.params;
      return `
      <div class="color-picker-module color-picker-module-hsb-sliders">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${hueLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-hue"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="360" class="color-picker-value-hue" data-color-index="0">
              ` : `
                <span class="color-picker-value-hue"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${saturationLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-saturation"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="100" class="color-picker-value-saturation" data-color-index="1">
              ` : `
                <span class="color-picker-value-saturation"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${brightnessLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-brightness"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="100" class="color-picker-value-brightness" data-color-index="2">
              ` : `
                <span class="color-picker-value-brightness"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
    },
    init(self) {
      self.hueRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-hue'),
        min: 0,
        max: 360,
        step: 0.1,
        value: 0,
        on: {
          change(range, value) {
            self.setValue({ hue: value });
          },
        },
      });
      self.saturationRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-saturation'),
        min: 0,
        max: 1,
        step: 0.001,
        value: 0,
        on: {
          change(range, value) {
            const s = Math.floor(value * 1000) / 1000;
            self.setValue({ hsb: [self.value.hsb[0], s, self.value.hsb[2]] });
          },
        },
      });
      self.brightnessRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-brightness'),
        min: 0,
        max: 1,
        step: 0.001,
        value: 0,
        on: {
          change(range, value) {
            const b = Math.floor(value * 1000) / 1000;
            self.setValue({ hsb: [self.value.hsb[0], self.value.hsb[1], b] });
          },
        },
      });

      function handleInputChange(e) {
        const hsb = [...self.value.hsb];
        const index = parseInt($(e.target).attr('data-color-index'), 10);
        let value = parseFloat(e.target.value);
        if (Number.isNaN(value)) {
          e.target.value = hsb[index];
          return;
        }
        if (index === 0) {
          value = Math.max(0, Math.min(360, value));
        } else {
          value = Math.max(0, Math.min(100, value)) / 100;
        }

        hsb[index] = value;
        self.setValue({ hsb });
      }

      self.$el.on('change', '.color-picker-module-hsb-sliders input', handleInputChange);

      self.destroyHsbSlidersEvents = function destroyHsbSlidersEvents() {
        self.$el.off('change', '.color-picker-module-hsb-sliders input', handleInputChange);
      };
    },
    update(self) {
      const {
        app,
        value,
      } = self;
      const { sliderValue, sliderValueEditable } = self.params;

      const { hsb, hue } = value;

      self.hueRangeSlider.value = hue;
      self.saturationRangeSlider.value = hsb[1];
      self.brightnessRangeSlider.value = hsb[2];

      self.hueRangeSlider.layout();
      self.saturationRangeSlider.layout();
      self.brightnessRangeSlider.layout();

      const hslCurrent = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);
      const hslLeft = Utils.colorHsbToHsl(hsb[0], 0, 1);
      const hslRight = Utils.colorHsbToHsl(hsb[0], 1, 1);
      const brightness = hsb[2];

      self.hueRangeSlider.$el[0].style.setProperty(
        '--f7-range-knob-color',
        `hsl(${hue}, 100%, 50%)`
      );
      self.saturationRangeSlider.$el[0].style.setProperty(
        '--f7-range-knob-color',
        `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`
      );
      self.brightnessRangeSlider.$el[0].style.setProperty(
        '--f7-range-knob-color',
        `rgb(${brightness * 255}, ${brightness * 255}, ${brightness * 255})`
      );
      self.saturationRangeSlider.$el.find('.range-bar').css(
        'background-image',
        `linear-gradient(${app.rtl ? 'to left' : 'to right'}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`
      );

      if (sliderValue && sliderValueEditable) {
        self.$el.find('input.color-picker-value-hue').val(`${hue}`);
        self.$el.find('input.color-picker-value-saturation').val(`${hsb[1] * 1000 / 10}`);
        self.$el.find('input.color-picker-value-brightness').val(`${hsb[2] * 1000 / 10}`);
      } else if (sliderValue) {
        self.$el.find('span.color-picker-value-hue').text(`${hue}`);
        self.$el.find('span.color-picker-value-saturation').text(`${hsb[1] * 1000 / 10}`);
        self.$el.find('span.color-picker-value-brightness').text(`${hsb[2] * 1000 / 10}`);
      }
    },
    destroy(self) {
      if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
        self.hueRangeSlider.destroy();
      }
      if (self.saturationRangeSlider && self.saturationRangeSlider.destroy) {
        self.saturationRangeSlider.destroy();
      }
      if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
        self.brightnessRangeSlider.destroy();
      }

      delete self.hueRangeSlider;
      delete self.saturationRangeSlider;
      delete self.brightnessRangeSlider;

      if (self.destroyHsbSlidersEvents) self.destroyHsbSlidersEvents();
      delete self.destroyHsbSlidersEvents;
    },
  };

  var moduleHueSlider = {
    render(self) {
      const { sliderLabel, sliderValue, sliderValueEditable, hueLabelText } = self.params;
      return `
      <div class="color-picker-module color-picker-module-hue-slider">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${hueLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-hue"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="360" class="color-picker-value-hue">
              ` : `
                <span class="color-picker-value-hue"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
    },
    init(self) {
      self.hueRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-hue'),
        min: 0,
        max: 360,
        step: 0.1,
        value: 0,
        on: {
          change(range, value) {
            self.setValue({ hue: value });
          },
        },
      });
    },
    update(self) {
      const {
        value,
      } = self;
      const { sliderValue, sliderValueEditable } = self.params;

      const { hue } = value;

      self.hueRangeSlider.value = hue;
      self.hueRangeSlider.layout();
      self.hueRangeSlider.$el[0].style.setProperty(
        '--f7-range-knob-color',
        `hsl(${hue}, 100%, 50%)`
      );
      if (sliderValue && sliderValueEditable) {
        self.$el.find('input.color-picker-value-hue').val(`${hue}`);
      } else if (sliderValue) {
        self.$el.find('span.color-picker-value-hue').text(`${hue}`);
      }
    },
    destroy(self) {
      if (self.hueRangeSlider && self.hueRangeSlider.destroy) {
        self.hueRangeSlider.destroy();
      }
      delete self.hueRangeSlider;
    },
  };

  var moduleBrightnessSlider = {
    render(self) {
      const { sliderLabel, sliderValue, sliderValueEditable, brightnessLabelText } = self.params;
      return `
      <div class="color-picker-module color-picker-module-brightness-slider">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${brightnessLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-brightness"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="0.1" min="0" max="100" class="color-picker-value-brightness">
              ` : `
                <span class="color-picker-value-brightness"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
    },
    init(self) {
      self.brightnessRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-brightness'),
        min: 0,
        max: 1,
        step: 0.001,
        value: 0,
        on: {
          change(range, value) {
            const b = Math.floor(value * 1000) / 1000;
            self.setValue({ hsb: [self.value.hsb[0], self.value.hsb[1], b] });
          },
        },
      });
    },
    update(self) {
      const {
        value,
        app,
      } = self;
      const { sliderValue, sliderValueEditable } = self.params;

      const { hsb } = value;

      self.brightnessRangeSlider.value = hsb[2];
      self.brightnessRangeSlider.layout();

      const hslCurrent = Utils.colorHsbToHsl(hsb[0], hsb[1], hsb[2]);
      const hslLeft = Utils.colorHsbToHsl(hsb[0], hsb[1], 0);
      const hslRight = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);

      self.brightnessRangeSlider.$el[0].style.setProperty(
        '--f7-range-knob-color',
        `hsl(${hslCurrent[0]}, ${hslCurrent[1] * 100}%, ${hslCurrent[2] * 100}%)`
      );
      self.brightnessRangeSlider.$el.find('.range-bar').css(
        'background-image',
        `linear-gradient(${app.rtl ? 'to left' : 'to right'}, hsl(${hslLeft[0]}, ${hslLeft[1] * 100}%, ${hslLeft[2] * 100}%), hsl(${hslRight[0]}, ${hslRight[1] * 100}%, ${hslRight[2] * 100}%))`
      );
      if (sliderValue && sliderValueEditable) {
        self.$el.find('input.color-picker-value-brightness').val(`${hsb[2] * 1000 / 10}`);
      } else if (sliderValue) {
        self.$el.find('span.color-picker-value-brightness').text(`${hsb[2] * 1000 / 10}`);
      }
    },
    destroy(self) {
      if (self.brightnessRangeSlider && self.brightnessRangeSlider.destroy) {
        self.brightnessRangeSlider.destroy();
      }
      delete self.brightnessRangeSlider;
    },
  };

  /* eslint indent: ["off"] */

  var modulePalette = {
    render(self) {
      return `
      <div class="color-picker-module color-picker-module-palette">
        <div class="color-picker-palette">
          ${self.params.palette.map((p) => {
            if (Array.isArray(p)) {
              let row = '<div class="color-picker-palette-row">';
              row += p.map(c => `
                <div class="color-picker-palette-value" data-palette-color="${c}" style="background-color: ${c}"></div>
              `).join('');
              row += '</div>';
              return row;
            }
            return `
              <div class="color-picker-palette-value" data-palette-color="${p}" style="background-color: ${p}"></div>
            `;
          }).join('')}
        </div>
      </div>
    `;
    },
    init(self) {
      function handlePaletteClick(e) {
        const hex = $(e.target).attr('data-palette-color');
        self.setValue({
          hex,
        });
      }

      self.$el.on('click', '.color-picker-module-palette .color-picker-palette-value', handlePaletteClick);

      self.destroyPaletteEvents = function destroyPaletteEvents() {
        self.$el.off('click', '.color-picker-module-hex input', handlePaletteClick);
      };
    },
    destroy(self) {
      if (self.destroyPaletteEvents) {
        self.destroyPaletteEvents();
      }
      delete self.destroyPaletteEvents;
    },
  };

  var moduleInitialCurrentColors = {
    render() {
      return `
      <div class="color-picker-module color-picker-module-initial-current-colors">
        <div class="color-picker-initial-current-colors">
          <div class="color-picker-initial-color"></div>
          <div class="color-picker-current-color"></div>
        </div>
      </div>
    `;
    },
    init(self) {
      function handleInitialColorClick() {
        if (self.initialValue) {
          const { hex, alpha } = self.initialValue;
          self.setValue({
            hex,
            alpha,
          });
        }
      }
      self.$el.on('click', '.color-picker-initial-color', handleInitialColorClick);
      self.destroyInitialCurrentEvents = function destroyInitialCurrentEvents() {
        self.$el.off('click', '.color-picker-initial-color', handleInitialColorClick);
      };
    },
    update(self) {
      self.$el.find('.color-picker-module-initial-current-colors .color-picker-initial-color').css(
        'background-color',
        self.initialValue.hex,
      );
      self.$el.find('.color-picker-module-initial-current-colors .color-picker-current-color').css(
        'background-color',
        self.value.hex,
      );
    },
    destroy(self) {
      if (self.destroyInitialCurrentEvents) {
        self.destroyInitialCurrentEvents();
      }
      delete self.destroyInitialCurrentEvents;
    },
  };

  var moduleRgbBars = {
    render(self) {
      const { barLabel, barValue, barValueEditable, redLabelText, greenLabelText, blueLabelText } = self.params;
      return `
      <div class="color-picker-module color-picker-module-rgb-bars">
        <div class="color-picker-bar-wrap">
          ${barLabel ? `
            <div class="color-picker-bar-label">${redLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-bar color-picker-bar-red"></div>
          ${barValue ? `
            <div class="color-picker-bar-value">
              ${barValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-bar-red" data-color-index="0">
              ` : `
                <span class="color-picker-value-bar-red"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-bar-wrap">
          ${barLabel ? `
            <div class="color-picker-bar-label">${greenLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-bar color-picker-bar-green"></div>
          ${barValue ? `
            <div class="color-picker-bar-value">
              ${barValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-bar-green" data-color-index="1">
              ` : `
                <span class="color-picker-value-bar-green"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-bar-wrap">
          ${barLabel ? `
            <div class="color-picker-bar-label">${blueLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-bar color-picker-bar-blue"></div>
          ${barValue ? `
            <div class="color-picker-bar-value">
              ${barValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-bar-blue" data-color-index="2">
              ` : `
                <span class="color-picker-value-bar-blue"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
    },
    init(self) {
      self.redBar = self.app.range.create({
        el: self.$el.find('.color-picker-bar-red'),
        min: 0,
        max: 255,
        step: 1,
        value: 0,
        vertical: true,
        on: {
          change(range, value) {
            self.setValue({ rgb: [value, self.value.rgb[1], self.value.rgb[2]] });
          },
        },
      });
      self.greenBar = self.app.range.create({
        el: self.$el.find('.color-picker-bar-green'),
        min: 0,
        max: 255,
        step: 1,
        value: 0,
        vertical: true,
        on: {
          change(range, value) {
            self.setValue({ rgb: [self.value.rgb[0], value, self.value.rgb[2]] });
          },
        },
      });
      self.blueBar = self.app.range.create({
        el: self.$el.find('.color-picker-bar-blue'),
        min: 0,
        max: 255,
        step: 1,
        value: 0,
        vertical: true,
        on: {
          change(range, value) {
            self.setValue({ rgb: [self.value.rgb[0], self.value.rgb[1], value] });
          },
        },
      });

      function handleInputChange(e) {
        const rgb = [...self.value.rgb];
        const index = parseInt($(e.target).attr('data-color-index'), 10);
        let value = parseInt(e.target.value, 10);
        if (Number.isNaN(value)) {
          e.target.value = rgb[index];
          return;
        }
        value = Math.max(0, Math.min(255, value));
        rgb[index] = value;
        self.setValue({ rgb });
      }

      self.$el.on('change', '.color-picker-module-rgb-bars input', handleInputChange);

      self.destroyRgbBarsEvents = function destroyRgbBarsEvents() {
        self.$el.off('change', '.color-picker-module-rgb-bars input', handleInputChange);
      };
    },
    update(self) {
      const {
        value,
        redBar,
        greenBar,
        blueBar,
      } = self;

      const { barValue, barValueEditable } = self.params;

      const { rgb } = value;

      redBar.value = rgb[0];
      greenBar.value = rgb[1];
      blueBar.value = rgb[2];

      redBar.layout();
      greenBar.layout();
      blueBar.layout();

      redBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
      greenBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
      blueBar.$el.find('.range-bar').css('background-image', `linear-gradient(to top, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);

      if (barValue && barValueEditable) {
        self.$el.find('input.color-picker-value-bar-red').val(rgb[0]);
        self.$el.find('input.color-picker-value-bar-green').val(rgb[1]);
        self.$el.find('input.color-picker-value-bar-blue').val(rgb[2]);
      } else if (barValue) {
        self.$el.find('span.color-picker-value-bar-red').text(rgb[0]);
        self.$el.find('span.color-picker-value-bar-green').text(rgb[1]);
        self.$el.find('span.color-picker-value-bar-blue').text(rgb[2]);
      }
    },
    destroy(self) {
      if (self.redBar && self.redBar.destroy) {
        self.redBar.destroy();
      }
      if (self.greenBar && self.greenBar.destroy) {
        self.greenBar.destroy();
      }
      if (self.blueBar && self.blueBar.destroy) {
        self.blueBar.destroy();
      }

      delete self.redBar;
      delete self.greenBar;
      delete self.blueBar;

      if (self.destroyRgbBarsEvents) self.destroyRgbBarsEvents();
      delete self.destroyRgbBarsEvents;
    },
  };

  var moduleRgbSliders = {
    render(self) {
      const { sliderLabel, sliderValue, sliderValueEditable, redLabelText, greenLabelText, blueLabelText } = self.params;
      return `
      <div class="color-picker-module color-picker-module-rgb-sliders">
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${redLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-red"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-red" data-color-index="0">
              ` : `
                <span class="color-picker-value-red"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${greenLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-green"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-green" data-color-index="1">
              ` : `
                <span class="color-picker-value-green"></span>
              `}
            </div>
          ` : ''}
        </div>
        <div class="color-picker-slider-wrap">
          ${sliderLabel ? `
            <div class="color-picker-slider-label">${blueLabelText}</div>
          ` : ''}
          <div class="range-slider color-picker-slider color-picker-slider-blue"></div>
          ${sliderValue ? `
            <div class="color-picker-slider-value">
              ${sliderValueEditable ? `
                <input type="number" step="1" min="0" max="255" class="color-picker-value-blue" data-color-index="2">
              ` : `
                <span class="color-picker-value-blue"></span>
              `}
            </div>
          ` : ''}
        </div>
      </div>
    `;
    },
    init(self) {
      self.redRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-red'),
        min: 0,
        max: 255,
        step: 1,
        value: 0,
        on: {
          change(range, value) {
            self.setValue({ rgb: [value, self.value.rgb[1], self.value.rgb[2]] });
          },
        },
      });
      self.greenRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-green'),
        min: 0,
        max: 255,
        step: 1,
        value: 0,
        on: {
          change(range, value) {
            self.setValue({ rgb: [self.value.rgb[0], value, self.value.rgb[2]] });
          },
        },
      });
      self.blueRangeSlider = self.app.range.create({
        el: self.$el.find('.color-picker-slider-blue'),
        min: 0,
        max: 255,
        step: 1,
        value: 0,
        on: {
          change(range, value) {
            self.setValue({ rgb: [self.value.rgb[0], self.value.rgb[1], value] });
          },
        },
      });

      function handleInputChange(e) {
        const rgb = [...self.value.rgb];
        const index = parseInt($(e.target).attr('data-color-index'), 10);
        let value = parseInt(e.target.value, 10);
        if (Number.isNaN(value)) {
          e.target.value = rgb[index];
          return;
        }
        value = Math.max(0, Math.min(255, value));
        rgb[index] = value;
        self.setValue({ rgb });
      }

      self.$el.on('change', '.color-picker-module-rgb-sliders input', handleInputChange);

      self.destroyRgbSlidersEvents = function destroyRgbSlidersEvents() {
        self.$el.off('change', '.color-picker-module-rgb-sliders input', handleInputChange);
      };
    },
    update(self) {
      const {
        app,
        value,
        redRangeSlider,
        greenRangeSlider,
        blueRangeSlider,
      } = self;

      const { sliderValue, sliderValueEditable } = self.params;

      const { rgb } = value;

      redRangeSlider.value = rgb[0];
      greenRangeSlider.value = rgb[1];
      blueRangeSlider.value = rgb[2];

      redRangeSlider.layout();
      greenRangeSlider.layout();
      blueRangeSlider.layout();

      redRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
      greenRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);
      blueRangeSlider.$el[0].style.setProperty('--f7-range-knob-color', `rgb(${rgb[0]}, ${rgb[1]}, ${rgb[2]})`);

      const direction = app.rtl ? 'to left' : 'to right';

      redRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(0, ${rgb[1]}, ${rgb[2]}), rgb(255, ${rgb[1]}, ${rgb[2]}))`);
      greenRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(${rgb[0]}, 0, ${rgb[2]}), rgb(${rgb[0]}, 255, ${rgb[2]}))`);
      blueRangeSlider.$el.find('.range-bar').css('background-image', `linear-gradient(${direction}, rgb(${rgb[0]}, ${rgb[1]}, 0), rgb(${rgb[0]}, ${rgb[1]}, 255))`);

      if (sliderValue && sliderValueEditable) {
        self.$el.find('input.color-picker-value-red').val(rgb[0]);
        self.$el.find('input.color-picker-value-green').val(rgb[1]);
        self.$el.find('input.color-picker-value-blue').val(rgb[2]);
      } else if (sliderValue) {
        self.$el.find('span.color-picker-value-red').text(rgb[0]);
        self.$el.find('span.color-picker-value-green').text(rgb[1]);
        self.$el.find('span.color-picker-value-blue').text(rgb[2]);
      }
    },
    destroy(self) {
      if (self.redRangeSlider && self.redRangeSlider.destroy) {
        self.redRangeSlider.destroy();
      }
      if (self.greenRangeSlider && self.greenRangeSlider.destroy) {
        self.greenRangeSlider.destroy();
      }
      if (self.blueRangeSlider && self.blueRangeSlider.destroy) {
        self.blueRangeSlider.destroy();
      }

      delete self.redRangeSlider;
      delete self.greenRangeSlider;
      delete self.blueRangeSlider;

      if (self.destroyRgbSlidersEvents) self.destroyRgbSlidersEvents();
      delete self.destroyRgbSlidersEvents;
    },
  };

  var moduleSbSpectrum = {
    render() {
      return `
      <div class="color-picker-module color-picker-module-sb-spectrum">
        <div class="color-picker-sb-spectrum" style="background-color: hsl(0, 100%, 50%)">
          <div class="color-picker-sb-spectrum-handle"></div>
        </div>
      </div>
    `;
    },
    init(self) {
      const { app } = self;

      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;

      let specterRect;
      let specterIsTouched;
      let specterHandleIsTouched;

      const { $el } = self;

      function setSBFromSpecterCoords(x, y) {
        let s = (x - specterRect.left) / specterRect.width;
        let b = (y - specterRect.top) / specterRect.height;
        s = Math.max(0, Math.min(1, s));
        b = 1 - Math.max(0, Math.min(1, b));

        self.setValue({ hsb: [self.value.hue, s, b] });
      }

      function handleTouchStart(e) {
        if (isMoved || isTouched) return;
        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        const $targetEl = $(e.target);
        specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;
        if (!specterHandleIsTouched) {
          specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
        }
        if (specterIsTouched) {
          specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
          setSBFromSpecterCoords(touchStartX, touchStartY);
        }
        if (specterHandleIsTouched || specterIsTouched) {
          $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
        }
      }
      function handleTouchMove(e) {
        if (!(specterIsTouched || specterHandleIsTouched)) return;
        touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        e.preventDefault();
        if (!isMoved) {
          // First move
          isMoved = true;
          if (specterHandleIsTouched) {
            specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
          }
        }
        if (specterIsTouched || specterHandleIsTouched) {
          setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
        }
      }
      function handleTouchEnd() {
        isMoved = false;
        if (specterIsTouched || specterHandleIsTouched) {
          $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
        }
        specterIsTouched = false;
        specterHandleIsTouched = false;
      }

      function handleResize() {
        self.modules['sb-spectrum'].update(self);
      }

      const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

      self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('resize', handleResize);

      self.destroySpectrumEvents = function destroySpectrumEvents() {
        self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        app.off('resize', handleResize);
      };
    },
    update(self) {
      const {
        value,
      } = self;

      const { hsl, hsb } = value;

      const specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
      const specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;

      self.$el.find('.color-picker-sb-spectrum')
        .css('background-color', `hsl(${hsl[0]}, 100%, 50%)`);

      self.$el.find('.color-picker-sb-spectrum-handle')
        .css('background-color', `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`)
        .transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
    },
    destroy(self) {
      if (self.destroySpectrumEvents) self.destroySpectrumEvents();
      delete self.destroySpectrumEvents;
    },
  };

  var moduleHsSpectrum = {
    render() {
      return `
      <div class="color-picker-module color-picker-module-hs-spectrum">
        <div class="color-picker-hs-spectrum">
          <div class="color-picker-hs-spectrum-handle"></div>
        </div>
      </div>
    `;
    },
    init(self) {
      const { app } = self;

      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;

      let specterRect;
      let specterIsTouched;
      let specterHandleIsTouched;

      const { $el } = self;

      function setHSFromSpecterCoords(x, y) {
        let h = (x - specterRect.left) / specterRect.width * 360;
        let s = (y - specterRect.top) / specterRect.height;
        h = Math.max(0, Math.min(360, h));
        s = 1 - Math.max(0, Math.min(1, s));

        self.setValue({ hsb: [h, s, self.value.hsb[2]] });
      }

      function handleTouchStart(e) {
        if (isMoved || isTouched) return;
        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        const $targetEl = $(e.target);
        specterHandleIsTouched = $targetEl.closest('.color-picker-hs-spectrum-handle').length > 0;
        if (!specterHandleIsTouched) {
          specterIsTouched = $targetEl.closest('.color-picker-hs-spectrum').length > 0;
        }
        if (specterIsTouched) {
          specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
          setHSFromSpecterCoords(touchStartX, touchStartY);
        }
        if (specterHandleIsTouched || specterIsTouched) {
          $el.find('.color-picker-hs-spectrum-handle').addClass('color-picker-hs-spectrum-handle-pressed');
        }
      }
      function handleTouchMove(e) {
        if (!(specterIsTouched || specterHandleIsTouched)) return;
        touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        e.preventDefault();
        if (!isMoved) {
          // First move
          isMoved = true;
          if (specterHandleIsTouched) {
            specterRect = $el.find('.color-picker-hs-spectrum')[0].getBoundingClientRect();
          }
        }
        if (specterIsTouched || specterHandleIsTouched) {
          setHSFromSpecterCoords(touchCurrentX, touchCurrentY);
        }
      }
      function handleTouchEnd() {
        isMoved = false;
        if (specterIsTouched || specterHandleIsTouched) {
          $el.find('.color-picker-hs-spectrum-handle').removeClass('color-picker-hs-spectrum-handle-pressed');
        }
        specterIsTouched = false;
        specterHandleIsTouched = false;
      }

      function handleResize() {
        self.modules['hs-spectrum'].update(self);
      }

      const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

      self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('resize', handleResize);

      self.destroySpectrumEvents = function destroySpectrumEvents() {
        self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        app.off('resize', handleResize);
      };
    },
    update(self) {
      const {
        value,
      } = self;

      const { hsb } = value;

      const specterWidth = self.$el.find('.color-picker-hs-spectrum')[0].offsetWidth;
      const specterHeight = self.$el.find('.color-picker-hs-spectrum')[0].offsetHeight;

      const hslBright = Utils.colorHsbToHsl(hsb[0], hsb[1], 1);

      self.$el.find('.color-picker-hs-spectrum-handle')
        .css('background-color', `hsl(${hslBright[0]}, ${hslBright[1] * 100}%, ${hslBright[2] * 100}%)`)
        .transform(`translate(${specterWidth * (hsb[0] / 360)}px, ${specterHeight * (1 - hsb[1])}px)`);
    },
    destroy(self) {
      if (self.destroySpectrumEvents) self.destroySpectrumEvents();
      delete self.destroySpectrumEvents;
    },
  };

  function svgWheelCircles() {
    const total = 256;
    let circles = '';
    for (let i = total; i > 0; i -= 1) {
      const angle = i * Math.PI / (total / 2);
      const hue = 360 / total * i;
      circles += `<circle cx="${150 - Math.sin(angle) * 125}" cy="${150 - Math.cos(angle) * 125}" r="25" fill="hsl(${hue}, 100%, 50%)"></circle>`;
    }
    return circles;
  }
  var moduleWheel = {
    render() {
      return `
      <div class="color-picker-module color-picker-module-wheel">
        <div class="color-picker-wheel">
          <svg viewBox="0 0 300 300" width="300" height="300">${svgWheelCircles()}</svg>
          <div class="color-picker-wheel-handle"></div>
          <div class="color-picker-sb-spectrum" style="background-color: hsl(0, 100%, 50%)">
            <div class="color-picker-sb-spectrum-handle"></div>
          </div>
        </div>
      </div>
    `;
    },
    init(self) {
      const { app } = self;

      let isTouched;
      let isMoved;
      let touchStartX;
      let touchStartY;
      let touchCurrentX;
      let touchCurrentY;

      let wheelRect;
      let wheelIsTouched;
      let wheelHandleIsTouched;
      let specterRect;
      let specterIsTouched;
      let specterHandleIsTouched;

      const { $el } = self;

      function setHueFromWheelCoords(x, y) {
        const wheelCenterX = wheelRect.left + wheelRect.width / 2;
        const wheelCenterY = wheelRect.top + wheelRect.height / 2;
        const angleRad = Math.atan2(y - wheelCenterY, x - wheelCenterX);
        let angleDeg = angleRad * 180 / Math.PI + 90;
        if (angleDeg < 0) angleDeg += 360;
        angleDeg = 360 - angleDeg;
        self.setValue({ hue: angleDeg });
      }
      function setSBFromSpecterCoords(x, y) {
        let s = (x - specterRect.left) / specterRect.width;
        let b = (y - specterRect.top) / specterRect.height;
        s = Math.max(0, Math.min(1, s));
        b = 1 - Math.max(0, Math.min(1, b));

        self.setValue({ hsb: [self.value.hue, s, b] });
      }

      function handleTouchStart(e) {
        if (isMoved || isTouched) return;
        touchStartX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentX = touchStartX;
        touchStartY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
        touchCurrentY = touchStartY;
        const $targetEl = $(e.target);
        wheelHandleIsTouched = $targetEl.closest('.color-picker-wheel-handle').length > 0;
        wheelIsTouched = $targetEl.closest('circle').length > 0;
        specterHandleIsTouched = $targetEl.closest('.color-picker-sb-spectrum-handle').length > 0;
        if (!specterHandleIsTouched) {
          specterIsTouched = $targetEl.closest('.color-picker-sb-spectrum').length > 0;
        }
        if (wheelIsTouched) {
          wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
          setHueFromWheelCoords(touchStartX, touchStartY);
        }
        if (specterIsTouched) {
          specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
          setSBFromSpecterCoords(touchStartX, touchStartY);
        }
        if (specterHandleIsTouched || specterIsTouched) {
          $el.find('.color-picker-sb-spectrum-handle').addClass('color-picker-sb-spectrum-handle-pressed');
        }
      }
      function handleTouchMove(e) {
        if (!(wheelIsTouched || wheelHandleIsTouched) && !(specterIsTouched || specterHandleIsTouched)) return;
        touchCurrentX = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
        touchCurrentY = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;
        e.preventDefault();
        if (!isMoved) {
          // First move
          isMoved = true;
          if (wheelHandleIsTouched) {
            wheelRect = $el.find('.color-picker-wheel')[0].getBoundingClientRect();
          }
          if (specterHandleIsTouched) {
            specterRect = $el.find('.color-picker-sb-spectrum')[0].getBoundingClientRect();
          }
        }
        if (wheelIsTouched || wheelHandleIsTouched) {
          setHueFromWheelCoords(touchCurrentX, touchCurrentY);
        }
        if (specterIsTouched || specterHandleIsTouched) {
          setSBFromSpecterCoords(touchCurrentX, touchCurrentY);
        }
      }
      function handleTouchEnd() {
        isMoved = false;
        if (specterIsTouched || specterHandleIsTouched) {
          $el.find('.color-picker-sb-spectrum-handle').removeClass('color-picker-sb-spectrum-handle-pressed');
        }
        wheelIsTouched = false;
        wheelHandleIsTouched = false;
        specterIsTouched = false;
        specterHandleIsTouched = false;
      }

      function handleResize() {
        self.modules.wheel.update(self);
      }

      const passiveListener = app.touchEvents.start === 'touchstart' && app.support.passiveListener ? { passive: true, capture: false } : false;

      self.$el.on(app.touchEvents.start, handleTouchStart, passiveListener);
      app.on('touchmove:active', handleTouchMove);
      app.on('touchend:passive', handleTouchEnd);
      app.on('resize', handleResize);

      self.destroyWheelEvents = function destroyWheelEvents() {
        self.$el.off(app.touchEvents.start, handleTouchStart, passiveListener);
        app.off('touchmove:active', handleTouchMove);
        app.off('touchend:passive', handleTouchEnd);
        app.off('resize', handleResize);
      };
    },
    update(self) {
      const {
        value,
      } = self;

      const { hsl, hsb } = value;

      const specterWidth = self.$el.find('.color-picker-sb-spectrum')[0].offsetWidth;
      const specterHeight = self.$el.find('.color-picker-sb-spectrum')[0].offsetHeight;
      const wheelSize = self.$el.find('.color-picker-wheel')[0].offsetWidth;
      const wheelHalfSize = wheelSize / 2;
      const angleRad = value.hue * Math.PI / 180;
      const handleSize = wheelSize / 6;
      const handleHalfSize = handleSize / 2;
      const tX = wheelHalfSize - Math.sin(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
      const tY = wheelHalfSize - Math.cos(angleRad) * (wheelHalfSize - handleHalfSize) - handleHalfSize;
      self.$el.find('.color-picker-wheel-handle')
        .css('background-color', `hsl(${hsl[0]}, 100%, 50%)`)
        .transform(`translate(${tX}px, ${tY}px)`);

      self.$el.find('.color-picker-sb-spectrum')
        .css('background-color', `hsl(${hsl[0]}, 100%, 50%)`);

      self.$el.find('.color-picker-sb-spectrum-handle')
        .css('background-color', `hsl(${hsl[0]}, ${hsl[1] * 100}%, ${hsl[2] * 100}%)`)
        .transform(`translate(${specterWidth * hsb[1]}px, ${specterHeight * (1 - hsb[2])}px)`);
    },
    destroy(self) {
      if (self.destroyWheelEvents) self.destroyWheelEvents();
      delete self.destroyWheelEvents;
    },
  };

  class ColorPicker extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);
      const self = this;

      self.params = Utils.extend({}, app.params.colorPicker, params);

      let $containerEl;
      if (self.params.containerEl) {
        $containerEl = $(self.params.containerEl);
        if ($containerEl.length === 0) return self;
      }

      let $inputEl;
      if (self.params.inputEl) {
        $inputEl = $(self.params.inputEl);
      }

      let $targetEl;
      if (self.params.targetEl) {
        $targetEl = $(self.params.targetEl);
      }

      Utils.extend(self, {
        app,
        $containerEl,
        containerEl: $containerEl && $containerEl[0],
        inline: $containerEl && $containerEl.length > 0,
        $inputEl,
        inputEl: $inputEl && $inputEl[0],
        $targetEl,
        targetEl: $targetEl && $targetEl[0],
        initialized: false,
        opened: false,
        url: self.params.url,
        modules: {
          'alpha-slider': moduleAlphaSlider,
          'current-color': moduleCurrentColor,
          'hex': moduleHex, // eslint-disable-line
          'hsb-sliders': moduleHsbSliders,
          'hue-slider': moduleHueSlider,
          'brightness-slider': moduleBrightnessSlider,
          'palette': modulePalette, // eslint-disable-line
          'initial-current-colors': moduleInitialCurrentColors,
          'rgb-bars': moduleRgbBars,
          'rgb-sliders': moduleRgbSliders,
          'sb-spectrum': moduleSbSpectrum,
          'hs-spectrum': moduleHsSpectrum,
          'wheel': moduleWheel, // eslint-disable-line
        },
      });

      function onInputClick() {
        self.open();
      }
      function onInputFocus(e) {
        e.preventDefault();
      }
      function onTargetClick() {
        self.open();
      }
      function onHtmlClick(e) {
        if (self.destroyed || !self.params) return;
        if (self.params.openIn === 'page') return;
        const $clickTargetEl = $(e.target);
        if (!self.opened || self.closing) return;
        if ($clickTargetEl.closest('[class*="backdrop"]').length) return;
        if ($clickTargetEl.closest('.color-picker-popup, .color-picker-popover').length) return;
        if ($inputEl && $inputEl.length > 0) {
          if ($clickTargetEl[0] !== $inputEl[0] && $clickTargetEl.closest('.sheet-modal').length === 0) {
            self.close();
          }
        } else if ($(e.target).closest('.sheet-modal').length === 0) {
          self.close();
        }
      }

      // Events
      Utils.extend(self, {
        attachInputEvents() {
          self.$inputEl.on('click', onInputClick);
          if (self.params.inputReadOnly) {
            self.$inputEl.on('focus mousedown', onInputFocus);
          }
        },
        detachInputEvents() {
          self.$inputEl.off('click', onInputClick);
          if (self.params.inputReadOnly) {
            self.$inputEl.off('focus mousedown', onInputFocus);
          }
        },
        attachTargetEvents() {
          self.$targetEl.on('click', onTargetClick);
        },
        detachTargetEvents() {
          self.$targetEl.off('click', onTargetClick);
        },
        attachHtmlEvents() {
          app.on('click', onHtmlClick);
        },
        detachHtmlEvents() {
          app.off('click', onHtmlClick);
        },
      });

      self.init();

      return self;
    }

    get view() {
      const { $inputEl, $targetEl, app, params } = this;
      let view;
      if (params.view) {
        view = params.view;
      } else {
        if ($inputEl) {
          view = $inputEl.parents('.view').length && $inputEl.parents('.view')[0].f7View;
        }
        if (!view && $targetEl) {
          view = $targetEl.parents('.view').length && $targetEl.parents('.view')[0].f7View;
        }
      }
      if (!view) view = app.views.main;

      return view;
    }

    attachEvents() {
      const self = this;
      self.centerModules = self.centerModules.bind(self);
      if (self.params.centerModules) {
        self.app.on('resize', self.centerModules);
      }
    }

    detachEvents() {
      const self = this;
      if (self.params.centerModules) {
        self.app.off('resize', self.centerModules);
      }
    }

    centerModules() {
      const self = this;
      if (!self.opened || !self.$el || self.inline) return;
      const $pageContentEl = self.$el.find('.page-content');
      if (!$pageContentEl.length) return;
      const { scrollHeight, offsetHeight } = $pageContentEl[0];
      if (scrollHeight <= offsetHeight) {
        $pageContentEl.addClass('justify-content-center');
      } else {
        $pageContentEl.removeClass('justify-content-center');
      }
    }

    initInput() {
      const self = this;
      if (!self.$inputEl) return;
      if (self.params.inputReadOnly) self.$inputEl.prop('readOnly', true);
    }

    getModalType() {
      const self = this;
      const { app, modal, params } = self;
      const { openIn, openInPhone } = params;
      if (modal && modal.type) return modal.type;
      if (openIn !== 'auto') return openIn;
      if (self.inline) return null;
      if (app.device.ios) {
        return app.device.ipad ? 'popover' : openInPhone;
      }
      if (app.width >= 768 || (app.device.desktop && app.theme === 'aurora')) {
        return 'popover';
      }

      return openInPhone;
    }

    formatValue() {
      const self = this;
      const { value } = self;
      if (self.params.formatValue) {
        return self.params.formatValue.call(self, value);
      }
      return value.hex;
    }

    // eslint-disable-next-line
    normalizeHsValues(arr) {
      return [
        Math.floor(arr[0] * 10) / 10,
        Math.floor(arr[1] * 1000) / 1000,
        Math.floor(arr[2] * 1000) / 1000,
      ];
    }

    setValue(value = {}, updateModules = true) {
      const self = this;
      if (typeof value === 'undefined') return;

      let {
        hex,
        rgb,
        hsl,
        hsb,
        alpha = 1,
        hue,
        rgba,
        hsla,
      } = (self.value || {});

      const needChangeEvent = self.value || (!self.value && !self.params.value);
      let valueChanged;
      Object.keys(value).forEach((k) => {
        if (!self.value || typeof self.value[k] === 'undefined') {
          valueChanged = true;
          return;
        }
        const v = value[k];
        if (Array.isArray(v)) {
          v.forEach((subV, subIndex) => {
            if (subV !== self.value[k][subIndex]) {
              valueChanged = true;
            }
          });
        } else if (v !== self.value[k]) {
          valueChanged = true;
        }
      });
      if (!valueChanged) return;

      if (value.rgb || value.rgba) {
        const [r, g, b, a = alpha] = (value.rgb || value.rgba);
        rgb = [r, g, b];
        hex = Utils.colorRgbToHex(...rgb);
        hsl = Utils.colorRgbToHsl(...rgb);
        hsb = Utils.colorHslToHsb(...hsl);
        hsl = self.normalizeHsValues(hsl);
        hsb = self.normalizeHsValues(hsb);
        hue = hsb[0];
        alpha = a;
        rgba = [rgb[0], rgb[1], rgb[2], a];
        hsla = [hsl[0], hsl[1], hsl[2], a];
      }

      if (value.hsl || value.hsla) {
        const [h, s, l, a = alpha] = (value.hsl || value.hsla);
        hsl = [h, s, l];
        rgb = Utils.colorHslToRgb(...hsl);
        hex = Utils.colorRgbToHex(...rgb);
        hsb = Utils.colorHslToHsb(...hsl);
        hsl = self.normalizeHsValues(hsl);
        hsb = self.normalizeHsValues(hsb);
        hue = hsb[0];
        alpha = a;
        rgba = [rgb[0], rgb[1], rgb[2], a];
        hsla = [hsl[0], hsl[1], hsl[2], a];
      }

      if (value.hsb) {
        const [h, s, b, a = alpha] = value.hsb;
        hsb = [h, s, b];
        hsl = Utils.colorHsbToHsl(...hsb);
        rgb = Utils.colorHslToRgb(...hsl);
        hex = Utils.colorRgbToHex(...rgb);
        hsl = self.normalizeHsValues(hsl);
        hsb = self.normalizeHsValues(hsb);
        hue = hsb[0];
        alpha = a;
        rgba = [rgb[0], rgb[1], rgb[2], a];
        hsla = [hsl[0], hsl[1], hsl[2], a];
      }

      if (value.hex) {
        rgb = Utils.colorHexToRgb(value.hex);
        hex = Utils.colorRgbToHex(...rgb);
        hsl = Utils.colorRgbToHsl(...rgb);
        hsb = Utils.colorHslToHsb(...hsl);
        hsl = self.normalizeHsValues(hsl);
        hsb = self.normalizeHsValues(hsb);
        hue = hsb[0];
        rgba = [rgb[0], rgb[1], rgb[2], alpha];
        hsla = [hsl[0], hsl[1], hsl[2], alpha];
      }

      if (typeof value.alpha !== 'undefined') {
        alpha = value.alpha;
        if (typeof rgb !== 'undefined') {
          rgba = [rgb[0], rgb[1], rgb[2], alpha];
        }
        if (typeof hsl !== 'undefined') {
          hsla = [hsl[0], hsl[1], hsl[2], alpha];
        }
      }

      if (typeof value.hue !== 'undefined') {
        const [h, s, l] = hsl; // eslint-disable-line
        hsl = [value.hue, s, l];
        hsb = Utils.colorHslToHsb(...hsl);
        rgb = Utils.colorHslToRgb(...hsl);
        hex = Utils.colorRgbToHex(...rgb);
        hsl = self.normalizeHsValues(hsl);
        hsb = self.normalizeHsValues(hsb);
        hue = hsb[0];
        rgba = [rgb[0], rgb[1], rgb[2], alpha];
        hsla = [hsl[0], hsl[1], hsl[2], alpha];
      }
      self.value = {
        hex,
        alpha,
        hue,
        rgb,
        hsl,
        hsb,
        rgba,
        hsla,
      };
      if (!self.initialValue) self.initialValue = Utils.extend({}, self.value);
      self.updateValue(needChangeEvent);
      if (self.opened && updateModules) {
        self.updateModules();
      }
    }

    getValue() {
      const self = this;
      return self.value;
    }

    updateValue(fireEvents = true) {
      const self = this;
      const { $inputEl, value, $targetEl } = self;
      if ($targetEl && self.params.targetElSetBackgroundColor) {
        const { rgba } = value;
        $targetEl.css('background-color', `rgba(${rgba.join(', ')})`);
      }
      if (fireEvents) {
        self.emit('local::change colorPickerChange', self, value);
      }

      if ($inputEl && $inputEl.length) {
        const inputValue = self.formatValue(value);
        if ($inputEl && $inputEl.length) {
          $inputEl.val(inputValue);
          if (fireEvents) {
            $inputEl.trigger('change');
          }
        }
      }
    }

    updateModules() {
      const self = this;
      const { modules } = self;
      self.params.modules.forEach((m) => {
        if (typeof m === 'string' && modules[m] && modules[m].update) {
          modules[m].update(self);
        } else if (m && m.update) {
          m.update(self);
        }
      });
    }

    update() {
      const self = this;
      self.updateModules();
    }

    renderPicker() {
      const self = this;
      const { params, modules } = self;
      let html = '';

      params.modules.forEach((m) => {
        if (typeof m === 'string' && modules[m] && modules[m].render) {
          html += modules[m].render(self);
        } else if (m && m.render) {
          html += m.render(self);
        }
      });

      return html;
    }

    renderNavbar() {
      const self = this;
      if (self.params.renderNavbar) {
        return self.params.renderNavbar.call(self, self);
      }
      const { openIn, navbarTitleText, navbarBackLinkText, navbarCloseText } = self.params;
      return `
    <div class="navbar">
      <div class="navbar-bg"></div>
      <div class="navbar-inner sliding">
        ${openIn === 'page' ? `
        <div class="left">
          <a class="link back">
            <i class="icon icon-back"></i>
            <span class="if-not-md">${navbarBackLinkText}</span>
          </a>
        </div>
        ` : ''}
        <div class="title">${navbarTitleText}</div>
        ${openIn !== 'page' ? `
        <div class="right">
          <a class="link popup-close" data-popup=".color-picker-popup">${navbarCloseText}</a>
        </div>
        ` : ''}
      </div>
    </div>
  `.trim();
    }

    renderToolbar() {
      const self = this;
      if (self.params.renderToolbar) {
        return self.params.renderToolbar.call(self, self);
      }
      return `
    <div class="toolbar toolbar-top no-shadow">
      <div class="toolbar-inner">
        <div class="left"></div>
        <div class="right">
          <a class="link sheet-close popover-close" data-sheet=".color-picker-sheet-modal" data-popover=".color-picker-popover">${self.params.toolbarCloseText}</a>
        </div>
      </div>
    </div>
  `.trim();
    }

    renderInline() {
      const self = this;
      const { cssClass, groupedModules } = self.params;
      const inlineHtml = `
    <div class="color-picker color-picker-inline ${groupedModules ? 'color-picker-grouped-modules' : ''} ${cssClass || ''}">
      ${self.renderPicker()}
    </div>
  `.trim();

      return inlineHtml;
    }

    renderSheet() {
      const self = this;
      const { cssClass, toolbarSheet, groupedModules } = self.params;
      const sheetHtml = `
    <div class="sheet-modal color-picker color-picker-sheet-modal ${groupedModules ? 'color-picker-grouped-modules' : ''} ${cssClass || ''}">
      ${toolbarSheet ? self.renderToolbar() : ''}
      <div class="sheet-modal-inner">
        <div class="page-content">
          ${self.renderPicker()}
        </div>
      </div>
    </div>
  `.trim();

      return sheetHtml;
    }

    renderPopover() {
      const self = this;
      const { cssClass, toolbarPopover, groupedModules } = self.params;
      const popoverHtml = `
    <div class="popover color-picker-popover ${cssClass || ''}">
      <div class="popover-inner">
        <div class="color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}">
          ${toolbarPopover ? self.renderToolbar() : ''}
          <div class="page-content">
            ${self.renderPicker()}
          </div>
        </div>
      </div>
    </div>
  `.trim();

      return popoverHtml;
    }

    renderPopup() {
      const self = this;
      const { cssClass, navbarPopup, groupedModules } = self.params;
      const popupHtml = `
    <div class="popup color-picker-popup ${cssClass || ''}">
      <div class="page">
        ${navbarPopup ? self.renderNavbar() : ''}
        <div class="color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}">
          <div class="page-content">
            ${self.renderPicker()}
          </div>
        </div>
      </div>
    </div>
  `.trim();

      return popupHtml;
    }

    renderPage() {
      const self = this;
      const { cssClass, groupedModules } = self.params;
      const pageHtml = `
    <div class="page color-picker-page ${cssClass || ''}" data-name="color-picker-page">
      ${self.renderNavbar()}
      <div class="color-picker ${groupedModules ? 'color-picker-grouped-modules' : ''}">
        <div class="page-content">
          ${self.renderPicker()}
        </div>
      </div>
    </div>
  `.trim();
      return pageHtml;
    }

    // eslint-disable-next-line
    render() {
      const self = this;
      const { params } = self;
      if (params.render) return params.render.call(self);
      if (self.inline) return self.renderInline();
      if (params.openIn === 'page') {
        return self.renderPage();
      }

      const modalType = self.getModalType();
      if (modalType === 'popover') return self.renderPopover();
      if (modalType === 'sheet') return self.renderSheet();
      if (modalType === 'popup') return self.renderPopup();
    }

    onOpen() {
      const self = this;
      const { initialized, $el, app, $inputEl, inline, value, params, modules } = self;
      self.closing = false;
      self.opened = true;
      self.opening = true;

      // Init main events
      self.attachEvents();

      params.modules.forEach((m) => {
        if (typeof m === 'string' && modules[m] && modules[m].init) {
          modules[m].init(self);
        } else if (m && m.init) {
          m.init(self);
        }
      });

      const updateValue = !value && params.value;

      // Set value
      if (!initialized) {
        if (value) self.setValue(value);
        else if (params.value) {
          self.setValue(params.value, false);
        } else if (!params.value) {
          self.setValue({ hex: '#ff0000' }, false);
        }
      } else if (value) {
        self.initialValue = Utils.extend({}, value);
        self.setValue(value, false);
      }

      // Update input value
      if (updateValue) self.updateValue();
      self.updateModules();

      // Center modules
      if (params.centerModules) {
        self.centerModules();
      }

      // Extra focus
      if (!inline && $inputEl && $inputEl.length && app.theme === 'md') {
        $inputEl.trigger('focus');
      }

      self.initialized = true;

      // Trigger events
      if ($el) {
        $el.trigger('colorpicker:open');
      }
      if ($inputEl) {
        $inputEl.trigger('colorpicker:open');
      }
      self.emit('local::open colorPickerOpen', self);
    }

    onOpened() {
      const self = this;
      self.opening = false;
      if (self.$el) {
        self.$el.trigger('colorpicker:opened');
      }
      if (self.$inputEl) {
        self.$inputEl.trigger('colorpicker:opened');
      }
      self.emit('local::opened colorPickerOpened', self);
    }

    onClose() {
      const self = this;
      const { app, params, modules } = self;
      self.opening = false;
      self.closing = true;

      // Detach events
      self.detachEvents();

      if (self.$inputEl && app.theme === 'md') {
        self.$inputEl.trigger('blur');
      }
      params.modules.forEach((m) => {
        if (typeof m === 'string' && modules[m] && modules[m].destroy) {
          modules[m].destroy(self);
        } else if (m && m.destroy) {
          m.destroy(self);
        }
      });

      if (self.$el) {
        self.$el.trigger('colorpicker:close');
      }
      if (self.$inputEl) {
        self.$inputEl.trigger('colorpicker:close');
      }
      self.emit('local::close colorPickerClose', self);
    }

    onClosed() {
      const self = this;
      self.opened = false;
      self.closing = false;

      if (!self.inline) {
        Utils.nextTick(() => {
          if (self.modal && self.modal.el && self.modal.destroy) {
            if (!self.params.routableModals) {
              self.modal.destroy();
            }
          }
          delete self.modal;
        });
      }
      if (self.$el) {
        self.$el.trigger('colorpicker:closed');
      }
      if (self.$inputEl) {
        self.$inputEl.trigger('colorpicker:closed');
      }
      self.emit('local::closed colorPickerClosed', self);
    }

    open() {
      const self = this;
      const { app, opened, inline, $inputEl, $targetEl, params } = self;
      if (opened) return;

      if (inline) {
        self.$el = $(self.render());
        self.$el[0].f7ColorPicker = self;
        self.$containerEl.append(self.$el);
        self.onOpen();
        self.onOpened();
        return;
      }

      const colorPickerContent = self.render();

      if (params.openIn === 'page') {
        self.view.router.navigate({
          url: self.url,
          route: {
            content: colorPickerContent,
            path: self.url,
            on: {
              pageBeforeIn(e, page) {
                self.$el = page.$el.find('.color-picker');
                self.$el[0].f7ColorPicker = self;
                self.onOpen();
              },
              pageAfterIn() {
                self.onOpened();
              },
              pageBeforeOut() {
                self.onClose();
              },
              pageAfterOut() {
                self.onClosed();
                if (self.$el && self.$el[0]) {
                  self.$el[0].f7ColorPicker = null;
                  delete self.$el[0].f7ColorPicker;
                }
              },
            },
          },
        });
      } else {
        const modalType = self.getModalType();
        let backdrop = params.backdrop;
        if (backdrop === null || typeof backdrop === 'undefined') {
          if (modalType === 'popover' && app.params.popover.backdrop !== false) backdrop = true;
          if (modalType === 'popup') backdrop = true;
        }
        const modalParams = {
          targetEl: ($targetEl || $inputEl),
          scrollToEl: params.scrollToInput ? ($targetEl || $inputEl) : undefined,
          content: colorPickerContent,
          backdrop,
          closeByBackdropClick: params.closeByBackdropClick,
          on: {
            open() {
              const modal = this;
              self.modal = modal;
              self.$el = modalType === 'popover' || modalType === 'popup' ? modal.$el.find('.color-picker') : modal.$el;
              self.$el[0].f7ColorPicker = self;
              self.onOpen();
            },
            opened() { self.onOpened(); },
            close() { self.onClose(); },
            closed() {
              self.onClosed();
              if (self.$el && self.$el[0]) {
                self.$el[0].f7ColorPicker = null;
                delete self.$el[0].f7ColorPicker;
              }
            },
          },
        };
        if (modalType === 'popup') {
          modalParams.push = params.popupPush;
          modalParams.swipeToClose = params.popupSwipeToClose;
        }
        if (modalType === 'sheet') {
          modalParams.push = params.sheetPush;
          modalParams.swipeToClose = params.sheetSwipeToClose;
        }
        if (params.routableModals && self.view) {
          self.view.router.navigate({
            url: self.url,
            route: {
              path: self.url,
              [modalType]: modalParams,
            },
          });
        } else {
          self.modal = app[modalType].create(modalParams);
          self.modal.open();
        }
      }
    }

    close() {
      const self = this;
      const { opened, inline } = self;
      if (!opened) return;
      if (inline) {
        self.onClose();
        self.onClosed();
        return;
      }
      if ((self.params.routableModals && self.view) || self.params.openIn === 'page') {
        self.view.router.back();
      } else {
        self.modal.close();
      }
    }

    init() {
      const self = this;

      self.initInput();

      if (self.inline) {
        self.open();
        self.emit('local::init colorPickerInit', self);
        return;
      }

      if (!self.initialized && self.params.value) {
        self.setValue(self.params.value);
      }

      // Attach input Events
      if (self.$inputEl) {
        self.attachInputEvents();
      }
      if (self.$targetEl) {
        self.attachTargetEvents();
      }
      if (self.params.closeByOutsideClick) {
        self.attachHtmlEvents();
      }
      self.emit('local::init colorPickerInit', self);
    }

    destroy() {
      const self = this;
      if (self.destroyed) return;
      const { $el } = self;
      self.emit('local::beforeDestroy colorPickerBeforeDestroy', self);
      if ($el) $el.trigger('colorpicker:beforedestroy');

      self.close();

      // Detach Events
      self.detachEvents();
      if (self.$inputEl) {
        self.detachInputEvents();
      }
      if (self.$targetEl) {
        self.detachTargetEvents();
      }
      if (self.params.closeByOutsideClick) {
        self.detachHtmlEvents();
      }

      if ($el && $el.length) delete self.$el[0].f7ColorPicker;
      Utils.deleteProps(self);
      self.destroyed = true;
    }
  }

  var ColorPicker$1 = {
    name: 'colorPicker',
    static: {
      ColorPicker,
    },
    create() {
      const app = this;
      app.colorPicker = ConstructorMethods({
        defaultSelector: '.color-picker',
        constructor: ColorPicker,
        app,
        domProp: 'f7ColorPicker',
      });
      app.colorPicker.close = function close(el = '.color-picker') {
        const $el = $(el);
        if ($el.length === 0) return;
        const colorPicker = $el[0].f7ColorPicker;
        if (!colorPicker || (colorPicker && !colorPicker.opened)) return;
        colorPicker.close();
      };
    },
    params: {
      colorPicker: {
        // Color picker settings
        value: null,
        modules: [
          'wheel',
        ],
        palette: [
          ['#FFEBEE', '#FFCDD2', '#EF9A9A', '#E57373', '#EF5350', '#F44336', '#E53935', '#D32F2F', '#C62828', '#B71C1C'],
          ['#F3E5F5', '#E1BEE7', '#CE93D8', '#BA68C8', '#AB47BC', '#9C27B0', '#8E24AA', '#7B1FA2', '#6A1B9A', '#4A148C'],
          ['#E8EAF6', '#C5CAE9', '#9FA8DA', '#7986CB', '#5C6BC0', '#3F51B5', '#3949AB', '#303F9F', '#283593', '#1A237E'],
          ['#E1F5FE', '#B3E5FC', '#81D4FA', '#4FC3F7', '#29B6F6', '#03A9F4', '#039BE5', '#0288D1', '#0277BD', '#01579B'],
          ['#E0F2F1', '#B2DFDB', '#80CBC4', '#4DB6AC', '#26A69A', '#009688', '#00897B', '#00796B', '#00695C', '#004D40'],
          ['#F1F8E9', '#DCEDC8', '#C5E1A5', '#AED581', '#9CCC65', '#8BC34A', '#7CB342', '#689F38', '#558B2F', '#33691E'],
          ['#FFFDE7', '#FFF9C4', '#FFF59D', '#FFF176', '#FFEE58', '#FFEB3B', '#FDD835', '#FBC02D', '#F9A825', '#F57F17'],
          ['#FFF3E0', '#FFE0B2', '#FFCC80', '#FFB74D', '#FFA726', '#FF9800', '#FB8C00', '#F57C00', '#EF6C00', '#E65100'],
        ],
        groupedModules: false,
        centerModules: true,

        sliderLabel: false,
        sliderValue: false,
        sliderValueEdiable: false,

        barLabel: false,
        barValue: false,
        barValueEdiable: false,

        hexLabel: false,
        hexValueEditable: false,

        redLabelText: 'R',
        greenLabelText: 'G',
        blueLabelText: 'B',
        hueLabelText: 'H',
        saturationLabelText: 'S',
        brightnessLabelText: 'B',
        hexLabelText: 'HEX',
        alphaLabelText: 'A',

        // Common opener settings
        containerEl: null,
        openIn: 'popover', // or 'popover' or 'sheet' or 'popup' or 'page' or 'auto'
        openInPhone: 'popup', // or 'popover' or 'sheet' or 'popup' or 'page'
        popupPush: false,
        popupSwipeToClose: undefined,
        sheetPush: false,
        sheetSwipeToClose: undefined,
        formatValue: null,
        targetEl: null,
        targetElSetBackgroundColor: false,
        inputEl: null,
        inputReadOnly: true,
        closeByOutsideClick: true,
        scrollToInput: true,
        toolbarSheet: true,
        toolbarPopover: false,
        toolbarCloseText: 'Done',
        navbarPopup: true,
        navbarCloseText: 'Done',
        navbarTitleText: 'Color',
        navbarBackLinkText: 'Back',
        cssClass: null,
        routableModals: true,
        view: null,
        url: 'color/',
        backdrop: null,
        closeByBackdropClick: true,
        // Render functions
        renderToolbar: null,
        renderNavbar: null,
        renderInline: null,
        renderPopover: null,
        renderSheet: null,
        renderPopup: null,
        render: null,
      },
    },
  };

  const Treeview = {
    open(itemEl) {
      const app = this;
      const $itemEl = $(itemEl).eq(0);
      if (!$itemEl.length) return;
      $itemEl.addClass('treeview-item-opened');
      $itemEl.trigger('treeview:open');
      app.emit('treeviewOpen', $itemEl[0]);
      function done(cancel) {
        if (cancel) {
          $itemEl.removeClass('treeview-item-opened');
          $itemEl.trigger('treeview:close');
          app.emit('treeviewClose', $itemEl[0]);
        } else {
          $itemEl[0].f7TreeviewChildrenLoaded = true;
        }
        $itemEl.find('.treeview-toggle').removeClass('treeview-toggle-hidden');
        $itemEl.find('.treeview-preloader').remove();
      }

      if ($itemEl.hasClass('treeview-load-children') && !$itemEl[0].f7TreeviewChildrenLoaded) {
        $itemEl.trigger('treeview:loadchildren', done);
        app.emit('treeviewLoadChildren', $itemEl[0], done);
        $itemEl.find('.treeview-toggle').addClass('treeview-toggle-hidden');
        $itemEl.find('.treeview-item-root').prepend(`<div class="preloader treeview-preloader">${Utils[`${app.theme}PreloaderContent`]}</div>`);
      }
    },
    close(itemEl) {
      const app = this;
      const $itemEl = $(itemEl).eq(0);
      if (!$itemEl.length) return;
      $itemEl.removeClass('treeview-item-opened');
      $itemEl.trigger('treeview:close');
      app.emit('treeviewClose', $itemEl[0]);
    },
    toggle(itemEl) {
      const app = this;
      const $itemEl = $(itemEl).eq(0);
      if (!$itemEl.length) return;
      const wasOpened = $itemEl.hasClass('treeview-item-opened');
      app.treeview[wasOpened ? 'close' : 'open']($itemEl);
    },
  };

  var Treeview$1 = {
    name: 'treeview',
    create() {
      const app = this;
      Utils.extend(app, {
        treeview: {
          open: Treeview.open.bind(app),
          close: Treeview.close.bind(app),
          toggle: Treeview.toggle.bind(app),
        },
      });
    },
    clicks: {
      '.treeview-toggle': function toggle($clickedEl, clickedData, e) {
        const app = this;
        if ($clickedEl.parents('.treeview-item-toggle').length) return;
        const $treeviewItemEl = $clickedEl.parents('.treeview-item').eq(0);
        if (!$treeviewItemEl.length) return;
        e.preventF7Router = true;
        app.treeview.toggle($treeviewItemEl[0]);
      },
      '.treeview-item-toggle': function toggle($clickedEl, clickedData, e) {
        const app = this;
        const $treeviewItemEl = $clickedEl.closest('.treeview-item').eq(0);
        if (!$treeviewItemEl.length) return;
        e.preventF7Router = true;
        app.treeview.toggle($treeviewItemEl[0]);
      },
    },
  };

  const textEditorButtonsMap = {
    // f7-icon, material-icon, command
    bold: ['bold', 'format_bold', 'bold'],
    italic: ['italic', 'format_italic', 'italic'],
    underline: ['underline', 'format_underlined', 'underline'],
    strikeThrough: ['strikethrough', 'strikethrough_s', 'strikeThrough'],
    orderedList: ['list_number', 'format_list_numbered', 'insertOrderedList'],
    unorderedList: ['list_bullet', 'format_list_bulleted', 'insertUnorderedList'],
    link: ['link', 'link', 'createLink'],
    image: ['photo', 'image', 'insertImage'],
    paragraph: ['paragraph', '<i class="icon">¶</i>', 'formatBlock.P'],
    h1: ['<i class="icon">H<sub>1</sub></i>', '<i class="icon">H<sub>1</sub></i>', 'formatBlock.H1'],
    h2: ['<i class="icon">H<sub>2</sub></i>', '<i class="icon">H<sub>2</sub></i>', 'formatBlock.H2'],
    h3: ['<i class="icon">H<sub>3</sub></i>', '<i class="icon">H<sub>3</sub></i>', 'formatBlock.H3'],
    alignLeft: ['text_alignleft', 'format_align_left', 'justifyLeft'],
    alignCenter: ['text_aligncenter', 'format_align_center', 'justifyCenter'],
    alignRight: ['text_alignright', 'format_align_right', 'justifyRight'],
    alignJustify: ['text_justify', 'format_align_justify', 'justifyFull'],
    subscript: ['textformat_subscript', '<i class="icon">A<sub>1</sub></i>', 'subscript'],
    superscript: ['textformat_superscript', '<i class="icon">A<sup>1</sup></i>', 'superscript'],
    indent: ['increase_indent', 'format_indent_increase', 'indent'],
    outdent: ['decrease_indent', 'format_indent_decrease', 'outdent'],
  };

  class TextEditor extends Framework7Class {
    constructor(app, params) {
      super(params, [app]);
      const self = this;

      const defaults = Utils.extend({}, app.params.textEditor);

      // Extend defaults with modules params
      self.useModulesParams(defaults);

      self.params = Utils.extend(defaults, params);

      const el = self.params.el;
      if (!el) return self;

      const $el = $(el);
      if ($el.length === 0) return self;

      if ($el[0].f7TextEditor) return $el[0].f7TextEditor;

      let $contentEl = $el.children('.text-editor-content');
      if (!$contentEl.length) {
        $el.append('<div class="text-editor-content" contenteditable></div>');
        $contentEl = $el.children('.text-editor-content');
      }

      Utils.extend(self, {
        app,
        $el,
        el: $el[0],
        $contentEl,
        contentEl: $contentEl[0],
      });
      if ('value' in params) {
        self.value = self.params.value;
      }

      if (self.params.mode === 'keyboard-toolbar') {
        if (!app.device.cordova && !app.device.android) {
          self.params.mode = 'popover';
        }
      }

      if (typeof self.params.buttons === 'string') {
        try {
          self.params.buttons = JSON.parse(self.params.buttons);
        } catch (err) {
          throw new Error('Framework7: TextEditor: wrong "buttons" parameter format');
        }
      }

      $el[0].f7TextEditor = self;

      // Bind
      self.onButtonClick = self.onButtonClick.bind(self);
      self.onFocus = self.onFocus.bind(self);
      self.onBlur = self.onBlur.bind(self);
      self.onInput = self.onInput.bind(self);
      self.onPaste = self.onPaste.bind(self);
      self.onSelectionChange = self.onSelectionChange.bind(self);
      self.closeKeyboardToolbar = self.closeKeyboardToolbar.bind(self);

      // Handle Events
      self.attachEvents = function attachEvents() {
        if (self.params.mode === 'toolbar') {
          self.$el.find('.text-editor-toolbar').on('click', 'button', self.onButtonClick);
        }
        if (self.params.mode === 'keyboard-toolbar') {
          self.$keyboardToolbarEl.on('click', 'button', self.onButtonClick);
          self.$el.parents('.page').on('page:beforeout', self.closeKeyboardToolbar);
        }
        if (self.params.mode === 'popover' && self.popover) {
          self.popover.$el.on('click', 'button', self.onButtonClick);
        }
        self.$contentEl.on('paste', self.onPaste);
        self.$contentEl.on('focus', self.onFocus);
        self.$contentEl.on('blur', self.onBlur);
        self.$contentEl.on('input', self.onInput, true);
        $(doc).on('selectionchange', self.onSelectionChange);
      };
      self.detachEvents = function detachEvents() {
        if (self.params.mode === 'toolbar') {
          self.$el.find('.text-editor-toolbar').off('click', 'button', self.onButtonClick);
        }
        if (self.params.mode === 'keyboard-toolbar') {
          self.$keyboardToolbarEl.off('click', 'button', self.onButtonClick);
          self.$el.parents('.page').off('page:beforeout', self.closeKeyboardToolbar);
        }
        if (self.params.mode === 'popover' && self.popover) {
          self.popover.$el.off('click', 'button', self.onButtonClick);
        }
        self.$contentEl.off('paste', self.onPaste);
        self.$contentEl.off('focus', self.onFocus);
        self.$contentEl.off('blur', self.onBlur);
        self.$contentEl.off('input', self.onInput, true);
        $(doc).off('selectionchange', self.onSelectionChange);
      };

      // Install Modules
      self.useModules();

      // Init
      self.init();

      return self;
    }

    setValue(newValue) {
      const self = this;
      const currentValue = self.value;
      if (currentValue === newValue) return self;
      self.value = newValue;
      self.$contentEl.html(newValue);
      self.$el.trigger('texteditor:change', self.value);
      self.emit('local::change textEditorChange', self, self.value);
      return self;
    }

    getValue() {
      const self = this;
      return self.value;
    }

    createLink() {
      const self = this;
      const currentSelection = win.getSelection();
      const selectedNodes = [];
      let $selectedLinks;
      if (currentSelection && currentSelection.anchorNode && $(currentSelection.anchorNode).parents(self.$el).length) {
        let anchorNode = currentSelection.anchorNode;
        while (anchorNode) {
          selectedNodes.push(anchorNode);
          if (!anchorNode.nextSibling || anchorNode === currentSelection.focusNode) {
            anchorNode = null;
          }
          if (anchorNode) {
            anchorNode = anchorNode.nextSibling;
          }
        }
        $selectedLinks = $(selectedNodes).closest('a').add($(selectedNodes).children('a'));
      }
      if ($selectedLinks && $selectedLinks.length) {
        $selectedLinks.each((linkIndex, linkNode) => {
          const selection = win.getSelection();
          const range = doc.createRange();
          range.selectNodeContents(linkNode);
          selection.removeAllRanges();
          selection.addRange(range);
          doc.execCommand('unlink', false);
          selection.removeAllRanges();
        });
        return self;
      }
      const currentRange = self.getSelectionRange();
      if (!currentRange) return self;
      const dialog = self.app.dialog.prompt(self.params.linkUrlText, '', (link) => {
        if (link && link.trim().length) {
          self.setSelectionRange(currentRange);
          doc.execCommand('createLink', false, link.trim());
        }
      });
      dialog.$el.find('input').focus();
      return self;
    }

    insertImage() {
      const self = this;
      const currentRange = self.getSelectionRange();
      if (!currentRange) return self;
      const dialog = self.app.dialog.prompt(self.params.imageUrlText, '', (imageUrl) => {
        if (imageUrl && imageUrl.trim().length) {
          self.setSelectionRange(currentRange);
          doc.execCommand('insertImage', false, imageUrl.trim());
        }
      });
      dialog.$el.find('input').focus();
      return self;
    }

    removePlaceholder() {
      const self = this;
      self.$contentEl.find('.text-editor-placeholder').remove();
    }

    insertPlaceholder() {
      const self = this;
      self.$contentEl.append(`<div class="text-editor-placeholder">${self.params.placeholder}</div>`);
    }

    onSelectionChange() {
      const self = this;
      if (self.params.mode === 'toolbar') return;
      const selection = win.getSelection();
      const selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      if (self.params.mode === 'keyboard-toolbar') {
        if (!selectionIsInContent) {
          self.closeKeyboardToolbar();
        } else {
          self.openKeyboardToolbar();
        }
        return;
      }
      if (self.params.mode === 'popover') {
        const selectionIsInPopover = $(selection.anchorNode).parents(self.popover.el).length || selection.anchorNode === self.popover.el;
        if (!selectionIsInContent && !selectionIsInPopover) {
          self.closePopover();
          return;
        }
        if (!selection.isCollapsed && selection.rangeCount) {
          const range = selection.getRangeAt(0);
          const rect = range.getBoundingClientRect();
          self.openPopover(rect.x + (win.scrollX || 0), rect.y + (win.scrollY || 0), rect.width, rect.height);
        } else if (selection.isCollapsed) {
          self.closePopover();
        }
      }
    }

    onPaste(e) {
      const self = this;
      if (self.params.clearFormattingOnPaste && e.clipboardData && e.clipboardData.getData) {
        const text = e.clipboardData.getData('text/plain');
        e.preventDefault();
        doc.execCommand('insertText', false, text);
      }
    }

    onInput() {
      const self = this;
      const value = self.$contentEl.html();

      self.$el.trigger('texteditor:input');
      self.emit('local:input textEditorInput', self);

      self.value = value;
      self.$el.trigger('texteditor:change', self.value);
      self.emit('local::change textEditorChange', self, self.value);
    }

    onFocus() {
      const self = this;
      self.removePlaceholder();
      self.$contentEl.focus();
      self.$el.trigger('texteditor:focus');
      self.emit('local::focus textEditorFocus', self);
    }

    onBlur() {
      const self = this;
      if (self.params.placeholder && self.$contentEl.html() === '') {
        self.insertPlaceholder();
      }
      if (self.params.mode === 'popover') {
        const selection = win.getSelection();
        const selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
        const inPopover = doc.activeElement && self.popover && $(doc.activeElement).closest(self.popover.$el).length;
        if (!inPopover && !selectionIsInContent) {
          self.closePopover();
        }
      }
      if (self.params.mode === 'keyboard-toolbar') {
        const selection = win.getSelection();
        const selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
        if (!selectionIsInContent) {
          self.closeKeyboardToolbar();
        }
      }
      self.$el.trigger('texteditor:blur');
      self.emit('local::blur textEditorBlur', self);
    }

    onButtonClick(e) {
      const self = this;
      const selection = win.getSelection();
      const selectionIsInContent = $(selection.anchorNode).parents(self.contentEl).length || selection.anchorNode === self.contentEl;
      if (!selectionIsInContent) return;
      const $buttonEl = $(e.target).closest('button');
      if ($buttonEl.parents('form').length) {
        e.preventDefault();
      }
      const button = $buttonEl.attr('data-button');
      const buttonData = self.params.customButtons && self.params.customButtons[button];
      if (!button || !(textEditorButtonsMap[button] || buttonData)) return;
      $buttonEl.trigger('texteditor:buttonclick', button);
      self.emit('local::buttonClick textEditorButtonClick', self, button);
      if (buttonData) {
        if (buttonData.onClick) buttonData.onClick(self, $buttonEl[0]);
        return;
      }
      const command = textEditorButtonsMap[button][2];
      if (command === 'createLink') {
        self.createLink();
        return;
      }
      if (command === 'insertImage') {
        self.insertImage();
        return;
      }
      if (command.indexOf('formatBlock') === 0) {
        const tagName = command.split('.')[1];
        const $anchorNode = $(selection.anchorNode);
        if ($anchorNode.parents(tagName.toLowerCase()).length || $anchorNode.is(tagName)) {
          doc.execCommand('formatBlock', false, 'div');
        } else {
          doc.execCommand('formatBlock', false, tagName);
        }
        return;
      }
      doc.execCommand(command, false);
    }

    // eslint-disable-next-line
    getSelectionRange() {
      if (win.getSelection) {
        const sel = win.getSelection();
        if (sel.getRangeAt && sel.rangeCount) {
          return sel.getRangeAt(0);
        }
      } else if (doc.selection && doc.selection.createRange) {
        return doc.selection.createRange();
      }
      return null;
    }

    // eslint-disable-next-line
    setSelectionRange(range) {
      if (range) {
        if (win.getSelection) {
          const sel = win.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
        } else if (doc.selection && range.select) {
          range.select();
        }
      }
    }

    renderButtons() {
      const self = this;
      let html = '';
      function renderButton(button) {
        const iconClass = self.app.theme === 'md' ? 'material-icons' : 'f7-icons';
        if (self.params.customButtons && self.params.customButtons[button]) {
          const buttonData = self.params.customButtons[button];
          return `<button type="button" class="text-editor-button" data-button="${button}">${buttonData.content || ''}</button>`;
        }
        if (!textEditorButtonsMap[button]) return '';
        const iconContent = textEditorButtonsMap[button][self.app.theme === 'md' ? 1 : 0];
        return `<button type="button" class="text-editor-button" data-button="${button}">${iconContent.indexOf('<') >= 0 ? iconContent : `<i class="${iconClass}">${iconContent}</i>`}</button>`.trim();
      }
      self.params.buttons.forEach((button, buttonIndex) => {
        if (Array.isArray(button)) {
          button.forEach((b) => {
            html += renderButton(b);
          });
          if (buttonIndex < self.params.buttons.length - 1 && self.params.dividers) {
            html += '<div class="text-editor-button-divider"></div>';
          }
        } else {
          html += renderButton(button);
        }
      });
      return html;
    }

    createToolbar() {
      const self = this;
      self.$el.prepend(`<div class="text-editor-toolbar">${self.renderButtons()}</div>`);
    }

    createKeyboardToolbar() {
      const self = this;
      const isDark = self.$el.closest('.theme-dark').length > 0 || self.app.device.prefersColorScheme() === 'dark';
      self.$keyboardToolbarEl = $(`<div class="toolbar toolbar-bottom text-editor-keyboard-toolbar ${isDark ? 'theme-dark' : ''}"><div class="toolbar-inner">${self.renderButtons()}</div></div>`);
    }

    createPopover() {
      const self = this;
      const isDark = self.$el.closest('.theme-dark').length > 0;
      self.popover = self.app.popover.create({
        content: `
        <div class="popover ${isDark ? 'theme-light' : 'theme-dark'} text-editor-popover">
          <div class="popover-inner">${self.renderButtons()}</div>
        </div>
      `,
        closeByOutsideClick: false,
        backdrop: false,
      });
    }

    openKeyboardToolbar() {
      const self = this;
      if (self.$keyboardToolbarEl.parent(self.app.root).length) return;
      self.$el.trigger('texteditor:keyboardopen');
      self.emit('local::keyboardOpen textEditorKeyboardOpen', self);
      self.app.root.append(self.$keyboardToolbarEl);
    }

    closeKeyboardToolbar() {
      const self = this;
      self.$keyboardToolbarEl.remove();
      self.$el.trigger('texteditor:keyboardclose');
      self.emit('local::keyboardClose textEditorKeyboardClose', self);
    }

    openPopover(targetX, targetY, targetWidth, targetHeight) {
      const self = this;

      if (!self.popover) return;
      Object.assign(self.popover.params, {
        targetX,
        targetY,
        targetWidth,
        targetHeight,
      });
      clearTimeout(self.popoverTimeout);
      self.popoverTimeout = setTimeout(() => {
        if (!self.popover) return;
        if (self.popover.opened) {
          self.popover.resize();
        } else {
          self.$el.trigger('texteditor:popoveropen');
          self.emit('local::popoverOpen textEditorPopoverOpen', self);
          self.popover.open();
        }
      }, 400);
    }

    closePopover() {
      const self = this;
      clearTimeout(self.popoverTimeout);
      if (!self.popover || !self.popover.opened) return;
      self.popoverTimeout = setTimeout(() => {
        if (!self.popover) return;
        self.$el.trigger('texteditor:popoverclose');
        self.emit('local::popoverClose textEditorPopoverClose', self);
        self.popover.close();
      }, 400);
    }

    init() {
      const self = this;
      if (self.value) {
        self.$contentEl.html(self.value);
      } else {
        self.value = self.$contentEl.html();
      }
      if (self.params.placeholder && self.value === '') {
        self.insertPlaceholder();
      }
      if (self.params.mode === 'toolbar') {
        self.createToolbar();
      } else if (self.params.mode === 'popover') {
        self.createPopover();
      } else if (self.params.mode === 'keyboard-toolbar') {
        self.createKeyboardToolbar();
      }

      self.attachEvents();
      self.$el.trigger('texteditor:init');
      self.emit('local::init textEditorInit', self);
      return self;
    }

    destroy() {
      let self = this;
      self.$el.trigger('texteditor:beforedestroy');
      self.emit('local::beforeDestroy textEditorBeforeDestroy', self);
      self.detachEvents();
      if (self.params.mode === 'keyboard-toolbar' && self.$keyboardToolbarEl) {
        self.$keyboardToolbarEl.remove();
      }
      if (self.popover) {
        self.popover.close(false);
        self.popover.destroy();
      }
      delete self.$el[0].f7TextEditor;
      Utils.deleteProps(self);
      self = null;
    }
  }

  var TextEditor$1 = {
    name: 'textEditor',
    params: {
      textEditor: {
        el: null,
        mode: 'toolbar', // or 'popover'
        value: undefined, // will use html content
        customButtons: null,
        buttons: [
          ['bold', 'italic', 'underline', 'strikeThrough'],
          ['orderedList', 'unorderedList'],
          ['link', 'image'],
          ['paragraph', 'h1', 'h2', 'h3'],
          ['alignLeft', 'alignCenter', 'alignRight', 'alignJustify'],
          ['subscript', 'superscript'],
          ['indent', 'outdent'],
        ],
        dividers: true,
        imageUrlText: 'Insert image URL',
        linkUrlText: 'Insert link URL',
        placeholder: null,
        clearFormattingOnPaste: true,
      },
    },
    create() {
      const app = this;
      app.textEditor = Utils.extend(
        ConstructorMethods({
          defaultSelector: '.text-editor',
          constructor: TextEditor,
          app,
          domProp: 'f7TextEditor',
        }),
      );
    },
    static: {
      TextEditor,
    },
    on: {
      tabMounted(tabEl) {
        const app = this;
        $(tabEl).find('.text-editor-init').each((index, editorEl) => {
          const dataset = $(editorEl).dataset();
          app.textEditor.create(Utils.extend({ el: editorEl }, dataset || {}));
        });
      },
      tabBeforeRemove(tabEl) {
        $(tabEl).find('.text-editor-init').each((index, editorEl) => {
          if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
        });
      },
      pageInit(page) {
        const app = this;
        page.$el.find('.text-editor-init').each((index, editorEl) => {
          const dataset = $(editorEl).dataset();
          app.textEditor.create(Utils.extend({ el: editorEl }, dataset || {}));
        });
      },
      pageBeforeRemove(page) {
        page.$el.find('.text-editor-init').each((index, editorEl) => {
          if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
        });
      },
    },
    vnode: {
      'text-editor-init': {
        insert(vnode) {
          const app = this;
          const editorEl = vnode.elm;
          const dataset = $(editorEl).dataset();
          app.textEditor.create(Utils.extend({ el: editorEl }, dataset || {}));
        },
        destroy(vnode) {
          const editorEl = vnode.elm;
          if (editorEl.f7TextEditor) editorEl.f7TextEditor.destroy();
        },
      },
    },
  };

  var Elevation = {
    name: 'elevation',
  };

  var Typography = {
    name: 'typography',
  };

  class ViAd extends Framework7Class {
    constructor(app, params = {}) {
      super(params, [app]);
      const vi = this;
      if (!win.vi) {
        throw new Error('Framework7: vi SDK not found.');
      }

      let orientation;
      if (typeof win.orientation !== 'undefined') {
        orientation = win.orientation === -90 || win.orientation === 90 ? 'horizontal' : 'vertical';
      }
      const defaults = Utils.extend(
        {},
        app.params.vi,
        {
          appId: app.id,
          appVer: app.version,
          language: app.language,
          width: app.width,
          height: app.height,
          os: Device.os,
          osVersion: Device.osVersion,
          orientation,
        }
      );

      // Extend defaults with modules params
      vi.useModulesParams(defaults);

      vi.params = Utils.extend(defaults, params);

      const adParams = {};
      const skipParams = ('on autoplay fallbackOverlay fallbackOverlayText enabled').split(' ');
      Object.keys(vi.params).forEach((paramName) => {
        if (skipParams.indexOf(paramName) >= 0) return;
        const paramValue = vi.params[paramName];
        if ([null, undefined].indexOf(paramValue) >= 0) return;
        adParams[paramName] = paramValue;
      });

      if (!vi.params.appId) {
        throw new Error('Framework7: "app.id" is required to display an ad. Make sure you have specified it on app initialization.');
      }
      if (!vi.params.placementId) {
        throw new Error('Framework7: "placementId" is required to display an ad.');
      }

      function onResize() {
        const $viFrame = $('iframe#viAd');
        if ($viFrame.length === 0) return;
        $viFrame
          .css({
            width: `${app.width}px`,
            height: `${app.height}px`,
          });
      }

      function removeOverlay() {
        if (!vi.$overlayEl) return;
        vi.$overlayEl.off('click touchstart');
        vi.$overlayEl.remove();
      }
      function createOverlay(videoEl) {
        if (!videoEl) return;
        vi.$overlayEl = $(`
        <div class="vi-overlay">
          ${vi.params.fallbackOverlayText ? `<div class="vi-overlay-text">${vi.params.fallbackOverlayText}</div>` : ''}
          <div class="vi-overlay-play-button"></div>
        </div>
      `.trim());

        let touchStartTime;
        vi.$overlayEl.on('touchstart', () => {
          touchStartTime = Utils.now();
        });
        vi.$overlayEl.on('click', () => {
          const timeDiff = Utils.now() - touchStartTime;
          if (timeDiff > 300) return;
          if (videoEl) {
            videoEl.play();
            removeOverlay();
            return;
          }
          vi.start();
          removeOverlay();
        });
        app.root.append(vi.$overlayEl);
      }

      // Create ad
      vi.ad = new win.vi.Ad(adParams);

      Utils.extend(vi.ad, {
        onAdReady() {
          app.on('resize', onResize);
          vi.emit('local::ready');
          if (vi.params.autoplay) {
            vi.start();
          }
        },
        onAdStarted() {
          vi.emit('local::started');
        },
        onAdClick(targetUrl) {
          vi.emit('local::click', targetUrl);
        },
        onAdImpression() {
          vi.emit('local::impression');
        },
        onAdStopped(reason) {
          app.off('resize', onResize);
          removeOverlay();

          vi.emit('local::stopped', reason);
          if (reason === 'complete') {
            vi.emit('local::complete');
            vi.emit('local::completed');
          }
          if (reason === 'userexit') {
            vi.emit('local::userexit');
          }
          vi.destroyed = true;
        },
        onAutoPlayFailed(reason, videoEl) {
          vi.emit('local::autoplayFailed', reason, videoEl);
          if (reason && reason.name && reason.name.indexOf('NotAllowedError') !== -1 && vi.params.fallbackOverlay) {
            createOverlay(videoEl);
          }
        },
        onAdError(msg) {
          removeOverlay();
          app.off('resize', onResize);
          vi.emit('local::error', msg);
          vi.destroyed = true;
        },
      });

      vi.init();

      Utils.extend(vi, {
        app,
      });
    }

    start() {
      const vi = this;
      if (vi.destroyed) return;
      if (vi.ad) vi.ad.startAd();
    }

    pause() {
      const vi = this;
      if (vi.destroyed) return;
      if (vi.ad) vi.ad.pauseAd();
    }

    resume() {
      const vi = this;
      if (vi.destroyed) return;
      if (vi.ad) vi.ad.resumeAd();
    }

    stop() {
      const vi = this;
      if (vi.destroyed) return;
      if (vi.ad) vi.ad.stopAd();
    }

    init() {
      const vi = this;
      if (vi.destroyed) return;
      if (vi.ad) vi.ad.initAd();
    }

    destroy() {
      const vi = this;
      vi.destroyed = true;
      vi.emit('local::beforeDestroy');
      Utils.deleteProps(vi);
    }
  }

  var Vi = {
    name: 'vi',
    params: {
      vi: {
        enabled: false,
        autoplay: true,
        fallbackOverlay: true,
        fallbackOverlayText: 'Please watch this ad',
        showMute: true,
        startMuted: (Device.ios || Device.android) && !Device.cordova,
        appId: null,
        appVer: null,
        language: null,
        width: null,
        height: null,
        placementId: 'pltd4o7ibb9rc653x14',
        placementType: 'interstitial',
        videoSlot: null,
        showProgress: true,
        showBranding: true,
        os: null,
        osVersion: null,
        orientation: null,
        age: null,
        gender: null,
        advertiserId: null,
        latitude: null,
        longitude: null,
        accuracy: null,
        storeId: null,
        ip: null,
        manufacturer: null,
        model: null,
        connectionType: null,
        connectionProvider: null,
      },
    },
    create() {
      const app = this;
      app.vi = {
        sdkReady: false,
        createAd(adParams) {
          return new ViAd(app, adParams);
        },
        loadSdk() {
          if (app.vi.sdkReady) return;
          const script = doc.createElement('script');
          script.onload = function onload() {
            app.emit('viSdkReady');
            app.vi.sdkReady = true;
          };
          script.src = 'https://c.vi-serve.com/viadshtml/vi.min.js';
          $('head').append(script);
        },
      };
    },
    on: {
      init() {
        const app = this;
        if (app.params.vi.enabled || (app.passedParams.vi && app.passedParams.vi.enabled !== false)) app.vi.loadSdk();
      },
    },
  };

  /**
   * Framework7 5.7.0
   * Full featured mobile HTML framework for building iOS & Android apps
   * https://framework7.io/
   *
   * Copyright 2014-2020 Vladimir Kharlampidi
   *
   * Released under the MIT License
   *
   * Released on: April 25, 2020
   */

  // Install Core Modules & Components

  Framework7.use([
    DeviceModule,
    SupportModule,
    UtilsModule,
    ResizeModule,
    RequestModule,
    TouchModule,
    ClicksModule,
    RouterModule,
    HistoryModule,
    ServiceWorkerModule,
    Statusbar$1,
    View$1,
    Navbar$1,
    Toolbar$1,
    Subnavbar,
    TouchRipple$1,
    Modal$1,
    Appbar,
    Dialog$1,
    Popup$1,
    LoginScreen$1,
    Popover$1,
    Actions$1,
    Sheet$1,
    Toast$1,
    Preloader$1,
    Progressbar$1,
    Sortable$1,
    Swipeout$1,
    Accordion$1,
    ContactsList,
    VirtualList$1,
    ListIndex$1,
    Timeline,
    Tabs,
    Panel$1,
    Card,
    Chip,
    Form,
    Input$1,
    Checkbox,
    Radio,
    Toggle$1,
    Range$1,
    Stepper$1,
    SmartSelect$1,
    Grid$1,
    Calendar$1,
    Picker$1,
    InfiniteScroll$1,
    PullToRefresh$1,
    Lazy$1,
    DataTable$1,
    Fab$1,
    Searchbar$1,
    Messages$1,
    Messagebar$1,
    Swiper$1,
    PhotoBrowser$1,
    Notification$1,
    Autocomplete$1,
    Tooltip$1,
    Gauge$1,
    Skeleton,
    Menu$1,
    ColorPicker$1,
    Treeview$1,
    TextEditor$1,
    Elevation,
    Typography,
    Vi
  ]);

  function noop() { }
  function assign(tar, src) {
      // @ts-ignore
      for (const k in src)
          tar[k] = src[k];
      return tar;
  }
  function add_location(element, file, line, column, char) {
      element.__svelte_meta = {
          loc: { file, line, column, char }
      };
  }
  function run(fn) {
      return fn();
  }
  function blank_object() {
      return Object.create(null);
  }
  function run_all(fns) {
      fns.forEach(run);
  }
  function is_function(thing) {
      return typeof thing === 'function';
  }
  function safe_not_equal(a, b) {
      return a != a ? b == b : a !== b || ((a && typeof a === 'object') || typeof a === 'function');
  }
  function create_slot(definition, ctx, $$scope, fn) {
      if (definition) {
          const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
          return definition[0](slot_ctx);
      }
  }
  function get_slot_context(definition, ctx, $$scope, fn) {
      return definition[1] && fn
          ? assign($$scope.ctx.slice(), definition[1](fn(ctx)))
          : $$scope.ctx;
  }
  function get_slot_changes(definition, $$scope, dirty, fn) {
      if (definition[2] && fn) {
          const lets = definition[2](fn(dirty));
          if ($$scope.dirty === undefined) {
              return lets;
          }
          if (typeof lets === 'object') {
              const merged = [];
              const len = Math.max($$scope.dirty.length, lets.length);
              for (let i = 0; i < len; i += 1) {
                  merged[i] = $$scope.dirty[i] | lets[i];
              }
              return merged;
          }
          return $$scope.dirty | lets;
      }
      return $$scope.dirty;
  }
  function exclude_internal_props(props) {
      const result = {};
      for (const k in props)
          if (k[0] !== '$')
              result[k] = props[k];
      return result;
  }

  function append$1(target, node) {
      target.appendChild(node);
  }
  function insert(target, node, anchor) {
      target.insertBefore(node, anchor || null);
  }
  function detach$1(node) {
      node.parentNode.removeChild(node);
  }
  function destroy_each(iterations, detaching) {
      for (let i = 0; i < iterations.length; i += 1) {
          if (iterations[i])
              iterations[i].d(detaching);
      }
  }
  function element(name) {
      return document.createElement(name);
  }
  function text$1(data) {
      return document.createTextNode(data);
  }
  function space() {
      return text$1(' ');
  }
  function empty$1() {
      return text$1('');
  }
  function listen(node, event, handler, options) {
      node.addEventListener(event, handler, options);
      return () => node.removeEventListener(event, handler, options);
  }
  function attr$1(node, attribute, value) {
      if (value == null)
          node.removeAttribute(attribute);
      else if (node.getAttribute(attribute) !== value)
          node.setAttribute(attribute, value);
  }
  function set_attributes(node, attributes) {
      // @ts-ignore
      const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
      for (const key in attributes) {
          if (attributes[key] == null) {
              node.removeAttribute(key);
          }
          else if (key === 'style') {
              node.style.cssText = attributes[key];
          }
          else if (key === '__value' || descriptors[key] && descriptors[key].set) {
              node[key] = attributes[key];
          }
          else {
              attr$1(node, key, attributes[key]);
          }
      }
  }
  function children$1(element) {
      return Array.from(element.childNodes);
  }
  function toggle_class(element, name, toggle) {
      element.classList[toggle ? 'add' : 'remove'](name);
  }
  function custom_event(type, detail) {
      const e = document.createEvent('CustomEvent');
      e.initCustomEvent(type, false, false, detail);
      return e;
  }

  let current_component;
  function set_current_component(component) {
      current_component = component;
  }
  function get_current_component() {
      if (!current_component)
          throw new Error(`Function called outside component initialization`);
      return current_component;
  }
  function onMount(fn) {
      get_current_component().$$.on_mount.push(fn);
  }
  function afterUpdate(fn) {
      get_current_component().$$.after_update.push(fn);
  }
  function onDestroy(fn) {
      get_current_component().$$.on_destroy.push(fn);
  }
  function createEventDispatcher() {
      const component = get_current_component();
      return (type, detail) => {
          const callbacks = component.$$.callbacks[type];
          if (callbacks) {
              // TODO are there situations where events could be dispatched
              // in a server (non-DOM) environment?
              const event = custom_event(type, detail);
              callbacks.slice().forEach(fn => {
                  fn.call(component, event);
              });
          }
      };
  }
  function setContext(key, context) {
      get_current_component().$$.context.set(key, context);
  }
  function getContext(key) {
      return get_current_component().$$.context.get(key);
  }

  const dirty_components = [];
  const binding_callbacks = [];
  const render_callbacks = [];
  const flush_callbacks = [];
  const resolved_promise = Promise.resolve();
  let update_scheduled = false;
  function schedule_update() {
      if (!update_scheduled) {
          update_scheduled = true;
          resolved_promise.then(flush);
      }
  }
  function tick() {
      schedule_update();
      return resolved_promise;
  }
  function add_render_callback(fn) {
      render_callbacks.push(fn);
  }
  let flushing = false;
  const seen_callbacks = new Set();
  function flush() {
      if (flushing)
          return;
      flushing = true;
      do {
          // first, call beforeUpdate functions
          // and update components
          for (let i = 0; i < dirty_components.length; i += 1) {
              const component = dirty_components[i];
              set_current_component(component);
              update$1(component.$$);
          }
          dirty_components.length = 0;
          while (binding_callbacks.length)
              binding_callbacks.pop()();
          // then, once components are updated, call
          // afterUpdate functions. This may cause
          // subsequent updates...
          for (let i = 0; i < render_callbacks.length; i += 1) {
              const callback = render_callbacks[i];
              if (!seen_callbacks.has(callback)) {
                  // ...so guard against infinite loops
                  seen_callbacks.add(callback);
                  callback();
              }
          }
          render_callbacks.length = 0;
      } while (dirty_components.length);
      while (flush_callbacks.length) {
          flush_callbacks.pop()();
      }
      update_scheduled = false;
      flushing = false;
      seen_callbacks.clear();
  }
  function update$1($$) {
      if ($$.fragment !== null) {
          $$.update();
          run_all($$.before_update);
          const dirty = $$.dirty;
          $$.dirty = [-1];
          $$.fragment && $$.fragment.p($$.ctx, dirty);
          $$.after_update.forEach(add_render_callback);
      }
  }
  const outroing = new Set();
  let outros;
  function group_outros() {
      outros = {
          r: 0,
          c: [],
          p: outros // parent group
      };
  }
  function check_outros() {
      if (!outros.r) {
          run_all(outros.c);
      }
      outros = outros.p;
  }
  function transition_in(block, local) {
      if (block && block.i) {
          outroing.delete(block);
          block.i(local);
      }
  }
  function transition_out(block, local, detach, callback) {
      if (block && block.o) {
          if (outroing.has(block))
              return;
          outroing.add(block);
          outros.c.push(() => {
              outroing.delete(block);
              if (callback) {
                  if (detach)
                      block.d(1);
                  callback();
              }
          });
          block.o(local);
      }
  }
  function outro_and_destroy_block(block, lookup) {
      transition_out(block, 1, 1, () => {
          lookup.delete(block.key);
      });
  }
  function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block, next, get_context) {
      let o = old_blocks.length;
      let n = list.length;
      let i = o;
      const old_indexes = {};
      while (i--)
          old_indexes[old_blocks[i].key] = i;
      const new_blocks = [];
      const new_lookup = new Map();
      const deltas = new Map();
      i = n;
      while (i--) {
          const child_ctx = get_context(ctx, list, i);
          const key = get_key(child_ctx);
          let block = lookup.get(key);
          if (!block) {
              block = create_each_block(key, child_ctx);
              block.c();
          }
          else if (dynamic) {
              block.p(child_ctx, dirty);
          }
          new_lookup.set(key, new_blocks[i] = block);
          if (key in old_indexes)
              deltas.set(key, Math.abs(i - old_indexes[key]));
      }
      const will_move = new Set();
      const did_move = new Set();
      function insert(block) {
          transition_in(block, 1);
          block.m(node, next, lookup.has(block.key));
          lookup.set(block.key, block);
          next = block.first;
          n--;
      }
      while (o && n) {
          const new_block = new_blocks[n - 1];
          const old_block = old_blocks[o - 1];
          const new_key = new_block.key;
          const old_key = old_block.key;
          if (new_block === old_block) {
              // do nothing
              next = new_block.first;
              o--;
              n--;
          }
          else if (!new_lookup.has(old_key)) {
              // remove old block
              destroy(old_block, lookup);
              o--;
          }
          else if (!lookup.has(new_key) || will_move.has(new_key)) {
              insert(new_block);
          }
          else if (did_move.has(old_key)) {
              o--;
          }
          else if (deltas.get(new_key) > deltas.get(old_key)) {
              did_move.add(new_key);
              insert(new_block);
          }
          else {
              will_move.add(old_key);
              o--;
          }
      }
      while (o--) {
          const old_block = old_blocks[o];
          if (!new_lookup.has(old_block.key))
              destroy(old_block, lookup);
      }
      while (n)
          insert(new_blocks[n - 1]);
      return new_blocks;
  }
  function validate_each_keys(ctx, list, get_context, get_key) {
      const keys = new Set();
      for (let i = 0; i < list.length; i++) {
          const key = get_key(get_context(ctx, list, i));
          if (keys.has(key)) {
              throw new Error(`Cannot have duplicate keys in a keyed each`);
          }
          keys.add(key);
      }
  }

  function get_spread_update(levels, updates) {
      const update = {};
      const to_null_out = {};
      const accounted_for = { $$scope: 1 };
      let i = levels.length;
      while (i--) {
          const o = levels[i];
          const n = updates[i];
          if (n) {
              for (const key in o) {
                  if (!(key in n))
                      to_null_out[key] = 1;
              }
              for (const key in n) {
                  if (!accounted_for[key]) {
                      update[key] = n[key];
                      accounted_for[key] = 1;
                  }
              }
              levels[i] = n;
          }
          else {
              for (const key in o) {
                  accounted_for[key] = 1;
              }
          }
      }
      for (const key in to_null_out) {
          if (!(key in update))
              update[key] = undefined;
      }
      return update;
  }
  function get_spread_object(spread_props) {
      return typeof spread_props === 'object' && spread_props !== null ? spread_props : {};
  }
  function create_component(block) {
      block && block.c();
  }
  function mount_component(component, target, anchor) {
      const { fragment, on_mount, on_destroy, after_update } = component.$$;
      fragment && fragment.m(target, anchor);
      // onMount happens before the initial afterUpdate
      add_render_callback(() => {
          const new_on_destroy = on_mount.map(run).filter(is_function);
          if (on_destroy) {
              on_destroy.push(...new_on_destroy);
          }
          else {
              // Edge case - component was destroyed immediately,
              // most likely as a result of a binding initialising
              run_all(new_on_destroy);
          }
          component.$$.on_mount = [];
      });
      after_update.forEach(add_render_callback);
  }
  function destroy_component(component, detaching) {
      const $$ = component.$$;
      if ($$.fragment !== null) {
          run_all($$.on_destroy);
          $$.fragment && $$.fragment.d(detaching);
          // TODO null out other refs, including component.$$ (but need to
          // preserve final state?)
          $$.on_destroy = $$.fragment = null;
          $$.ctx = [];
      }
  }
  function make_dirty(component, i) {
      if (component.$$.dirty[0] === -1) {
          dirty_components.push(component);
          schedule_update();
          component.$$.dirty.fill(0);
      }
      component.$$.dirty[(i / 31) | 0] |= (1 << (i % 31));
  }
  function init(component, options, instance, create_fragment, not_equal, props, dirty = [-1]) {
      const parent_component = current_component;
      set_current_component(component);
      const prop_values = options.props || {};
      const $$ = component.$$ = {
          fragment: null,
          ctx: null,
          // state
          props,
          update: noop,
          not_equal,
          bound: blank_object(),
          // lifecycle
          on_mount: [],
          on_destroy: [],
          before_update: [],
          after_update: [],
          context: new Map(parent_component ? parent_component.$$.context : []),
          // everything else
          callbacks: blank_object(),
          dirty
      };
      let ready = false;
      $$.ctx = instance
          ? instance(component, prop_values, (i, ret, ...rest) => {
              const value = rest.length ? rest[0] : ret;
              if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
                  if ($$.bound[i])
                      $$.bound[i](value);
                  if (ready)
                      make_dirty(component, i);
              }
              return ret;
          })
          : [];
      $$.update();
      ready = true;
      run_all($$.before_update);
      // `false` as a special case of no DOM component
      $$.fragment = create_fragment ? create_fragment($$.ctx) : false;
      if (options.target) {
          if (options.hydrate) {
              const nodes = children$1(options.target);
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              $$.fragment && $$.fragment.l(nodes);
              nodes.forEach(detach$1);
          }
          else {
              // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
              $$.fragment && $$.fragment.c();
          }
          if (options.intro)
              transition_in(component.$$.fragment);
          mount_component(component, options.target, options.anchor);
          flush();
      }
      set_current_component(parent_component);
  }
  class SvelteComponent {
      $destroy() {
          destroy_component(this, 1);
          this.$destroy = noop;
      }
      $on(type, callback) {
          const callbacks = (this.$$.callbacks[type] || (this.$$.callbacks[type] = []));
          callbacks.push(callback);
          return () => {
              const index = callbacks.indexOf(callback);
              if (index !== -1)
                  callbacks.splice(index, 1);
          };
      }
      $set() {
          // overridden by instance, if it has props
      }
  }

  function dispatch_dev(type, detail) {
      document.dispatchEvent(custom_event(type, Object.assign({ version: '3.21.0' }, detail)));
  }
  function append_dev(target, node) {
      dispatch_dev("SvelteDOMInsert", { target, node });
      append$1(target, node);
  }
  function insert_dev(target, node, anchor) {
      dispatch_dev("SvelteDOMInsert", { target, node, anchor });
      insert(target, node, anchor);
  }
  function detach_dev(node) {
      dispatch_dev("SvelteDOMRemove", { node });
      detach$1(node);
  }
  function listen_dev(node, event, handler, options, has_prevent_default, has_stop_propagation) {
      const modifiers = options === true ? ["capture"] : options ? Array.from(Object.keys(options)) : [];
      if (has_prevent_default)
          modifiers.push('preventDefault');
      if (has_stop_propagation)
          modifiers.push('stopPropagation');
      dispatch_dev("SvelteDOMAddEventListener", { node, event, handler, modifiers });
      const dispose = listen(node, event, handler, options);
      return () => {
          dispatch_dev("SvelteDOMRemoveEventListener", { node, event, handler, modifiers });
          dispose();
      };
  }
  function attr_dev(node, attribute, value) {
      attr$1(node, attribute, value);
      if (value == null)
          dispatch_dev("SvelteDOMRemoveAttribute", { node, attribute });
      else
          dispatch_dev("SvelteDOMSetAttribute", { node, attribute, value });
  }
  function prop_dev(node, property, value) {
      node[property] = value;
      dispatch_dev("SvelteDOMSetProperty", { node, property, value });
  }
  function set_data_dev(text, data) {
      data = '' + data;
      if (text.data === data)
          return;
      dispatch_dev("SvelteDOMSetData", { node: text, data });
      text.data = data;
  }
  function validate_each_argument(arg) {
      if (typeof arg !== 'string' && !(arg && typeof arg === 'object' && 'length' in arg)) {
          let msg = '{#each} only iterates over array-like objects.';
          if (typeof Symbol === 'function' && arg && Symbol.iterator in arg) {
              msg += ' You can use a spread to convert this iterable into an array.';
          }
          throw new Error(msg);
      }
  }
  function validate_slots(name, slot, keys) {
      for (const slot_key of Object.keys(slot)) {
          if (!~keys.indexOf(slot_key)) {
              console.warn(`<${name}> received an unexpected slot "${slot_key}".`);
          }
      }
  }
  class SvelteComponentDev extends SvelteComponent {
      constructor(options) {
          if (!options || (!options.target && !options.$$inline)) {
              throw new Error(`'target' is a required option`);
          }
          super();
      }
      $destroy() {
          super.$destroy();
          this.$destroy = () => {
              console.warn(`Component was already destroyed`); // eslint-disable-line no-console
          };
      }
      $capture_state() { }
      $inject_state() { }
  }

  const Utils$1 = {
    text(text) {
      if (typeof text === 'undefined' || text === null) return '';
      return text;
    },
    noUndefinedProps(obj) {
      const o = {};
      Object.keys(obj).forEach((key) => {
        if (typeof obj[key] !== 'undefined') o[key] = obj[key];
      });
      return o;
    },
    isTrueProp(val) {
      return val === true || val === '';
    },
    isStringProp(val) {
      return typeof val === 'string' && val !== '';
    },
    isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
    },
    now() {
      return Date.now();
    },
    extend(...args) {
      let deep = true;
      let to;
      let from;
      if (typeof args[0] === 'boolean') {
        [deep, to] = args;
        args.splice(0, 2);
        from = args;
      } else {
        [to] = args;
        args.splice(0, 1);
        from = args;
      }
      for (let i = 0; i < from.length; i += 1) {
        const nextSource = args[i];
        if (nextSource !== undefined && nextSource !== null) {
          const keysArray = Object.keys(Object(nextSource));
          for (let nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            const nextKey = keysArray[nextIndex];
            const desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
            if (desc !== undefined && desc.enumerable) {
              if (!deep) {
                to[nextKey] = nextSource[nextKey];
              } else if (Utils$1.isObject(to[nextKey]) && Utils$1.isObject(nextSource[nextKey])) {
                Utils$1.extend(to[nextKey], nextSource[nextKey]);
              } else if (!Utils$1.isObject(to[nextKey]) && Utils$1.isObject(nextSource[nextKey])) {
                to[nextKey] = {};
                Utils$1.extend(to[nextKey], nextSource[nextKey]);
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }
      return to;
    },
    flattenArray(...args) {
      const arr = [];
      args.forEach((arg) => {
        if (Array.isArray(arg)) arr.push(...Utils$1.flattenArray(...arg));
        else arr.push(arg);
      });
      return arr;
    },
    classNames(...args) {
      const classes = [];
      args.forEach((arg) => {
        if (typeof arg === 'object' && arg.constructor === Object) {
          Object.keys(arg).forEach((key) => {
            if (arg[key]) classes.push(key);
          });
        } else if (arg) classes.push(arg);
      });
      const uniqueClasses = [];
      classes.forEach((c) => {
        if (uniqueClasses.indexOf(c) < 0) uniqueClasses.push(c);
      });
      return uniqueClasses.join(' ');
    },
    bindMethods(context, methods = []) {
      for (let i = 0; i < methods.length; i += 1) {
        if (context[methods[i]]) context[methods[i]] = context[methods[i]].bind(context);
      }
    },
  };

  const Mixins = {
    colorProps: {
      color: String,
      colorTheme: String,
      textColor: String,
      bgColor: String,
      borderColor: String,
      rippleColor: String,
      themeDark: Boolean,
    },
    colorClasses(props) {
      const {
        color,
        colorTheme,
        textColor,
        bgColor,
        borderColor,
        rippleColor,
        themeDark,
      } = props;

      return {
        'theme-dark': themeDark,
        [`color-${color}`]: color,
        [`color-theme-${colorTheme}`]: colorTheme,
        [`text-color-${textColor}`]: textColor,
        [`bg-color-${bgColor}`]: bgColor,
        [`border-color-${borderColor}`]: borderColor,
        [`ripple-color-${rippleColor}`]: rippleColor,
      };
    },
    linkIconProps: {
      icon: String,
      iconMaterial: String,
      iconF7: String,
      iconIos: String,
      iconMd: String,
      iconAurora: String,
      iconColor: String,
      iconSize: [String, Number],
    },
    linkRouterProps: {
      back: Boolean,
      external: Boolean,
      force: Boolean,
      animate: {
        type: Boolean,
        default: undefined,
      },
      ignoreCache: Boolean,
      reloadCurrent: Boolean,
      reloadAll: Boolean,
      reloadPrevious: Boolean,
      reloadDetail: {
        type: Boolean,
        default: undefined,
      },
      routeTabId: String,
      view: String,
      routeProps: Object,
      preventRouter: Boolean,
      transition: String,
    },
    linkRouterAttrs(props) {
      const {
        force,
        reloadCurrent,
        reloadPrevious,
        reloadAll,
        reloadDetail,
        animate,
        ignoreCache,
        routeTabId,
        view,
        transition,
      } = props;

      let dataAnimate;
      if ('animate' in props && typeof animate !== 'undefined') {
        dataAnimate = animate.toString();
      }

      let dataReloadDetail;
      if ('reloadDetail' in props && typeof reloadDetail !== 'undefined') {
        dataReloadDetail = reloadDetail.toString();
      }

      return {
        'data-force': force || undefined,
        'data-reload-current': reloadCurrent || undefined,
        'data-reload-all': reloadAll || undefined,
        'data-reload-previous': reloadPrevious || undefined,
        'data-reload-detail': dataReloadDetail,
        'data-animate': dataAnimate,
        'data-ignore-cache': ignoreCache || undefined,
        'data-route-tab-id': routeTabId || undefined,
        'data-view': Utils$1.isStringProp(view) ? view : undefined,
        'data-transition': Utils$1.isStringProp(transition) ? transition : undefined,
      };
    },
    linkRouterClasses(props) {
      const { back, linkBack, external, preventRouter } = props;

      return {
        back: back || linkBack,
        external,
        'prevent-router': preventRouter,
      };
    },
    linkActionsProps: {
      searchbarEnable: [Boolean, String],
      searchbarDisable: [Boolean, String],

      searchbarClear: [Boolean, String],
      searchbarToggle: [Boolean, String],

      // Panel
      panelOpen: [Boolean, String],
      panelClose: [Boolean, String],
      panelToggle: [Boolean, String],

      // Popup
      popupOpen: [Boolean, String],
      popupClose: [Boolean, String],

      // Actions
      actionsOpen: [Boolean, String],
      actionsClose: [Boolean, String],

      // Popover
      popoverOpen: [Boolean, String],
      popoverClose: [Boolean, String],

      // Login Screen
      loginScreenOpen: [Boolean, String],
      loginScreenClose: [Boolean, String],

      // Picker
      sheetOpen: [Boolean, String],
      sheetClose: [Boolean, String],

      // Sortable
      sortableEnable: [Boolean, String],
      sortableDisable: [Boolean, String],
      sortableToggle: [Boolean, String],

      // Card
      cardOpen: [Boolean, String],
      cardPreventOpen: [Boolean, String],
      cardClose: [Boolean, String],

      // Menu
      menuClose: {
        type: [Boolean, String],
        default: undefined,
      },
    },
    linkActionsAttrs(props) {
      const {
        searchbarEnable,
        searchbarDisable,
        searchbarClear,
        searchbarToggle,
        panelOpen,
        panelClose,
        panelToggle,
        popupOpen,
        popupClose,
        actionsOpen,
        actionsClose,
        popoverOpen,
        popoverClose,
        loginScreenOpen,
        loginScreenClose,
        sheetOpen,
        sheetClose,
        sortableEnable,
        sortableDisable,
        sortableToggle,
        cardOpen,
        cardClose,
      } = props;

      return {
        'data-searchbar': (Utils$1.isStringProp(searchbarEnable) && searchbarEnable)
                          || (Utils$1.isStringProp(searchbarDisable) && searchbarDisable)
                          || (Utils$1.isStringProp(searchbarClear) && searchbarClear)
                          || (Utils$1.isStringProp(searchbarToggle) && searchbarToggle) || undefined,
        'data-panel': (Utils$1.isStringProp(panelOpen) && panelOpen)
                      || (Utils$1.isStringProp(panelClose) && panelClose)
                      || (Utils$1.isStringProp(panelToggle) && panelToggle) || undefined,
        'data-popup': (Utils$1.isStringProp(popupOpen) && popupOpen)
                      || (Utils$1.isStringProp(popupClose) && popupClose) || undefined,
        'data-actions': (Utils$1.isStringProp(actionsOpen) && actionsOpen)
                      || (Utils$1.isStringProp(actionsClose) && actionsClose) || undefined,
        'data-popover': (Utils$1.isStringProp(popoverOpen) && popoverOpen)
                        || (Utils$1.isStringProp(popoverClose) && popoverClose) || undefined,
        'data-sheet': (Utils$1.isStringProp(sheetOpen) && sheetOpen)
                      || (Utils$1.isStringProp(sheetClose) && sheetClose) || undefined,
        'data-login-screen': (Utils$1.isStringProp(loginScreenOpen) && loginScreenOpen)
                             || (Utils$1.isStringProp(loginScreenClose) && loginScreenClose) || undefined,
        'data-sortable': (Utils$1.isStringProp(sortableEnable) && sortableEnable)
                         || (Utils$1.isStringProp(sortableDisable) && sortableDisable)
                         || (Utils$1.isStringProp(sortableToggle) && sortableToggle) || undefined,
        'data-card': (Utils$1.isStringProp(cardOpen) && cardOpen)
                      || (Utils$1.isStringProp(cardClose) && cardClose) || undefined,
      };
    },
    linkActionsClasses(props) {
      const {
        searchbarEnable,
        searchbarDisable,
        searchbarClear,
        searchbarToggle,
        panelOpen,
        panelClose,
        panelToggle,
        popupOpen,
        popupClose,
        actionsClose,
        actionsOpen,
        popoverOpen,
        popoverClose,
        loginScreenOpen,
        loginScreenClose,
        sheetOpen,
        sheetClose,
        sortableEnable,
        sortableDisable,
        sortableToggle,
        cardOpen,
        cardPreventOpen,
        cardClose,
        menuClose,
      } = props;

      return {
        'searchbar-enable': searchbarEnable || searchbarEnable === '',
        'searchbar-disable': searchbarDisable || searchbarDisable === '',
        'searchbar-clear': searchbarClear || searchbarClear === '',
        'searchbar-toggle': searchbarToggle || searchbarToggle === '',
        'panel-close': panelClose || panelClose === '',
        'panel-open': panelOpen || panelOpen === '',
        'panel-toggle': panelToggle || panelToggle === '',
        'popup-close': popupClose || popupClose === '',
        'popup-open': popupOpen || popupOpen === '',
        'actions-close': actionsClose || actionsClose === '',
        'actions-open': actionsOpen || actionsOpen === '',
        'popover-close': popoverClose || popoverClose === '',
        'popover-open': popoverOpen || popoverOpen === '',
        'sheet-close': sheetClose || sheetClose === '',
        'sheet-open': sheetOpen || sheetOpen === '',
        'login-screen-close': loginScreenClose || loginScreenClose === '',
        'login-screen-open': loginScreenOpen || loginScreenOpen === '',
        'sortable-enable': sortableEnable || sortableEnable === '',
        'sortable-disable': sortableDisable || sortableDisable === '',
        'sortable-toggle': sortableToggle || sortableToggle === '',
        'card-close': cardClose || cardClose === '',
        'card-open': cardOpen || cardOpen === '',
        'card-prevent-open': cardPreventOpen || cardPreventOpen === '',
        'menu-close': menuClose || menuClose === '',
      };
    },
  };

  /* node_modules/framework7-svelte/components/accordion-content.svelte generated by Svelte v3.21.0 */
  const file = "node_modules/framework7-svelte/components/accordion-content.svelte";

  function create_fragment(ctx) {
  	let div;
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[6].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (default_slot) default_slot.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[2]);
  			add_location(div, file, 18, 0, 342);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 32) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 4) {
  				attr_dev(div, "class", /*classes*/ ctx[2]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance($$self, $$props, $$invalidate) {
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Accordion_content", $$slots, ['default']);

  	$$self.$set = $$new_props => {
  		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
  		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		Mixins,
  		Utils: Utils$1,
  		id,
  		style,
  		className,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
  		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(2, classes = Utils$1.classNames(className, "accordion-item-content", Mixins.colorClasses($$props)));
  	};

  	$$props = exclude_internal_props($$props);
  	return [id, style, classes, className, $$props, $$scope, $$slots];
  }

  class Accordion_content extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance, create_fragment, safe_not_equal, { id: 0, style: 1, class: 3 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Accordion_content",
  			options,
  			id: create_fragment.name
  		});
  	}

  	get id() {
  		throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Accordion_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Accordion_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  const f7 = {
    instance: null,
    Framework7: null,
    events: null,
    init(rootEl, params = {}, routes) {
      const { events, Framework7 } = f7;
      const f7Params = Utils$1.extend({}, params, {
        root: rootEl,
      });
      if (routes && routes.length && !f7Params.routes) f7Params.routes = routes;

      const instance = new Framework7(f7Params);
      if (instance.initialized) {
        f7.instance = instance;
        events.emit('ready', f7.instance);
      } else {
        instance.on('init', () => {
          f7.instance = instance;
          events.emit('ready', f7.instance);
        });
      }
    },
    ready(callback) {
      if (!callback) return;
      if (f7.instance) callback(f7.instance);
      else {
        f7.events.once('ready', callback);
      }
    },
    routers: {
      views: [],
      tabs: [],
      modals: null,
    },
  };

  function hasSlots (args, name) {
    return args && args[1] && args[1].$$slots && args[1].$$slots[name] && args[1].$$slots[name].length > 0;
  }

  /* node_modules/framework7-svelte/components/routable-modals.svelte generated by Svelte v3.21.0 */
  const file$1 = "node_modules/framework7-svelte/components/routable-modals.svelte";

  function get_each_context(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[4] = list[i];
  	return child_ctx;
  }

  // (33:2) {#each modals as modal (modal.id)}
  function create_each_block(key_1, ctx) {
  	let first;
  	let switch_instance_anchor;
  	let current;
  	const switch_instance_spread_levels = [/*modal*/ ctx[4].props];
  	var switch_value = /*modal*/ ctx[4].component;

  	function switch_props(ctx) {
  		let switch_instance_props = {};

  		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
  			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
  		}

  		return {
  			props: switch_instance_props,
  			$$inline: true
  		};
  	}

  	if (switch_value) {
  		var switch_instance = new switch_value(switch_props());
  	}

  	const block = {
  		key: key_1,
  		first: null,
  		c: function create() {
  			first = empty$1();
  			if (switch_instance) create_component(switch_instance.$$.fragment);
  			switch_instance_anchor = empty$1();
  			this.first = first;
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, first, anchor);

  			if (switch_instance) {
  				mount_component(switch_instance, target, anchor);
  			}

  			insert_dev(target, switch_instance_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const switch_instance_changes = (dirty & /*modals*/ 1)
  			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*modal*/ ctx[4].props)])
  			: {};

  			if (switch_value !== (switch_value = /*modal*/ ctx[4].component)) {
  				if (switch_instance) {
  					group_outros();
  					const old_component = switch_instance;

  					transition_out(old_component.$$.fragment, 1, 0, () => {
  						destroy_component(old_component, 1);
  					});

  					check_outros();
  				}

  				if (switch_value) {
  					switch_instance = new switch_value(switch_props());
  					create_component(switch_instance.$$.fragment);
  					transition_in(switch_instance.$$.fragment, 1);
  					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
  				} else {
  					switch_instance = null;
  				}
  			} else if (switch_value) {
  				switch_instance.$set(switch_instance_changes);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(first);
  			if (detaching) detach_dev(switch_instance_anchor);
  			if (switch_instance) destroy_component(switch_instance, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block.name,
  		type: "each",
  		source: "(33:2) {#each modals as modal (modal.id)}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$1(ctx) {
  	let div;
  	let each_blocks = [];
  	let each_1_lookup = new Map();
  	let current;
  	let each_value = /*modals*/ ctx[0];
  	validate_each_argument(each_value);
  	const get_key = ctx => /*modal*/ ctx[4].id;
  	validate_each_keys(ctx, each_value, get_each_context, get_key);

  	for (let i = 0; i < each_value.length; i += 1) {
  		let child_ctx = get_each_context(ctx, each_value, i);
  		let key = get_key(child_ctx);
  		each_1_lookup.set(key, each_blocks[i] = create_each_block(key, child_ctx));
  	}

  	const block = {
  		c: function create() {
  			div = element("div");

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			attr_dev(div, "class", "framework7-modals");
  			add_location(div, file$1, 31, 0, 614);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(div, null);
  			}

  			/*div_binding*/ ctx[3](div);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (dirty & /*modals*/ 1) {
  				const each_value = /*modals*/ ctx[0];
  				validate_each_argument(each_value);
  				group_outros();
  				validate_each_keys(ctx, each_value, get_each_context, get_key);
  				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block, null, get_each_context);
  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			for (let i = 0; i < each_value.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].d();
  			}

  			/*div_binding*/ ctx[3](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$1.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$1($$self, $$props, $$invalidate) {
  	let modals = [];
  	let el;
  	let routerData;

  	onMount(() => {
  		routerData = {
  			el,
  			modals,
  			setModals(m) {
  				tick().then(() => {
  					$$invalidate(0, modals = m);
  				});
  			}
  		};

  		f7.routers.modals = routerData;
  	});

  	afterUpdate(() => {
  		if (!routerData) return;
  		f7.events.emit("modalsRouterDidUpdate", routerData);
  	});

  	onDestroy(() => {
  		if (!routerData) return;
  		f7.routers.modals = null;
  		routerData = null;
  	});

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Routable_modals> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Routable_modals", $$slots, []);

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(1, el = $$value);
  		});
  	}

  	$$self.$capture_state = () => ({
  		onMount,
  		onDestroy,
  		afterUpdate,
  		tick,
  		f7,
  		modals,
  		el,
  		routerData
  	});

  	$$self.$inject_state = $$props => {
  		if ("modals" in $$props) $$invalidate(0, modals = $$props.modals);
  		if ("el" in $$props) $$invalidate(1, el = $$props.el);
  		if ("routerData" in $$props) routerData = $$props.routerData;
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [modals, el, routerData, div_binding];
  }

  class Routable_modals extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$1, create_fragment$1, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Routable_modals",
  			options,
  			id: create_fragment$1.name
  		});
  	}
  }

  /* node_modules/framework7-svelte/components/app.svelte generated by Svelte v3.21.0 */
  const file$2 = "node_modules/framework7-svelte/components/app.svelte";

  function create_fragment$2(ctx) {
  	let div;
  	let t;
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[9].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);
  	const routablemodals = new Routable_modals({ $$inline: true });

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (default_slot) default_slot.c();
  			t = space();
  			create_component(routablemodals.$$.fragment);
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "class", /*classes*/ ctx[3]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			add_location(div, file$2, 34, 0, 789);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			append_dev(div, t);
  			mount_component(routablemodals, div, null);
  			/*div_binding*/ ctx[10](div);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 256) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[8], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*classes*/ 8) {
  				attr_dev(div, "class", /*classes*/ ctx[3]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			transition_in(routablemodals.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			transition_out(routablemodals.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (default_slot) default_slot.d(detaching);
  			destroy_component(routablemodals);
  			/*div_binding*/ ctx[10](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$2.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$2($$self, $$props, $$invalidate) {
  	let { id = "framework7-root" } = $$props;
  	let { params = {} } = $$props;
  	let { routes = [] } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let el;

  	onMount(() => {
  		const parentEl = el.parentNode;

  		if (parentEl && parentEl !== document.body && parentEl.parentNode === document.body) {
  			parentEl.style.height = "100%";
  		}

  		if (f7.instance) return;
  		f7.init(el, params, routes);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("App", $$slots, ['default']);

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(2, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("params" in $$new_props) $$invalidate(4, params = $$new_props.params);
  		if ("routes" in $$new_props) $$invalidate(5, routes = $$new_props.routes);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
  		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		f7,
  		RoutableModals: Routable_modals,
  		Mixins,
  		Utils: Utils$1,
  		id,
  		params,
  		routes,
  		style,
  		className,
  		el,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("params" in $$props) $$invalidate(4, params = $$new_props.params);
  		if ("routes" in $$props) $$invalidate(5, routes = $$new_props.routes);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
  		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
  		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(3, classes = Utils$1.classNames(className, "framework7-root", Mixins.colorClasses($$props)));
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		el,
  		classes,
  		params,
  		routes,
  		className,
  		$$props,
  		$$scope,
  		$$slots,
  		div_binding
  	];
  }

  class App extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance$2, create_fragment$2, safe_not_equal, {
  			id: 0,
  			params: 4,
  			routes: 5,
  			style: 1,
  			class: 6
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "App",
  			options,
  			id: create_fragment$2.name
  		});
  	}

  	get id() {
  		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get params() {
  		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set params(value) {
  		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get routes() {
  		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set routes(value) {
  		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<App>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<App>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/badge.svelte generated by Svelte v3.21.0 */
  const file$3 = "node_modules/framework7-svelte/components/badge.svelte";

  function create_fragment$3(ctx) {
  	let span;
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[6].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

  	const block = {
  		c: function create() {
  			span = element("span");
  			if (default_slot) default_slot.c();
  			attr_dev(span, "id", /*id*/ ctx[0]);
  			attr_dev(span, "style", /*style*/ ctx[1]);
  			attr_dev(span, "class", /*classes*/ ctx[2]);
  			add_location(span, file$3, 16, 0, 323);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);

  			if (default_slot) {
  				default_slot.m(span, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 32) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(span, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(span, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 4) {
  				attr_dev(span, "class", /*classes*/ ctx[2]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$3.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$3($$self, $$props, $$invalidate) {
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Badge", $$slots, ['default']);

  	$$self.$set = $$new_props => {
  		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
  		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		Mixins,
  		Utils: Utils$1,
  		id,
  		style,
  		className,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
  		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(2, classes = Utils$1.classNames(className, "badge", Mixins.colorClasses($$props)));
  	};

  	$$props = exclude_internal_props($$props);
  	return [id, style, classes, className, $$props, $$scope, $$slots];
  }

  class Badge extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$3, create_fragment$3, safe_not_equal, { id: 0, style: 1, class: 3 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Badge",
  			options,
  			id: create_fragment$3.name
  		});
  	}

  	get id() {
  		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Badge>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Badge>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/block-header.svelte generated by Svelte v3.21.0 */
  const file$4 = "node_modules/framework7-svelte/components/block-header.svelte";

  function create_fragment$4(ctx) {
  	let div;
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[6].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[5], null);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (default_slot) default_slot.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[2]);
  			add_location(div, file$4, 17, 0, 331);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 32) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[5], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[5], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 4) {
  				attr_dev(div, "class", /*classes*/ ctx[2]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$4.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$4($$self, $$props, $$invalidate) {
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Block_header", $$slots, ['default']);

  	$$self.$set = $$new_props => {
  		$$invalidate(4, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
  		if ("$$scope" in $$new_props) $$invalidate(5, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		Utils: Utils$1,
  		Mixins,
  		id,
  		style,
  		className,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(4, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
  		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(2, classes = Utils$1.classNames(className, "block-header", Mixins.colorClasses($$props)));
  	};

  	$$props = exclude_internal_props($$props);
  	return [id, style, classes, className, $$props, $$scope, $$slots];
  }

  class Block_header extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$4, create_fragment$4, safe_not_equal, { id: 0, style: 1, class: 3 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Block_header",
  			options,
  			id: create_fragment$4.name
  		});
  	}

  	get id() {
  		throw new Error("<Block_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Block_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Block_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Block_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Block_header>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Block_header>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/block.svelte generated by Svelte v3.21.0 */
  const file$5 = "node_modules/framework7-svelte/components/block.svelte";

  function create_fragment$5(ctx) {
  	let div;
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[26].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[25], null);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (default_slot) default_slot.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[3]);
  			add_location(div, file$5, 82, 0, 2164);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			/*div_binding*/ ctx[27](div);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 33554432) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[25], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[25], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 8) {
  				attr_dev(div, "class", /*classes*/ ctx[3]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (default_slot) default_slot.d(detaching);
  			/*div_binding*/ ctx[27](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$5.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$5($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { inset = false } = $$props;
  	let { xsmallInset = false } = $$props;
  	let { smallInset = false } = $$props;
  	let { mediumInset = false } = $$props;
  	let { largeInset = false } = $$props;
  	let { xlargeInset = false } = $$props;
  	let { strong = false } = $$props;
  	let { tabs = false } = $$props;
  	let { tab = false } = $$props;
  	let { tabActive = false } = $$props;
  	let { accordionList = false } = $$props;
  	let { accordionOpposite = false } = $$props;
  	let { noHairlines = false } = $$props;
  	let { noHairlinesMd = false } = $$props;
  	let { noHairlinesIos = false } = $$props;
  	let { noHairlinesAurora = false } = $$props;
  	let { class: className = undefined } = $$props;
  	let el;

  	function onTabShow(tabEl) {
  		if (el !== tabEl) return;
  		dispatch("tabShow");
  		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
  	}

  	function onTabHide(tabEl) {
  		if (el !== tabEl) return;
  		dispatch("tabHide");
  		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
  	}

  	onMount(() => {
  		f7.ready(() => {
  			f7.instance.on("tabShow", onTabShow);
  			f7.instance.on("tabHide", onTabHide);
  		});
  	});

  	onDestroy(() => {
  		if (f7.instance) {
  			f7.instance.off("tabShow", onTabShow);
  			f7.instance.off("tabHide", onTabHide);
  		}
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Block", $$slots, ['default']);

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(2, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("inset" in $$new_props) $$invalidate(4, inset = $$new_props.inset);
  		if ("xsmallInset" in $$new_props) $$invalidate(5, xsmallInset = $$new_props.xsmallInset);
  		if ("smallInset" in $$new_props) $$invalidate(6, smallInset = $$new_props.smallInset);
  		if ("mediumInset" in $$new_props) $$invalidate(7, mediumInset = $$new_props.mediumInset);
  		if ("largeInset" in $$new_props) $$invalidate(8, largeInset = $$new_props.largeInset);
  		if ("xlargeInset" in $$new_props) $$invalidate(9, xlargeInset = $$new_props.xlargeInset);
  		if ("strong" in $$new_props) $$invalidate(10, strong = $$new_props.strong);
  		if ("tabs" in $$new_props) $$invalidate(11, tabs = $$new_props.tabs);
  		if ("tab" in $$new_props) $$invalidate(12, tab = $$new_props.tab);
  		if ("tabActive" in $$new_props) $$invalidate(13, tabActive = $$new_props.tabActive);
  		if ("accordionList" in $$new_props) $$invalidate(14, accordionList = $$new_props.accordionList);
  		if ("accordionOpposite" in $$new_props) $$invalidate(15, accordionOpposite = $$new_props.accordionOpposite);
  		if ("noHairlines" in $$new_props) $$invalidate(16, noHairlines = $$new_props.noHairlines);
  		if ("noHairlinesMd" in $$new_props) $$invalidate(17, noHairlinesMd = $$new_props.noHairlinesMd);
  		if ("noHairlinesIos" in $$new_props) $$invalidate(18, noHairlinesIos = $$new_props.noHairlinesIos);
  		if ("noHairlinesAurora" in $$new_props) $$invalidate(19, noHairlinesAurora = $$new_props.noHairlinesAurora);
  		if ("class" in $$new_props) $$invalidate(20, className = $$new_props.class);
  		if ("$$scope" in $$new_props) $$invalidate(25, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		onDestroy,
  		createEventDispatcher,
  		f7,
  		Mixins,
  		Utils: Utils$1,
  		dispatch,
  		id,
  		style,
  		inset,
  		xsmallInset,
  		smallInset,
  		mediumInset,
  		largeInset,
  		xlargeInset,
  		strong,
  		tabs,
  		tab,
  		tabActive,
  		accordionList,
  		accordionOpposite,
  		noHairlines,
  		noHairlinesMd,
  		noHairlinesIos,
  		noHairlinesAurora,
  		className,
  		el,
  		onTabShow,
  		onTabHide,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("inset" in $$props) $$invalidate(4, inset = $$new_props.inset);
  		if ("xsmallInset" in $$props) $$invalidate(5, xsmallInset = $$new_props.xsmallInset);
  		if ("smallInset" in $$props) $$invalidate(6, smallInset = $$new_props.smallInset);
  		if ("mediumInset" in $$props) $$invalidate(7, mediumInset = $$new_props.mediumInset);
  		if ("largeInset" in $$props) $$invalidate(8, largeInset = $$new_props.largeInset);
  		if ("xlargeInset" in $$props) $$invalidate(9, xlargeInset = $$new_props.xlargeInset);
  		if ("strong" in $$props) $$invalidate(10, strong = $$new_props.strong);
  		if ("tabs" in $$props) $$invalidate(11, tabs = $$new_props.tabs);
  		if ("tab" in $$props) $$invalidate(12, tab = $$new_props.tab);
  		if ("tabActive" in $$props) $$invalidate(13, tabActive = $$new_props.tabActive);
  		if ("accordionList" in $$props) $$invalidate(14, accordionList = $$new_props.accordionList);
  		if ("accordionOpposite" in $$props) $$invalidate(15, accordionOpposite = $$new_props.accordionOpposite);
  		if ("noHairlines" in $$props) $$invalidate(16, noHairlines = $$new_props.noHairlines);
  		if ("noHairlinesMd" in $$props) $$invalidate(17, noHairlinesMd = $$new_props.noHairlinesMd);
  		if ("noHairlinesIos" in $$props) $$invalidate(18, noHairlinesIos = $$new_props.noHairlinesIos);
  		if ("noHairlinesAurora" in $$props) $$invalidate(19, noHairlinesAurora = $$new_props.noHairlinesAurora);
  		if ("className" in $$props) $$invalidate(20, className = $$new_props.className);
  		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
  		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(3, classes = Utils$1.classNames(
  			className,
  			"block",
  			{
  				inset,
  				"xsmall-inset": xsmallInset,
  				"small-inset": smallInset,
  				"medium-inset": mediumInset,
  				"large-inset": largeInset,
  				"xlarge-inset": xlargeInset,
  				"block-strong": strong,
  				"accordion-list": accordionList,
  				"accordion-opposite": accordionOpposite,
  				tabs,
  				tab,
  				"tab-active": tabActive,
  				"no-hairlines": noHairlines,
  				"no-hairlines-md": noHairlinesMd,
  				"no-hairlines-ios": noHairlinesIos,
  				"no-hairlines-aurora": noHairlinesAurora
  			},
  			Mixins.colorClasses($$props)
  		));
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		el,
  		classes,
  		inset,
  		xsmallInset,
  		smallInset,
  		mediumInset,
  		largeInset,
  		xlargeInset,
  		strong,
  		tabs,
  		tab,
  		tabActive,
  		accordionList,
  		accordionOpposite,
  		noHairlines,
  		noHairlinesMd,
  		noHairlinesIos,
  		noHairlinesAurora,
  		className,
  		dispatch,
  		onTabShow,
  		onTabHide,
  		$$props,
  		$$scope,
  		$$slots,
  		div_binding
  	];
  }

  class Block extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance$5, create_fragment$5, safe_not_equal, {
  			id: 0,
  			style: 1,
  			inset: 4,
  			xsmallInset: 5,
  			smallInset: 6,
  			mediumInset: 7,
  			largeInset: 8,
  			xlargeInset: 9,
  			strong: 10,
  			tabs: 11,
  			tab: 12,
  			tabActive: 13,
  			accordionList: 14,
  			accordionOpposite: 15,
  			noHairlines: 16,
  			noHairlinesMd: 17,
  			noHairlinesIos: 18,
  			noHairlinesAurora: 19,
  			class: 20
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Block",
  			options,
  			id: create_fragment$5.name
  		});
  	}

  	get id() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get inset() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set inset(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get xsmallInset() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set xsmallInset(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smallInset() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smallInset(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get mediumInset() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set mediumInset(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get largeInset() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set largeInset(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get xlargeInset() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set xlargeInset(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get strong() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set strong(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabs() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabs(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tab() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tab(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabActive() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabActive(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get accordionList() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set accordionList(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get accordionOpposite() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set accordionOpposite(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlines() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlines(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesMd() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesMd(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesIos() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesIos(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesAurora() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesAurora(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Block>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Block>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* eslint no-underscore-dangle: "off" */

  let routerComponentIdCounter = 0;

  var componentsRouter = {
    proto: {
      pageComponentLoader(routerEl, component, componentUrl, options, resolve, reject) {
        const router = this;
        const el = routerEl;
        let viewRouter;
        f7.routers.views.forEach((data) => {
          if (data.el && data.el === routerEl) {
            viewRouter = data;
          }
        });

        if (!viewRouter) {
          reject();
          return;
        }

        const id = `${Utils$1.now()}_${(routerComponentIdCounter += 1)}`;
        const pageData = {
          component,
          id,
          props: Utils$1.extend(
            {
              f7route: options.route,
              $f7route: options.route,
              f7router: router,
              $f7router: router,
            },
            options.route.params,
            options.props || {},
          ),
        };
        if (viewRouter.component) {
          viewRouter.component.$f7router = router;
          viewRouter.component.$f7route = options.route;
        }

        let resolved;
        function onDidUpdate(componentRouterData) {
          if (componentRouterData !== viewRouter || resolved) return;
          f7.events.off('viewRouterDidUpdate', onDidUpdate);

          const pageEl = el.children[el.children.length - 1];
          pageData.el = pageEl;

          resolve(pageEl);
          resolved = true;
        }

        f7.events.on('viewRouterDidUpdate', onDidUpdate);

        viewRouter.pages.push(pageData);
        viewRouter.setPages(viewRouter.pages);
      },
      removePage($pageEl) {
        if (!$pageEl) return;
        const router = this;
        let f7Page;
        if ('length' in $pageEl && $pageEl[0]) f7Page = $pageEl[0].f7Page;
        else f7Page = $pageEl.f7Page;
        if (f7Page && f7Page.route && f7Page.route.route && f7Page.route.route.keepAlive) {
          router.app.$($pageEl).remove();
          return;
        }
        let viewRouter;
        f7.routers.views.forEach((data) => {
          if (data.el && data.el === router.el) {
            viewRouter = data;
          }
        });

        let pageEl;
        if ('length' in $pageEl) {
          // Dom7
          if ($pageEl.length === 0) return;
          pageEl = $pageEl[0];
        } else {
          pageEl = $pageEl;
        }
        if (!pageEl) return;

        let pageComponentFound;
        viewRouter.pages.forEach((page, index) => {
          if (page.el === pageEl) {
            pageComponentFound = true;
            viewRouter.pages.splice(index, 1);
            viewRouter.setPages(viewRouter.pages);
          }
        });
        if (!pageComponentFound) {
          pageEl.parentNode.removeChild(pageEl);
        }
      },
      tabComponentLoader(tabEl, component, componentUrl, options, resolve, reject) {
        const router = this;
        if (!tabEl) reject();

        let tabRouter;
        f7.routers.tabs.forEach((tabData) => {
          if (tabData.el && tabData.el === tabEl) {
            tabRouter = tabData;
          }
        });
        if (!tabRouter) {
          reject();
          return;
        }

        const id = `${Utils$1.now()}_${(routerComponentIdCounter += 1)}`;
        const tabContent = {
          id,
          component,
          props: Utils$1.extend(
            {
              f7route: options.route,
              $f7route: options.route,
              f7router: router,
              $f7router: router,
            },
            options.route.params,
            options.props || {},
          ),
        };

        if (tabRouter.component) {
          tabRouter.component.$f7router = router;
          tabRouter.component.$f7route = options.route;
        }

        let resolved;
        function onDidUpdate(componentRouterData) {
          if (componentRouterData !== tabRouter || resolved) return;
          f7.events.off('tabRouterDidUpdate', onDidUpdate);

          const tabContentEl = tabEl.children[0];
          resolve(tabContentEl);

          resolved = true;
        }

        f7.events.on('tabRouterDidUpdate', onDidUpdate);

        tabRouter.setTabContent(tabContent);
      },
      removeTabContent(tabEl) {
        if (!tabEl) return;

        let tabRouter;
        f7.routers.tabs.forEach((tabData) => {
          if (tabData.el && tabData.el === tabEl) {
            tabRouter = tabData;
          }
        });
        const hasComponent = tabRouter && tabRouter.component;
        if (!tabRouter || !hasComponent) {
          tabEl.innerHTML = ''; // eslint-disable-line
          return;
        }
        tabRouter.setTabContent(null);
      },
      modalComponentLoader(rootEl, component, componentUrl, options, resolve, reject) {
        const router = this;
        const modalsRouter = f7.routers.modals;

        if (!modalsRouter) {
          reject();
          return;
        }

        const id = `${Utils$1.now()}_${(routerComponentIdCounter += 1)}`;
        const modalData = {
          component,
          id,
          props: Utils$1.extend(
            {
              f7route: options.route,
              $f7route: options.route,
              f7router: router,
              $f7router: router,
            },
            options.route.params,
            options.props || {},
          ),
        };
        if (modalsRouter.component) {
          modalsRouter.component.$f7router = router;
          modalsRouter.component.$f7route = options.route;
        }

        let resolved;
        function onDidUpdate() {
          if (resolved) return;
          f7.events.off('modalsRouterDidUpdate', onDidUpdate);

          const modalEl = modalsRouter.el.children[modalsRouter.el.children.length - 1];
          modalData.el = modalEl;

          resolve(modalEl);
          resolved = true;
        }

        f7.events.on('modalsRouterDidUpdate', onDidUpdate);

        modalsRouter.modals.push(modalData);
        modalsRouter.setModals(modalsRouter.modals);
      },
      removeModal(modalEl) {
        const modalsRouter = f7.routers.modals;
        if (!modalsRouter) return;

        let modalDataToRemove;
        modalsRouter.modals.forEach((modalData) => {
          if (modalData.el === modalEl) modalDataToRemove = modalData;
        });

        modalsRouter.modals.splice(modalsRouter.modals.indexOf(modalDataToRemove), 1);
        modalsRouter.setModals(modalsRouter.modals);
      },
    },
  };

  /* eslint no-underscore-dangle: "off" */
  const f7Theme = {};
  const Plugin = {
    name: 'phenomePlugin',
    installed: false,
    install(params = {}) {
      if (Plugin.installed) return;
      Plugin.installed = true;
      const Framework7 = this;
      f7.Framework7 = Framework7;
      f7.events = new Framework7.Events();
      // eslint-disable-next-line
      
      const { theme } = params;
      if (theme === 'md') f7Theme.md = true;
      if (theme === 'ios') f7Theme.ios = true;
      if (theme === 'aurora') f7Theme.aurora = true;
      if (!theme || theme === 'auto') {
        f7Theme.ios = !!Framework7.device.ios;
        f7Theme.aurora = Framework7.device.desktop && Framework7.device.electron;
        f7Theme.md = !f7Theme.ios && !f7Theme.aurora;
      }
      f7.ready(() => {
        f7Theme.ios = f7.instance.theme === 'ios';
        f7Theme.md = f7.instance.theme === 'md';
        f7Theme.aurora = f7.instance.theme === 'aurora';
      });
      
      // Extend F7 Router
      Framework7.Router.use(componentsRouter);
    },
  };

  /* node_modules/framework7-svelte/components/icon.svelte generated by Svelte v3.21.0 */
  const file$6 = "node_modules/framework7-svelte/components/icon.svelte";

  function create_fragment$6(ctx) {
  	let i;
  	let t0_value = (/*iconText*/ ctx[3] || "") + "";
  	let t0;
  	let t1;
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[26].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[25], null);

  	const block = {
  		c: function create() {
  			i = element("i");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (default_slot) default_slot.c();
  			attr_dev(i, "id", /*id*/ ctx[0]);
  			attr_dev(i, "style", /*iconStyle*/ ctx[4]);
  			attr_dev(i, "class", /*iconClasses*/ ctx[2]);
  			add_location(i, file$6, 135, 0, 3326);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, i, anchor);
  			append_dev(i, t0);
  			append_dev(i, t1);

  			if (default_slot) {
  				default_slot.m(i, null);
  			}

  			/*i_binding*/ ctx[27](i);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if ((!current || dirty & /*iconText*/ 8) && t0_value !== (t0_value = (/*iconText*/ ctx[3] || "") + "")) set_data_dev(t0, t0_value);

  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 33554432) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[25], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[25], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(i, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*iconStyle*/ 16) {
  				attr_dev(i, "style", /*iconStyle*/ ctx[4]);
  			}

  			if (!current || dirty & /*iconClasses*/ 4) {
  				attr_dev(i, "class", /*iconClasses*/ ctx[2]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(i);
  			if (default_slot) default_slot.d(detaching);
  			/*i_binding*/ ctx[27](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$6.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$6($$self, $$props, $$invalidate) {
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { material = undefined } = $$props;
  	let { f7: f7$1 = undefined } = $$props;
  	let { icon = undefined } = $$props;
  	let { ios = undefined } = $$props;
  	let { aurora = undefined } = $$props;
  	let { md = undefined } = $$props;
  	let { tooltip = undefined } = $$props;
  	let { tooltipTrigger = undefined } = $$props;
  	let { size = undefined } = $$props;

  	// eslint-disable-next-line
  	let _theme = f7.instance ? f7Theme : null;

  	let el;
  	let f7Tooltip;
  	let classes = { icon: true };

  	if (!f7.instance) {
  		f7.ready(() => {
  			$$invalidate(16, _theme = f7Theme);
  		});
  	}

  	let themeIcon;

  	function iconTextComputed(t) {
  		let textComputed = material || f7$1;

  		if (md && t && t.md && (md.indexOf("material:") >= 0 || md.indexOf("f7:") >= 0)) {
  			textComputed = md.split(":")[1];
  		} else if (ios && t && t.ios && (ios.indexOf("material:") >= 0 || ios.indexOf("f7:") >= 0)) {
  			textComputed = ios.split(":")[1];
  		} else if (aurora && t && t.aurora && (aurora.indexOf("material:") >= 0 || aurora.indexOf("f7:") >= 0)) {
  			textComputed = aurora.split(":")[1];
  		}

  		return textComputed;
  	}

  	let tooltipText = tooltip;

  	function watchTooltip(newText) {
  		const oldText = tooltipText;
  		if (oldText === newText) return;
  		tooltipText = newText;

  		if (!newText && f7Tooltip) {
  			f7Tooltip.destroy();
  			f7Tooltip = null;
  			return;
  		}

  		if (newText && !f7Tooltip && f7.instance) {
  			f7Tooltip = f7.instance.tooltip.create({
  				targetEl: el,
  				text: newText,
  				trigger: tooltipTrigger
  			});

  			return;
  		}

  		if (!newText || !f7Tooltip) return;
  		f7Tooltip.setText(newText);
  	}

  	onMount(() => {
  		if (!tooltip) return;

  		f7.ready(() => {
  			f7Tooltip = f7.instance.tooltip.create({
  				targetEl: el,
  				text: tooltip,
  				trigger: tooltipTrigger
  			});
  		});
  	});

  	onDestroy(() => {
  		if (f7Tooltip && f7Tooltip.destroy) {
  			f7Tooltip.destroy();
  			f7Tooltip = null;
  		}
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Icon", $$slots, ['default']);

  	function i_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(1, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(24, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(5, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
  		if ("material" in $$new_props) $$invalidate(7, material = $$new_props.material);
  		if ("f7" in $$new_props) $$invalidate(8, f7$1 = $$new_props.f7);
  		if ("icon" in $$new_props) $$invalidate(9, icon = $$new_props.icon);
  		if ("ios" in $$new_props) $$invalidate(10, ios = $$new_props.ios);
  		if ("aurora" in $$new_props) $$invalidate(11, aurora = $$new_props.aurora);
  		if ("md" in $$new_props) $$invalidate(12, md = $$new_props.md);
  		if ("tooltip" in $$new_props) $$invalidate(13, tooltip = $$new_props.tooltip);
  		if ("tooltipTrigger" in $$new_props) $$invalidate(14, tooltipTrigger = $$new_props.tooltipTrigger);
  		if ("size" in $$new_props) $$invalidate(15, size = $$new_props.size);
  		if ("$$scope" in $$new_props) $$invalidate(25, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		onDestroy,
  		Mixins,
  		Utils: Utils$1,
  		theme: f7Theme,
  		F7: f7,
  		id,
  		style,
  		className,
  		material,
  		f7: f7$1,
  		icon,
  		ios,
  		aurora,
  		md,
  		tooltip,
  		tooltipTrigger,
  		size,
  		_theme,
  		el,
  		f7Tooltip,
  		classes,
  		themeIcon,
  		iconTextComputed,
  		tooltipText,
  		watchTooltip,
  		iconClasses,
  		iconText,
  		iconSize,
  		iconStyle
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(24, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(5, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
  		if ("material" in $$props) $$invalidate(7, material = $$new_props.material);
  		if ("f7" in $$props) $$invalidate(8, f7$1 = $$new_props.f7);
  		if ("icon" in $$props) $$invalidate(9, icon = $$new_props.icon);
  		if ("ios" in $$props) $$invalidate(10, ios = $$new_props.ios);
  		if ("aurora" in $$props) $$invalidate(11, aurora = $$new_props.aurora);
  		if ("md" in $$props) $$invalidate(12, md = $$new_props.md);
  		if ("tooltip" in $$props) $$invalidate(13, tooltip = $$new_props.tooltip);
  		if ("tooltipTrigger" in $$props) $$invalidate(14, tooltipTrigger = $$new_props.tooltipTrigger);
  		if ("size" in $$props) $$invalidate(15, size = $$new_props.size);
  		if ("_theme" in $$props) $$invalidate(16, _theme = $$new_props._theme);
  		if ("el" in $$props) $$invalidate(1, el = $$new_props.el);
  		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
  		if ("classes" in $$props) $$invalidate(18, classes = $$new_props.classes);
  		if ("themeIcon" in $$props) $$invalidate(19, themeIcon = $$new_props.themeIcon);
  		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
  		if ("iconClasses" in $$props) $$invalidate(2, iconClasses = $$new_props.iconClasses);
  		if ("iconText" in $$props) $$invalidate(3, iconText = $$new_props.iconText);
  		if ("iconSize" in $$props) $$invalidate(21, iconSize = $$new_props.iconSize);
  		if ("iconStyle" in $$props) $$invalidate(4, iconStyle = $$new_props.iconStyle);
  	};

  	let iconClasses;
  	let iconText;
  	let iconSize;
  	let iconStyle;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*_theme, ios, md, aurora*/ 72704) {
  			 if (_theme) {
  				if (_theme.ios) $$invalidate(19, themeIcon = ios);
  				if (_theme.md) $$invalidate(19, themeIcon = md);
  				if (_theme.aurora) $$invalidate(19, themeIcon = aurora);
  			}
  		}

  		if ($$self.$$.dirty & /*themeIcon, material, f7, icon*/ 525184) {
  			 if (themeIcon) {
  				const parts = themeIcon.split(":");
  				const prop = parts[0];
  				const value = parts[1];

  				if (prop === "material" || prop === "f7") {
  					$$invalidate(18, classes["material-icons"] = prop === "material", classes);
  					$$invalidate(18, classes["f7-icons"] = prop === "f7", classes);
  				}

  				if (prop === "icon") {
  					$$invalidate(18, classes[value] = true, classes);
  				}
  			} else {
  				$$invalidate(18, classes = {
  					icon: true,
  					"material-icons": material,
  					"f7-icons": f7$1
  				});

  				if (icon) $$invalidate(18, classes[icon] = true, classes);
  			}
  		}

  		 $$invalidate(2, iconClasses = Utils$1.classNames(className, classes, Mixins.colorClasses($$props)));

  		if ($$self.$$.dirty & /*_theme*/ 65536) {
  			 $$invalidate(3, iconText = iconTextComputed(_theme));
  		}

  		if ($$self.$$.dirty & /*size*/ 32768) {
  			 $$invalidate(21, iconSize = typeof size === "number" || parseFloat(size) === size * 1
  			? `${size}px`
  			: size);
  		}

  		if ($$self.$$.dirty & /*style, iconSize*/ 2097184) {
  			 $$invalidate(4, iconStyle = (style || "") + (iconSize
  			? `;font-size: ${iconSize}; width: ${iconSize}; height: ${iconSize}`.replace(";;", "")
  			: ""));
  		}

  		if ($$self.$$.dirty & /*tooltip*/ 8192) {
  			 watchTooltip(tooltip);
  		}
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		el,
  		iconClasses,
  		iconText,
  		iconStyle,
  		style,
  		className,
  		material,
  		f7$1,
  		icon,
  		ios,
  		aurora,
  		md,
  		tooltip,
  		tooltipTrigger,
  		size,
  		_theme,
  		f7Tooltip,
  		classes,
  		themeIcon,
  		tooltipText,
  		iconSize,
  		iconTextComputed,
  		watchTooltip,
  		$$props,
  		$$scope,
  		$$slots,
  		i_binding
  	];
  }

  class Icon extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance$6, create_fragment$6, safe_not_equal, {
  			id: 0,
  			style: 5,
  			class: 6,
  			material: 7,
  			f7: 8,
  			icon: 9,
  			ios: 10,
  			aurora: 11,
  			md: 12,
  			tooltip: 13,
  			tooltipTrigger: 14,
  			size: 15
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Icon",
  			options,
  			id: create_fragment$6.name
  		});
  	}

  	get id() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get material() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set material(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get f7() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set f7(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get icon() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set icon(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ios() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ios(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get aurora() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set aurora(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get md() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set md(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tooltip() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tooltip(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tooltipTrigger() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tooltipTrigger(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get size() {
  		throw new Error("<Icon>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<Icon>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/button.svelte generated by Svelte v3.21.0 */
  const file$7 = "node_modules/framework7-svelte/components/button.svelte";

  // (194:0) {:else}
  function create_else_block(ctx) {
  	let a;
  	let t0;
  	let t1;
  	let current;
  	let dispose;
  	let if_block0 = /*hasIcon*/ ctx[7] && create_if_block_4(ctx);
  	let if_block1 = typeof /*text*/ ctx[2] !== "undefined" && create_if_block_3(ctx);
  	const default_slot_template = /*$$slots*/ ctx[50].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[49], null);

  	let a_levels = [
  		{ id: /*id*/ ctx[0] },
  		{ style: /*style*/ ctx[1] },
  		{ class: /*classes*/ ctx[5] },
  		/*attrs*/ ctx[4]
  	];

  	let a_data = {};

  	for (let i = 0; i < a_levels.length; i += 1) {
  		a_data = assign(a_data, a_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			a = element("a");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			if (if_block1) if_block1.c();
  			t1 = space();
  			if (default_slot) default_slot.c();
  			set_attributes(a, a_data);
  			add_location(a, file$7, 194, 2, 5116);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, a, anchor);
  			if (if_block0) if_block0.m(a, null);
  			append_dev(a, t0);
  			if (if_block1) if_block1.m(a, null);
  			append_dev(a, t1);

  			if (default_slot) {
  				default_slot.m(a, null);
  			}

  			/*a_binding*/ ctx[52](a);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(a, "click", /*onClick*/ ctx[8], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasIcon*/ ctx[7]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[0] & /*hasIcon*/ 128) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_4(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(a, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (typeof /*text*/ ctx[2] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);
  				} else {
  					if_block1 = create_if_block_3(ctx);
  					if_block1.c();
  					if_block1.m(a, t1);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 262144) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[49], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[49], dirty, null));
  				}
  			}

  			set_attributes(a, get_spread_update(a_levels, [
  				dirty[0] & /*id*/ 1 && { id: /*id*/ ctx[0] },
  				dirty[0] & /*style*/ 2 && { style: /*style*/ ctx[1] },
  				dirty[0] & /*classes*/ 32 && { class: /*classes*/ ctx[5] },
  				dirty[0] & /*attrs*/ 16 && /*attrs*/ ctx[4]
  			]));
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (default_slot) default_slot.d(detaching);
  			/*a_binding*/ ctx[52](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block.name,
  		type: "else",
  		source: "(194:0) {:else}",
  		ctx
  	});

  	return block;
  }

  // (168:0) {#if tagName === 'button'}
  function create_if_block(ctx) {
  	let button;
  	let t0;
  	let t1;
  	let current;
  	let dispose;
  	let if_block0 = /*hasIcon*/ ctx[7] && create_if_block_2(ctx);
  	let if_block1 = typeof /*text*/ ctx[2] !== "undefined" && create_if_block_1(ctx);
  	const default_slot_template = /*$$slots*/ ctx[50].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[49], null);

  	let button_levels = [
  		{ id: /*id*/ ctx[0] },
  		{ style: /*style*/ ctx[1] },
  		{ class: /*classes*/ ctx[5] },
  		/*attrs*/ ctx[4]
  	];

  	let button_data = {};

  	for (let i = 0; i < button_levels.length; i += 1) {
  		button_data = assign(button_data, button_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			button = element("button");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			if (if_block1) if_block1.c();
  			t1 = space();
  			if (default_slot) default_slot.c();
  			set_attributes(button, button_data);
  			add_location(button, file$7, 168, 2, 4571);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, button, anchor);
  			if (if_block0) if_block0.m(button, null);
  			append_dev(button, t0);
  			if (if_block1) if_block1.m(button, null);
  			append_dev(button, t1);

  			if (default_slot) {
  				default_slot.m(button, null);
  			}

  			/*button_binding*/ ctx[51](button);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(button, "click", /*onClick*/ ctx[8], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasIcon*/ ctx[7]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[0] & /*hasIcon*/ 128) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_2(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(button, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (typeof /*text*/ ctx[2] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);
  				} else {
  					if_block1 = create_if_block_1(ctx);
  					if_block1.c();
  					if_block1.m(button, t1);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 262144) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[49], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[49], dirty, null));
  				}
  			}

  			set_attributes(button, get_spread_update(button_levels, [
  				dirty[0] & /*id*/ 1 && { id: /*id*/ ctx[0] },
  				dirty[0] & /*style*/ 2 && { style: /*style*/ ctx[1] },
  				dirty[0] & /*classes*/ 32 && { class: /*classes*/ ctx[5] },
  				dirty[0] & /*attrs*/ 16 && /*attrs*/ ctx[4]
  			]));
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(button);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (default_slot) default_slot.d(detaching);
  			/*button_binding*/ ctx[51](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block.name,
  		type: "if",
  		source: "(168:0) {#if tagName === 'button'}",
  		ctx
  	});

  	return block;
  }

  // (203:4) {#if hasIcon}
  function create_if_block_4(ctx) {
  	let current;

  	const icon = new Icon({
  			props: {
  				material: /*$$props*/ ctx[9].iconMaterial,
  				f7: /*$$props*/ ctx[9].iconF7,
  				icon: /*$$props*/ ctx[9].icon,
  				md: /*$$props*/ ctx[9].iconMd,
  				ios: /*$$props*/ ctx[9].iconIos,
  				aurora: /*$$props*/ ctx[9].iconAurora,
  				color: /*$$props*/ ctx[9].iconColor,
  				size: /*$$props*/ ctx[9].iconSize
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(icon.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(icon, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const icon_changes = {};
  			if (dirty[0] & /*$$props*/ 512) icon_changes.material = /*$$props*/ ctx[9].iconMaterial;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.f7 = /*$$props*/ ctx[9].iconF7;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.icon = /*$$props*/ ctx[9].icon;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.md = /*$$props*/ ctx[9].iconMd;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.ios = /*$$props*/ ctx[9].iconIos;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.aurora = /*$$props*/ ctx[9].iconAurora;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.color = /*$$props*/ ctx[9].iconColor;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.size = /*$$props*/ ctx[9].iconSize;
  			icon.$set(icon_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(icon.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(icon.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(icon, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_4.name,
  		type: "if",
  		source: "(203:4) {#if hasIcon}",
  		ctx
  	});

  	return block;
  }

  // (215:4) {#if typeof text !== 'undefined'}
  function create_if_block_3(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*text*/ ctx[2]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$7, 215, 6, 5579);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*text*/ 4 && t_value !== (t_value = Utils$1.text(/*text*/ ctx[2]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3.name,
  		type: "if",
  		source: "(215:4) {#if typeof text !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (177:4) {#if hasIcon}
  function create_if_block_2(ctx) {
  	let current;

  	const icon = new Icon({
  			props: {
  				material: /*$$props*/ ctx[9].iconMaterial,
  				f7: /*$$props*/ ctx[9].iconF7,
  				icon: /*$$props*/ ctx[9].icon,
  				md: /*$$props*/ ctx[9].iconMd,
  				ios: /*$$props*/ ctx[9].iconIos,
  				aurora: /*$$props*/ ctx[9].iconAurora,
  				color: /*$$props*/ ctx[9].iconColor,
  				size: /*$$props*/ ctx[9].iconSize
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(icon.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(icon, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const icon_changes = {};
  			if (dirty[0] & /*$$props*/ 512) icon_changes.material = /*$$props*/ ctx[9].iconMaterial;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.f7 = /*$$props*/ ctx[9].iconF7;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.icon = /*$$props*/ ctx[9].icon;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.md = /*$$props*/ ctx[9].iconMd;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.ios = /*$$props*/ ctx[9].iconIos;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.aurora = /*$$props*/ ctx[9].iconAurora;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.color = /*$$props*/ ctx[9].iconColor;
  			if (dirty[0] & /*$$props*/ 512) icon_changes.size = /*$$props*/ ctx[9].iconSize;
  			icon.$set(icon_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(icon.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(icon.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(icon, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2.name,
  		type: "if",
  		source: "(177:4) {#if hasIcon}",
  		ctx
  	});

  	return block;
  }

  // (189:4) {#if typeof text !== 'undefined'}
  function create_if_block_1(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*text*/ ctx[2]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$7, 189, 6, 5039);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*text*/ 4 && t_value !== (t_value = Utils$1.text(/*text*/ ctx[2]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1.name,
  		type: "if",
  		source: "(189:4) {#if typeof text !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$7(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block, create_else_block];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*tagName*/ ctx[6] === "button") return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			if_block.c();
  			if_block_anchor = empty$1();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$7.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$7($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { text = undefined } = $$props;
  	let { tabLink = undefined } = $$props;
  	let { tabLinkActive = false } = $$props;
  	let { type = undefined } = $$props;
  	let { href = "#" } = $$props;
  	let { target = undefined } = $$props;
  	let { round = false } = $$props;
  	let { roundMd = false } = $$props;
  	let { roundIos = false } = $$props;
  	let { roundAurora = false } = $$props;
  	let { fill = false } = $$props;
  	let { fillMd = false } = $$props;
  	let { fillIos = false } = $$props;
  	let { fillAurora = false } = $$props;
  	let { large = false } = $$props;
  	let { largeMd = false } = $$props;
  	let { largeIos = false } = $$props;
  	let { largeAurora = false } = $$props;
  	let { small = false } = $$props;
  	let { smallMd = false } = $$props;
  	let { smallIos = false } = $$props;
  	let { smallAurora = false } = $$props;
  	let { raised = false } = $$props;
  	let { raisedMd = false } = $$props;
  	let { raisedIos = false } = $$props;
  	let { raisedAurora = false } = $$props;
  	let { outline = false } = $$props;
  	let { outlineMd = false } = $$props;
  	let { outlineIos = false } = $$props;
  	let { outlineAurora = false } = $$props;
  	let { active = false } = $$props;
  	let { disabled = false } = $$props;
  	let { tooltip = undefined } = $$props;
  	let { tooltipTrigger = undefined } = $$props;
  	let el;
  	let f7Tooltip;
  	let tooltipText = tooltip;

  	function watchTooltip(newText) {
  		const oldText = tooltipText;
  		if (oldText === newText) return;
  		tooltipText = newText;

  		if (!newText && f7Tooltip) {
  			f7Tooltip.destroy();
  			f7Tooltip = null;
  			return;
  		}

  		if (newText && !f7Tooltip && f7.instance) {
  			f7Tooltip = f7.instance.tooltip.create({
  				targetEl: el,
  				text: newText,
  				trigger: tooltipTrigger
  			});

  			return;
  		}

  		if (!newText || !f7Tooltip) return;
  		f7Tooltip.setText(newText);
  	}

  	function onClick() {
  		dispatch("click");
  		if (typeof $$props.onClick === "function") $$props.onClick();
  	}

  	onMount(() => {
  		if ($$props.routeProps) {
  			$$invalidate(3, el.f7RouteProps = $$props.routeProps, el);
  		}

  		if (!tooltip) return;

  		f7.ready(() => {
  			f7Tooltip = f7.instance.tooltip.create({
  				targetEl: el,
  				text: tooltip,
  				trigger: tooltipTrigger
  			});
  		});
  	});

  	afterUpdate(() => {
  		if ($$props.routeProps) {
  			$$invalidate(3, el.f7RouteProps = $$props.routeProps, el);
  		}
  	});

  	onDestroy(() => {
  		if (el) delete el.f7RouteProps;

  		if (f7Tooltip && f7Tooltip.destroy) {
  			f7Tooltip.destroy();
  			f7Tooltip = null;
  		}
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Button", $$slots, ['default']);

  	function button_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(3, el = $$value);
  		});
  	}

  	function a_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(3, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(9, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(10, className = $$new_props.class);
  		if ("text" in $$new_props) $$invalidate(2, text = $$new_props.text);
  		if ("tabLink" in $$new_props) $$invalidate(11, tabLink = $$new_props.tabLink);
  		if ("tabLinkActive" in $$new_props) $$invalidate(12, tabLinkActive = $$new_props.tabLinkActive);
  		if ("type" in $$new_props) $$invalidate(13, type = $$new_props.type);
  		if ("href" in $$new_props) $$invalidate(14, href = $$new_props.href);
  		if ("target" in $$new_props) $$invalidate(15, target = $$new_props.target);
  		if ("round" in $$new_props) $$invalidate(16, round = $$new_props.round);
  		if ("roundMd" in $$new_props) $$invalidate(17, roundMd = $$new_props.roundMd);
  		if ("roundIos" in $$new_props) $$invalidate(18, roundIos = $$new_props.roundIos);
  		if ("roundAurora" in $$new_props) $$invalidate(19, roundAurora = $$new_props.roundAurora);
  		if ("fill" in $$new_props) $$invalidate(20, fill = $$new_props.fill);
  		if ("fillMd" in $$new_props) $$invalidate(21, fillMd = $$new_props.fillMd);
  		if ("fillIos" in $$new_props) $$invalidate(22, fillIos = $$new_props.fillIos);
  		if ("fillAurora" in $$new_props) $$invalidate(23, fillAurora = $$new_props.fillAurora);
  		if ("large" in $$new_props) $$invalidate(24, large = $$new_props.large);
  		if ("largeMd" in $$new_props) $$invalidate(25, largeMd = $$new_props.largeMd);
  		if ("largeIos" in $$new_props) $$invalidate(26, largeIos = $$new_props.largeIos);
  		if ("largeAurora" in $$new_props) $$invalidate(27, largeAurora = $$new_props.largeAurora);
  		if ("small" in $$new_props) $$invalidate(28, small = $$new_props.small);
  		if ("smallMd" in $$new_props) $$invalidate(29, smallMd = $$new_props.smallMd);
  		if ("smallIos" in $$new_props) $$invalidate(30, smallIos = $$new_props.smallIos);
  		if ("smallAurora" in $$new_props) $$invalidate(31, smallAurora = $$new_props.smallAurora);
  		if ("raised" in $$new_props) $$invalidate(32, raised = $$new_props.raised);
  		if ("raisedMd" in $$new_props) $$invalidate(33, raisedMd = $$new_props.raisedMd);
  		if ("raisedIos" in $$new_props) $$invalidate(34, raisedIos = $$new_props.raisedIos);
  		if ("raisedAurora" in $$new_props) $$invalidate(35, raisedAurora = $$new_props.raisedAurora);
  		if ("outline" in $$new_props) $$invalidate(36, outline = $$new_props.outline);
  		if ("outlineMd" in $$new_props) $$invalidate(37, outlineMd = $$new_props.outlineMd);
  		if ("outlineIos" in $$new_props) $$invalidate(38, outlineIos = $$new_props.outlineIos);
  		if ("outlineAurora" in $$new_props) $$invalidate(39, outlineAurora = $$new_props.outlineAurora);
  		if ("active" in $$new_props) $$invalidate(40, active = $$new_props.active);
  		if ("disabled" in $$new_props) $$invalidate(41, disabled = $$new_props.disabled);
  		if ("tooltip" in $$new_props) $$invalidate(42, tooltip = $$new_props.tooltip);
  		if ("tooltipTrigger" in $$new_props) $$invalidate(43, tooltipTrigger = $$new_props.tooltipTrigger);
  		if ("$$scope" in $$new_props) $$invalidate(49, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher,
  		onMount,
  		afterUpdate,
  		onDestroy,
  		Mixins,
  		Utils: Utils$1,
  		f7,
  		Icon,
  		dispatch,
  		id,
  		style,
  		className,
  		text,
  		tabLink,
  		tabLinkActive,
  		type,
  		href,
  		target,
  		round,
  		roundMd,
  		roundIos,
  		roundAurora,
  		fill,
  		fillMd,
  		fillIos,
  		fillAurora,
  		large,
  		largeMd,
  		largeIos,
  		largeAurora,
  		small,
  		smallMd,
  		smallIos,
  		smallAurora,
  		raised,
  		raisedMd,
  		raisedIos,
  		raisedAurora,
  		outline,
  		outlineMd,
  		outlineIos,
  		outlineAurora,
  		active,
  		disabled,
  		tooltip,
  		tooltipTrigger,
  		el,
  		f7Tooltip,
  		tooltipText,
  		watchTooltip,
  		onClick,
  		hrefComputed,
  		attrs,
  		classes,
  		tagName,
  		hasIcon
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(9, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(10, className = $$new_props.className);
  		if ("text" in $$props) $$invalidate(2, text = $$new_props.text);
  		if ("tabLink" in $$props) $$invalidate(11, tabLink = $$new_props.tabLink);
  		if ("tabLinkActive" in $$props) $$invalidate(12, tabLinkActive = $$new_props.tabLinkActive);
  		if ("type" in $$props) $$invalidate(13, type = $$new_props.type);
  		if ("href" in $$props) $$invalidate(14, href = $$new_props.href);
  		if ("target" in $$props) $$invalidate(15, target = $$new_props.target);
  		if ("round" in $$props) $$invalidate(16, round = $$new_props.round);
  		if ("roundMd" in $$props) $$invalidate(17, roundMd = $$new_props.roundMd);
  		if ("roundIos" in $$props) $$invalidate(18, roundIos = $$new_props.roundIos);
  		if ("roundAurora" in $$props) $$invalidate(19, roundAurora = $$new_props.roundAurora);
  		if ("fill" in $$props) $$invalidate(20, fill = $$new_props.fill);
  		if ("fillMd" in $$props) $$invalidate(21, fillMd = $$new_props.fillMd);
  		if ("fillIos" in $$props) $$invalidate(22, fillIos = $$new_props.fillIos);
  		if ("fillAurora" in $$props) $$invalidate(23, fillAurora = $$new_props.fillAurora);
  		if ("large" in $$props) $$invalidate(24, large = $$new_props.large);
  		if ("largeMd" in $$props) $$invalidate(25, largeMd = $$new_props.largeMd);
  		if ("largeIos" in $$props) $$invalidate(26, largeIos = $$new_props.largeIos);
  		if ("largeAurora" in $$props) $$invalidate(27, largeAurora = $$new_props.largeAurora);
  		if ("small" in $$props) $$invalidate(28, small = $$new_props.small);
  		if ("smallMd" in $$props) $$invalidate(29, smallMd = $$new_props.smallMd);
  		if ("smallIos" in $$props) $$invalidate(30, smallIos = $$new_props.smallIos);
  		if ("smallAurora" in $$props) $$invalidate(31, smallAurora = $$new_props.smallAurora);
  		if ("raised" in $$props) $$invalidate(32, raised = $$new_props.raised);
  		if ("raisedMd" in $$props) $$invalidate(33, raisedMd = $$new_props.raisedMd);
  		if ("raisedIos" in $$props) $$invalidate(34, raisedIos = $$new_props.raisedIos);
  		if ("raisedAurora" in $$props) $$invalidate(35, raisedAurora = $$new_props.raisedAurora);
  		if ("outline" in $$props) $$invalidate(36, outline = $$new_props.outline);
  		if ("outlineMd" in $$props) $$invalidate(37, outlineMd = $$new_props.outlineMd);
  		if ("outlineIos" in $$props) $$invalidate(38, outlineIos = $$new_props.outlineIos);
  		if ("outlineAurora" in $$props) $$invalidate(39, outlineAurora = $$new_props.outlineAurora);
  		if ("active" in $$props) $$invalidate(40, active = $$new_props.active);
  		if ("disabled" in $$props) $$invalidate(41, disabled = $$new_props.disabled);
  		if ("tooltip" in $$props) $$invalidate(42, tooltip = $$new_props.tooltip);
  		if ("tooltipTrigger" in $$props) $$invalidate(43, tooltipTrigger = $$new_props.tooltipTrigger);
  		if ("el" in $$props) $$invalidate(3, el = $$new_props.el);
  		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
  		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
  		if ("hrefComputed" in $$props) $$invalidate(46, hrefComputed = $$new_props.hrefComputed);
  		if ("attrs" in $$props) $$invalidate(4, attrs = $$new_props.attrs);
  		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
  		if ("tagName" in $$props) $$invalidate(6, tagName = $$new_props.tagName);
  		if ("hasIcon" in $$props) $$invalidate(7, hasIcon = $$new_props.hasIcon);
  	};

  	let hrefComputed;
  	let attrs;
  	let classes;
  	let tagName;
  	let hasIcon;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[0] & /*href*/ 16384) {
  			 $$invalidate(46, hrefComputed = href === true ? "#" : href || undefined);
  		}

  		 $$invalidate(4, attrs = Utils$1.extend(
  			{
  				href: hrefComputed,
  				target,
  				type,
  				"data-tab": Utils$1.isStringProp(tabLink) && tabLink || undefined
  			},
  			Mixins.linkRouterAttrs($$props),
  			Mixins.linkActionsAttrs($$props)
  		));

  		 $$invalidate(5, classes = Utils$1.classNames(
  			className,
  			"button",
  			{
  				"tab-link": tabLink || tabLink === "",
  				"tab-link-active": tabLinkActive,
  				"button-round": round,
  				"button-round-ios": roundIos,
  				"button-round-aurora": roundAurora,
  				"button-round-md": roundMd,
  				"button-fill": fill,
  				"button-fill-ios": fillIos,
  				"button-fill-aurora": fillAurora,
  				"button-fill-md": fillMd,
  				"button-large": large,
  				"button-large-ios": largeIos,
  				"button-large-aurora": largeAurora,
  				"button-large-md": largeMd,
  				"button-small": small,
  				"button-small-ios": smallIos,
  				"button-small-aurora": smallAurora,
  				"button-small-md": smallMd,
  				"button-raised": raised,
  				"button-raised-ios": raisedIos,
  				"button-raised-aurora": raisedAurora,
  				"button-raised-md": raisedMd,
  				"button-active": active,
  				"button-outline": outline,
  				"button-outline-ios": outlineIos,
  				"button-outline-aurora": outlineAurora,
  				"button-outline-md": outlineMd,
  				disabled
  			},
  			Mixins.colorClasses($$props),
  			Mixins.linkRouterClasses($$props),
  			Mixins.linkActionsClasses($$props)
  		));

  		if ($$self.$$.dirty[0] & /*type*/ 8192) {
  			 $$invalidate(6, tagName = type === "submit" || type === "reset" || type === "button"
  			? "button"
  			: "a");
  		}

  		 $$invalidate(7, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);

  		if ($$self.$$.dirty[1] & /*tooltip*/ 2048) {
  			 watchTooltip(tooltip);
  		}
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		text,
  		el,
  		attrs,
  		classes,
  		tagName,
  		hasIcon,
  		onClick,
  		$$props,
  		className,
  		tabLink,
  		tabLinkActive,
  		type,
  		href,
  		target,
  		round,
  		roundMd,
  		roundIos,
  		roundAurora,
  		fill,
  		fillMd,
  		fillIos,
  		fillAurora,
  		large,
  		largeMd,
  		largeIos,
  		largeAurora,
  		small,
  		smallMd,
  		smallIos,
  		smallAurora,
  		raised,
  		raisedMd,
  		raisedIos,
  		raisedAurora,
  		outline,
  		outlineMd,
  		outlineIos,
  		outlineAurora,
  		active,
  		disabled,
  		tooltip,
  		tooltipTrigger,
  		f7Tooltip,
  		tooltipText,
  		hrefComputed,
  		dispatch,
  		watchTooltip,
  		$$scope,
  		$$slots,
  		button_binding,
  		a_binding
  	];
  }

  class Button extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(
  			this,
  			options,
  			instance$7,
  			create_fragment$7,
  			safe_not_equal,
  			{
  				id: 0,
  				style: 1,
  				class: 10,
  				text: 2,
  				tabLink: 11,
  				tabLinkActive: 12,
  				type: 13,
  				href: 14,
  				target: 15,
  				round: 16,
  				roundMd: 17,
  				roundIos: 18,
  				roundAurora: 19,
  				fill: 20,
  				fillMd: 21,
  				fillIos: 22,
  				fillAurora: 23,
  				large: 24,
  				largeMd: 25,
  				largeIos: 26,
  				largeAurora: 27,
  				small: 28,
  				smallMd: 29,
  				smallIos: 30,
  				smallAurora: 31,
  				raised: 32,
  				raisedMd: 33,
  				raisedIos: 34,
  				raisedAurora: 35,
  				outline: 36,
  				outlineMd: 37,
  				outlineIos: 38,
  				outlineAurora: 39,
  				active: 40,
  				disabled: 41,
  				tooltip: 42,
  				tooltipTrigger: 43
  			},
  			[-1, -1]
  		);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Button",
  			options,
  			id: create_fragment$7.name
  		});
  	}

  	get id() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get text() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set text(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabLink() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabLink(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabLinkActive() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabLinkActive(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get type() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set type(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get href() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set href(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get target() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set target(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get round() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set round(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get roundMd() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set roundMd(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get roundIos() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set roundIos(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get roundAurora() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set roundAurora(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get fill() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set fill(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get fillMd() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set fillMd(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get fillIos() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set fillIos(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get fillAurora() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set fillAurora(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get large() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set large(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get largeMd() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set largeMd(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get largeIos() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set largeIos(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get largeAurora() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set largeAurora(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get small() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set small(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smallMd() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smallMd(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smallIos() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smallIos(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smallAurora() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smallAurora(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get raised() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set raised(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get raisedMd() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set raisedMd(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get raisedIos() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set raisedIos(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get raisedAurora() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set raisedAurora(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get outline() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set outline(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get outlineMd() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set outlineMd(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get outlineIos() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set outlineIos(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get outlineAurora() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set outlineAurora(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get active() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set active(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get disabled() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set disabled(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tooltip() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tooltip(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tooltipTrigger() {
  		throw new Error("<Button>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tooltipTrigger(value) {
  		throw new Error("<Button>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/col.svelte generated by Svelte v3.21.0 */
  const file$8 = "node_modules/framework7-svelte/components/col.svelte";

  // (79:25) 
  function create_if_block_2$1(ctx) {
  	let span;
  	let t;
  	let current;
  	let dispose;
  	const default_slot_template = /*$$slots*/ ctx[21].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
  	let if_block = /*resizable*/ ctx[3] && /*resizableHandler*/ ctx[4] && create_if_block_3$1(ctx);

  	const block = {
  		c: function create() {
  			span = element("span");
  			if (default_slot) default_slot.c();
  			t = space();
  			if (if_block) if_block.c();
  			attr_dev(span, "id", /*id*/ ctx[0]);
  			attr_dev(span, "style", /*style*/ ctx[1]);
  			attr_dev(span, "class", /*classes*/ ctx[6]);
  			add_location(span, file$8, 79, 2, 1954);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, span, anchor);

  			if (default_slot) {
  				default_slot.m(span, null);
  			}

  			append_dev(span, t);
  			if (if_block) if_block.m(span, null);
  			/*span_binding*/ ctx[23](span);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(span, "click", /*onClick*/ ctx[7], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[20], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null));
  				}
  			}

  			if (/*resizable*/ ctx[3] && /*resizableHandler*/ ctx[4]) {
  				if (if_block) ; else {
  					if_block = create_if_block_3$1(ctx);
  					if_block.c();
  					if_block.m(span, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(span, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(span, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 64) {
  				attr_dev(span, "class", /*classes*/ ctx[6]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  			if (default_slot) default_slot.d(detaching);
  			if (if_block) if_block.d();
  			/*span_binding*/ ctx[23](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$1.name,
  		type: "if",
  		source: "(79:25) ",
  		ctx
  	});

  	return block;
  }

  // (66:0) {#if tag === 'div'}
  function create_if_block$1(ctx) {
  	let div;
  	let t;
  	let current;
  	let dispose;
  	const default_slot_template = /*$$slots*/ ctx[21].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[20], null);
  	let if_block = /*resizable*/ ctx[3] && /*resizableHandler*/ ctx[4] && create_if_block_1$1(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (default_slot) default_slot.c();
  			t = space();
  			if (if_block) if_block.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[6]);
  			add_location(div, file$8, 66, 2, 1710);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			append_dev(div, t);
  			if (if_block) if_block.m(div, null);
  			/*div_binding*/ ctx[22](div);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(div, "click", /*onClick*/ ctx[7], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 1048576) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[20], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[20], dirty, null));
  				}
  			}

  			if (/*resizable*/ ctx[3] && /*resizableHandler*/ ctx[4]) {
  				if (if_block) ; else {
  					if_block = create_if_block_1$1(ctx);
  					if_block.c();
  					if_block.m(div, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 64) {
  				attr_dev(div, "class", /*classes*/ ctx[6]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (default_slot) default_slot.d(detaching);
  			if (if_block) if_block.d();
  			/*div_binding*/ ctx[22](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$1.name,
  		type: "if",
  		source: "(66:0) {#if tag === 'div'}",
  		ctx
  	});

  	return block;
  }

  // (88:4) {#if resizable && resizableHandler}
  function create_if_block_3$1(ctx) {
  	let span;

  	const block = {
  		c: function create() {
  			span = element("span");
  			attr_dev(span, "class", "resize-handler");
  			add_location(span, file$8, 88, 6, 2115);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$1.name,
  		type: "if",
  		source: "(88:4) {#if resizable && resizableHandler}",
  		ctx
  	});

  	return block;
  }

  // (75:4) {#if resizable && resizableHandler}
  function create_if_block_1$1(ctx) {
  	let span;

  	const block = {
  		c: function create() {
  			span = element("span");
  			attr_dev(span, "class", "resize-handler");
  			add_location(span, file$8, 75, 6, 1870);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$1.name,
  		type: "if",
  		source: "(75:4) {#if resizable && resizableHandler}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$8(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block$1, create_if_block_2$1];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*tag*/ ctx[2] === "div") return 0;
  		if (/*tag*/ ctx[2] === "span") return 1;
  		return -1;
  	}

  	if (~(current_block_type_index = select_block_type(ctx))) {
  		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	}

  	const block = {
  		c: function create() {
  			if (if_block) if_block.c();
  			if_block_anchor = empty$1();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (~current_block_type_index) {
  				if_blocks[current_block_type_index].m(target, anchor);
  			}

  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if (~current_block_type_index) {
  					if_blocks[current_block_type_index].p(ctx, dirty);
  				}
  			} else {
  				if (if_block) {
  					group_outros();

  					transition_out(if_blocks[previous_block_index], 1, 1, () => {
  						if_blocks[previous_block_index] = null;
  					});

  					check_outros();
  				}

  				if (~current_block_type_index) {
  					if_block = if_blocks[current_block_type_index];

  					if (!if_block) {
  						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  						if_block.c();
  					}

  					transition_in(if_block, 1);
  					if_block.m(if_block_anchor.parentNode, if_block_anchor);
  				} else {
  					if_block = null;
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (~current_block_type_index) {
  				if_blocks[current_block_type_index].d(detaching);
  			}

  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$8.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$8($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { tag = "div" } = $$props;
  	let { width = "auto" } = $$props;
  	let { xsmall = undefined } = $$props;
  	let { small = undefined } = $$props;
  	let { medium = undefined } = $$props;
  	let { large = undefined } = $$props;
  	let { xlarge = undefined } = $$props;
  	let { resizable = false } = $$props;
  	let { resizableFixed = false } = $$props;
  	let { resizableAbsolute = false } = $$props;
  	let { resizableHandler = true } = $$props;
  	let el;

  	function onClick() {
  		dispatch("click");
  		if (typeof $$props.onClick === "function") $$props.onClick();
  	}

  	function onResize(targetEl) {
  		if (el !== targetEl) return;
  		dispatch("gridResize");
  		if (typeof $$props.onGridResize === "function") $$props.onGridResize();
  	}

  	onMount(() => {
  		f7.ready(() => {
  			f7.instance.on("gridResize", onResize);
  		});
  	});

  	onDestroy(() => {
  		if (!f7.instance) return;
  		f7.instance.off("gridResize", onResize);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Col", $$slots, ['default']);

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(5, el = $$value);
  		});
  	}

  	function span_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(5, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(19, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
  		if ("tag" in $$new_props) $$invalidate(2, tag = $$new_props.tag);
  		if ("width" in $$new_props) $$invalidate(9, width = $$new_props.width);
  		if ("xsmall" in $$new_props) $$invalidate(10, xsmall = $$new_props.xsmall);
  		if ("small" in $$new_props) $$invalidate(11, small = $$new_props.small);
  		if ("medium" in $$new_props) $$invalidate(12, medium = $$new_props.medium);
  		if ("large" in $$new_props) $$invalidate(13, large = $$new_props.large);
  		if ("xlarge" in $$new_props) $$invalidate(14, xlarge = $$new_props.xlarge);
  		if ("resizable" in $$new_props) $$invalidate(3, resizable = $$new_props.resizable);
  		if ("resizableFixed" in $$new_props) $$invalidate(15, resizableFixed = $$new_props.resizableFixed);
  		if ("resizableAbsolute" in $$new_props) $$invalidate(16, resizableAbsolute = $$new_props.resizableAbsolute);
  		if ("resizableHandler" in $$new_props) $$invalidate(4, resizableHandler = $$new_props.resizableHandler);
  		if ("$$scope" in $$new_props) $$invalidate(20, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher,
  		onMount,
  		onDestroy,
  		Mixins,
  		Utils: Utils$1,
  		f7,
  		dispatch,
  		id,
  		style,
  		className,
  		tag,
  		width,
  		xsmall,
  		small,
  		medium,
  		large,
  		xlarge,
  		resizable,
  		resizableFixed,
  		resizableAbsolute,
  		resizableHandler,
  		el,
  		onClick,
  		onResize,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(19, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
  		if ("tag" in $$props) $$invalidate(2, tag = $$new_props.tag);
  		if ("width" in $$props) $$invalidate(9, width = $$new_props.width);
  		if ("xsmall" in $$props) $$invalidate(10, xsmall = $$new_props.xsmall);
  		if ("small" in $$props) $$invalidate(11, small = $$new_props.small);
  		if ("medium" in $$props) $$invalidate(12, medium = $$new_props.medium);
  		if ("large" in $$props) $$invalidate(13, large = $$new_props.large);
  		if ("xlarge" in $$props) $$invalidate(14, xlarge = $$new_props.xlarge);
  		if ("resizable" in $$props) $$invalidate(3, resizable = $$new_props.resizable);
  		if ("resizableFixed" in $$props) $$invalidate(15, resizableFixed = $$new_props.resizableFixed);
  		if ("resizableAbsolute" in $$props) $$invalidate(16, resizableAbsolute = $$new_props.resizableAbsolute);
  		if ("resizableHandler" in $$props) $$invalidate(4, resizableHandler = $$new_props.resizableHandler);
  		if ("el" in $$props) $$invalidate(5, el = $$new_props.el);
  		if ("classes" in $$props) $$invalidate(6, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(6, classes = Utils$1.classNames(
  			className,
  			{
  				col: width === "auto",
  				[`col-${width}`]: width !== "auto",
  				[`xsmall-${xsmall}`]: xsmall,
  				[`small-${small}`]: small,
  				[`medium-${medium}`]: medium,
  				[`large-${large}`]: large,
  				[`xlarge-${xlarge}`]: xlarge,
  				resizable,
  				"resizable-fixed": resizableFixed,
  				"resizable-absolute": resizableAbsolute
  			},
  			Mixins.colorClasses($$props)
  		));
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		tag,
  		resizable,
  		resizableHandler,
  		el,
  		classes,
  		onClick,
  		className,
  		width,
  		xsmall,
  		small,
  		medium,
  		large,
  		xlarge,
  		resizableFixed,
  		resizableAbsolute,
  		dispatch,
  		onResize,
  		$$props,
  		$$scope,
  		$$slots,
  		div_binding,
  		span_binding
  	];
  }

  class Col extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance$8, create_fragment$8, safe_not_equal, {
  			id: 0,
  			style: 1,
  			class: 8,
  			tag: 2,
  			width: 9,
  			xsmall: 10,
  			small: 11,
  			medium: 12,
  			large: 13,
  			xlarge: 14,
  			resizable: 3,
  			resizableFixed: 15,
  			resizableAbsolute: 16,
  			resizableHandler: 4
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Col",
  			options,
  			id: create_fragment$8.name
  		});
  	}

  	get id() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tag() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tag(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get width() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set width(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get xsmall() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set xsmall(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get small() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set small(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get medium() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set medium(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get large() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set large(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get xlarge() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set xlarge(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get resizable() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set resizable(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get resizableFixed() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set resizableFixed(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get resizableAbsolute() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set resizableAbsolute(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get resizableHandler() {
  		throw new Error("<Col>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set resizableHandler(value) {
  		throw new Error("<Col>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/link.svelte generated by Svelte v3.21.0 */
  const file$9 = "node_modules/framework7-svelte/components/link.svelte";

  // (162:2) {#if hasIcon}
  function create_if_block_2$2(ctx) {
  	let current;

  	const icon = new Icon({
  			props: {
  				material: /*$$props*/ ctx[12].iconMaterial,
  				f7: /*$$props*/ ctx[12].iconF7,
  				icon: /*$$props*/ ctx[12].icon,
  				md: /*$$props*/ ctx[12].iconMd,
  				ios: /*$$props*/ ctx[12].iconIos,
  				aurora: /*$$props*/ ctx[12].iconAurora,
  				color: /*$$props*/ ctx[12].iconColor,
  				size: /*$$props*/ ctx[12].iconSize,
  				$$slots: { default: [create_default_slot_1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(icon.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(icon, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const icon_changes = {};
  			if (dirty[0] & /*$$props*/ 4096) icon_changes.material = /*$$props*/ ctx[12].iconMaterial;
  			if (dirty[0] & /*$$props*/ 4096) icon_changes.f7 = /*$$props*/ ctx[12].iconF7;
  			if (dirty[0] & /*$$props*/ 4096) icon_changes.icon = /*$$props*/ ctx[12].icon;
  			if (dirty[0] & /*$$props*/ 4096) icon_changes.md = /*$$props*/ ctx[12].iconMd;
  			if (dirty[0] & /*$$props*/ 4096) icon_changes.ios = /*$$props*/ ctx[12].iconIos;
  			if (dirty[0] & /*$$props*/ 4096) icon_changes.aurora = /*$$props*/ ctx[12].iconAurora;
  			if (dirty[0] & /*$$props*/ 4096) icon_changes.color = /*$$props*/ ctx[12].iconColor;
  			if (dirty[0] & /*$$props*/ 4096) icon_changes.size = /*$$props*/ ctx[12].iconSize;

  			if (dirty[0] & /*badgeColor, iconBadge*/ 48 | dirty[1] & /*$$scope*/ 32) {
  				icon_changes.$$scope = { dirty, ctx };
  			}

  			icon.$set(icon_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(icon.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(icon.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(icon, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$2.name,
  		type: "if",
  		source: "(162:2) {#if hasIcon}",
  		ctx
  	});

  	return block;
  }

  // (172:5) {#if iconBadge}
  function create_if_block_3$2(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[4],
  				$$slots: { default: [create_default_slot_2] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 16) badge_1_changes.color = /*badgeColor*/ ctx[4];

  			if (dirty[0] & /*iconBadge*/ 32 | dirty[1] & /*$$scope*/ 32) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$2.name,
  		type: "if",
  		source: "(172:5) {#if iconBadge}",
  		ctx
  	});

  	return block;
  }

  // (172:20) <Badge color={badgeColor}>
  function create_default_slot_2(ctx) {
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(/*iconBadge*/ ctx[5]);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*iconBadge*/ 32) set_data_dev(t, /*iconBadge*/ ctx[5]);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_2.name,
  		type: "slot",
  		source: "(172:20) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (163:4) <Icon       material={$$props.iconMaterial}       f7={$$props.iconF7}       icon={$$props.icon}       md={$$props.iconMd}       ios={$$props.iconIos}       aurora={$$props.iconAurora}       color={$$props.iconColor}       size={$$props.iconSize}     >
  function create_default_slot_1(ctx) {
  	let if_block_anchor;
  	let current;
  	let if_block = /*iconBadge*/ ctx[5] && create_if_block_3$2(ctx);

  	const block = {
  		c: function create() {
  			if (if_block) if_block.c();
  			if_block_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if (if_block) if_block.m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*iconBadge*/ ctx[5]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);

  					if (dirty[0] & /*iconBadge*/ 32) {
  						transition_in(if_block, 1);
  					}
  				} else {
  					if_block = create_if_block_3$2(ctx);
  					if_block.c();
  					transition_in(if_block, 1);
  					if_block.m(if_block_anchor.parentNode, if_block_anchor);
  				}
  			} else if (if_block) {
  				group_outros();

  				transition_out(if_block, 1, 1, () => {
  					if_block = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block) if_block.d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1.name,
  		type: "slot",
  		source: "(163:4) <Icon       material={$$props.iconMaterial}       f7={$$props.iconF7}       icon={$$props.icon}       md={$$props.iconMd}       ios={$$props.iconIos}       aurora={$$props.iconAurora}       color={$$props.iconColor}       size={$$props.iconSize}     >",
  		ctx
  	});

  	return block;
  }

  // (175:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}
  function create_if_block$2(ctx) {
  	let span;
  	let t0_value = Utils$1.text(/*text*/ ctx[2]) + "";
  	let t0;
  	let t1;
  	let current;
  	let if_block = typeof /*badge*/ ctx[3] !== "undefined" && create_if_block_1$2(ctx);

  	const block = {
  		c: function create() {
  			span = element("span");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (if_block) if_block.c();
  			toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[7]);
  			add_location(span, file$9, 175, 4, 4488);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t0);
  			append_dev(span, t1);
  			if (if_block) if_block.m(span, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*text*/ 4) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

  			if (typeof /*badge*/ ctx[3] !== "undefined") {
  				if (if_block) {
  					if_block.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 8) {
  						transition_in(if_block, 1);
  					}
  				} else {
  					if_block = create_if_block_1$2(ctx);
  					if_block.c();
  					transition_in(if_block, 1);
  					if_block.m(span, null);
  				}
  			} else if (if_block) {
  				group_outros();

  				transition_out(if_block, 1, 1, () => {
  					if_block = null;
  				});

  				check_outros();
  			}

  			if (dirty[0] & /*isTabbarLabel*/ 128) {
  				toggle_class(span, "tabbar-label", /*isTabbarLabel*/ ctx[7]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  			if (if_block) if_block.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$2.name,
  		type: "if",
  		source: "(175:2) {#if typeof text !== 'undefined' || typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (178:6) {#if typeof badge !== 'undefined'}
  function create_if_block_1$2(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[4],
  				$$slots: { default: [create_default_slot] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 16) badge_1_changes.color = /*badgeColor*/ ctx[4];

  			if (dirty[0] & /*badge*/ 8 | dirty[1] & /*$$scope*/ 32) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$2.name,
  		type: "if",
  		source: "(178:6) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (178:40) <Badge color={badgeColor}>
  function create_default_slot(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[3]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 8 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[3]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot.name,
  		type: "slot",
  		source: "(178:40) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  function create_fragment$9(ctx) {
  	let a;
  	let t0;
  	let t1;
  	let current;
  	let dispose;
  	let if_block0 = /*hasIcon*/ ctx[10] && create_if_block_2$2(ctx);
  	const default_slot_template = /*$$slots*/ ctx[34].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[36], null);
  	let if_block1 = (typeof /*text*/ ctx[2] !== "undefined" || typeof /*badge*/ ctx[3] !== "undefined") && create_if_block$2(ctx);

  	let a_levels = [
  		{ id: /*id*/ ctx[0] },
  		{ style: /*style*/ ctx[1] },
  		{ class: /*classes*/ ctx[9] },
  		/*attrs*/ ctx[8]
  	];

  	let a_data = {};

  	for (let i = 0; i < a_levels.length; i += 1) {
  		a_data = assign(a_data, a_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			a = element("a");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			if (default_slot) default_slot.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			set_attributes(a, a_data);
  			add_location(a, file$9, 153, 0, 3953);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, a, anchor);
  			if (if_block0) if_block0.m(a, null);
  			append_dev(a, t0);

  			if (default_slot) {
  				default_slot.m(a, null);
  			}

  			append_dev(a, t1);
  			if (if_block1) if_block1.m(a, null);
  			/*a_binding*/ ctx[35](a);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(a, "click", /*onClick*/ ctx[11], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasIcon*/ ctx[10]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[0] & /*hasIcon*/ 1024) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_2$2(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(a, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 32) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[36], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[36], dirty, null));
  				}
  			}

  			if (typeof /*text*/ ctx[2] !== "undefined" || typeof /*badge*/ ctx[3] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*text, badge*/ 12) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block$2(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(a, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			set_attributes(a, get_spread_update(a_levels, [
  				dirty[0] & /*id*/ 1 && { id: /*id*/ ctx[0] },
  				dirty[0] & /*style*/ 2 && { style: /*style*/ ctx[1] },
  				dirty[0] & /*classes*/ 512 && { class: /*classes*/ ctx[9] },
  				dirty[0] & /*attrs*/ 256 && /*attrs*/ ctx[8]
  			]));
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(default_slot, local);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(default_slot, local);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (if_block0) if_block0.d();
  			if (default_slot) default_slot.d(detaching);
  			if (if_block1) if_block1.d();
  			/*a_binding*/ ctx[35](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$9.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$9($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { noLinkClass = false } = $$props;
  	let { text = undefined } = $$props;
  	let { tabLink = undefined } = $$props;
  	let { tabLinkActive = false } = $$props;
  	let { tabbarLabel = false } = $$props;
  	let { iconOnly = false } = $$props;
  	let { badge = undefined } = $$props;
  	let { badgeColor = undefined } = $$props;
  	let { iconBadge = undefined } = $$props;
  	let { href = "#" } = $$props;
  	let { target = undefined } = $$props;
  	let { tooltip = undefined } = $$props;
  	let { tooltipTrigger = undefined } = $$props;
  	let { smartSelect = false } = $$props;
  	let { smartSelectParams = undefined } = $$props;
  	let el;
  	let f7Tooltip;
  	let f7SmartSelect;
  	let isTabbarLabel = tabbarLabel;
  	let tooltipText = tooltip;

  	function watchTooltip(newText) {
  		const oldText = tooltipText;
  		if (oldText === newText) return;
  		tooltipText = newText;

  		if (!newText && f7Tooltip) {
  			f7Tooltip.destroy();
  			f7Tooltip = null;
  			return;
  		}

  		if (newText && !f7Tooltip && f7.instance) {
  			f7Tooltip = f7.instance.tooltip.create({
  				targetEl: el,
  				text: newText,
  				trigger: tooltipTrigger
  			});

  			return;
  		}

  		if (!newText || !f7Tooltip) return;
  		f7Tooltip.setText(newText);
  	}

  	function onClick() {
  		dispatch("click");
  		if (typeof $$props.onClick === "function") $$props.onClick();
  	}

  	onMount(() => {
  		if ($$props.routeProps) {
  			$$invalidate(6, el.f7RouteProps = $$props.routeProps, el);
  		}

  		f7.ready(() => {
  			if (tabbarLabel || (tabLink || tabLink === "") && f7.instance.$(el).parents(".tabbar-labels").length) {
  				$$invalidate(7, isTabbarLabel = true);
  			}

  			if (smartSelect) {
  				const ssParams = Utils$1.extend({ el }, smartSelectParams || {});
  				f7SmartSelect = f7.instance.smartSelect.create(ssParams);
  			}

  			if (tooltip) {
  				f7Tooltip = f7.instance.tooltip.create({
  					targetEl: el,
  					text: tooltip,
  					trigger: tooltipTrigger
  				});
  			}
  		});
  	});

  	afterUpdate(() => {
  		if ($$props.routeProps) {
  			$$invalidate(6, el.f7RouteProps = $$props.routeProps, el);
  		}
  	});

  	onDestroy(() => {
  		if (el) delete el.f7RouteProps;

  		if (f7SmartSelect && f7SmartSelect.destroy) {
  			f7SmartSelect.destroy();
  			f7SmartSelect = null;
  		}

  		if (f7Tooltip && f7Tooltip.destroy) {
  			f7Tooltip.destroy();
  			f7Tooltip = null;
  		}
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Link", $$slots, ['default']);

  	function a_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(6, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(12, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(13, className = $$new_props.class);
  		if ("noLinkClass" in $$new_props) $$invalidate(14, noLinkClass = $$new_props.noLinkClass);
  		if ("text" in $$new_props) $$invalidate(2, text = $$new_props.text);
  		if ("tabLink" in $$new_props) $$invalidate(15, tabLink = $$new_props.tabLink);
  		if ("tabLinkActive" in $$new_props) $$invalidate(16, tabLinkActive = $$new_props.tabLinkActive);
  		if ("tabbarLabel" in $$new_props) $$invalidate(17, tabbarLabel = $$new_props.tabbarLabel);
  		if ("iconOnly" in $$new_props) $$invalidate(18, iconOnly = $$new_props.iconOnly);
  		if ("badge" in $$new_props) $$invalidate(3, badge = $$new_props.badge);
  		if ("badgeColor" in $$new_props) $$invalidate(4, badgeColor = $$new_props.badgeColor);
  		if ("iconBadge" in $$new_props) $$invalidate(5, iconBadge = $$new_props.iconBadge);
  		if ("href" in $$new_props) $$invalidate(19, href = $$new_props.href);
  		if ("target" in $$new_props) $$invalidate(20, target = $$new_props.target);
  		if ("tooltip" in $$new_props) $$invalidate(21, tooltip = $$new_props.tooltip);
  		if ("tooltipTrigger" in $$new_props) $$invalidate(22, tooltipTrigger = $$new_props.tooltipTrigger);
  		if ("smartSelect" in $$new_props) $$invalidate(23, smartSelect = $$new_props.smartSelect);
  		if ("smartSelectParams" in $$new_props) $$invalidate(24, smartSelectParams = $$new_props.smartSelectParams);
  		if ("$$scope" in $$new_props) $$invalidate(36, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher,
  		onMount,
  		afterUpdate,
  		onDestroy,
  		Mixins,
  		Utils: Utils$1,
  		f7,
  		hasSlots,
  		Badge,
  		Icon,
  		dispatch,
  		id,
  		style,
  		className,
  		noLinkClass,
  		text,
  		tabLink,
  		tabLinkActive,
  		tabbarLabel,
  		iconOnly,
  		badge,
  		badgeColor,
  		iconBadge,
  		href,
  		target,
  		tooltip,
  		tooltipTrigger,
  		smartSelect,
  		smartSelectParams,
  		el,
  		f7Tooltip,
  		f7SmartSelect,
  		isTabbarLabel,
  		tooltipText,
  		watchTooltip,
  		onClick,
  		hrefComputed,
  		attrs,
  		hasDefaultSlots,
  		iconOnlyComputed,
  		classes,
  		hasIcon,
  		hasIconBadge
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(12, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(13, className = $$new_props.className);
  		if ("noLinkClass" in $$props) $$invalidate(14, noLinkClass = $$new_props.noLinkClass);
  		if ("text" in $$props) $$invalidate(2, text = $$new_props.text);
  		if ("tabLink" in $$props) $$invalidate(15, tabLink = $$new_props.tabLink);
  		if ("tabLinkActive" in $$props) $$invalidate(16, tabLinkActive = $$new_props.tabLinkActive);
  		if ("tabbarLabel" in $$props) $$invalidate(17, tabbarLabel = $$new_props.tabbarLabel);
  		if ("iconOnly" in $$props) $$invalidate(18, iconOnly = $$new_props.iconOnly);
  		if ("badge" in $$props) $$invalidate(3, badge = $$new_props.badge);
  		if ("badgeColor" in $$props) $$invalidate(4, badgeColor = $$new_props.badgeColor);
  		if ("iconBadge" in $$props) $$invalidate(5, iconBadge = $$new_props.iconBadge);
  		if ("href" in $$props) $$invalidate(19, href = $$new_props.href);
  		if ("target" in $$props) $$invalidate(20, target = $$new_props.target);
  		if ("tooltip" in $$props) $$invalidate(21, tooltip = $$new_props.tooltip);
  		if ("tooltipTrigger" in $$props) $$invalidate(22, tooltipTrigger = $$new_props.tooltipTrigger);
  		if ("smartSelect" in $$props) $$invalidate(23, smartSelect = $$new_props.smartSelect);
  		if ("smartSelectParams" in $$props) $$invalidate(24, smartSelectParams = $$new_props.smartSelectParams);
  		if ("el" in $$props) $$invalidate(6, el = $$new_props.el);
  		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
  		if ("f7SmartSelect" in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
  		if ("isTabbarLabel" in $$props) $$invalidate(7, isTabbarLabel = $$new_props.isTabbarLabel);
  		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
  		if ("hrefComputed" in $$props) $$invalidate(28, hrefComputed = $$new_props.hrefComputed);
  		if ("attrs" in $$props) $$invalidate(8, attrs = $$new_props.attrs);
  		if ("hasDefaultSlots" in $$props) $$invalidate(29, hasDefaultSlots = $$new_props.hasDefaultSlots);
  		if ("iconOnlyComputed" in $$props) $$invalidate(30, iconOnlyComputed = $$new_props.iconOnlyComputed);
  		if ("classes" in $$props) $$invalidate(9, classes = $$new_props.classes);
  		if ("hasIcon" in $$props) $$invalidate(10, hasIcon = $$new_props.hasIcon);
  		if ("hasIconBadge" in $$props) hasIconBadge = $$new_props.hasIconBadge;
  	};

  	let hrefComputed;
  	let attrs;
  	let hasDefaultSlots;
  	let iconOnlyComputed;
  	let classes;
  	let hasIcon;
  	let hasIconBadge;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[0] & /*href*/ 524288) {
  			 $$invalidate(28, hrefComputed = href === true ? "#" : href || undefined);
  		}

  		 $$invalidate(8, attrs = Utils$1.extend(
  			{
  				href: hrefComputed,
  				target,
  				"data-tab": Utils$1.isStringProp(tabLink) && tabLink || undefined
  			},
  			Mixins.linkRouterAttrs($$props),
  			Mixins.linkActionsAttrs($$props)
  		));

  		if ($$self.$$.dirty[0] & /*iconOnly, text, hasDefaultSlots*/ 537133060) {
  			 $$invalidate(30, iconOnlyComputed = iconOnly || !text && !hasDefaultSlots);
  		}

  		 $$invalidate(9, classes = Utils$1.classNames(
  			className,
  			{
  				link: !(noLinkClass || isTabbarLabel),
  				"icon-only": iconOnlyComputed,
  				"tab-link": tabLink || tabLink === "",
  				"tab-link-active": tabLinkActive,
  				"smart-select": smartSelect
  			},
  			Mixins.colorClasses($$props),
  			Mixins.linkRouterClasses($$props),
  			Mixins.linkActionsClasses($$props)
  		));

  		 $$invalidate(10, hasIcon = $$props.icon || $$props.iconMaterial || $$props.iconF7 || $$props.iconMd || $$props.iconIos || $$props.iconAurora);
  		 hasIconBadge = $$props.hasIconBadge;

  		if ($$self.$$.dirty[0] & /*tooltip*/ 2097152) {
  			 watchTooltip(tooltip);
  		}
  	};

  	 $$invalidate(29, hasDefaultSlots = hasSlots(arguments, "default"));
  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		text,
  		badge,
  		badgeColor,
  		iconBadge,
  		el,
  		isTabbarLabel,
  		attrs,
  		classes,
  		hasIcon,
  		onClick,
  		$$props,
  		className,
  		noLinkClass,
  		tabLink,
  		tabLinkActive,
  		tabbarLabel,
  		iconOnly,
  		href,
  		target,
  		tooltip,
  		tooltipTrigger,
  		smartSelect,
  		smartSelectParams,
  		f7Tooltip,
  		f7SmartSelect,
  		tooltipText,
  		hrefComputed,
  		hasDefaultSlots,
  		iconOnlyComputed,
  		hasIconBadge,
  		dispatch,
  		watchTooltip,
  		$$slots,
  		a_binding,
  		$$scope
  	];
  }

  class Link extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(
  			this,
  			options,
  			instance$9,
  			create_fragment$9,
  			safe_not_equal,
  			{
  				id: 0,
  				style: 1,
  				class: 13,
  				noLinkClass: 14,
  				text: 2,
  				tabLink: 15,
  				tabLinkActive: 16,
  				tabbarLabel: 17,
  				iconOnly: 18,
  				badge: 3,
  				badgeColor: 4,
  				iconBadge: 5,
  				href: 19,
  				target: 20,
  				tooltip: 21,
  				tooltipTrigger: 22,
  				smartSelect: 23,
  				smartSelectParams: 24
  			},
  			[-1, -1]
  		);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Link",
  			options,
  			id: create_fragment$9.name
  		});
  	}

  	get id() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noLinkClass() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noLinkClass(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get text() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set text(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabLink() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabLink(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabLinkActive() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabLinkActive(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabbarLabel() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabbarLabel(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get iconOnly() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set iconOnly(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get badge() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set badge(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get badgeColor() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set badgeColor(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get iconBadge() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set iconBadge(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get href() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set href(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get target() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set target(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tooltip() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tooltip(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tooltipTrigger() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tooltipTrigger(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smartSelect() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smartSelect(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smartSelectParams() {
  		throw new Error("<Link>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smartSelectParams(value) {
  		throw new Error("<Link>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/list-item.svelte generated by Svelte v3.21.0 */
  const file$a = "node_modules/framework7-svelte/components/list-item.svelte";
  const get_root_end_slot_changes = dirty => ({});
  const get_root_end_slot_context = ctx => ({});
  const get_root_slot_changes = dirty => ({});
  const get_root_slot_context = ctx => ({});
  const get_content_end_slot_changes_5 = dirty => ({});
  const get_content_end_slot_context_5 = ctx => ({});
  const get_content_slot_changes_5 = dirty => ({});
  const get_content_slot_context_5 = ctx => ({});
  const get_inner_end_slot_changes_5 = dirty => ({});
  const get_inner_end_slot_context_5 = ctx => ({});
  const get_inner_slot_changes_11 = dirty => ({});
  const get_inner_slot_context_11 = ctx => ({});
  const get_after_end_slot_changes_11 = dirty => ({});
  const get_after_end_slot_context_11 = ctx => ({});
  const get_after_slot_changes_11 = dirty => ({});
  const get_after_slot_context_11 = ctx => ({});
  const get_after_start_slot_changes_11 = dirty => ({});
  const get_after_start_slot_context_11 = ctx => ({});
  const get_after_title_slot_changes_11 = dirty => ({});
  const get_after_title_slot_context_11 = ctx => ({});
  const get_footer_slot_changes_11 = dirty => ({});
  const get_footer_slot_context_11 = ctx => ({});
  const get_title_slot_changes_11 = dirty => ({});
  const get_title_slot_context_11 = ctx => ({});
  const get_header_slot_changes_11 = dirty => ({});
  const get_header_slot_context_11 = ctx => ({});
  const get_before_title_slot_changes_11 = dirty => ({});
  const get_before_title_slot_context_11 = ctx => ({});
  const get_footer_slot_changes_10 = dirty => ({});
  const get_footer_slot_context_10 = ctx => ({});
  const get_inner_slot_changes_10 = dirty => ({});
  const get_inner_slot_context_10 = ctx => ({});
  const get_text_slot_changes_5 = dirty => ({});
  const get_text_slot_context_5 = ctx => ({});
  const get_subtitle_slot_changes_5 = dirty => ({});
  const get_subtitle_slot_context_5 = ctx => ({});
  const get_after_end_slot_changes_10 = dirty => ({});
  const get_after_end_slot_context_10 = ctx => ({});
  const get_after_slot_changes_10 = dirty => ({});
  const get_after_slot_context_10 = ctx => ({});
  const get_after_start_slot_changes_10 = dirty => ({});
  const get_after_start_slot_context_10 = ctx => ({});
  const get_after_title_slot_changes_10 = dirty => ({});
  const get_after_title_slot_context_10 = ctx => ({});
  const get_title_slot_changes_10 = dirty => ({});
  const get_title_slot_context_10 = ctx => ({});
  const get_before_title_slot_changes_10 = dirty => ({});
  const get_before_title_slot_context_10 = ctx => ({});
  const get_header_slot_changes_10 = dirty => ({});
  const get_header_slot_context_10 = ctx => ({});
  const get_inner_start_slot_changes_5 = dirty => ({});
  const get_inner_start_slot_context_5 = ctx => ({});
  const get_media_slot_changes_5 = dirty => ({});
  const get_media_slot_context_5 = ctx => ({});
  const get_content_start_slot_changes_5 = dirty => ({});
  const get_content_start_slot_context_5 = ctx => ({});
  const get_content_end_slot_changes_4 = dirty => ({});
  const get_content_end_slot_context_4 = ctx => ({});
  const get_content_slot_changes_4 = dirty => ({});
  const get_content_slot_context_4 = ctx => ({});
  const get_inner_end_slot_changes_4 = dirty => ({});
  const get_inner_end_slot_context_4 = ctx => ({});
  const get_inner_slot_changes_9 = dirty => ({});
  const get_inner_slot_context_9 = ctx => ({});
  const get_after_end_slot_changes_9 = dirty => ({});
  const get_after_end_slot_context_9 = ctx => ({});
  const get_after_slot_changes_9 = dirty => ({});
  const get_after_slot_context_9 = ctx => ({});
  const get_after_start_slot_changes_9 = dirty => ({});
  const get_after_start_slot_context_9 = ctx => ({});
  const get_after_title_slot_changes_9 = dirty => ({});
  const get_after_title_slot_context_9 = ctx => ({});
  const get_footer_slot_changes_9 = dirty => ({});
  const get_footer_slot_context_9 = ctx => ({});
  const get_title_slot_changes_9 = dirty => ({});
  const get_title_slot_context_9 = ctx => ({});
  const get_header_slot_changes_9 = dirty => ({});
  const get_header_slot_context_9 = ctx => ({});
  const get_before_title_slot_changes_9 = dirty => ({});
  const get_before_title_slot_context_9 = ctx => ({});
  const get_footer_slot_changes_8 = dirty => ({});
  const get_footer_slot_context_8 = ctx => ({});
  const get_inner_slot_changes_8 = dirty => ({});
  const get_inner_slot_context_8 = ctx => ({});
  const get_text_slot_changes_4 = dirty => ({});
  const get_text_slot_context_4 = ctx => ({});
  const get_subtitle_slot_changes_4 = dirty => ({});
  const get_subtitle_slot_context_4 = ctx => ({});
  const get_after_end_slot_changes_8 = dirty => ({});
  const get_after_end_slot_context_8 = ctx => ({});
  const get_after_slot_changes_8 = dirty => ({});
  const get_after_slot_context_8 = ctx => ({});
  const get_after_start_slot_changes_8 = dirty => ({});
  const get_after_start_slot_context_8 = ctx => ({});
  const get_after_title_slot_changes_8 = dirty => ({});
  const get_after_title_slot_context_8 = ctx => ({});
  const get_title_slot_changes_8 = dirty => ({});
  const get_title_slot_context_8 = ctx => ({});
  const get_before_title_slot_changes_8 = dirty => ({});
  const get_before_title_slot_context_8 = ctx => ({});
  const get_header_slot_changes_8 = dirty => ({});
  const get_header_slot_context_8 = ctx => ({});
  const get_inner_start_slot_changes_4 = dirty => ({});
  const get_inner_start_slot_context_4 = ctx => ({});
  const get_media_slot_changes_4 = dirty => ({});
  const get_media_slot_context_4 = ctx => ({});
  const get_content_start_slot_changes_4 = dirty => ({});
  const get_content_start_slot_context_4 = ctx => ({});
  const get_content_end_slot_changes_3 = dirty => ({});
  const get_content_end_slot_context_3 = ctx => ({});
  const get_content_slot_changes_3 = dirty => ({});
  const get_content_slot_context_3 = ctx => ({});
  const get_inner_end_slot_changes_3 = dirty => ({});
  const get_inner_end_slot_context_3 = ctx => ({});
  const get_inner_slot_changes_7 = dirty => ({});
  const get_inner_slot_context_7 = ctx => ({});
  const get_after_end_slot_changes_7 = dirty => ({});
  const get_after_end_slot_context_7 = ctx => ({});
  const get_after_slot_changes_7 = dirty => ({});
  const get_after_slot_context_7 = ctx => ({});
  const get_after_start_slot_changes_7 = dirty => ({});
  const get_after_start_slot_context_7 = ctx => ({});
  const get_after_title_slot_changes_7 = dirty => ({});
  const get_after_title_slot_context_7 = ctx => ({});
  const get_footer_slot_changes_7 = dirty => ({});
  const get_footer_slot_context_7 = ctx => ({});
  const get_title_slot_changes_7 = dirty => ({});
  const get_title_slot_context_7 = ctx => ({});
  const get_header_slot_changes_7 = dirty => ({});
  const get_header_slot_context_7 = ctx => ({});
  const get_before_title_slot_changes_7 = dirty => ({});
  const get_before_title_slot_context_7 = ctx => ({});
  const get_footer_slot_changes_6 = dirty => ({});
  const get_footer_slot_context_6 = ctx => ({});
  const get_inner_slot_changes_6 = dirty => ({});
  const get_inner_slot_context_6 = ctx => ({});
  const get_text_slot_changes_3 = dirty => ({});
  const get_text_slot_context_3 = ctx => ({});
  const get_subtitle_slot_changes_3 = dirty => ({});
  const get_subtitle_slot_context_3 = ctx => ({});
  const get_after_end_slot_changes_6 = dirty => ({});
  const get_after_end_slot_context_6 = ctx => ({});
  const get_after_slot_changes_6 = dirty => ({});
  const get_after_slot_context_6 = ctx => ({});
  const get_after_start_slot_changes_6 = dirty => ({});
  const get_after_start_slot_context_6 = ctx => ({});
  const get_after_title_slot_changes_6 = dirty => ({});
  const get_after_title_slot_context_6 = ctx => ({});
  const get_title_slot_changes_6 = dirty => ({});
  const get_title_slot_context_6 = ctx => ({});
  const get_before_title_slot_changes_6 = dirty => ({});
  const get_before_title_slot_context_6 = ctx => ({});
  const get_header_slot_changes_6 = dirty => ({});
  const get_header_slot_context_6 = ctx => ({});
  const get_inner_start_slot_changes_3 = dirty => ({});
  const get_inner_start_slot_context_3 = ctx => ({});
  const get_media_slot_changes_3 = dirty => ({});
  const get_media_slot_context_3 = ctx => ({});
  const get_content_start_slot_changes_3 = dirty => ({});
  const get_content_start_slot_context_3 = ctx => ({});
  const get_content_end_slot_changes_2 = dirty => ({});
  const get_content_end_slot_context_2 = ctx => ({});
  const get_content_slot_changes_2 = dirty => ({});
  const get_content_slot_context_2 = ctx => ({});
  const get_inner_end_slot_changes_2 = dirty => ({});
  const get_inner_end_slot_context_2 = ctx => ({});
  const get_inner_slot_changes_5 = dirty => ({});
  const get_inner_slot_context_5 = ctx => ({});
  const get_after_end_slot_changes_5 = dirty => ({});
  const get_after_end_slot_context_5 = ctx => ({});
  const get_after_slot_changes_5 = dirty => ({});
  const get_after_slot_context_5 = ctx => ({});
  const get_after_start_slot_changes_5 = dirty => ({});
  const get_after_start_slot_context_5 = ctx => ({});
  const get_after_title_slot_changes_5 = dirty => ({});
  const get_after_title_slot_context_5 = ctx => ({});
  const get_footer_slot_changes_5 = dirty => ({});
  const get_footer_slot_context_5 = ctx => ({});
  const get_title_slot_changes_5 = dirty => ({});
  const get_title_slot_context_5 = ctx => ({});
  const get_header_slot_changes_5 = dirty => ({});
  const get_header_slot_context_5 = ctx => ({});
  const get_before_title_slot_changes_5 = dirty => ({});
  const get_before_title_slot_context_5 = ctx => ({});
  const get_footer_slot_changes_4 = dirty => ({});
  const get_footer_slot_context_4 = ctx => ({});
  const get_inner_slot_changes_4 = dirty => ({});
  const get_inner_slot_context_4 = ctx => ({});
  const get_text_slot_changes_2 = dirty => ({});
  const get_text_slot_context_2 = ctx => ({});
  const get_subtitle_slot_changes_2 = dirty => ({});
  const get_subtitle_slot_context_2 = ctx => ({});
  const get_after_end_slot_changes_4 = dirty => ({});
  const get_after_end_slot_context_4 = ctx => ({});
  const get_after_slot_changes_4 = dirty => ({});
  const get_after_slot_context_4 = ctx => ({});
  const get_after_start_slot_changes_4 = dirty => ({});
  const get_after_start_slot_context_4 = ctx => ({});
  const get_after_title_slot_changes_4 = dirty => ({});
  const get_after_title_slot_context_4 = ctx => ({});
  const get_title_slot_changes_4 = dirty => ({});
  const get_title_slot_context_4 = ctx => ({});
  const get_before_title_slot_changes_4 = dirty => ({});
  const get_before_title_slot_context_4 = ctx => ({});
  const get_header_slot_changes_4 = dirty => ({});
  const get_header_slot_context_4 = ctx => ({});
  const get_inner_start_slot_changes_2 = dirty => ({});
  const get_inner_start_slot_context_2 = ctx => ({});
  const get_media_slot_changes_2 = dirty => ({});
  const get_media_slot_context_2 = ctx => ({});
  const get_content_start_slot_changes_2 = dirty => ({});
  const get_content_start_slot_context_2 = ctx => ({});
  const get_content_end_slot_changes_1 = dirty => ({});
  const get_content_end_slot_context_1 = ctx => ({});
  const get_content_slot_changes_1 = dirty => ({});
  const get_content_slot_context_1 = ctx => ({});
  const get_inner_end_slot_changes_1 = dirty => ({});
  const get_inner_end_slot_context_1 = ctx => ({});
  const get_inner_slot_changes_3 = dirty => ({});
  const get_inner_slot_context_3 = ctx => ({});
  const get_after_end_slot_changes_3 = dirty => ({});
  const get_after_end_slot_context_3 = ctx => ({});
  const get_after_slot_changes_3 = dirty => ({});
  const get_after_slot_context_3 = ctx => ({});
  const get_after_start_slot_changes_3 = dirty => ({});
  const get_after_start_slot_context_3 = ctx => ({});
  const get_after_title_slot_changes_3 = dirty => ({});
  const get_after_title_slot_context_3 = ctx => ({});
  const get_footer_slot_changes_3 = dirty => ({});
  const get_footer_slot_context_3 = ctx => ({});
  const get_title_slot_changes_3 = dirty => ({});
  const get_title_slot_context_3 = ctx => ({});
  const get_header_slot_changes_3 = dirty => ({});
  const get_header_slot_context_3 = ctx => ({});
  const get_before_title_slot_changes_3 = dirty => ({});
  const get_before_title_slot_context_3 = ctx => ({});
  const get_footer_slot_changes_2 = dirty => ({});
  const get_footer_slot_context_2 = ctx => ({});
  const get_inner_slot_changes_2 = dirty => ({});
  const get_inner_slot_context_2 = ctx => ({});
  const get_text_slot_changes_1 = dirty => ({});
  const get_text_slot_context_1 = ctx => ({});
  const get_subtitle_slot_changes_1 = dirty => ({});
  const get_subtitle_slot_context_1 = ctx => ({});
  const get_after_end_slot_changes_2 = dirty => ({});
  const get_after_end_slot_context_2 = ctx => ({});
  const get_after_slot_changes_2 = dirty => ({});
  const get_after_slot_context_2 = ctx => ({});
  const get_after_start_slot_changes_2 = dirty => ({});
  const get_after_start_slot_context_2 = ctx => ({});
  const get_after_title_slot_changes_2 = dirty => ({});
  const get_after_title_slot_context_2 = ctx => ({});
  const get_title_slot_changes_2 = dirty => ({});
  const get_title_slot_context_2 = ctx => ({});
  const get_before_title_slot_changes_2 = dirty => ({});
  const get_before_title_slot_context_2 = ctx => ({});
  const get_header_slot_changes_2 = dirty => ({});
  const get_header_slot_context_2 = ctx => ({});
  const get_inner_start_slot_changes_1 = dirty => ({});
  const get_inner_start_slot_context_1 = ctx => ({});
  const get_media_slot_changes_1 = dirty => ({});
  const get_media_slot_context_1 = ctx => ({});
  const get_content_start_slot_changes_1 = dirty => ({});
  const get_content_start_slot_context_1 = ctx => ({});
  const get_content_end_slot_changes = dirty => ({});
  const get_content_end_slot_context = ctx => ({});
  const get_content_slot_changes = dirty => ({});
  const get_content_slot_context = ctx => ({});
  const get_inner_end_slot_changes = dirty => ({});
  const get_inner_end_slot_context = ctx => ({});
  const get_inner_slot_changes_1 = dirty => ({});
  const get_inner_slot_context_1 = ctx => ({});
  const get_after_end_slot_changes_1 = dirty => ({});
  const get_after_end_slot_context_1 = ctx => ({});
  const get_after_slot_changes_1 = dirty => ({});
  const get_after_slot_context_1 = ctx => ({});
  const get_after_start_slot_changes_1 = dirty => ({});
  const get_after_start_slot_context_1 = ctx => ({});
  const get_after_title_slot_changes_1 = dirty => ({});
  const get_after_title_slot_context_1 = ctx => ({});
  const get_footer_slot_changes_1 = dirty => ({});
  const get_footer_slot_context_1 = ctx => ({});
  const get_title_slot_changes_1 = dirty => ({});
  const get_title_slot_context_1 = ctx => ({});
  const get_header_slot_changes_1 = dirty => ({});
  const get_header_slot_context_1 = ctx => ({});
  const get_before_title_slot_changes_1 = dirty => ({});
  const get_before_title_slot_context_1 = ctx => ({});
  const get_footer_slot_changes = dirty => ({});
  const get_footer_slot_context = ctx => ({});
  const get_inner_slot_changes = dirty => ({});
  const get_inner_slot_context = ctx => ({});
  const get_text_slot_changes = dirty => ({});
  const get_text_slot_context = ctx => ({});
  const get_subtitle_slot_changes = dirty => ({});
  const get_subtitle_slot_context = ctx => ({});
  const get_after_end_slot_changes = dirty => ({});
  const get_after_end_slot_context = ctx => ({});
  const get_after_slot_changes = dirty => ({});
  const get_after_slot_context = ctx => ({});
  const get_after_start_slot_changes = dirty => ({});
  const get_after_start_slot_context = ctx => ({});
  const get_after_title_slot_changes = dirty => ({});
  const get_after_title_slot_context = ctx => ({});
  const get_title_slot_changes = dirty => ({});
  const get_title_slot_context = ctx => ({});
  const get_before_title_slot_changes = dirty => ({});
  const get_before_title_slot_context = ctx => ({});
  const get_header_slot_changes = dirty => ({});
  const get_header_slot_context = ctx => ({});
  const get_inner_start_slot_changes = dirty => ({});
  const get_inner_start_slot_context = ctx => ({});
  const get_media_slot_changes = dirty => ({});
  const get_media_slot_context = ctx => ({});
  const get_content_start_slot_changes = dirty => ({});
  const get_content_start_slot_context = ctx => ({});
  const get_root_start_slot_changes = dirty => ({});
  const get_root_start_slot_context = ctx => ({});

  // (368:0) {:else}
  function create_else_block$1(ctx) {
  	let li;
  	let t0;
  	let current_block_type_index;
  	let if_block0;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let current;
  	const root_start_slot_template = /*$$slots*/ ctx[89]["root-start"];
  	const root_start_slot = create_slot(root_start_slot_template, ctx, /*$$scope*/ ctx[103], get_root_start_slot_context);
  	const if_block_creators = [create_if_block_4$1, create_if_block_67, create_else_block_7];
  	const if_blocks = [];

  	function select_block_type_1(ctx, dirty) {
  		if (/*swipeout*/ ctx[13]) return 0;
  		if (/*isLink*/ ctx[37]) return 1;
  		return 2;
  	}

  	current_block_type_index = select_block_type_1(ctx);
  	if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	let if_block1 = /*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && !/*isSortableOpposite*/ ctx[31] && create_if_block_3$3(ctx);
  	let if_block2 = (/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_2$3(ctx);
  	const root_slot_template = /*$$slots*/ ctx[89].root;
  	const root_slot = create_slot(root_slot_template, ctx, /*$$scope*/ ctx[103], get_root_slot_context);
  	const root_end_slot_template = /*$$slots*/ ctx[89]["root-end"];
  	const root_end_slot = create_slot(root_end_slot_template, ctx, /*$$scope*/ ctx[103], get_root_end_slot_context);

  	const block = {
  		c: function create() {
  			li = element("li");
  			if (root_start_slot) root_start_slot.c();
  			t0 = space();
  			if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (if_block2) if_block2.c();
  			t3 = space();
  			if (root_slot) root_slot.c();
  			t4 = space();
  			if (root_end_slot) root_end_slot.c();
  			attr_dev(li, "id", /*id*/ ctx[0]);
  			attr_dev(li, "style", /*style*/ ctx[1]);
  			attr_dev(li, "class", /*liClasses*/ ctx[33]);
  			attr_dev(li, "data-virtual-list-index", /*virtualListIndex*/ ctx[24]);
  			add_location(li, file$a, 368, 2, 12132);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, li, anchor);

  			if (root_start_slot) {
  				root_start_slot.m(li, null);
  			}

  			append_dev(li, t0);
  			if_blocks[current_block_type_index].m(li, null);
  			append_dev(li, t1);
  			if (if_block1) if_block1.m(li, null);
  			append_dev(li, t2);
  			if (if_block2) if_block2.m(li, null);
  			append_dev(li, t3);

  			if (root_slot) {
  				root_slot.m(li, null);
  			}

  			append_dev(li, t4);

  			if (root_end_slot) {
  				root_end_slot.m(li, null);
  			}

  			/*li_binding_2*/ ctx[102](li);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (root_start_slot) {
  				if (root_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					root_start_slot.p(get_slot_context(root_start_slot_template, ctx, /*$$scope*/ ctx[103], get_root_start_slot_context), get_slot_changes(root_start_slot_template, /*$$scope*/ ctx[103], dirty, get_root_start_slot_changes));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_1(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block0 = if_blocks[current_block_type_index];

  				if (!if_block0) {
  					if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block0.c();
  				}

  				transition_in(if_block0, 1);
  				if_block0.m(li, t1);
  			}

  			if (/*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && !/*isSortableOpposite*/ ctx[31]) {
  				if (if_block1) ; else {
  					if_block1 = create_if_block_3$3(ctx);
  					if_block1.c();
  					if_block1.m(li, t2);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}

  			if (/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_2$3(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(li, t3);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (root_slot) {
  				if (root_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					root_slot.p(get_slot_context(root_slot_template, ctx, /*$$scope*/ ctx[103], get_root_slot_context), get_slot_changes(root_slot_template, /*$$scope*/ ctx[103], dirty, get_root_slot_changes));
  				}
  			}

  			if (root_end_slot) {
  				if (root_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					root_end_slot.p(get_slot_context(root_end_slot_template, ctx, /*$$scope*/ ctx[103], get_root_end_slot_context), get_slot_changes(root_end_slot_template, /*$$scope*/ ctx[103], dirty, get_root_end_slot_changes));
  				}
  			}

  			if (!current || dirty[0] & /*id*/ 1) {
  				attr_dev(li, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty[0] & /*style*/ 2) {
  				attr_dev(li, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty[1] & /*liClasses*/ 4) {
  				attr_dev(li, "class", /*liClasses*/ ctx[33]);
  			}

  			if (!current || dirty[0] & /*virtualListIndex*/ 16777216) {
  				attr_dev(li, "data-virtual-list-index", /*virtualListIndex*/ ctx[24]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(root_start_slot, local);
  			transition_in(if_block0);
  			transition_in(if_block2);
  			transition_in(root_slot, local);
  			transition_in(root_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(root_start_slot, local);
  			transition_out(if_block0);
  			transition_out(if_block2);
  			transition_out(root_slot, local);
  			transition_out(root_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  			if (root_start_slot) root_start_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (if_block1) if_block1.d();
  			if (if_block2) if_block2.d();
  			if (root_slot) root_slot.d(detaching);
  			if (root_end_slot) root_end_slot.d(detaching);
  			/*li_binding_2*/ ctx[102](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$1.name,
  		type: "else",
  		source: "(368:0) {:else}",
  		ctx
  	});

  	return block;
  }

  // (363:19) 
  function create_if_block_1$3(ctx) {
  	let li;
  	let t0_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t0;
  	let t1;
  	let current;
  	let dispose;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			li = element("li");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (default_slot) default_slot.c();
  			attr_dev(li, "id", /*id*/ ctx[0]);
  			attr_dev(li, "style", /*style*/ ctx[1]);
  			attr_dev(li, "class", /*liClasses*/ ctx[33]);
  			attr_dev(li, "data-virtual-list-index", /*virtualListIndex*/ ctx[24]);
  			add_location(li, file$a, 363, 2, 11953);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, li, anchor);
  			append_dev(li, t0);
  			append_dev(li, t1);

  			if (default_slot) {
  				default_slot.m(li, null);
  			}

  			/*li_binding_1*/ ctx[91](li);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(li, "click", /*onClick*/ ctx[45], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}

  			if (!current || dirty[0] & /*id*/ 1) {
  				attr_dev(li, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty[0] & /*style*/ 2) {
  				attr_dev(li, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty[1] & /*liClasses*/ 4) {
  				attr_dev(li, "class", /*liClasses*/ ctx[33]);
  			}

  			if (!current || dirty[0] & /*virtualListIndex*/ 16777216) {
  				attr_dev(li, "data-virtual-list-index", /*virtualListIndex*/ ctx[24]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  			if (default_slot) default_slot.d(detaching);
  			/*li_binding_1*/ ctx[91](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$3.name,
  		type: "if",
  		source: "(363:19) ",
  		ctx
  	});

  	return block;
  }

  // (359:0) {#if (divider || groupTitle)}
  function create_if_block$3(ctx) {
  	let li;
  	let span;
  	let current;
  	let dispose;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);
  	const default_slot_or_fallback = default_slot || fallback_block(ctx);

  	const block = {
  		c: function create() {
  			li = element("li");
  			span = element("span");
  			if (default_slot_or_fallback) default_slot_or_fallback.c();
  			add_location(span, file$a, 360, 4, 11877);
  			attr_dev(li, "id", /*id*/ ctx[0]);
  			attr_dev(li, "style", /*style*/ ctx[1]);
  			attr_dev(li, "class", /*liClasses*/ ctx[33]);
  			attr_dev(li, "data-virtual-list-index", /*virtualListIndex*/ ctx[24]);
  			add_location(li, file$a, 359, 2, 11749);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, li, anchor);
  			append_dev(li, span);

  			if (default_slot_or_fallback) {
  				default_slot_or_fallback.m(span, null);
  			}

  			/*li_binding*/ ctx[90](li);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(li, "click", /*onClick*/ ctx[45], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			} else {
  				if (default_slot_or_fallback && default_slot_or_fallback.p && dirty[0] & /*title*/ 4) {
  					default_slot_or_fallback.p(ctx, dirty);
  				}
  			}

  			if (!current || dirty[0] & /*id*/ 1) {
  				attr_dev(li, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty[0] & /*style*/ 2) {
  				attr_dev(li, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty[1] & /*liClasses*/ 4) {
  				attr_dev(li, "class", /*liClasses*/ ctx[33]);
  			}

  			if (!current || dirty[0] & /*virtualListIndex*/ 16777216) {
  				attr_dev(li, "data-virtual-list-index", /*virtualListIndex*/ ctx[24]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot_or_fallback, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot_or_fallback, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(li);
  			if (default_slot_or_fallback) default_slot_or_fallback.d(detaching);
  			/*li_binding*/ ctx[90](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$3.name,
  		type: "if",
  		source: "(359:0) {#if (divider || groupTitle)}",
  		ctx
  	});

  	return block;
  }

  // (848:6) {:else}
  function create_else_block_7(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block_88, create_else_block_9];
  	const if_blocks = [];

  	function select_block_type_8(ctx, dirty) {
  		if (/*checkbox*/ ctx[16] || /*radio*/ ctx[17]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_8(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			if_block.c();
  			if_block_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_8(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_7.name,
  		type: "else",
  		source: "(848:6) {:else}",
  		ctx
  	});

  	return block;
  }

  // (732:6) {#if isLink}
  function create_if_block_67(ctx) {
  	let a;
  	let div1;
  	let t0;
  	let t1;
  	let t2;
  	let div0;
  	let t3;
  	let current_block_type_index;
  	let if_block2;
  	let t4;
  	let t5;
  	let t6;
  	let current;
  	let dispose;
  	const content_start_slot_template = /*$$slots*/ ctx[89]["content-start"];
  	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_3);
  	let if_block0 = /*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31] && create_if_block_87(ctx);
  	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_85(ctx);
  	const inner_start_slot_template = /*$$slots*/ ctx[89]["inner-start"];
  	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_3);
  	const if_block_creators = [create_if_block_68, create_else_block_6];
  	const if_blocks = [];

  	function select_block_type_7(ctx, dirty) {
  		if (/*isMedia*/ ctx[29]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_7(ctx);
  	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	const inner_end_slot_template = /*$$slots*/ ctx[89]["inner-end"];
  	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_3);
  	const content_slot_template = /*$$slots*/ ctx[89].content;
  	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_3);
  	const content_end_slot_template = /*$$slots*/ ctx[89]["content-end"];
  	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_3);
  	let a_levels = [{ class: /*linkClasses*/ ctx[35] }, /*linkAttrs*/ ctx[36]];
  	let a_data = {};

  	for (let i = 0; i < a_levels.length; i += 1) {
  		a_data = assign(a_data, a_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			a = element("a");
  			div1 = element("div");
  			if (content_start_slot) content_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			div0 = element("div");
  			if (inner_start_slot) inner_start_slot.c();
  			t3 = space();
  			if_block2.c();
  			t4 = space();
  			if (inner_end_slot) inner_end_slot.c();
  			t5 = space();
  			if (content_slot) content_slot.c();
  			t6 = space();
  			if (content_end_slot) content_end_slot.c();
  			attr_dev(div0, "class", "item-inner");
  			add_location(div0, file$a, 747, 12, 27078);
  			attr_dev(div1, "class", /*contentClasses*/ ctx[34]);
  			add_location(div1, file$a, 734, 10, 26603);
  			set_attributes(a, a_data);
  			add_location(a, file$a, 732, 8, 26478);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, a, anchor);
  			append_dev(a, div1);

  			if (content_start_slot) {
  				content_start_slot.m(div1, null);
  			}

  			append_dev(div1, t0);
  			if (if_block0) if_block0.m(div1, null);
  			append_dev(div1, t1);
  			if (if_block1) if_block1.m(div1, null);
  			append_dev(div1, t2);
  			append_dev(div1, div0);

  			if (inner_start_slot) {
  				inner_start_slot.m(div0, null);
  			}

  			append_dev(div0, t3);
  			if_blocks[current_block_type_index].m(div0, null);
  			append_dev(div0, t4);

  			if (inner_end_slot) {
  				inner_end_slot.m(div0, null);
  			}

  			/*div0_binding_2*/ ctx[97](div0);
  			append_dev(div1, t5);

  			if (content_slot) {
  				content_slot.m(div1, null);
  			}

  			append_dev(div1, t6);

  			if (content_end_slot) {
  				content_end_slot.m(div1, null);
  			}

  			/*a_binding_1*/ ctx[98](a);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(a, "click", /*onClick*/ ctx[45], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (content_start_slot) {
  				if (content_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_start_slot.p(get_slot_context(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_3), get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[103], dirty, get_content_start_slot_changes_3));
  				}
  			}

  			if (/*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31]) {
  				if (if_block0) ; else {
  					if_block0 = create_if_block_87(ctx);
  					if_block0.c();
  					if_block0.m(div1, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (/*hasMedia*/ ctx[38]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasMedia*/ 128) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_85(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div1, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_start_slot) {
  				if (inner_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_start_slot.p(get_slot_context(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_3), get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_start_slot_changes_3));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_7(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block2 = if_blocks[current_block_type_index];

  				if (!if_block2) {
  					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block2.c();
  				}

  				transition_in(if_block2, 1);
  				if_block2.m(div0, t4);
  			}

  			if (inner_end_slot) {
  				if (inner_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_end_slot.p(get_slot_context(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_3), get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_end_slot_changes_3));
  				}
  			}

  			if (content_slot) {
  				if (content_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_slot.p(get_slot_context(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_3), get_slot_changes(content_slot_template, /*$$scope*/ ctx[103], dirty, get_content_slot_changes_3));
  				}
  			}

  			if (content_end_slot) {
  				if (content_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_end_slot.p(get_slot_context(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_3), get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[103], dirty, get_content_end_slot_changes_3));
  				}
  			}

  			if (!current || dirty[1] & /*contentClasses*/ 8) {
  				attr_dev(div1, "class", /*contentClasses*/ ctx[34]);
  			}

  			set_attributes(a, get_spread_update(a_levels, [
  				dirty[1] & /*linkClasses*/ 16 && { class: /*linkClasses*/ ctx[35] },
  				dirty[1] & /*linkAttrs*/ 32 && /*linkAttrs*/ ctx[36]
  			]));
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(content_start_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_start_slot, local);
  			transition_in(if_block2);
  			transition_in(inner_end_slot, local);
  			transition_in(content_slot, local);
  			transition_in(content_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(content_start_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_start_slot, local);
  			transition_out(if_block2);
  			transition_out(inner_end_slot, local);
  			transition_out(content_slot, local);
  			transition_out(content_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (content_start_slot) content_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (inner_start_slot) inner_start_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (inner_end_slot) inner_end_slot.d(detaching);
  			/*div0_binding_2*/ ctx[97](null);
  			if (content_slot) content_slot.d(detaching);
  			if (content_end_slot) content_end_slot.d(detaching);
  			/*a_binding_1*/ ctx[98](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_67.name,
  		type: "if",
  		source: "(732:6) {#if isLink}",
  		ctx
  	});

  	return block;
  }

  // (371:4) {#if swipeout}
  function create_if_block_4$1(ctx) {
  	let div;
  	let current_block_type_index;
  	let if_block;
  	let current;
  	const if_block_creators = [create_if_block_5, create_else_block_2];
  	const if_blocks = [];

  	function select_block_type_2(ctx, dirty) {
  		if (/*isLink*/ ctx[37]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_2(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if_block.c();
  			attr_dev(div, "class", "swipeout-content");
  			add_location(div, file$a, 371, 6, 12291);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if_blocks[current_block_type_index].m(div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_2(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(div, null);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if_blocks[current_block_type_index].d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_4$1.name,
  		type: "if",
  		source: "(371:4) {#if swipeout}",
  		ctx
  	});

  	return block;
  }

  // (974:8) {:else}
  function create_else_block_9(ctx) {
  	let div1;
  	let t0;
  	let t1;
  	let t2;
  	let div0;
  	let t3;
  	let current_block_type_index;
  	let if_block2;
  	let t4;
  	let t5;
  	let t6;
  	let current;
  	let dispose;
  	const content_start_slot_template = /*$$slots*/ ctx[89]["content-start"];
  	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_5);
  	let if_block0 = /*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31] && create_if_block_128(ctx);
  	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_126(ctx);
  	const inner_start_slot_template = /*$$slots*/ ctx[89]["inner-start"];
  	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_5);
  	const if_block_creators = [create_if_block_109, create_else_block_10];
  	const if_blocks = [];

  	function select_block_type_10(ctx, dirty) {
  		if (/*isMedia*/ ctx[29]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_10(ctx);
  	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	const inner_end_slot_template = /*$$slots*/ ctx[89]["inner-end"];
  	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_5);
  	const content_slot_template = /*$$slots*/ ctx[89].content;
  	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_5);
  	const content_end_slot_template = /*$$slots*/ ctx[89]["content-end"];
  	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_5);

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			if (content_start_slot) content_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			div0 = element("div");
  			if (inner_start_slot) inner_start_slot.c();
  			t3 = space();
  			if_block2.c();
  			t4 = space();
  			if (inner_end_slot) inner_end_slot.c();
  			t5 = space();
  			if (content_slot) content_slot.c();
  			t6 = space();
  			if (content_end_slot) content_end_slot.c();
  			attr_dev(div0, "class", "item-inner");
  			add_location(div0, file$a, 987, 12, 36082);
  			attr_dev(div1, "class", /*contentClasses*/ ctx[34]);
  			add_location(div1, file$a, 974, 10, 35588);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div1, anchor);

  			if (content_start_slot) {
  				content_start_slot.m(div1, null);
  			}

  			append_dev(div1, t0);
  			if (if_block0) if_block0.m(div1, null);
  			append_dev(div1, t1);
  			if (if_block1) if_block1.m(div1, null);
  			append_dev(div1, t2);
  			append_dev(div1, div0);

  			if (inner_start_slot) {
  				inner_start_slot.m(div0, null);
  			}

  			append_dev(div0, t3);
  			if_blocks[current_block_type_index].m(div0, null);
  			append_dev(div0, t4);

  			if (inner_end_slot) {
  				inner_end_slot.m(div0, null);
  			}

  			/*div0_binding_3*/ ctx[101](div0);
  			append_dev(div1, t5);

  			if (content_slot) {
  				content_slot.m(div1, null);
  			}

  			append_dev(div1, t6);

  			if (content_end_slot) {
  				content_end_slot.m(div1, null);
  			}

  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(div1, "click", /*onClick*/ ctx[45], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (content_start_slot) {
  				if (content_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_start_slot.p(get_slot_context(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_5), get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[103], dirty, get_content_start_slot_changes_5));
  				}
  			}

  			if (/*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31]) {
  				if (if_block0) ; else {
  					if_block0 = create_if_block_128(ctx);
  					if_block0.c();
  					if_block0.m(div1, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (/*hasMedia*/ ctx[38]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasMedia*/ 128) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_126(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div1, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_start_slot) {
  				if (inner_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_start_slot.p(get_slot_context(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_5), get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_start_slot_changes_5));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_10(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block2 = if_blocks[current_block_type_index];

  				if (!if_block2) {
  					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block2.c();
  				}

  				transition_in(if_block2, 1);
  				if_block2.m(div0, t4);
  			}

  			if (inner_end_slot) {
  				if (inner_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_end_slot.p(get_slot_context(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_5), get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_end_slot_changes_5));
  				}
  			}

  			if (content_slot) {
  				if (content_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_slot.p(get_slot_context(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_5), get_slot_changes(content_slot_template, /*$$scope*/ ctx[103], dirty, get_content_slot_changes_5));
  				}
  			}

  			if (content_end_slot) {
  				if (content_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_end_slot.p(get_slot_context(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_5), get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[103], dirty, get_content_end_slot_changes_5));
  				}
  			}

  			if (!current || dirty[1] & /*contentClasses*/ 8) {
  				attr_dev(div1, "class", /*contentClasses*/ ctx[34]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(content_start_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_start_slot, local);
  			transition_in(if_block2);
  			transition_in(inner_end_slot, local);
  			transition_in(content_slot, local);
  			transition_in(content_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(content_start_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_start_slot, local);
  			transition_out(if_block2);
  			transition_out(inner_end_slot, local);
  			transition_out(content_slot, local);
  			transition_out(content_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  			if (content_start_slot) content_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (inner_start_slot) inner_start_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (inner_end_slot) inner_end_slot.d(detaching);
  			/*div0_binding_3*/ ctx[101](null);
  			if (content_slot) content_slot.d(detaching);
  			if (content_end_slot) content_end_slot.d(detaching);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_9.name,
  		type: "else",
  		source: "(974:8) {:else}",
  		ctx
  	});

  	return block;
  }

  // (850:8) {#if checkbox || radio}
  function create_if_block_88(ctx) {
  	let label;
  	let t0;
  	let t1;
  	let input;
  	let input_value_value;
  	let input_type_value;
  	let t2;
  	let i;
  	let i_class_value;
  	let t3;
  	let t4;
  	let div;
  	let t5;
  	let current_block_type_index;
  	let if_block2;
  	let t6;
  	let t7;
  	let t8;
  	let current;
  	let dispose;
  	const content_start_slot_template = /*$$slots*/ ctx[89]["content-start"];
  	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_4);
  	let if_block0 = /*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31] && create_if_block_108(ctx);
  	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_106(ctx);
  	const inner_start_slot_template = /*$$slots*/ ctx[89]["inner-start"];
  	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_4);
  	const if_block_creators = [create_if_block_89, create_else_block_8];
  	const if_blocks = [];

  	function select_block_type_9(ctx, dirty) {
  		if (/*isMedia*/ ctx[29]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_9(ctx);
  	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	const inner_end_slot_template = /*$$slots*/ ctx[89]["inner-end"];
  	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_4);
  	const content_slot_template = /*$$slots*/ ctx[89].content;
  	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_4);
  	const content_end_slot_template = /*$$slots*/ ctx[89]["content-end"];
  	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_4);

  	const block = {
  		c: function create() {
  			label = element("label");
  			if (content_start_slot) content_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			input = element("input");
  			t2 = space();
  			i = element("i");
  			t3 = space();
  			if (if_block1) if_block1.c();
  			t4 = space();
  			div = element("div");
  			if (inner_start_slot) inner_start_slot.c();
  			t5 = space();
  			if_block2.c();
  			t6 = space();
  			if (inner_end_slot) inner_end_slot.c();
  			t7 = space();
  			if (content_slot) content_slot.c();
  			t8 = space();
  			if (content_end_slot) content_end_slot.c();

  			input.value = input_value_value = typeof /*value*/ ctx[20] === "undefined"
  			? ""
  			: /*value*/ ctx[20];

  			attr_dev(input, "name", /*name*/ ctx[19]);
  			input.checked = /*checked*/ ctx[18];
  			input.readOnly = /*readonly*/ ctx[21];
  			input.disabled = /*disabled*/ ctx[23];
  			input.required = /*required*/ ctx[22];
  			attr_dev(input, "type", input_type_value = /*radio*/ ctx[17] ? "radio" : "checkbox");
  			add_location(input, file$a, 855, 12, 31160);
  			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[17] ? "radio" : "checkbox"}`);
  			add_location(i, file$a, 866, 12, 31537);
  			attr_dev(div, "class", "item-inner");
  			add_location(div, file$a, 875, 12, 31861);
  			attr_dev(label, "class", /*contentClasses*/ ctx[34]);
  			add_location(label, file$a, 850, 10, 30918);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, label, anchor);

  			if (content_start_slot) {
  				content_start_slot.m(label, null);
  			}

  			append_dev(label, t0);
  			if (if_block0) if_block0.m(label, null);
  			append_dev(label, t1);
  			append_dev(label, input);
  			/*input_binding_1*/ ctx[99](input);
  			append_dev(label, t2);
  			append_dev(label, i);
  			append_dev(label, t3);
  			if (if_block1) if_block1.m(label, null);
  			append_dev(label, t4);
  			append_dev(label, div);

  			if (inner_start_slot) {
  				inner_start_slot.m(div, null);
  			}

  			append_dev(div, t5);
  			if_blocks[current_block_type_index].m(div, null);
  			append_dev(div, t6);

  			if (inner_end_slot) {
  				inner_end_slot.m(div, null);
  			}

  			/*div_binding_1*/ ctx[100](div);
  			append_dev(label, t7);

  			if (content_slot) {
  				content_slot.m(label, null);
  			}

  			append_dev(label, t8);

  			if (content_end_slot) {
  				content_end_slot.m(label, null);
  			}

  			current = true;
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input, "change", /*onChange*/ ctx[46], false, false, false),
  				listen_dev(label, "click", /*onClick*/ ctx[45], false, false, false)
  			];
  		},
  		p: function update(ctx, dirty) {
  			if (content_start_slot) {
  				if (content_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_start_slot.p(get_slot_context(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_4), get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[103], dirty, get_content_start_slot_changes_4));
  				}
  			}

  			if (/*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31]) {
  				if (if_block0) ; else {
  					if_block0 = create_if_block_108(ctx);
  					if_block0.c();
  					if_block0.m(label, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (!current || dirty[0] & /*value*/ 1048576 && input_value_value !== (input_value_value = typeof /*value*/ ctx[20] === "undefined"
  			? ""
  			: /*value*/ ctx[20]) && input.value !== input_value_value) {
  				prop_dev(input, "value", input_value_value);
  			}

  			if (!current || dirty[0] & /*name*/ 524288) {
  				attr_dev(input, "name", /*name*/ ctx[19]);
  			}

  			if (!current || dirty[0] & /*checked*/ 262144) {
  				prop_dev(input, "checked", /*checked*/ ctx[18]);
  			}

  			if (!current || dirty[0] & /*readonly*/ 2097152) {
  				prop_dev(input, "readOnly", /*readonly*/ ctx[21]);
  			}

  			if (!current || dirty[0] & /*disabled*/ 8388608) {
  				prop_dev(input, "disabled", /*disabled*/ ctx[23]);
  			}

  			if (!current || dirty[0] & /*required*/ 4194304) {
  				prop_dev(input, "required", /*required*/ ctx[22]);
  			}

  			if (!current || dirty[0] & /*radio*/ 131072 && input_type_value !== (input_type_value = /*radio*/ ctx[17] ? "radio" : "checkbox")) {
  				attr_dev(input, "type", input_type_value);
  			}

  			if (!current || dirty[0] & /*radio*/ 131072 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[17] ? "radio" : "checkbox"}`)) {
  				attr_dev(i, "class", i_class_value);
  			}

  			if (/*hasMedia*/ ctx[38]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasMedia*/ 128) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_106(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(label, t4);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_start_slot) {
  				if (inner_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_start_slot.p(get_slot_context(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_4), get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_start_slot_changes_4));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_9(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block2 = if_blocks[current_block_type_index];

  				if (!if_block2) {
  					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block2.c();
  				}

  				transition_in(if_block2, 1);
  				if_block2.m(div, t6);
  			}

  			if (inner_end_slot) {
  				if (inner_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_end_slot.p(get_slot_context(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_4), get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_end_slot_changes_4));
  				}
  			}

  			if (content_slot) {
  				if (content_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_slot.p(get_slot_context(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_4), get_slot_changes(content_slot_template, /*$$scope*/ ctx[103], dirty, get_content_slot_changes_4));
  				}
  			}

  			if (content_end_slot) {
  				if (content_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_end_slot.p(get_slot_context(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_4), get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[103], dirty, get_content_end_slot_changes_4));
  				}
  			}

  			if (!current || dirty[1] & /*contentClasses*/ 8) {
  				attr_dev(label, "class", /*contentClasses*/ ctx[34]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(content_start_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_start_slot, local);
  			transition_in(if_block2);
  			transition_in(inner_end_slot, local);
  			transition_in(content_slot, local);
  			transition_in(content_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(content_start_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_start_slot, local);
  			transition_out(if_block2);
  			transition_out(inner_end_slot, local);
  			transition_out(content_slot, local);
  			transition_out(content_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(label);
  			if (content_start_slot) content_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			/*input_binding_1*/ ctx[99](null);
  			if (if_block1) if_block1.d();
  			if (inner_start_slot) inner_start_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (inner_end_slot) inner_end_slot.d(detaching);
  			/*div_binding_1*/ ctx[100](null);
  			if (content_slot) content_slot.d(detaching);
  			if (content_end_slot) content_end_slot.d(detaching);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_88.name,
  		type: "if",
  		source: "(850:8) {#if checkbox || radio}",
  		ctx
  	});

  	return block;
  }

  // (977:12) {#if isSortable && sortable !== false && isSortableOpposite}
  function create_if_block_128(ctx) {
  	let div;

  	const block = {
  		c: function create() {
  			div = element("div");
  			attr_dev(div, "class", "sortable-handler");
  			add_location(div, file$a, 977, 14, 35765);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_128.name,
  		type: "if",
  		source: "(977:12) {#if isSortable && sortable !== false && isSortableOpposite}",
  		ctx
  	});

  	return block;
  }

  // (980:12) {#if hasMedia}
  function create_if_block_126(ctx) {
  	let div;
  	let t;
  	let current;
  	let if_block = typeof /*media*/ ctx[4] !== "undefined" && create_if_block_127(ctx);
  	const media_slot_template = /*$$slots*/ ctx[89].media;
  	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_5);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block) if_block.c();
  			t = space();
  			if (media_slot) media_slot.c();
  			attr_dev(div, "class", "item-media");
  			add_location(div, file$a, 980, 14, 35857);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block) if_block.m(div, null);
  			append_dev(div, t);

  			if (media_slot) {
  				media_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (typeof /*media*/ ctx[4] !== "undefined") {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_127(ctx);
  					if_block.c();
  					if_block.m(div, t);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (media_slot) {
  				if (media_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					media_slot.p(get_slot_context(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_5), get_slot_changes(media_slot_template, /*$$scope*/ ctx[103], dirty, get_media_slot_changes_5));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(media_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(media_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  			if (media_slot) media_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_126.name,
  		type: "if",
  		source: "(980:12) {#if hasMedia}",
  		ctx
  	});

  	return block;
  }

  // (982:16) {#if typeof media !== 'undefined'}
  function create_if_block_127(ctx) {
  	let img;
  	let img_src_value;

  	const block = {
  		c: function create() {
  			img = element("img");
  			if (img.src !== (img_src_value = /*media*/ ctx[4])) attr_dev(img, "src", img_src_value);
  			add_location(img, file$a, 982, 18, 35951);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, img, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*media*/ 16 && img.src !== (img_src_value = /*media*/ ctx[4])) {
  				attr_dev(img, "src", img_src_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(img);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_127.name,
  		type: "if",
  		source: "(982:16) {#if typeof media !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (1042:14) {:else}
  function create_else_block_10(ctx) {
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let if_block2_anchor;
  	let current;
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_11);
  	let if_block0 = (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) && create_if_block_123(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_11);
  	let if_block1 = /*hasAfter*/ ctx[44] && create_if_block_120(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_11);
  	let if_block2 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_119(ctx);

  	const block = {
  		c: function create() {
  			if (before_title_slot) before_title_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (after_title_slot) after_title_slot.c();
  			t2 = space();
  			if (if_block1) if_block1.c();
  			t3 = space();
  			if (inner_slot) inner_slot.c();
  			t4 = space();
  			if (if_block2) if_block2.c();
  			if_block2_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if (before_title_slot) {
  				before_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t0, anchor);
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t1, anchor);

  			if (after_title_slot) {
  				after_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t2, anchor);
  			if (if_block1) if_block1.m(target, anchor);
  			insert_dev(target, t3, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t4, anchor);
  			if (if_block2) if_block2.m(target, anchor);
  			insert_dev(target, if_block2_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_11), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_11));
  				}
  			}

  			if (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 1792) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_123(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t1.parentNode, t1);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_11), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_11));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_120(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(t3.parentNode, t3);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_11), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_11));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_119(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_title_slot, local);
  			transition_in(if_block0);
  			transition_in(after_title_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_slot, local);
  			transition_in(if_block2);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_title_slot, local);
  			transition_out(if_block0);
  			transition_out(after_title_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_slot, local);
  			transition_out(if_block2);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t1);
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (detaching) detach_dev(t2);
  			if (if_block1) if_block1.d(detaching);
  			if (detaching) detach_dev(t3);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t4);
  			if (if_block2) if_block2.d(detaching);
  			if (detaching) detach_dev(if_block2_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_10.name,
  		type: "else",
  		source: "(1042:14) {:else}",
  		ctx
  	});

  	return block;
  }

  // (990:14) {#if isMedia}
  function create_if_block_109(ctx) {
  	let t0;
  	let div;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let t5;
  	let t6;
  	let t7;
  	let t8;
  	let if_block6_anchor;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_118(ctx);
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_10);
  	let if_block1 = /*hasTitle*/ ctx[39] && create_if_block_117(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_10);
  	let if_block2 = /*hasAfter*/ ctx[44] && create_if_block_114(ctx);
  	let if_block3 = /*hasSubtitle*/ ctx[42] && create_if_block_113(ctx);
  	let if_block4 = /*hasText*/ ctx[43] && create_if_block_112(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_10);
  	let if_block5 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_111(ctx);
  	let if_block6 = /*hasFooter*/ ctx[41] && create_if_block_110(ctx);

  	const block = {
  		c: function create() {
  			if (if_block0) if_block0.c();
  			t0 = space();
  			div = element("div");
  			if (before_title_slot) before_title_slot.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_title_slot) after_title_slot.c();
  			t3 = space();
  			if (if_block2) if_block2.c();
  			t4 = space();
  			if (if_block3) if_block3.c();
  			t5 = space();
  			if (if_block4) if_block4.c();
  			t6 = space();
  			if (inner_slot) inner_slot.c();
  			t7 = space();
  			if (if_block5) if_block5.c();
  			t8 = space();
  			if (if_block6) if_block6.c();
  			if_block6_anchor = empty$1();
  			attr_dev(div, "class", "item-title-row");
  			add_location(div, file$a, 996, 16, 36420);
  		},
  		m: function mount(target, anchor) {
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div, anchor);

  			if (before_title_slot) {
  				before_title_slot.m(div, null);
  			}

  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_title_slot) {
  				after_title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block2) if_block2.m(div, null);
  			insert_dev(target, t4, anchor);
  			if (if_block3) if_block3.m(target, anchor);
  			insert_dev(target, t5, anchor);
  			if (if_block4) if_block4.m(target, anchor);
  			insert_dev(target, t6, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t7, anchor);
  			if (if_block5) if_block5.m(target, anchor);
  			insert_dev(target, t8, anchor);
  			if (if_block6) if_block6.m(target, anchor);
  			insert_dev(target, if_block6_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_118(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t0.parentNode, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_10), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_10));
  				}
  			}

  			if (/*hasTitle*/ ctx[39]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle*/ 256) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_117(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_10), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_10));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_114(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(div, null);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (/*hasSubtitle*/ ctx[42]) {
  				if (if_block3) {
  					if_block3.p(ctx, dirty);

  					if (dirty[1] & /*hasSubtitle*/ 2048) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block_113(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(t5.parentNode, t5);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}

  			if (/*hasText*/ ctx[43]) {
  				if (if_block4) {
  					if_block4.p(ctx, dirty);

  					if (dirty[1] & /*hasText*/ 4096) {
  						transition_in(if_block4, 1);
  					}
  				} else {
  					if_block4 = create_if_block_112(ctx);
  					if_block4.c();
  					transition_in(if_block4, 1);
  					if_block4.m(t6.parentNode, t6);
  				}
  			} else if (if_block4) {
  				group_outros();

  				transition_out(if_block4, 1, 1, () => {
  					if_block4 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_10), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_10));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block5) {
  					if_block5.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block5, 1);
  					}
  				} else {
  					if_block5 = create_if_block_111(ctx);
  					if_block5.c();
  					transition_in(if_block5, 1);
  					if_block5.m(t8.parentNode, t8);
  				}
  			} else if (if_block5) {
  				group_outros();

  				transition_out(if_block5, 1, 1, () => {
  					if_block5 = null;
  				});

  				check_outros();
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block6) {
  					if_block6.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block6, 1);
  					}
  				} else {
  					if_block6 = create_if_block_110(ctx);
  					if_block6.c();
  					transition_in(if_block6, 1);
  					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
  				}
  			} else if (if_block6) {
  				group_outros();

  				transition_out(if_block6, 1, 1, () => {
  					if_block6 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(before_title_slot, local);
  			transition_in(if_block1);
  			transition_in(after_title_slot, local);
  			transition_in(if_block2);
  			transition_in(if_block3);
  			transition_in(if_block4);
  			transition_in(inner_slot, local);
  			transition_in(if_block5);
  			transition_in(if_block6);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(before_title_slot, local);
  			transition_out(if_block1);
  			transition_out(after_title_slot, local);
  			transition_out(if_block2);
  			transition_out(if_block3);
  			transition_out(if_block4);
  			transition_out(inner_slot, local);
  			transition_out(if_block5);
  			transition_out(if_block6);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div);
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (if_block2) if_block2.d();
  			if (detaching) detach_dev(t4);
  			if (if_block3) if_block3.d(detaching);
  			if (detaching) detach_dev(t5);
  			if (if_block4) if_block4.d(detaching);
  			if (detaching) detach_dev(t6);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t7);
  			if (if_block5) if_block5.d(detaching);
  			if (detaching) detach_dev(t8);
  			if (if_block6) if_block6.d(detaching);
  			if (detaching) detach_dev(if_block6_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_109.name,
  		type: "if",
  		source: "(990:14) {#if isMedia}",
  		ctx
  	});

  	return block;
  }

  // (1044:16) {#if (hasTitle || hasHeader || hasFooter)}
  function create_if_block_123(ctx) {
  	let div;
  	let t0;
  	let t1_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_125(ctx);
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_11);
  	let if_block1 = /*hasFooter*/ ctx[41] && create_if_block_124(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			t1 = text$1(t1_value);
  			t2 = space();
  			if (title_slot) title_slot.c();
  			t3 = space();
  			if (if_block1) if_block1.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 1044, 18, 38261);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t0);
  			append_dev(div, t1);
  			append_dev(div, t2);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block1) if_block1.m(div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_125(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t1, t1_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_11), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_11));
  				}
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_124(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(title_slot, local);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(title_slot, local);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block0) if_block0.d();
  			if (title_slot) title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_123.name,
  		type: "if",
  		source: "(1044:16) {#if (hasTitle || hasHeader || hasFooter)}",
  		ctx
  	});

  	return block;
  }

  // (1046:20) {#if hasHeader}
  function create_if_block_125(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_11);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 1046, 22, 38344);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_11), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_11));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_125.name,
  		type: "if",
  		source: "(1046:20) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (1054:20) {#if hasFooter}
  function create_if_block_124(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_11);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 1054, 22, 38657);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_11), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_11));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_124.name,
  		type: "if",
  		source: "(1054:20) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (1063:16) {#if hasAfter}
  function create_if_block_120(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_11);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_122(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_121(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_11);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_11);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 1063, 18, 38970);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_11), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_11));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_122(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_121(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_11), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_11));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_11), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_11));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_120.name,
  		type: "if",
  		source: "(1063:16) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (1066:20) {#if typeof after !== 'undefined'}
  function create_if_block_122(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 1066, 22, 39120);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_122.name,
  		type: "if",
  		source: "(1066:20) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (1069:20) {#if typeof badge !== 'undefined'}
  function create_if_block_121(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_11] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_121.name,
  		type: "if",
  		source: "(1069:20) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (1070:22) <Badge color={badgeColor}>
  function create_default_slot_11(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_11.name,
  		type: "slot",
  		source: "(1070:22) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (1077:16) {#if !(swipeout || accordionItem)}
  function create_if_block_119(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_119.name,
  		type: "if",
  		source: "(1077:16) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (991:16) {#if hasHeader}
  function create_if_block_118(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_10);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 991, 18, 36247);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_10), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_10));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_118.name,
  		type: "if",
  		source: "(991:16) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (999:18) {#if (hasTitle)}
  function create_if_block_117(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t0;
  	let t1;
  	let current;
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_10);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (title_slot) title_slot.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 999, 20, 36551);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_10), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_10));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(title_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(title_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (title_slot) title_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_117.name,
  		type: "if",
  		source: "(999:18) {#if (hasTitle)}",
  		ctx
  	});

  	return block;
  }

  // (1006:18) {#if hasAfter}
  function create_if_block_114(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_10);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_116(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_115(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_10);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_10);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 1006, 20, 36812);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_10), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_10));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_116(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_115(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_10), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_10));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_10), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_10));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_114.name,
  		type: "if",
  		source: "(1006:18) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (1009:22) {#if typeof after !== 'undefined'}
  function create_if_block_116(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 1009, 24, 36968);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_116.name,
  		type: "if",
  		source: "(1009:22) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (1012:22) {#if typeof badge !== 'undefined'}
  function create_if_block_115(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_10] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_115.name,
  		type: "if",
  		source: "(1012:22) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (1013:24) <Badge color={badgeColor}>
  function create_default_slot_10(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_10.name,
  		type: "slot",
  		source: "(1013:24) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (1020:16) {#if hasSubtitle}
  function create_if_block_113(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "";
  	let t0;
  	let t1;
  	let current;
  	const subtitle_slot_template = /*$$slots*/ ctx[89].subtitle;
  	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_5);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (subtitle_slot) subtitle_slot.c();
  			attr_dev(div, "class", "item-subtitle");
  			add_location(div, file$a, 1020, 18, 37410);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (subtitle_slot) {
  				subtitle_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

  			if (subtitle_slot) {
  				if (subtitle_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					subtitle_slot.p(get_slot_context(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_5), get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[103], dirty, get_subtitle_slot_changes_5));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(subtitle_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(subtitle_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (subtitle_slot) subtitle_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_113.name,
  		type: "if",
  		source: "(1020:16) {#if hasSubtitle}",
  		ctx
  	});

  	return block;
  }

  // (1026:16) {#if hasText}
  function create_if_block_112(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*text*/ ctx[3]) + "";
  	let t0;
  	let t1;
  	let current;
  	const text_slot_template = /*$$slots*/ ctx[89].text;
  	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_5);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (text_slot) text_slot.c();
  			attr_dev(div, "class", "item-text");
  			add_location(div, file$a, 1026, 18, 37621);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (text_slot) {
  				text_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

  			if (text_slot) {
  				if (text_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					text_slot.p(get_slot_context(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_5), get_slot_changes(text_slot_template, /*$$scope*/ ctx[103], dirty, get_text_slot_changes_5));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(text_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(text_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (text_slot) text_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_112.name,
  		type: "if",
  		source: "(1026:16) {#if hasText}",
  		ctx
  	});

  	return block;
  }

  // (1033:16) {#if !(swipeout || accordionItem)}
  function create_if_block_111(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_111.name,
  		type: "if",
  		source: "(1033:16) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (1036:16) {#if hasFooter}
  function create_if_block_110(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_10);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 1036, 18, 37960);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_10), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_10));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_110.name,
  		type: "if",
  		source: "(1036:16) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (853:12) {#if isSortable && sortable !== false && isSortableOpposite}
  function create_if_block_108(ctx) {
  	let div;

  	const block = {
  		c: function create() {
  			div = element("div");
  			attr_dev(div, "class", "sortable-handler");
  			add_location(div, file$a, 853, 14, 31097);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_108.name,
  		type: "if",
  		source: "(853:12) {#if isSortable && sortable !== false && isSortableOpposite}",
  		ctx
  	});

  	return block;
  }

  // (868:12) {#if hasMedia}
  function create_if_block_106(ctx) {
  	let div;
  	let t;
  	let current;
  	let if_block = typeof /*media*/ ctx[4] !== "undefined" && create_if_block_107(ctx);
  	const media_slot_template = /*$$slots*/ ctx[89].media;
  	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_4);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block) if_block.c();
  			t = space();
  			if (media_slot) media_slot.c();
  			attr_dev(div, "class", "item-media");
  			add_location(div, file$a, 868, 14, 31636);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block) if_block.m(div, null);
  			append_dev(div, t);

  			if (media_slot) {
  				media_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (typeof /*media*/ ctx[4] !== "undefined") {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_107(ctx);
  					if_block.c();
  					if_block.m(div, t);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (media_slot) {
  				if (media_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					media_slot.p(get_slot_context(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_4), get_slot_changes(media_slot_template, /*$$scope*/ ctx[103], dirty, get_media_slot_changes_4));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(media_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(media_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  			if (media_slot) media_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_106.name,
  		type: "if",
  		source: "(868:12) {#if hasMedia}",
  		ctx
  	});

  	return block;
  }

  // (870:16) {#if typeof media !== 'undefined'}
  function create_if_block_107(ctx) {
  	let img;
  	let img_src_value;

  	const block = {
  		c: function create() {
  			img = element("img");
  			if (img.src !== (img_src_value = /*media*/ ctx[4])) attr_dev(img, "src", img_src_value);
  			add_location(img, file$a, 870, 18, 31730);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, img, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*media*/ 16 && img.src !== (img_src_value = /*media*/ ctx[4])) {
  				attr_dev(img, "src", img_src_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(img);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_107.name,
  		type: "if",
  		source: "(870:16) {#if typeof media !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (930:14) {:else}
  function create_else_block_8(ctx) {
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let if_block2_anchor;
  	let current;
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_9);
  	let if_block0 = (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) && create_if_block_103(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_9);
  	let if_block1 = /*hasAfter*/ ctx[44] && create_if_block_100(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_9);
  	let if_block2 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_99(ctx);

  	const block = {
  		c: function create() {
  			if (before_title_slot) before_title_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (after_title_slot) after_title_slot.c();
  			t2 = space();
  			if (if_block1) if_block1.c();
  			t3 = space();
  			if (inner_slot) inner_slot.c();
  			t4 = space();
  			if (if_block2) if_block2.c();
  			if_block2_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if (before_title_slot) {
  				before_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t0, anchor);
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t1, anchor);

  			if (after_title_slot) {
  				after_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t2, anchor);
  			if (if_block1) if_block1.m(target, anchor);
  			insert_dev(target, t3, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t4, anchor);
  			if (if_block2) if_block2.m(target, anchor);
  			insert_dev(target, if_block2_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_9), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_9));
  				}
  			}

  			if (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 1792) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_103(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t1.parentNode, t1);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_9), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_9));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_100(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(t3.parentNode, t3);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_9), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_9));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_99(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_title_slot, local);
  			transition_in(if_block0);
  			transition_in(after_title_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_slot, local);
  			transition_in(if_block2);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_title_slot, local);
  			transition_out(if_block0);
  			transition_out(after_title_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_slot, local);
  			transition_out(if_block2);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t1);
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (detaching) detach_dev(t2);
  			if (if_block1) if_block1.d(detaching);
  			if (detaching) detach_dev(t3);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t4);
  			if (if_block2) if_block2.d(detaching);
  			if (detaching) detach_dev(if_block2_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_8.name,
  		type: "else",
  		source: "(930:14) {:else}",
  		ctx
  	});

  	return block;
  }

  // (878:14) {#if isMedia}
  function create_if_block_89(ctx) {
  	let t0;
  	let div;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let t5;
  	let t6;
  	let t7;
  	let t8;
  	let if_block6_anchor;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_98(ctx);
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_8);
  	let if_block1 = /*hasTitle*/ ctx[39] && create_if_block_97(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_8);
  	let if_block2 = /*hasAfter*/ ctx[44] && create_if_block_94(ctx);
  	let if_block3 = /*hasSubtitle*/ ctx[42] && create_if_block_93(ctx);
  	let if_block4 = /*hasText*/ ctx[43] && create_if_block_92(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_8);
  	let if_block5 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_91(ctx);
  	let if_block6 = /*hasFooter*/ ctx[41] && create_if_block_90(ctx);

  	const block = {
  		c: function create() {
  			if (if_block0) if_block0.c();
  			t0 = space();
  			div = element("div");
  			if (before_title_slot) before_title_slot.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_title_slot) after_title_slot.c();
  			t3 = space();
  			if (if_block2) if_block2.c();
  			t4 = space();
  			if (if_block3) if_block3.c();
  			t5 = space();
  			if (if_block4) if_block4.c();
  			t6 = space();
  			if (inner_slot) inner_slot.c();
  			t7 = space();
  			if (if_block5) if_block5.c();
  			t8 = space();
  			if (if_block6) if_block6.c();
  			if_block6_anchor = empty$1();
  			attr_dev(div, "class", "item-title-row");
  			add_location(div, file$a, 884, 16, 32199);
  		},
  		m: function mount(target, anchor) {
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div, anchor);

  			if (before_title_slot) {
  				before_title_slot.m(div, null);
  			}

  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_title_slot) {
  				after_title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block2) if_block2.m(div, null);
  			insert_dev(target, t4, anchor);
  			if (if_block3) if_block3.m(target, anchor);
  			insert_dev(target, t5, anchor);
  			if (if_block4) if_block4.m(target, anchor);
  			insert_dev(target, t6, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t7, anchor);
  			if (if_block5) if_block5.m(target, anchor);
  			insert_dev(target, t8, anchor);
  			if (if_block6) if_block6.m(target, anchor);
  			insert_dev(target, if_block6_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_98(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t0.parentNode, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_8), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_8));
  				}
  			}

  			if (/*hasTitle*/ ctx[39]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle*/ 256) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_97(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_8), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_8));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_94(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(div, null);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (/*hasSubtitle*/ ctx[42]) {
  				if (if_block3) {
  					if_block3.p(ctx, dirty);

  					if (dirty[1] & /*hasSubtitle*/ 2048) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block_93(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(t5.parentNode, t5);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}

  			if (/*hasText*/ ctx[43]) {
  				if (if_block4) {
  					if_block4.p(ctx, dirty);

  					if (dirty[1] & /*hasText*/ 4096) {
  						transition_in(if_block4, 1);
  					}
  				} else {
  					if_block4 = create_if_block_92(ctx);
  					if_block4.c();
  					transition_in(if_block4, 1);
  					if_block4.m(t6.parentNode, t6);
  				}
  			} else if (if_block4) {
  				group_outros();

  				transition_out(if_block4, 1, 1, () => {
  					if_block4 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_8), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_8));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block5) {
  					if_block5.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block5, 1);
  					}
  				} else {
  					if_block5 = create_if_block_91(ctx);
  					if_block5.c();
  					transition_in(if_block5, 1);
  					if_block5.m(t8.parentNode, t8);
  				}
  			} else if (if_block5) {
  				group_outros();

  				transition_out(if_block5, 1, 1, () => {
  					if_block5 = null;
  				});

  				check_outros();
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block6) {
  					if_block6.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block6, 1);
  					}
  				} else {
  					if_block6 = create_if_block_90(ctx);
  					if_block6.c();
  					transition_in(if_block6, 1);
  					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
  				}
  			} else if (if_block6) {
  				group_outros();

  				transition_out(if_block6, 1, 1, () => {
  					if_block6 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(before_title_slot, local);
  			transition_in(if_block1);
  			transition_in(after_title_slot, local);
  			transition_in(if_block2);
  			transition_in(if_block3);
  			transition_in(if_block4);
  			transition_in(inner_slot, local);
  			transition_in(if_block5);
  			transition_in(if_block6);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(before_title_slot, local);
  			transition_out(if_block1);
  			transition_out(after_title_slot, local);
  			transition_out(if_block2);
  			transition_out(if_block3);
  			transition_out(if_block4);
  			transition_out(inner_slot, local);
  			transition_out(if_block5);
  			transition_out(if_block6);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div);
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (if_block2) if_block2.d();
  			if (detaching) detach_dev(t4);
  			if (if_block3) if_block3.d(detaching);
  			if (detaching) detach_dev(t5);
  			if (if_block4) if_block4.d(detaching);
  			if (detaching) detach_dev(t6);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t7);
  			if (if_block5) if_block5.d(detaching);
  			if (detaching) detach_dev(t8);
  			if (if_block6) if_block6.d(detaching);
  			if (detaching) detach_dev(if_block6_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_89.name,
  		type: "if",
  		source: "(878:14) {#if isMedia}",
  		ctx
  	});

  	return block;
  }

  // (932:16) {#if (hasTitle || hasHeader || hasFooter)}
  function create_if_block_103(ctx) {
  	let div;
  	let t0;
  	let t1_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_105(ctx);
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_9);
  	let if_block1 = /*hasFooter*/ ctx[41] && create_if_block_104(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			t1 = text$1(t1_value);
  			t2 = space();
  			if (title_slot) title_slot.c();
  			t3 = space();
  			if (if_block1) if_block1.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 932, 18, 34040);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t0);
  			append_dev(div, t1);
  			append_dev(div, t2);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block1) if_block1.m(div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_105(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t1, t1_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_9), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_9));
  				}
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_104(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(title_slot, local);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(title_slot, local);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block0) if_block0.d();
  			if (title_slot) title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_103.name,
  		type: "if",
  		source: "(932:16) {#if (hasTitle || hasHeader || hasFooter)}",
  		ctx
  	});

  	return block;
  }

  // (934:20) {#if hasHeader}
  function create_if_block_105(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_9);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 934, 22, 34123);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_9), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_9));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_105.name,
  		type: "if",
  		source: "(934:20) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (942:20) {#if hasFooter}
  function create_if_block_104(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_9);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 942, 22, 34436);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_9), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_9));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_104.name,
  		type: "if",
  		source: "(942:20) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (951:16) {#if hasAfter}
  function create_if_block_100(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_9);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_102(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_101(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_9);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_9);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 951, 18, 34749);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_9), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_9));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_102(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_101(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_9), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_9));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_9), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_9));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_100.name,
  		type: "if",
  		source: "(951:16) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (954:20) {#if typeof after !== 'undefined'}
  function create_if_block_102(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 954, 22, 34899);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_102.name,
  		type: "if",
  		source: "(954:20) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (957:20) {#if typeof badge !== 'undefined'}
  function create_if_block_101(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_9] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_101.name,
  		type: "if",
  		source: "(957:20) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (958:22) <Badge color={badgeColor}>
  function create_default_slot_9(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_9.name,
  		type: "slot",
  		source: "(958:22) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (965:16) {#if !(swipeout || accordionItem)}
  function create_if_block_99(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_99.name,
  		type: "if",
  		source: "(965:16) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (879:16) {#if hasHeader}
  function create_if_block_98(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_8);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 879, 18, 32026);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_8), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_8));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_98.name,
  		type: "if",
  		source: "(879:16) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (887:18) {#if (hasTitle)}
  function create_if_block_97(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t0;
  	let t1;
  	let current;
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_8);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (title_slot) title_slot.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 887, 20, 32330);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_8), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_8));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(title_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(title_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (title_slot) title_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_97.name,
  		type: "if",
  		source: "(887:18) {#if (hasTitle)}",
  		ctx
  	});

  	return block;
  }

  // (894:18) {#if hasAfter}
  function create_if_block_94(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_8);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_96(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_95(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_8);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_8);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 894, 20, 32591);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_8), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_8));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_96(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_95(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_8), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_8));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_8), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_8));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_94.name,
  		type: "if",
  		source: "(894:18) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (897:22) {#if typeof after !== 'undefined'}
  function create_if_block_96(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 897, 24, 32747);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_96.name,
  		type: "if",
  		source: "(897:22) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (900:22) {#if typeof badge !== 'undefined'}
  function create_if_block_95(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_8] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_95.name,
  		type: "if",
  		source: "(900:22) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (901:24) <Badge color={badgeColor}>
  function create_default_slot_8(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_8.name,
  		type: "slot",
  		source: "(901:24) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (908:16) {#if hasSubtitle}
  function create_if_block_93(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "";
  	let t0;
  	let t1;
  	let current;
  	const subtitle_slot_template = /*$$slots*/ ctx[89].subtitle;
  	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_4);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (subtitle_slot) subtitle_slot.c();
  			attr_dev(div, "class", "item-subtitle");
  			add_location(div, file$a, 908, 18, 33189);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (subtitle_slot) {
  				subtitle_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

  			if (subtitle_slot) {
  				if (subtitle_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					subtitle_slot.p(get_slot_context(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_4), get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[103], dirty, get_subtitle_slot_changes_4));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(subtitle_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(subtitle_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (subtitle_slot) subtitle_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_93.name,
  		type: "if",
  		source: "(908:16) {#if hasSubtitle}",
  		ctx
  	});

  	return block;
  }

  // (914:16) {#if hasText}
  function create_if_block_92(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*text*/ ctx[3]) + "";
  	let t0;
  	let t1;
  	let current;
  	const text_slot_template = /*$$slots*/ ctx[89].text;
  	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_4);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (text_slot) text_slot.c();
  			attr_dev(div, "class", "item-text");
  			add_location(div, file$a, 914, 18, 33400);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (text_slot) {
  				text_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

  			if (text_slot) {
  				if (text_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					text_slot.p(get_slot_context(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_4), get_slot_changes(text_slot_template, /*$$scope*/ ctx[103], dirty, get_text_slot_changes_4));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(text_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(text_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (text_slot) text_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_92.name,
  		type: "if",
  		source: "(914:16) {#if hasText}",
  		ctx
  	});

  	return block;
  }

  // (921:16) {#if !(swipeout || accordionItem)}
  function create_if_block_91(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_91.name,
  		type: "if",
  		source: "(921:16) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (924:16) {#if hasFooter}
  function create_if_block_90(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_8);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 924, 18, 33739);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_8), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_8));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_90.name,
  		type: "if",
  		source: "(924:16) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (737:12) {#if isSortable && sortable !== false && isSortableOpposite}
  function create_if_block_87(ctx) {
  	let div;

  	const block = {
  		c: function create() {
  			div = element("div");
  			attr_dev(div, "class", "sortable-handler");
  			add_location(div, file$a, 737, 14, 26761);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_87.name,
  		type: "if",
  		source: "(737:12) {#if isSortable && sortable !== false && isSortableOpposite}",
  		ctx
  	});

  	return block;
  }

  // (740:12) {#if hasMedia}
  function create_if_block_85(ctx) {
  	let div;
  	let t;
  	let current;
  	let if_block = typeof /*media*/ ctx[4] !== "undefined" && create_if_block_86(ctx);
  	const media_slot_template = /*$$slots*/ ctx[89].media;
  	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_3);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block) if_block.c();
  			t = space();
  			if (media_slot) media_slot.c();
  			attr_dev(div, "class", "item-media");
  			add_location(div, file$a, 740, 14, 26853);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block) if_block.m(div, null);
  			append_dev(div, t);

  			if (media_slot) {
  				media_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (typeof /*media*/ ctx[4] !== "undefined") {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_86(ctx);
  					if_block.c();
  					if_block.m(div, t);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (media_slot) {
  				if (media_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					media_slot.p(get_slot_context(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_3), get_slot_changes(media_slot_template, /*$$scope*/ ctx[103], dirty, get_media_slot_changes_3));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(media_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(media_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  			if (media_slot) media_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_85.name,
  		type: "if",
  		source: "(740:12) {#if hasMedia}",
  		ctx
  	});

  	return block;
  }

  // (742:16) {#if typeof media !== 'undefined'}
  function create_if_block_86(ctx) {
  	let img;
  	let img_src_value;

  	const block = {
  		c: function create() {
  			img = element("img");
  			if (img.src !== (img_src_value = /*media*/ ctx[4])) attr_dev(img, "src", img_src_value);
  			add_location(img, file$a, 742, 18, 26947);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, img, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*media*/ 16 && img.src !== (img_src_value = /*media*/ ctx[4])) {
  				attr_dev(img, "src", img_src_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(img);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_86.name,
  		type: "if",
  		source: "(742:16) {#if typeof media !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (802:14) {:else}
  function create_else_block_6(ctx) {
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let if_block2_anchor;
  	let current;
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_7);
  	let if_block0 = (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) && create_if_block_82(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_7);
  	let if_block1 = /*hasAfter*/ ctx[44] && create_if_block_79(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_7);
  	let if_block2 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_78(ctx);

  	const block = {
  		c: function create() {
  			if (before_title_slot) before_title_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (after_title_slot) after_title_slot.c();
  			t2 = space();
  			if (if_block1) if_block1.c();
  			t3 = space();
  			if (inner_slot) inner_slot.c();
  			t4 = space();
  			if (if_block2) if_block2.c();
  			if_block2_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if (before_title_slot) {
  				before_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t0, anchor);
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t1, anchor);

  			if (after_title_slot) {
  				after_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t2, anchor);
  			if (if_block1) if_block1.m(target, anchor);
  			insert_dev(target, t3, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t4, anchor);
  			if (if_block2) if_block2.m(target, anchor);
  			insert_dev(target, if_block2_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_7), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_7));
  				}
  			}

  			if (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 1792) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_82(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t1.parentNode, t1);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_7), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_7));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_79(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(t3.parentNode, t3);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_7), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_7));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_78(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_title_slot, local);
  			transition_in(if_block0);
  			transition_in(after_title_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_slot, local);
  			transition_in(if_block2);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_title_slot, local);
  			transition_out(if_block0);
  			transition_out(after_title_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_slot, local);
  			transition_out(if_block2);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t1);
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (detaching) detach_dev(t2);
  			if (if_block1) if_block1.d(detaching);
  			if (detaching) detach_dev(t3);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t4);
  			if (if_block2) if_block2.d(detaching);
  			if (detaching) detach_dev(if_block2_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_6.name,
  		type: "else",
  		source: "(802:14) {:else}",
  		ctx
  	});

  	return block;
  }

  // (750:14) {#if isMedia}
  function create_if_block_68(ctx) {
  	let t0;
  	let div;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let t5;
  	let t6;
  	let t7;
  	let t8;
  	let if_block6_anchor;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_77(ctx);
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_6);
  	let if_block1 = /*hasTitle*/ ctx[39] && create_if_block_76(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_6);
  	let if_block2 = /*hasAfter*/ ctx[44] && create_if_block_73(ctx);
  	let if_block3 = /*hasSubtitle*/ ctx[42] && create_if_block_72(ctx);
  	let if_block4 = /*hasText*/ ctx[43] && create_if_block_71(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_6);
  	let if_block5 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_70(ctx);
  	let if_block6 = /*hasFooter*/ ctx[41] && create_if_block_69(ctx);

  	const block = {
  		c: function create() {
  			if (if_block0) if_block0.c();
  			t0 = space();
  			div = element("div");
  			if (before_title_slot) before_title_slot.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_title_slot) after_title_slot.c();
  			t3 = space();
  			if (if_block2) if_block2.c();
  			t4 = space();
  			if (if_block3) if_block3.c();
  			t5 = space();
  			if (if_block4) if_block4.c();
  			t6 = space();
  			if (inner_slot) inner_slot.c();
  			t7 = space();
  			if (if_block5) if_block5.c();
  			t8 = space();
  			if (if_block6) if_block6.c();
  			if_block6_anchor = empty$1();
  			attr_dev(div, "class", "item-title-row");
  			add_location(div, file$a, 756, 16, 27416);
  		},
  		m: function mount(target, anchor) {
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div, anchor);

  			if (before_title_slot) {
  				before_title_slot.m(div, null);
  			}

  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_title_slot) {
  				after_title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block2) if_block2.m(div, null);
  			insert_dev(target, t4, anchor);
  			if (if_block3) if_block3.m(target, anchor);
  			insert_dev(target, t5, anchor);
  			if (if_block4) if_block4.m(target, anchor);
  			insert_dev(target, t6, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t7, anchor);
  			if (if_block5) if_block5.m(target, anchor);
  			insert_dev(target, t8, anchor);
  			if (if_block6) if_block6.m(target, anchor);
  			insert_dev(target, if_block6_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_77(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t0.parentNode, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_6), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_6));
  				}
  			}

  			if (/*hasTitle*/ ctx[39]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle*/ 256) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_76(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_6), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_6));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_73(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(div, null);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (/*hasSubtitle*/ ctx[42]) {
  				if (if_block3) {
  					if_block3.p(ctx, dirty);

  					if (dirty[1] & /*hasSubtitle*/ 2048) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block_72(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(t5.parentNode, t5);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}

  			if (/*hasText*/ ctx[43]) {
  				if (if_block4) {
  					if_block4.p(ctx, dirty);

  					if (dirty[1] & /*hasText*/ 4096) {
  						transition_in(if_block4, 1);
  					}
  				} else {
  					if_block4 = create_if_block_71(ctx);
  					if_block4.c();
  					transition_in(if_block4, 1);
  					if_block4.m(t6.parentNode, t6);
  				}
  			} else if (if_block4) {
  				group_outros();

  				transition_out(if_block4, 1, 1, () => {
  					if_block4 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_6), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_6));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block5) {
  					if_block5.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block5, 1);
  					}
  				} else {
  					if_block5 = create_if_block_70(ctx);
  					if_block5.c();
  					transition_in(if_block5, 1);
  					if_block5.m(t8.parentNode, t8);
  				}
  			} else if (if_block5) {
  				group_outros();

  				transition_out(if_block5, 1, 1, () => {
  					if_block5 = null;
  				});

  				check_outros();
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block6) {
  					if_block6.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block6, 1);
  					}
  				} else {
  					if_block6 = create_if_block_69(ctx);
  					if_block6.c();
  					transition_in(if_block6, 1);
  					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
  				}
  			} else if (if_block6) {
  				group_outros();

  				transition_out(if_block6, 1, 1, () => {
  					if_block6 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(before_title_slot, local);
  			transition_in(if_block1);
  			transition_in(after_title_slot, local);
  			transition_in(if_block2);
  			transition_in(if_block3);
  			transition_in(if_block4);
  			transition_in(inner_slot, local);
  			transition_in(if_block5);
  			transition_in(if_block6);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(before_title_slot, local);
  			transition_out(if_block1);
  			transition_out(after_title_slot, local);
  			transition_out(if_block2);
  			transition_out(if_block3);
  			transition_out(if_block4);
  			transition_out(inner_slot, local);
  			transition_out(if_block5);
  			transition_out(if_block6);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div);
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (if_block2) if_block2.d();
  			if (detaching) detach_dev(t4);
  			if (if_block3) if_block3.d(detaching);
  			if (detaching) detach_dev(t5);
  			if (if_block4) if_block4.d(detaching);
  			if (detaching) detach_dev(t6);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t7);
  			if (if_block5) if_block5.d(detaching);
  			if (detaching) detach_dev(t8);
  			if (if_block6) if_block6.d(detaching);
  			if (detaching) detach_dev(if_block6_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_68.name,
  		type: "if",
  		source: "(750:14) {#if isMedia}",
  		ctx
  	});

  	return block;
  }

  // (804:16) {#if (hasTitle || hasHeader || hasFooter)}
  function create_if_block_82(ctx) {
  	let div;
  	let t0;
  	let t1_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_84(ctx);
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_7);
  	let if_block1 = /*hasFooter*/ ctx[41] && create_if_block_83(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			t1 = text$1(t1_value);
  			t2 = space();
  			if (title_slot) title_slot.c();
  			t3 = space();
  			if (if_block1) if_block1.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 804, 18, 29257);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t0);
  			append_dev(div, t1);
  			append_dev(div, t2);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block1) if_block1.m(div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_84(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t1, t1_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_7), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_7));
  				}
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_83(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(title_slot, local);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(title_slot, local);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block0) if_block0.d();
  			if (title_slot) title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_82.name,
  		type: "if",
  		source: "(804:16) {#if (hasTitle || hasHeader || hasFooter)}",
  		ctx
  	});

  	return block;
  }

  // (806:20) {#if hasHeader}
  function create_if_block_84(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_7);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 806, 22, 29340);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_7), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_7));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_84.name,
  		type: "if",
  		source: "(806:20) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (814:20) {#if hasFooter}
  function create_if_block_83(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_7);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 814, 22, 29653);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_7), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_7));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_83.name,
  		type: "if",
  		source: "(814:20) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (823:16) {#if hasAfter}
  function create_if_block_79(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_7);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_81(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_80(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_7);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_7);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 823, 18, 29966);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_7), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_7));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_81(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_80(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_7), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_7));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_7), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_7));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_79.name,
  		type: "if",
  		source: "(823:16) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (826:20) {#if typeof after !== 'undefined'}
  function create_if_block_81(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 826, 22, 30116);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_81.name,
  		type: "if",
  		source: "(826:20) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (829:20) {#if typeof badge !== 'undefined'}
  function create_if_block_80(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_7] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_80.name,
  		type: "if",
  		source: "(829:20) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (830:22) <Badge color={badgeColor}>
  function create_default_slot_7(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_7.name,
  		type: "slot",
  		source: "(830:22) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (837:16) {#if !(swipeout || accordionItem)}
  function create_if_block_78(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_78.name,
  		type: "if",
  		source: "(837:16) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (751:16) {#if hasHeader}
  function create_if_block_77(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_6);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 751, 18, 27243);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_6), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_6));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_77.name,
  		type: "if",
  		source: "(751:16) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (759:18) {#if (hasTitle)}
  function create_if_block_76(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t0;
  	let t1;
  	let current;
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_6);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (title_slot) title_slot.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 759, 20, 27547);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_6), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_6));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(title_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(title_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (title_slot) title_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_76.name,
  		type: "if",
  		source: "(759:18) {#if (hasTitle)}",
  		ctx
  	});

  	return block;
  }

  // (766:18) {#if hasAfter}
  function create_if_block_73(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_6);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_75(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_74(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_6);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_6);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 766, 20, 27808);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_6), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_6));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_75(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_74(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_6), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_6));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_6), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_6));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_73.name,
  		type: "if",
  		source: "(766:18) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (769:22) {#if typeof after !== 'undefined'}
  function create_if_block_75(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 769, 24, 27964);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_75.name,
  		type: "if",
  		source: "(769:22) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (772:22) {#if typeof badge !== 'undefined'}
  function create_if_block_74(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_6] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_74.name,
  		type: "if",
  		source: "(772:22) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (773:24) <Badge color={badgeColor}>
  function create_default_slot_6(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_6.name,
  		type: "slot",
  		source: "(773:24) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (780:16) {#if hasSubtitle}
  function create_if_block_72(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "";
  	let t0;
  	let t1;
  	let current;
  	const subtitle_slot_template = /*$$slots*/ ctx[89].subtitle;
  	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_3);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (subtitle_slot) subtitle_slot.c();
  			attr_dev(div, "class", "item-subtitle");
  			add_location(div, file$a, 780, 18, 28406);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (subtitle_slot) {
  				subtitle_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

  			if (subtitle_slot) {
  				if (subtitle_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					subtitle_slot.p(get_slot_context(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_3), get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[103], dirty, get_subtitle_slot_changes_3));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(subtitle_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(subtitle_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (subtitle_slot) subtitle_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_72.name,
  		type: "if",
  		source: "(780:16) {#if hasSubtitle}",
  		ctx
  	});

  	return block;
  }

  // (786:16) {#if hasText}
  function create_if_block_71(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*text*/ ctx[3]) + "";
  	let t0;
  	let t1;
  	let current;
  	const text_slot_template = /*$$slots*/ ctx[89].text;
  	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_3);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (text_slot) text_slot.c();
  			attr_dev(div, "class", "item-text");
  			add_location(div, file$a, 786, 18, 28617);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (text_slot) {
  				text_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

  			if (text_slot) {
  				if (text_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					text_slot.p(get_slot_context(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_3), get_slot_changes(text_slot_template, /*$$scope*/ ctx[103], dirty, get_text_slot_changes_3));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(text_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(text_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (text_slot) text_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_71.name,
  		type: "if",
  		source: "(786:16) {#if hasText}",
  		ctx
  	});

  	return block;
  }

  // (793:16) {#if !(swipeout || accordionItem)}
  function create_if_block_70(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_70.name,
  		type: "if",
  		source: "(793:16) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (796:16) {#if hasFooter}
  function create_if_block_69(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_6);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 796, 18, 28956);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_6), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_6));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_69.name,
  		type: "if",
  		source: "(796:16) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (489:8) {:else}
  function create_else_block_2(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block_26, create_else_block_4];
  	const if_blocks = [];

  	function select_block_type_4(ctx, dirty) {
  		if (/*checkbox*/ ctx[16] || /*radio*/ ctx[17]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_4(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			if_block.c();
  			if_block_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_4(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_2.name,
  		type: "else",
  		source: "(489:8) {:else}",
  		ctx
  	});

  	return block;
  }

  // (373:8) {#if isLink}
  function create_if_block_5(ctx) {
  	let a;
  	let div1;
  	let t0;
  	let t1;
  	let t2;
  	let div0;
  	let t3;
  	let current_block_type_index;
  	let if_block2;
  	let t4;
  	let t5;
  	let t6;
  	let current;
  	let dispose;
  	const content_start_slot_template = /*$$slots*/ ctx[89]["content-start"];
  	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context);
  	let if_block0 = /*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31] && create_if_block_25(ctx);
  	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_23(ctx);
  	const inner_start_slot_template = /*$$slots*/ ctx[89]["inner-start"];
  	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context);
  	const if_block_creators = [create_if_block_6, create_else_block_1];
  	const if_blocks = [];

  	function select_block_type_3(ctx, dirty) {
  		if (/*isMedia*/ ctx[29]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_3(ctx);
  	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	const inner_end_slot_template = /*$$slots*/ ctx[89]["inner-end"];
  	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context);
  	const content_slot_template = /*$$slots*/ ctx[89].content;
  	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context);
  	const content_end_slot_template = /*$$slots*/ ctx[89]["content-end"];
  	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context);
  	let a_levels = [{ class: /*linkClasses*/ ctx[35] }, /*linkAttrs*/ ctx[36]];
  	let a_data = {};

  	for (let i = 0; i < a_levels.length; i += 1) {
  		a_data = assign(a_data, a_levels[i]);
  	}

  	const block = {
  		c: function create() {
  			a = element("a");
  			div1 = element("div");
  			if (content_start_slot) content_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			div0 = element("div");
  			if (inner_start_slot) inner_start_slot.c();
  			t3 = space();
  			if_block2.c();
  			t4 = space();
  			if (inner_end_slot) inner_end_slot.c();
  			t5 = space();
  			if (content_slot) content_slot.c();
  			t6 = space();
  			if (content_end_slot) content_end_slot.c();
  			attr_dev(div0, "class", "item-inner");
  			add_location(div0, file$a, 388, 14, 12983);
  			attr_dev(div1, "class", /*contentClasses*/ ctx[34]);
  			add_location(div1, file$a, 375, 12, 12482);
  			set_attributes(a, a_data);
  			add_location(a, file$a, 373, 10, 12353);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, a, anchor);
  			append_dev(a, div1);

  			if (content_start_slot) {
  				content_start_slot.m(div1, null);
  			}

  			append_dev(div1, t0);
  			if (if_block0) if_block0.m(div1, null);
  			append_dev(div1, t1);
  			if (if_block1) if_block1.m(div1, null);
  			append_dev(div1, t2);
  			append_dev(div1, div0);

  			if (inner_start_slot) {
  				inner_start_slot.m(div0, null);
  			}

  			append_dev(div0, t3);
  			if_blocks[current_block_type_index].m(div0, null);
  			append_dev(div0, t4);

  			if (inner_end_slot) {
  				inner_end_slot.m(div0, null);
  			}

  			/*div0_binding*/ ctx[92](div0);
  			append_dev(div1, t5);

  			if (content_slot) {
  				content_slot.m(div1, null);
  			}

  			append_dev(div1, t6);

  			if (content_end_slot) {
  				content_end_slot.m(div1, null);
  			}

  			/*a_binding*/ ctx[93](a);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(a, "click", /*onClick*/ ctx[45], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (content_start_slot) {
  				if (content_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_start_slot.p(get_slot_context(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context), get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[103], dirty, get_content_start_slot_changes));
  				}
  			}

  			if (/*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31]) {
  				if (if_block0) ; else {
  					if_block0 = create_if_block_25(ctx);
  					if_block0.c();
  					if_block0.m(div1, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (/*hasMedia*/ ctx[38]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasMedia*/ 128) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_23(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div1, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_start_slot) {
  				if (inner_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_start_slot.p(get_slot_context(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context), get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_start_slot_changes));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_3(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block2 = if_blocks[current_block_type_index];

  				if (!if_block2) {
  					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block2.c();
  				}

  				transition_in(if_block2, 1);
  				if_block2.m(div0, t4);
  			}

  			if (inner_end_slot) {
  				if (inner_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_end_slot.p(get_slot_context(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context), get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_end_slot_changes));
  				}
  			}

  			if (content_slot) {
  				if (content_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_slot.p(get_slot_context(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context), get_slot_changes(content_slot_template, /*$$scope*/ ctx[103], dirty, get_content_slot_changes));
  				}
  			}

  			if (content_end_slot) {
  				if (content_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_end_slot.p(get_slot_context(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context), get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[103], dirty, get_content_end_slot_changes));
  				}
  			}

  			if (!current || dirty[1] & /*contentClasses*/ 8) {
  				attr_dev(div1, "class", /*contentClasses*/ ctx[34]);
  			}

  			set_attributes(a, get_spread_update(a_levels, [
  				dirty[1] & /*linkClasses*/ 16 && { class: /*linkClasses*/ ctx[35] },
  				dirty[1] & /*linkAttrs*/ 32 && /*linkAttrs*/ ctx[36]
  			]));
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(content_start_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_start_slot, local);
  			transition_in(if_block2);
  			transition_in(inner_end_slot, local);
  			transition_in(content_slot, local);
  			transition_in(content_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(content_start_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_start_slot, local);
  			transition_out(if_block2);
  			transition_out(inner_end_slot, local);
  			transition_out(content_slot, local);
  			transition_out(content_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  			if (content_start_slot) content_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (inner_start_slot) inner_start_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (inner_end_slot) inner_end_slot.d(detaching);
  			/*div0_binding*/ ctx[92](null);
  			if (content_slot) content_slot.d(detaching);
  			if (content_end_slot) content_end_slot.d(detaching);
  			/*a_binding*/ ctx[93](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_5.name,
  		type: "if",
  		source: "(373:8) {#if isLink}",
  		ctx
  	});

  	return block;
  }

  // (615:10) {:else}
  function create_else_block_4(ctx) {
  	let div1;
  	let t0;
  	let t1;
  	let t2;
  	let div0;
  	let t3;
  	let current_block_type_index;
  	let if_block2;
  	let t4;
  	let t5;
  	let t6;
  	let current;
  	let dispose;
  	const content_start_slot_template = /*$$slots*/ ctx[89]["content-start"];
  	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_2);
  	let if_block0 = /*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31] && create_if_block_66(ctx);
  	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_64(ctx);
  	const inner_start_slot_template = /*$$slots*/ ctx[89]["inner-start"];
  	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_2);
  	const if_block_creators = [create_if_block_47, create_else_block_5];
  	const if_blocks = [];

  	function select_block_type_6(ctx, dirty) {
  		if (/*isMedia*/ ctx[29]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_6(ctx);
  	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	const inner_end_slot_template = /*$$slots*/ ctx[89]["inner-end"];
  	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_2);
  	const content_slot_template = /*$$slots*/ ctx[89].content;
  	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_2);
  	const content_end_slot_template = /*$$slots*/ ctx[89]["content-end"];
  	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_2);

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			if (content_start_slot) content_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			div0 = element("div");
  			if (inner_start_slot) inner_start_slot.c();
  			t3 = space();
  			if_block2.c();
  			t4 = space();
  			if (inner_end_slot) inner_end_slot.c();
  			t5 = space();
  			if (content_slot) content_slot.c();
  			t6 = space();
  			if (content_end_slot) content_end_slot.c();
  			attr_dev(div0, "class", "item-inner");
  			add_location(div0, file$a, 628, 14, 22467);
  			attr_dev(div1, "class", /*contentClasses*/ ctx[34]);
  			add_location(div1, file$a, 615, 12, 21947);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div1, anchor);

  			if (content_start_slot) {
  				content_start_slot.m(div1, null);
  			}

  			append_dev(div1, t0);
  			if (if_block0) if_block0.m(div1, null);
  			append_dev(div1, t1);
  			if (if_block1) if_block1.m(div1, null);
  			append_dev(div1, t2);
  			append_dev(div1, div0);

  			if (inner_start_slot) {
  				inner_start_slot.m(div0, null);
  			}

  			append_dev(div0, t3);
  			if_blocks[current_block_type_index].m(div0, null);
  			append_dev(div0, t4);

  			if (inner_end_slot) {
  				inner_end_slot.m(div0, null);
  			}

  			/*div0_binding_1*/ ctx[96](div0);
  			append_dev(div1, t5);

  			if (content_slot) {
  				content_slot.m(div1, null);
  			}

  			append_dev(div1, t6);

  			if (content_end_slot) {
  				content_end_slot.m(div1, null);
  			}

  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(div1, "click", /*onClick*/ ctx[45], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (content_start_slot) {
  				if (content_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_start_slot.p(get_slot_context(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_2), get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[103], dirty, get_content_start_slot_changes_2));
  				}
  			}

  			if (/*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31]) {
  				if (if_block0) ; else {
  					if_block0 = create_if_block_66(ctx);
  					if_block0.c();
  					if_block0.m(div1, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (/*hasMedia*/ ctx[38]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasMedia*/ 128) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_64(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div1, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_start_slot) {
  				if (inner_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_start_slot.p(get_slot_context(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_2), get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_start_slot_changes_2));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_6(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block2 = if_blocks[current_block_type_index];

  				if (!if_block2) {
  					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block2.c();
  				}

  				transition_in(if_block2, 1);
  				if_block2.m(div0, t4);
  			}

  			if (inner_end_slot) {
  				if (inner_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_end_slot.p(get_slot_context(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_2), get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_end_slot_changes_2));
  				}
  			}

  			if (content_slot) {
  				if (content_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_slot.p(get_slot_context(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_2), get_slot_changes(content_slot_template, /*$$scope*/ ctx[103], dirty, get_content_slot_changes_2));
  				}
  			}

  			if (content_end_slot) {
  				if (content_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_end_slot.p(get_slot_context(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_2), get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[103], dirty, get_content_end_slot_changes_2));
  				}
  			}

  			if (!current || dirty[1] & /*contentClasses*/ 8) {
  				attr_dev(div1, "class", /*contentClasses*/ ctx[34]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(content_start_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_start_slot, local);
  			transition_in(if_block2);
  			transition_in(inner_end_slot, local);
  			transition_in(content_slot, local);
  			transition_in(content_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(content_start_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_start_slot, local);
  			transition_out(if_block2);
  			transition_out(inner_end_slot, local);
  			transition_out(content_slot, local);
  			transition_out(content_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  			if (content_start_slot) content_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (inner_start_slot) inner_start_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (inner_end_slot) inner_end_slot.d(detaching);
  			/*div0_binding_1*/ ctx[96](null);
  			if (content_slot) content_slot.d(detaching);
  			if (content_end_slot) content_end_slot.d(detaching);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_4.name,
  		type: "else",
  		source: "(615:10) {:else}",
  		ctx
  	});

  	return block;
  }

  // (491:10) {#if checkbox || radio}
  function create_if_block_26(ctx) {
  	let label;
  	let t0;
  	let t1;
  	let input;
  	let input_value_value;
  	let input_type_value;
  	let t2;
  	let i;
  	let i_class_value;
  	let t3;
  	let t4;
  	let div;
  	let t5;
  	let current_block_type_index;
  	let if_block2;
  	let t6;
  	let t7;
  	let t8;
  	let current;
  	let dispose;
  	const content_start_slot_template = /*$$slots*/ ctx[89]["content-start"];
  	const content_start_slot = create_slot(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_1);
  	let if_block0 = /*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31] && create_if_block_46(ctx);
  	let if_block1 = /*hasMedia*/ ctx[38] && create_if_block_44(ctx);
  	const inner_start_slot_template = /*$$slots*/ ctx[89]["inner-start"];
  	const inner_start_slot = create_slot(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_1);
  	const if_block_creators = [create_if_block_27, create_else_block_3];
  	const if_blocks = [];

  	function select_block_type_5(ctx, dirty) {
  		if (/*isMedia*/ ctx[29]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_5(ctx);
  	if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	const inner_end_slot_template = /*$$slots*/ ctx[89]["inner-end"];
  	const inner_end_slot = create_slot(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_1);
  	const content_slot_template = /*$$slots*/ ctx[89].content;
  	const content_slot = create_slot(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_1);
  	const content_end_slot_template = /*$$slots*/ ctx[89]["content-end"];
  	const content_end_slot = create_slot(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_1);

  	const block = {
  		c: function create() {
  			label = element("label");
  			if (content_start_slot) content_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			input = element("input");
  			t2 = space();
  			i = element("i");
  			t3 = space();
  			if (if_block1) if_block1.c();
  			t4 = space();
  			div = element("div");
  			if (inner_start_slot) inner_start_slot.c();
  			t5 = space();
  			if_block2.c();
  			t6 = space();
  			if (inner_end_slot) inner_end_slot.c();
  			t7 = space();
  			if (content_slot) content_slot.c();
  			t8 = space();
  			if (content_end_slot) content_end_slot.c();

  			input.value = input_value_value = typeof /*value*/ ctx[20] === "undefined"
  			? ""
  			: /*value*/ ctx[20];

  			attr_dev(input, "name", /*name*/ ctx[19]);
  			input.checked = /*checked*/ ctx[18];
  			input.readOnly = /*readonly*/ ctx[21];
  			input.disabled = /*disabled*/ ctx[23];
  			input.required = /*required*/ ctx[22];
  			attr_dev(input, "type", input_type_value = /*radio*/ ctx[17] ? "radio" : "checkbox");
  			add_location(input, file$a, 496, 14, 17281);
  			attr_dev(i, "class", i_class_value = `icon icon-${/*radio*/ ctx[17] ? "radio" : "checkbox"}`);
  			add_location(i, file$a, 507, 14, 17680);
  			attr_dev(div, "class", "item-inner");
  			add_location(div, file$a, 516, 14, 18022);
  			attr_dev(label, "class", /*contentClasses*/ ctx[34]);
  			add_location(label, file$a, 491, 12, 17029);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, label, anchor);

  			if (content_start_slot) {
  				content_start_slot.m(label, null);
  			}

  			append_dev(label, t0);
  			if (if_block0) if_block0.m(label, null);
  			append_dev(label, t1);
  			append_dev(label, input);
  			/*input_binding*/ ctx[94](input);
  			append_dev(label, t2);
  			append_dev(label, i);
  			append_dev(label, t3);
  			if (if_block1) if_block1.m(label, null);
  			append_dev(label, t4);
  			append_dev(label, div);

  			if (inner_start_slot) {
  				inner_start_slot.m(div, null);
  			}

  			append_dev(div, t5);
  			if_blocks[current_block_type_index].m(div, null);
  			append_dev(div, t6);

  			if (inner_end_slot) {
  				inner_end_slot.m(div, null);
  			}

  			/*div_binding*/ ctx[95](div);
  			append_dev(label, t7);

  			if (content_slot) {
  				content_slot.m(label, null);
  			}

  			append_dev(label, t8);

  			if (content_end_slot) {
  				content_end_slot.m(label, null);
  			}

  			current = true;
  			if (remount) run_all(dispose);

  			dispose = [
  				listen_dev(input, "change", /*onChange*/ ctx[46], false, false, false),
  				listen_dev(label, "click", /*onClick*/ ctx[45], false, false, false)
  			];
  		},
  		p: function update(ctx, dirty) {
  			if (content_start_slot) {
  				if (content_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_start_slot.p(get_slot_context(content_start_slot_template, ctx, /*$$scope*/ ctx[103], get_content_start_slot_context_1), get_slot_changes(content_start_slot_template, /*$$scope*/ ctx[103], dirty, get_content_start_slot_changes_1));
  				}
  			}

  			if (/*isSortable*/ ctx[30] && /*sortable*/ ctx[14] !== false && /*isSortableOpposite*/ ctx[31]) {
  				if (if_block0) ; else {
  					if_block0 = create_if_block_46(ctx);
  					if_block0.c();
  					if_block0.m(label, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (!current || dirty[0] & /*value*/ 1048576 && input_value_value !== (input_value_value = typeof /*value*/ ctx[20] === "undefined"
  			? ""
  			: /*value*/ ctx[20]) && input.value !== input_value_value) {
  				prop_dev(input, "value", input_value_value);
  			}

  			if (!current || dirty[0] & /*name*/ 524288) {
  				attr_dev(input, "name", /*name*/ ctx[19]);
  			}

  			if (!current || dirty[0] & /*checked*/ 262144) {
  				prop_dev(input, "checked", /*checked*/ ctx[18]);
  			}

  			if (!current || dirty[0] & /*readonly*/ 2097152) {
  				prop_dev(input, "readOnly", /*readonly*/ ctx[21]);
  			}

  			if (!current || dirty[0] & /*disabled*/ 8388608) {
  				prop_dev(input, "disabled", /*disabled*/ ctx[23]);
  			}

  			if (!current || dirty[0] & /*required*/ 4194304) {
  				prop_dev(input, "required", /*required*/ ctx[22]);
  			}

  			if (!current || dirty[0] & /*radio*/ 131072 && input_type_value !== (input_type_value = /*radio*/ ctx[17] ? "radio" : "checkbox")) {
  				attr_dev(input, "type", input_type_value);
  			}

  			if (!current || dirty[0] & /*radio*/ 131072 && i_class_value !== (i_class_value = `icon icon-${/*radio*/ ctx[17] ? "radio" : "checkbox"}`)) {
  				attr_dev(i, "class", i_class_value);
  			}

  			if (/*hasMedia*/ ctx[38]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasMedia*/ 128) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_44(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(label, t4);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_start_slot) {
  				if (inner_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_start_slot.p(get_slot_context(inner_start_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_start_slot_context_1), get_slot_changes(inner_start_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_start_slot_changes_1));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_5(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block2 = if_blocks[current_block_type_index];

  				if (!if_block2) {
  					if_block2 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block2.c();
  				}

  				transition_in(if_block2, 1);
  				if_block2.m(div, t6);
  			}

  			if (inner_end_slot) {
  				if (inner_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_end_slot.p(get_slot_context(inner_end_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_end_slot_context_1), get_slot_changes(inner_end_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_end_slot_changes_1));
  				}
  			}

  			if (content_slot) {
  				if (content_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_slot.p(get_slot_context(content_slot_template, ctx, /*$$scope*/ ctx[103], get_content_slot_context_1), get_slot_changes(content_slot_template, /*$$scope*/ ctx[103], dirty, get_content_slot_changes_1));
  				}
  			}

  			if (content_end_slot) {
  				if (content_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					content_end_slot.p(get_slot_context(content_end_slot_template, ctx, /*$$scope*/ ctx[103], get_content_end_slot_context_1), get_slot_changes(content_end_slot_template, /*$$scope*/ ctx[103], dirty, get_content_end_slot_changes_1));
  				}
  			}

  			if (!current || dirty[1] & /*contentClasses*/ 8) {
  				attr_dev(label, "class", /*contentClasses*/ ctx[34]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(content_start_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_start_slot, local);
  			transition_in(if_block2);
  			transition_in(inner_end_slot, local);
  			transition_in(content_slot, local);
  			transition_in(content_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(content_start_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_start_slot, local);
  			transition_out(if_block2);
  			transition_out(inner_end_slot, local);
  			transition_out(content_slot, local);
  			transition_out(content_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(label);
  			if (content_start_slot) content_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			/*input_binding*/ ctx[94](null);
  			if (if_block1) if_block1.d();
  			if (inner_start_slot) inner_start_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (inner_end_slot) inner_end_slot.d(detaching);
  			/*div_binding*/ ctx[95](null);
  			if (content_slot) content_slot.d(detaching);
  			if (content_end_slot) content_end_slot.d(detaching);
  			run_all(dispose);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_26.name,
  		type: "if",
  		source: "(491:10) {#if checkbox || radio}",
  		ctx
  	});

  	return block;
  }

  // (618:14) {#if isSortable && sortable !== false && isSortableOpposite}
  function create_if_block_66(ctx) {
  	let div;

  	const block = {
  		c: function create() {
  			div = element("div");
  			attr_dev(div, "class", "sortable-handler");
  			add_location(div, file$a, 618, 16, 22130);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_66.name,
  		type: "if",
  		source: "(618:14) {#if isSortable && sortable !== false && isSortableOpposite}",
  		ctx
  	});

  	return block;
  }

  // (621:14) {#if hasMedia}
  function create_if_block_64(ctx) {
  	let div;
  	let t;
  	let current;
  	let if_block = typeof /*media*/ ctx[4] !== "undefined" && create_if_block_65(ctx);
  	const media_slot_template = /*$$slots*/ ctx[89].media;
  	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_2);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block) if_block.c();
  			t = space();
  			if (media_slot) media_slot.c();
  			attr_dev(div, "class", "item-media");
  			add_location(div, file$a, 621, 16, 22228);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block) if_block.m(div, null);
  			append_dev(div, t);

  			if (media_slot) {
  				media_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (typeof /*media*/ ctx[4] !== "undefined") {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_65(ctx);
  					if_block.c();
  					if_block.m(div, t);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (media_slot) {
  				if (media_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					media_slot.p(get_slot_context(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_2), get_slot_changes(media_slot_template, /*$$scope*/ ctx[103], dirty, get_media_slot_changes_2));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(media_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(media_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  			if (media_slot) media_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_64.name,
  		type: "if",
  		source: "(621:14) {#if hasMedia}",
  		ctx
  	});

  	return block;
  }

  // (623:18) {#if typeof media !== 'undefined'}
  function create_if_block_65(ctx) {
  	let img;
  	let img_src_value;

  	const block = {
  		c: function create() {
  			img = element("img");
  			if (img.src !== (img_src_value = /*media*/ ctx[4])) attr_dev(img, "src", img_src_value);
  			add_location(img, file$a, 623, 20, 22326);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, img, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*media*/ 16 && img.src !== (img_src_value = /*media*/ ctx[4])) {
  				attr_dev(img, "src", img_src_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(img);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_65.name,
  		type: "if",
  		source: "(623:18) {#if typeof media !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (683:16) {:else}
  function create_else_block_5(ctx) {
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let if_block2_anchor;
  	let current;
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_5);
  	let if_block0 = (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) && create_if_block_61(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_5);
  	let if_block1 = /*hasAfter*/ ctx[44] && create_if_block_58(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_5);
  	let if_block2 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_57(ctx);

  	const block = {
  		c: function create() {
  			if (before_title_slot) before_title_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (after_title_slot) after_title_slot.c();
  			t2 = space();
  			if (if_block1) if_block1.c();
  			t3 = space();
  			if (inner_slot) inner_slot.c();
  			t4 = space();
  			if (if_block2) if_block2.c();
  			if_block2_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if (before_title_slot) {
  				before_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t0, anchor);
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t1, anchor);

  			if (after_title_slot) {
  				after_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t2, anchor);
  			if (if_block1) if_block1.m(target, anchor);
  			insert_dev(target, t3, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t4, anchor);
  			if (if_block2) if_block2.m(target, anchor);
  			insert_dev(target, if_block2_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_5), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_5));
  				}
  			}

  			if (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 1792) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_61(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t1.parentNode, t1);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_5), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_5));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_58(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(t3.parentNode, t3);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_5), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_5));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_57(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_title_slot, local);
  			transition_in(if_block0);
  			transition_in(after_title_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_slot, local);
  			transition_in(if_block2);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_title_slot, local);
  			transition_out(if_block0);
  			transition_out(after_title_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_slot, local);
  			transition_out(if_block2);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t1);
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (detaching) detach_dev(t2);
  			if (if_block1) if_block1.d(detaching);
  			if (detaching) detach_dev(t3);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t4);
  			if (if_block2) if_block2.d(detaching);
  			if (detaching) detach_dev(if_block2_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_5.name,
  		type: "else",
  		source: "(683:16) {:else}",
  		ctx
  	});

  	return block;
  }

  // (631:16) {#if isMedia}
  function create_if_block_47(ctx) {
  	let t0;
  	let div;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let t5;
  	let t6;
  	let t7;
  	let t8;
  	let if_block6_anchor;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_56(ctx);
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_4);
  	let if_block1 = /*hasTitle*/ ctx[39] && create_if_block_55(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_4);
  	let if_block2 = /*hasAfter*/ ctx[44] && create_if_block_52(ctx);
  	let if_block3 = /*hasSubtitle*/ ctx[42] && create_if_block_51(ctx);
  	let if_block4 = /*hasText*/ ctx[43] && create_if_block_50(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_4);
  	let if_block5 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_49(ctx);
  	let if_block6 = /*hasFooter*/ ctx[41] && create_if_block_48(ctx);

  	const block = {
  		c: function create() {
  			if (if_block0) if_block0.c();
  			t0 = space();
  			div = element("div");
  			if (before_title_slot) before_title_slot.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_title_slot) after_title_slot.c();
  			t3 = space();
  			if (if_block2) if_block2.c();
  			t4 = space();
  			if (if_block3) if_block3.c();
  			t5 = space();
  			if (if_block4) if_block4.c();
  			t6 = space();
  			if (inner_slot) inner_slot.c();
  			t7 = space();
  			if (if_block5) if_block5.c();
  			t8 = space();
  			if (if_block6) if_block6.c();
  			if_block6_anchor = empty$1();
  			attr_dev(div, "class", "item-title-row");
  			add_location(div, file$a, 637, 18, 22823);
  		},
  		m: function mount(target, anchor) {
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div, anchor);

  			if (before_title_slot) {
  				before_title_slot.m(div, null);
  			}

  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_title_slot) {
  				after_title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block2) if_block2.m(div, null);
  			insert_dev(target, t4, anchor);
  			if (if_block3) if_block3.m(target, anchor);
  			insert_dev(target, t5, anchor);
  			if (if_block4) if_block4.m(target, anchor);
  			insert_dev(target, t6, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t7, anchor);
  			if (if_block5) if_block5.m(target, anchor);
  			insert_dev(target, t8, anchor);
  			if (if_block6) if_block6.m(target, anchor);
  			insert_dev(target, if_block6_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_56(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t0.parentNode, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_4), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_4));
  				}
  			}

  			if (/*hasTitle*/ ctx[39]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle*/ 256) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_55(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_4), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_4));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_52(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(div, null);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (/*hasSubtitle*/ ctx[42]) {
  				if (if_block3) {
  					if_block3.p(ctx, dirty);

  					if (dirty[1] & /*hasSubtitle*/ 2048) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block_51(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(t5.parentNode, t5);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}

  			if (/*hasText*/ ctx[43]) {
  				if (if_block4) {
  					if_block4.p(ctx, dirty);

  					if (dirty[1] & /*hasText*/ 4096) {
  						transition_in(if_block4, 1);
  					}
  				} else {
  					if_block4 = create_if_block_50(ctx);
  					if_block4.c();
  					transition_in(if_block4, 1);
  					if_block4.m(t6.parentNode, t6);
  				}
  			} else if (if_block4) {
  				group_outros();

  				transition_out(if_block4, 1, 1, () => {
  					if_block4 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_4), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_4));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block5) {
  					if_block5.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block5, 1);
  					}
  				} else {
  					if_block5 = create_if_block_49(ctx);
  					if_block5.c();
  					transition_in(if_block5, 1);
  					if_block5.m(t8.parentNode, t8);
  				}
  			} else if (if_block5) {
  				group_outros();

  				transition_out(if_block5, 1, 1, () => {
  					if_block5 = null;
  				});

  				check_outros();
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block6) {
  					if_block6.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block6, 1);
  					}
  				} else {
  					if_block6 = create_if_block_48(ctx);
  					if_block6.c();
  					transition_in(if_block6, 1);
  					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
  				}
  			} else if (if_block6) {
  				group_outros();

  				transition_out(if_block6, 1, 1, () => {
  					if_block6 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(before_title_slot, local);
  			transition_in(if_block1);
  			transition_in(after_title_slot, local);
  			transition_in(if_block2);
  			transition_in(if_block3);
  			transition_in(if_block4);
  			transition_in(inner_slot, local);
  			transition_in(if_block5);
  			transition_in(if_block6);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(before_title_slot, local);
  			transition_out(if_block1);
  			transition_out(after_title_slot, local);
  			transition_out(if_block2);
  			transition_out(if_block3);
  			transition_out(if_block4);
  			transition_out(inner_slot, local);
  			transition_out(if_block5);
  			transition_out(if_block6);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div);
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (if_block2) if_block2.d();
  			if (detaching) detach_dev(t4);
  			if (if_block3) if_block3.d(detaching);
  			if (detaching) detach_dev(t5);
  			if (if_block4) if_block4.d(detaching);
  			if (detaching) detach_dev(t6);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t7);
  			if (if_block5) if_block5.d(detaching);
  			if (detaching) detach_dev(t8);
  			if (if_block6) if_block6.d(detaching);
  			if (detaching) detach_dev(if_block6_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_47.name,
  		type: "if",
  		source: "(631:16) {#if isMedia}",
  		ctx
  	});

  	return block;
  }

  // (685:18) {#if (hasTitle || hasHeader || hasFooter)}
  function create_if_block_61(ctx) {
  	let div;
  	let t0;
  	let t1_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_63(ctx);
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_5);
  	let if_block1 = /*hasFooter*/ ctx[41] && create_if_block_62(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			t1 = text$1(t1_value);
  			t2 = space();
  			if (title_slot) title_slot.c();
  			t3 = space();
  			if (if_block1) if_block1.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 685, 20, 24760);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t0);
  			append_dev(div, t1);
  			append_dev(div, t2);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block1) if_block1.m(div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_63(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t1, t1_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_5), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_5));
  				}
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_62(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(title_slot, local);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(title_slot, local);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block0) if_block0.d();
  			if (title_slot) title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_61.name,
  		type: "if",
  		source: "(685:18) {#if (hasTitle || hasHeader || hasFooter)}",
  		ctx
  	});

  	return block;
  }

  // (687:22) {#if hasHeader}
  function create_if_block_63(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_5);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 687, 24, 24847);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_5), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_5));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_63.name,
  		type: "if",
  		source: "(687:22) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (695:22) {#if hasFooter}
  function create_if_block_62(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_5);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 695, 24, 25176);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_5), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_5));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_62.name,
  		type: "if",
  		source: "(695:22) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (704:18) {#if hasAfter}
  function create_if_block_58(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_5);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_60(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_59(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_5);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_5);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 704, 20, 25507);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_5), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_5));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_60(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_59(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_5), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_5));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_5), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_5));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_58.name,
  		type: "if",
  		source: "(704:18) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (707:22) {#if typeof after !== 'undefined'}
  function create_if_block_60(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 707, 24, 25663);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_60.name,
  		type: "if",
  		source: "(707:22) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (710:22) {#if typeof badge !== 'undefined'}
  function create_if_block_59(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_5] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_59.name,
  		type: "if",
  		source: "(710:22) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (711:24) <Badge color={badgeColor}>
  function create_default_slot_5(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_5.name,
  		type: "slot",
  		source: "(711:24) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (718:18) {#if !(swipeout || accordionItem)}
  function create_if_block_57(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_57.name,
  		type: "if",
  		source: "(718:18) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (632:18) {#if hasHeader}
  function create_if_block_56(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_4);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 632, 20, 22640);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_4), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_4));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_56.name,
  		type: "if",
  		source: "(632:18) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (640:20) {#if (hasTitle)}
  function create_if_block_55(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t0;
  	let t1;
  	let current;
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_4);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (title_slot) title_slot.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 640, 22, 22960);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_4), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_4));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(title_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(title_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (title_slot) title_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_55.name,
  		type: "if",
  		source: "(640:20) {#if (hasTitle)}",
  		ctx
  	});

  	return block;
  }

  // (647:20) {#if hasAfter}
  function create_if_block_52(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_4);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_54(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_53(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_4);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_4);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 647, 22, 23235);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_4), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_4));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_54(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_53(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_4), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_4));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_4), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_4));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_52.name,
  		type: "if",
  		source: "(647:20) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (650:24) {#if typeof after !== 'undefined'}
  function create_if_block_54(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 650, 26, 23397);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_54.name,
  		type: "if",
  		source: "(650:24) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (653:24) {#if typeof badge !== 'undefined'}
  function create_if_block_53(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_4] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_53.name,
  		type: "if",
  		source: "(653:24) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (654:26) <Badge color={badgeColor}>
  function create_default_slot_4(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_4.name,
  		type: "slot",
  		source: "(654:26) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (661:18) {#if hasSubtitle}
  function create_if_block_51(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "";
  	let t0;
  	let t1;
  	let current;
  	const subtitle_slot_template = /*$$slots*/ ctx[89].subtitle;
  	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_2);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (subtitle_slot) subtitle_slot.c();
  			attr_dev(div, "class", "item-subtitle");
  			add_location(div, file$a, 661, 20, 23861);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (subtitle_slot) {
  				subtitle_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

  			if (subtitle_slot) {
  				if (subtitle_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					subtitle_slot.p(get_slot_context(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_2), get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[103], dirty, get_subtitle_slot_changes_2));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(subtitle_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(subtitle_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (subtitle_slot) subtitle_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_51.name,
  		type: "if",
  		source: "(661:18) {#if hasSubtitle}",
  		ctx
  	});

  	return block;
  }

  // (667:18) {#if hasText}
  function create_if_block_50(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*text*/ ctx[3]) + "";
  	let t0;
  	let t1;
  	let current;
  	const text_slot_template = /*$$slots*/ ctx[89].text;
  	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_2);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (text_slot) text_slot.c();
  			attr_dev(div, "class", "item-text");
  			add_location(div, file$a, 667, 20, 24084);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (text_slot) {
  				text_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

  			if (text_slot) {
  				if (text_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					text_slot.p(get_slot_context(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_2), get_slot_changes(text_slot_template, /*$$scope*/ ctx[103], dirty, get_text_slot_changes_2));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(text_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(text_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (text_slot) text_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_50.name,
  		type: "if",
  		source: "(667:18) {#if hasText}",
  		ctx
  	});

  	return block;
  }

  // (674:18) {#if !(swipeout || accordionItem)}
  function create_if_block_49(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_49.name,
  		type: "if",
  		source: "(674:18) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (677:18) {#if hasFooter}
  function create_if_block_48(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_4);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 677, 20, 24443);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_4), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_4));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_48.name,
  		type: "if",
  		source: "(677:18) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (494:14) {#if isSortable && sortable !== false && isSortableOpposite}
  function create_if_block_46(ctx) {
  	let div;

  	const block = {
  		c: function create() {
  			div = element("div");
  			attr_dev(div, "class", "sortable-handler");
  			add_location(div, file$a, 494, 16, 17214);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_46.name,
  		type: "if",
  		source: "(494:14) {#if isSortable && sortable !== false && isSortableOpposite}",
  		ctx
  	});

  	return block;
  }

  // (509:14) {#if hasMedia}
  function create_if_block_44(ctx) {
  	let div;
  	let t;
  	let current;
  	let if_block = typeof /*media*/ ctx[4] !== "undefined" && create_if_block_45(ctx);
  	const media_slot_template = /*$$slots*/ ctx[89].media;
  	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_1);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block) if_block.c();
  			t = space();
  			if (media_slot) media_slot.c();
  			attr_dev(div, "class", "item-media");
  			add_location(div, file$a, 509, 16, 17783);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block) if_block.m(div, null);
  			append_dev(div, t);

  			if (media_slot) {
  				media_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (typeof /*media*/ ctx[4] !== "undefined") {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_45(ctx);
  					if_block.c();
  					if_block.m(div, t);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (media_slot) {
  				if (media_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					media_slot.p(get_slot_context(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context_1), get_slot_changes(media_slot_template, /*$$scope*/ ctx[103], dirty, get_media_slot_changes_1));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(media_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(media_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  			if (media_slot) media_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_44.name,
  		type: "if",
  		source: "(509:14) {#if hasMedia}",
  		ctx
  	});

  	return block;
  }

  // (511:18) {#if typeof media !== 'undefined'}
  function create_if_block_45(ctx) {
  	let img;
  	let img_src_value;

  	const block = {
  		c: function create() {
  			img = element("img");
  			if (img.src !== (img_src_value = /*media*/ ctx[4])) attr_dev(img, "src", img_src_value);
  			add_location(img, file$a, 511, 20, 17881);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, img, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*media*/ 16 && img.src !== (img_src_value = /*media*/ ctx[4])) {
  				attr_dev(img, "src", img_src_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(img);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_45.name,
  		type: "if",
  		source: "(511:18) {#if typeof media !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (571:16) {:else}
  function create_else_block_3(ctx) {
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let if_block2_anchor;
  	let current;
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_3);
  	let if_block0 = (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) && create_if_block_41(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_3);
  	let if_block1 = /*hasAfter*/ ctx[44] && create_if_block_38(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_3);
  	let if_block2 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_37(ctx);

  	const block = {
  		c: function create() {
  			if (before_title_slot) before_title_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (after_title_slot) after_title_slot.c();
  			t2 = space();
  			if (if_block1) if_block1.c();
  			t3 = space();
  			if (inner_slot) inner_slot.c();
  			t4 = space();
  			if (if_block2) if_block2.c();
  			if_block2_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if (before_title_slot) {
  				before_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t0, anchor);
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t1, anchor);

  			if (after_title_slot) {
  				after_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t2, anchor);
  			if (if_block1) if_block1.m(target, anchor);
  			insert_dev(target, t3, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t4, anchor);
  			if (if_block2) if_block2.m(target, anchor);
  			insert_dev(target, if_block2_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_3), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_3));
  				}
  			}

  			if (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 1792) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_41(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t1.parentNode, t1);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_3), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_3));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_38(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(t3.parentNode, t3);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_3), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_3));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_37(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_title_slot, local);
  			transition_in(if_block0);
  			transition_in(after_title_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_slot, local);
  			transition_in(if_block2);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_title_slot, local);
  			transition_out(if_block0);
  			transition_out(after_title_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_slot, local);
  			transition_out(if_block2);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t1);
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (detaching) detach_dev(t2);
  			if (if_block1) if_block1.d(detaching);
  			if (detaching) detach_dev(t3);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t4);
  			if (if_block2) if_block2.d(detaching);
  			if (detaching) detach_dev(if_block2_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_3.name,
  		type: "else",
  		source: "(571:16) {:else}",
  		ctx
  	});

  	return block;
  }

  // (519:16) {#if isMedia}
  function create_if_block_27(ctx) {
  	let t0;
  	let div;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let t5;
  	let t6;
  	let t7;
  	let t8;
  	let if_block6_anchor;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_36(ctx);
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_2);
  	let if_block1 = /*hasTitle*/ ctx[39] && create_if_block_35(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_2);
  	let if_block2 = /*hasAfter*/ ctx[44] && create_if_block_32(ctx);
  	let if_block3 = /*hasSubtitle*/ ctx[42] && create_if_block_31(ctx);
  	let if_block4 = /*hasText*/ ctx[43] && create_if_block_30(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_2);
  	let if_block5 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_29(ctx);
  	let if_block6 = /*hasFooter*/ ctx[41] && create_if_block_28(ctx);

  	const block = {
  		c: function create() {
  			if (if_block0) if_block0.c();
  			t0 = space();
  			div = element("div");
  			if (before_title_slot) before_title_slot.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_title_slot) after_title_slot.c();
  			t3 = space();
  			if (if_block2) if_block2.c();
  			t4 = space();
  			if (if_block3) if_block3.c();
  			t5 = space();
  			if (if_block4) if_block4.c();
  			t6 = space();
  			if (inner_slot) inner_slot.c();
  			t7 = space();
  			if (if_block5) if_block5.c();
  			t8 = space();
  			if (if_block6) if_block6.c();
  			if_block6_anchor = empty$1();
  			attr_dev(div, "class", "item-title-row");
  			add_location(div, file$a, 525, 18, 18378);
  		},
  		m: function mount(target, anchor) {
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div, anchor);

  			if (before_title_slot) {
  				before_title_slot.m(div, null);
  			}

  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_title_slot) {
  				after_title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block2) if_block2.m(div, null);
  			insert_dev(target, t4, anchor);
  			if (if_block3) if_block3.m(target, anchor);
  			insert_dev(target, t5, anchor);
  			if (if_block4) if_block4.m(target, anchor);
  			insert_dev(target, t6, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t7, anchor);
  			if (if_block5) if_block5.m(target, anchor);
  			insert_dev(target, t8, anchor);
  			if (if_block6) if_block6.m(target, anchor);
  			insert_dev(target, if_block6_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_36(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t0.parentNode, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_2), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_2));
  				}
  			}

  			if (/*hasTitle*/ ctx[39]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle*/ 256) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_35(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_2), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_2));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_32(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(div, null);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (/*hasSubtitle*/ ctx[42]) {
  				if (if_block3) {
  					if_block3.p(ctx, dirty);

  					if (dirty[1] & /*hasSubtitle*/ 2048) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block_31(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(t5.parentNode, t5);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}

  			if (/*hasText*/ ctx[43]) {
  				if (if_block4) {
  					if_block4.p(ctx, dirty);

  					if (dirty[1] & /*hasText*/ 4096) {
  						transition_in(if_block4, 1);
  					}
  				} else {
  					if_block4 = create_if_block_30(ctx);
  					if_block4.c();
  					transition_in(if_block4, 1);
  					if_block4.m(t6.parentNode, t6);
  				}
  			} else if (if_block4) {
  				group_outros();

  				transition_out(if_block4, 1, 1, () => {
  					if_block4 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_2), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_2));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block5) {
  					if_block5.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block5, 1);
  					}
  				} else {
  					if_block5 = create_if_block_29(ctx);
  					if_block5.c();
  					transition_in(if_block5, 1);
  					if_block5.m(t8.parentNode, t8);
  				}
  			} else if (if_block5) {
  				group_outros();

  				transition_out(if_block5, 1, 1, () => {
  					if_block5 = null;
  				});

  				check_outros();
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block6) {
  					if_block6.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block6, 1);
  					}
  				} else {
  					if_block6 = create_if_block_28(ctx);
  					if_block6.c();
  					transition_in(if_block6, 1);
  					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
  				}
  			} else if (if_block6) {
  				group_outros();

  				transition_out(if_block6, 1, 1, () => {
  					if_block6 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(before_title_slot, local);
  			transition_in(if_block1);
  			transition_in(after_title_slot, local);
  			transition_in(if_block2);
  			transition_in(if_block3);
  			transition_in(if_block4);
  			transition_in(inner_slot, local);
  			transition_in(if_block5);
  			transition_in(if_block6);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(before_title_slot, local);
  			transition_out(if_block1);
  			transition_out(after_title_slot, local);
  			transition_out(if_block2);
  			transition_out(if_block3);
  			transition_out(if_block4);
  			transition_out(inner_slot, local);
  			transition_out(if_block5);
  			transition_out(if_block6);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div);
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (if_block2) if_block2.d();
  			if (detaching) detach_dev(t4);
  			if (if_block3) if_block3.d(detaching);
  			if (detaching) detach_dev(t5);
  			if (if_block4) if_block4.d(detaching);
  			if (detaching) detach_dev(t6);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t7);
  			if (if_block5) if_block5.d(detaching);
  			if (detaching) detach_dev(t8);
  			if (if_block6) if_block6.d(detaching);
  			if (detaching) detach_dev(if_block6_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_27.name,
  		type: "if",
  		source: "(519:16) {#if isMedia}",
  		ctx
  	});

  	return block;
  }

  // (573:18) {#if (hasTitle || hasHeader || hasFooter)}
  function create_if_block_41(ctx) {
  	let div;
  	let t0;
  	let t1_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_43(ctx);
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_3);
  	let if_block1 = /*hasFooter*/ ctx[41] && create_if_block_42(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			t1 = text$1(t1_value);
  			t2 = space();
  			if (title_slot) title_slot.c();
  			t3 = space();
  			if (if_block1) if_block1.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 573, 20, 20315);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t0);
  			append_dev(div, t1);
  			append_dev(div, t2);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block1) if_block1.m(div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_43(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t1, t1_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_3), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_3));
  				}
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_42(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(title_slot, local);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(title_slot, local);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block0) if_block0.d();
  			if (title_slot) title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_41.name,
  		type: "if",
  		source: "(573:18) {#if (hasTitle || hasHeader || hasFooter)}",
  		ctx
  	});

  	return block;
  }

  // (575:22) {#if hasHeader}
  function create_if_block_43(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_3);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 575, 24, 20402);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_3), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_3));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_43.name,
  		type: "if",
  		source: "(575:22) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (583:22) {#if hasFooter}
  function create_if_block_42(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_3);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 583, 24, 20731);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_3), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_3));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_42.name,
  		type: "if",
  		source: "(583:22) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (592:18) {#if hasAfter}
  function create_if_block_38(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_3);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_40(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_39(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_3);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_3);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 592, 20, 21062);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_3), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_3));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_40(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_39(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_3), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_3));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_3), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_3));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_38.name,
  		type: "if",
  		source: "(592:18) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (595:22) {#if typeof after !== 'undefined'}
  function create_if_block_40(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 595, 24, 21218);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_40.name,
  		type: "if",
  		source: "(595:22) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (598:22) {#if typeof badge !== 'undefined'}
  function create_if_block_39(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_3] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_39.name,
  		type: "if",
  		source: "(598:22) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (599:24) <Badge color={badgeColor}>
  function create_default_slot_3(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_3.name,
  		type: "slot",
  		source: "(599:24) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (606:18) {#if !(swipeout || accordionItem)}
  function create_if_block_37(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_37.name,
  		type: "if",
  		source: "(606:18) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (520:18) {#if hasHeader}
  function create_if_block_36(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_2);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 520, 20, 18195);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_2), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_2));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_36.name,
  		type: "if",
  		source: "(520:18) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (528:20) {#if (hasTitle)}
  function create_if_block_35(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t0;
  	let t1;
  	let current;
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_2);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (title_slot) title_slot.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 528, 22, 18515);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_2), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_2));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(title_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(title_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (title_slot) title_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_35.name,
  		type: "if",
  		source: "(528:20) {#if (hasTitle)}",
  		ctx
  	});

  	return block;
  }

  // (535:20) {#if hasAfter}
  function create_if_block_32(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_2);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_34(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_33(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_2);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_2);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 535, 22, 18790);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_2), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_2));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_34(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_33(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_2), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_2));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_2), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_2));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_32.name,
  		type: "if",
  		source: "(535:20) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (538:24) {#if typeof after !== 'undefined'}
  function create_if_block_34(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 538, 26, 18952);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_34.name,
  		type: "if",
  		source: "(538:24) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (541:24) {#if typeof badge !== 'undefined'}
  function create_if_block_33(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_2$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_33.name,
  		type: "if",
  		source: "(541:24) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (542:26) <Badge color={badgeColor}>
  function create_default_slot_2$1(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_2$1.name,
  		type: "slot",
  		source: "(542:26) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (549:18) {#if hasSubtitle}
  function create_if_block_31(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "";
  	let t0;
  	let t1;
  	let current;
  	const subtitle_slot_template = /*$$slots*/ ctx[89].subtitle;
  	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_1);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (subtitle_slot) subtitle_slot.c();
  			attr_dev(div, "class", "item-subtitle");
  			add_location(div, file$a, 549, 20, 19416);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (subtitle_slot) {
  				subtitle_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

  			if (subtitle_slot) {
  				if (subtitle_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					subtitle_slot.p(get_slot_context(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context_1), get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[103], dirty, get_subtitle_slot_changes_1));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(subtitle_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(subtitle_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (subtitle_slot) subtitle_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_31.name,
  		type: "if",
  		source: "(549:18) {#if hasSubtitle}",
  		ctx
  	});

  	return block;
  }

  // (555:18) {#if hasText}
  function create_if_block_30(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*text*/ ctx[3]) + "";
  	let t0;
  	let t1;
  	let current;
  	const text_slot_template = /*$$slots*/ ctx[89].text;
  	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_1);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (text_slot) text_slot.c();
  			attr_dev(div, "class", "item-text");
  			add_location(div, file$a, 555, 20, 19639);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (text_slot) {
  				text_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

  			if (text_slot) {
  				if (text_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					text_slot.p(get_slot_context(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context_1), get_slot_changes(text_slot_template, /*$$scope*/ ctx[103], dirty, get_text_slot_changes_1));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(text_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(text_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (text_slot) text_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_30.name,
  		type: "if",
  		source: "(555:18) {#if hasText}",
  		ctx
  	});

  	return block;
  }

  // (562:18) {#if !(swipeout || accordionItem)}
  function create_if_block_29(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_29.name,
  		type: "if",
  		source: "(562:18) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (565:18) {#if hasFooter}
  function create_if_block_28(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_2);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 565, 20, 19998);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_2), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_2));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_28.name,
  		type: "if",
  		source: "(565:18) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (378:14) {#if isSortable && sortable !== false && isSortableOpposite}
  function create_if_block_25(ctx) {
  	let div;

  	const block = {
  		c: function create() {
  			div = element("div");
  			attr_dev(div, "class", "sortable-handler");
  			add_location(div, file$a, 378, 16, 12646);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_25.name,
  		type: "if",
  		source: "(378:14) {#if isSortable && sortable !== false && isSortableOpposite}",
  		ctx
  	});

  	return block;
  }

  // (381:14) {#if hasMedia}
  function create_if_block_23(ctx) {
  	let div;
  	let t;
  	let current;
  	let if_block = typeof /*media*/ ctx[4] !== "undefined" && create_if_block_24(ctx);
  	const media_slot_template = /*$$slots*/ ctx[89].media;
  	const media_slot = create_slot(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block) if_block.c();
  			t = space();
  			if (media_slot) media_slot.c();
  			attr_dev(div, "class", "item-media");
  			add_location(div, file$a, 381, 16, 12744);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block) if_block.m(div, null);
  			append_dev(div, t);

  			if (media_slot) {
  				media_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (typeof /*media*/ ctx[4] !== "undefined") {
  				if (if_block) {
  					if_block.p(ctx, dirty);
  				} else {
  					if_block = create_if_block_24(ctx);
  					if_block.c();
  					if_block.m(div, t);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (media_slot) {
  				if (media_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					media_slot.p(get_slot_context(media_slot_template, ctx, /*$$scope*/ ctx[103], get_media_slot_context), get_slot_changes(media_slot_template, /*$$scope*/ ctx[103], dirty, get_media_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(media_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(media_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  			if (media_slot) media_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_23.name,
  		type: "if",
  		source: "(381:14) {#if hasMedia}",
  		ctx
  	});

  	return block;
  }

  // (383:18) {#if typeof media !== 'undefined'}
  function create_if_block_24(ctx) {
  	let img;
  	let img_src_value;

  	const block = {
  		c: function create() {
  			img = element("img");
  			if (img.src !== (img_src_value = /*media*/ ctx[4])) attr_dev(img, "src", img_src_value);
  			add_location(img, file$a, 383, 20, 12842);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, img, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*media*/ 16 && img.src !== (img_src_value = /*media*/ ctx[4])) {
  				attr_dev(img, "src", img_src_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(img);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_24.name,
  		type: "if",
  		source: "(383:18) {#if typeof media !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (443:16) {:else}
  function create_else_block_1(ctx) {
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let if_block2_anchor;
  	let current;
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_1);
  	let if_block0 = (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) && create_if_block_20(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_1);
  	let if_block1 = /*hasAfter*/ ctx[44] && create_if_block_17(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_1);
  	let if_block2 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_16(ctx);

  	const block = {
  		c: function create() {
  			if (before_title_slot) before_title_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (after_title_slot) after_title_slot.c();
  			t2 = space();
  			if (if_block1) if_block1.c();
  			t3 = space();
  			if (inner_slot) inner_slot.c();
  			t4 = space();
  			if (if_block2) if_block2.c();
  			if_block2_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if (before_title_slot) {
  				before_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t0, anchor);
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t1, anchor);

  			if (after_title_slot) {
  				after_title_slot.m(target, anchor);
  			}

  			insert_dev(target, t2, anchor);
  			if (if_block1) if_block1.m(target, anchor);
  			insert_dev(target, t3, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t4, anchor);
  			if (if_block2) if_block2.m(target, anchor);
  			insert_dev(target, if_block2_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context_1), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes_1));
  				}
  			}

  			if (/*hasTitle*/ ctx[39] || /*hasHeader*/ ctx[40] || /*hasFooter*/ ctx[41]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle, hasHeader, hasFooter*/ 1792) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_20(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t1.parentNode, t1);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context_1), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes_1));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_17(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(t3.parentNode, t3);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context_1), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes_1));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_16(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(if_block2_anchor.parentNode, if_block2_anchor);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_title_slot, local);
  			transition_in(if_block0);
  			transition_in(after_title_slot, local);
  			transition_in(if_block1);
  			transition_in(inner_slot, local);
  			transition_in(if_block2);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_title_slot, local);
  			transition_out(if_block0);
  			transition_out(after_title_slot, local);
  			transition_out(if_block1);
  			transition_out(inner_slot, local);
  			transition_out(if_block2);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t1);
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (detaching) detach_dev(t2);
  			if (if_block1) if_block1.d(detaching);
  			if (detaching) detach_dev(t3);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t4);
  			if (if_block2) if_block2.d(detaching);
  			if (detaching) detach_dev(if_block2_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_1.name,
  		type: "else",
  		source: "(443:16) {:else}",
  		ctx
  	});

  	return block;
  }

  // (391:16) {#if isMedia}
  function create_if_block_6(ctx) {
  	let t0;
  	let div;
  	let t1;
  	let t2;
  	let t3;
  	let t4;
  	let t5;
  	let t6;
  	let t7;
  	let t8;
  	let if_block6_anchor;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_15(ctx);
  	const before_title_slot_template = /*$$slots*/ ctx[89]["before-title"];
  	const before_title_slot = create_slot(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context);
  	let if_block1 = /*hasTitle*/ ctx[39] && create_if_block_14(ctx);
  	const after_title_slot_template = /*$$slots*/ ctx[89]["after-title"];
  	const after_title_slot = create_slot(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context);
  	let if_block2 = /*hasAfter*/ ctx[44] && create_if_block_11(ctx);
  	let if_block3 = /*hasSubtitle*/ ctx[42] && create_if_block_10(ctx);
  	let if_block4 = /*hasText*/ ctx[43] && create_if_block_9(ctx);
  	const inner_slot_template = /*$$slots*/ ctx[89].inner;
  	const inner_slot = create_slot(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context);
  	let if_block5 = !(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15]) && create_if_block_8(ctx);
  	let if_block6 = /*hasFooter*/ ctx[41] && create_if_block_7(ctx);

  	const block = {
  		c: function create() {
  			if (if_block0) if_block0.c();
  			t0 = space();
  			div = element("div");
  			if (before_title_slot) before_title_slot.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_title_slot) after_title_slot.c();
  			t3 = space();
  			if (if_block2) if_block2.c();
  			t4 = space();
  			if (if_block3) if_block3.c();
  			t5 = space();
  			if (if_block4) if_block4.c();
  			t6 = space();
  			if (inner_slot) inner_slot.c();
  			t7 = space();
  			if (if_block5) if_block5.c();
  			t8 = space();
  			if (if_block6) if_block6.c();
  			if_block6_anchor = empty$1();
  			attr_dev(div, "class", "item-title-row");
  			add_location(div, file$a, 397, 18, 13339);
  		},
  		m: function mount(target, anchor) {
  			if (if_block0) if_block0.m(target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, div, anchor);

  			if (before_title_slot) {
  				before_title_slot.m(div, null);
  			}

  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_title_slot) {
  				after_title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block2) if_block2.m(div, null);
  			insert_dev(target, t4, anchor);
  			if (if_block3) if_block3.m(target, anchor);
  			insert_dev(target, t5, anchor);
  			if (if_block4) if_block4.m(target, anchor);
  			insert_dev(target, t6, anchor);

  			if (inner_slot) {
  				inner_slot.m(target, anchor);
  			}

  			insert_dev(target, t7, anchor);
  			if (if_block5) if_block5.m(target, anchor);
  			insert_dev(target, t8, anchor);
  			if (if_block6) if_block6.m(target, anchor);
  			insert_dev(target, if_block6_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_15(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(t0.parentNode, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (before_title_slot) {
  				if (before_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					before_title_slot.p(get_slot_context(before_title_slot_template, ctx, /*$$scope*/ ctx[103], get_before_title_slot_context), get_slot_changes(before_title_slot_template, /*$$scope*/ ctx[103], dirty, get_before_title_slot_changes));
  				}
  			}

  			if (/*hasTitle*/ ctx[39]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasTitle*/ 256) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_14(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_title_slot) {
  				if (after_title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_title_slot.p(get_slot_context(after_title_slot_template, ctx, /*$$scope*/ ctx[103], get_after_title_slot_context), get_slot_changes(after_title_slot_template, /*$$scope*/ ctx[103], dirty, get_after_title_slot_changes));
  				}
  			}

  			if (/*hasAfter*/ ctx[44]) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[1] & /*hasAfter*/ 8192) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_11(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(div, null);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (/*hasSubtitle*/ ctx[42]) {
  				if (if_block3) {
  					if_block3.p(ctx, dirty);

  					if (dirty[1] & /*hasSubtitle*/ 2048) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block_10(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(t5.parentNode, t5);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}

  			if (/*hasText*/ ctx[43]) {
  				if (if_block4) {
  					if_block4.p(ctx, dirty);

  					if (dirty[1] & /*hasText*/ 4096) {
  						transition_in(if_block4, 1);
  					}
  				} else {
  					if_block4 = create_if_block_9(ctx);
  					if_block4.c();
  					transition_in(if_block4, 1);
  					if_block4.m(t6.parentNode, t6);
  				}
  			} else if (if_block4) {
  				group_outros();

  				transition_out(if_block4, 1, 1, () => {
  					if_block4 = null;
  				});

  				check_outros();
  			}

  			if (inner_slot) {
  				if (inner_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					inner_slot.p(get_slot_context(inner_slot_template, ctx, /*$$scope*/ ctx[103], get_inner_slot_context), get_slot_changes(inner_slot_template, /*$$scope*/ ctx[103], dirty, get_inner_slot_changes));
  				}
  			}

  			if (!(/*swipeout*/ ctx[13] || /*accordionItem*/ ctx[15])) {
  				if (if_block5) {
  					if_block5.p(ctx, dirty);

  					if (dirty[0] & /*swipeout, accordionItem*/ 40960) {
  						transition_in(if_block5, 1);
  					}
  				} else {
  					if_block5 = create_if_block_8(ctx);
  					if_block5.c();
  					transition_in(if_block5, 1);
  					if_block5.m(t8.parentNode, t8);
  				}
  			} else if (if_block5) {
  				group_outros();

  				transition_out(if_block5, 1, 1, () => {
  					if_block5 = null;
  				});

  				check_outros();
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block6) {
  					if_block6.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block6, 1);
  					}
  				} else {
  					if_block6 = create_if_block_7(ctx);
  					if_block6.c();
  					transition_in(if_block6, 1);
  					if_block6.m(if_block6_anchor.parentNode, if_block6_anchor);
  				}
  			} else if (if_block6) {
  				group_outros();

  				transition_out(if_block6, 1, 1, () => {
  					if_block6 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(before_title_slot, local);
  			transition_in(if_block1);
  			transition_in(after_title_slot, local);
  			transition_in(if_block2);
  			transition_in(if_block3);
  			transition_in(if_block4);
  			transition_in(inner_slot, local);
  			transition_in(if_block5);
  			transition_in(if_block6);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(before_title_slot, local);
  			transition_out(if_block1);
  			transition_out(after_title_slot, local);
  			transition_out(if_block2);
  			transition_out(if_block3);
  			transition_out(if_block4);
  			transition_out(inner_slot, local);
  			transition_out(if_block5);
  			transition_out(if_block6);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block0) if_block0.d(detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(div);
  			if (before_title_slot) before_title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  			if (after_title_slot) after_title_slot.d(detaching);
  			if (if_block2) if_block2.d();
  			if (detaching) detach_dev(t4);
  			if (if_block3) if_block3.d(detaching);
  			if (detaching) detach_dev(t5);
  			if (if_block4) if_block4.d(detaching);
  			if (detaching) detach_dev(t6);
  			if (inner_slot) inner_slot.d(detaching);
  			if (detaching) detach_dev(t7);
  			if (if_block5) if_block5.d(detaching);
  			if (detaching) detach_dev(t8);
  			if (if_block6) if_block6.d(detaching);
  			if (detaching) detach_dev(if_block6_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_6.name,
  		type: "if",
  		source: "(391:16) {#if isMedia}",
  		ctx
  	});

  	return block;
  }

  // (445:18) {#if (hasTitle || hasHeader || hasFooter)}
  function create_if_block_20(ctx) {
  	let div;
  	let t0;
  	let t1_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	let if_block0 = /*hasHeader*/ ctx[40] && create_if_block_22(ctx);
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_1);
  	let if_block1 = /*hasFooter*/ ctx[41] && create_if_block_21(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			t1 = text$1(t1_value);
  			t2 = space();
  			if (title_slot) title_slot.c();
  			t3 = space();
  			if (if_block1) if_block1.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 445, 20, 15276);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t0);
  			append_dev(div, t1);
  			append_dev(div, t2);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			append_dev(div, t3);
  			if (if_block1) if_block1.m(div, null);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*hasHeader*/ ctx[40]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[1] & /*hasHeader*/ 512) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_22(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if ((!current || dirty[0] & /*title*/ 4) && t1_value !== (t1_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t1, t1_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context_1), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes_1));
  				}
  			}

  			if (/*hasFooter*/ ctx[41]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[1] & /*hasFooter*/ 1024) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_21(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, null);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(title_slot, local);
  			transition_in(if_block1);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(title_slot, local);
  			transition_out(if_block1);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block0) if_block0.d();
  			if (title_slot) title_slot.d(detaching);
  			if (if_block1) if_block1.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_20.name,
  		type: "if",
  		source: "(445:18) {#if (hasTitle || hasHeader || hasFooter)}",
  		ctx
  	});

  	return block;
  }

  // (447:22) {#if hasHeader}
  function create_if_block_22(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_1);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 447, 24, 15363);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context_1), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes_1));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_22.name,
  		type: "if",
  		source: "(447:22) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (455:22) {#if hasFooter}
  function create_if_block_21(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_1);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 455, 24, 15692);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context_1), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes_1));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_21.name,
  		type: "if",
  		source: "(455:22) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (464:18) {#if hasAfter}
  function create_if_block_17(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_1);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_19(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_18(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_1);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_1);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 464, 20, 16023);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context_1), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes_1));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_19(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_18(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context_1), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes_1));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context_1), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes_1));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_17.name,
  		type: "if",
  		source: "(464:18) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (467:22) {#if typeof after !== 'undefined'}
  function create_if_block_19(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 467, 24, 16179);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_19.name,
  		type: "if",
  		source: "(467:22) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (470:22) {#if typeof badge !== 'undefined'}
  function create_if_block_18(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot_1$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_18.name,
  		type: "if",
  		source: "(470:22) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (471:24) <Badge color={badgeColor}>
  function create_default_slot_1$1(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1$1.name,
  		type: "slot",
  		source: "(471:24) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (478:18) {#if !(swipeout || accordionItem)}
  function create_if_block_16(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_16.name,
  		type: "if",
  		source: "(478:18) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (392:18) {#if hasHeader}
  function create_if_block_15(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*header*/ ctx[6]) + "";
  	let t0;
  	let t1;
  	let current;
  	const header_slot_template = /*$$slots*/ ctx[89].header;
  	const header_slot = create_slot(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (header_slot) header_slot.c();
  			attr_dev(div, "class", "item-header");
  			add_location(div, file$a, 392, 20, 13156);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (header_slot) {
  				header_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*header*/ 64) && t0_value !== (t0_value = Utils$1.text(/*header*/ ctx[6]) + "")) set_data_dev(t0, t0_value);

  			if (header_slot) {
  				if (header_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					header_slot.p(get_slot_context(header_slot_template, ctx, /*$$scope*/ ctx[103], get_header_slot_context), get_slot_changes(header_slot_template, /*$$scope*/ ctx[103], dirty, get_header_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(header_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(header_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (header_slot) header_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_15.name,
  		type: "if",
  		source: "(392:18) {#if hasHeader}",
  		ctx
  	});

  	return block;
  }

  // (400:20) {#if (hasTitle)}
  function create_if_block_14(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t0;
  	let t1;
  	let current;
  	const title_slot_template = /*$$slots*/ ctx[89].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (title_slot) title_slot.c();
  			attr_dev(div, "class", "item-title");
  			add_location(div, file$a, 400, 22, 13476);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (title_slot) {
  				title_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*title*/ 4) && t0_value !== (t0_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t0, t0_value);

  			if (title_slot) {
  				if (title_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[103], get_title_slot_context), get_slot_changes(title_slot_template, /*$$scope*/ ctx[103], dirty, get_title_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(title_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(title_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (title_slot) title_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_14.name,
  		type: "if",
  		source: "(400:20) {#if (hasTitle)}",
  		ctx
  	});

  	return block;
  }

  // (407:20) {#if hasAfter}
  function create_if_block_11(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let current;
  	const after_start_slot_template = /*$$slots*/ ctx[89]["after-start"];
  	const after_start_slot = create_slot(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context);
  	let if_block0 = typeof /*after*/ ctx[8] !== "undefined" && create_if_block_13(ctx);
  	let if_block1 = typeof /*badge*/ ctx[9] !== "undefined" && create_if_block_12(ctx);
  	const after_slot_template = /*$$slots*/ ctx[89].after;
  	const after_slot = create_slot(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context);
  	const after_end_slot_template = /*$$slots*/ ctx[89]["after-end"];
  	const after_end_slot = create_slot(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (after_start_slot) after_start_slot.c();
  			t0 = space();
  			if (if_block0) if_block0.c();
  			t1 = space();
  			if (if_block1) if_block1.c();
  			t2 = space();
  			if (after_slot) after_slot.c();
  			t3 = space();
  			if (after_end_slot) after_end_slot.c();
  			attr_dev(div, "class", "item-after");
  			add_location(div, file$a, 407, 22, 13751);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (after_start_slot) {
  				after_start_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t1);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t2);

  			if (after_slot) {
  				after_slot.m(div, null);
  			}

  			append_dev(div, t3);

  			if (after_end_slot) {
  				after_end_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (after_start_slot) {
  				if (after_start_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_start_slot.p(get_slot_context(after_start_slot_template, ctx, /*$$scope*/ ctx[103], get_after_start_slot_context), get_slot_changes(after_start_slot_template, /*$$scope*/ ctx[103], dirty, get_after_start_slot_changes));
  				}
  			}

  			if (typeof /*after*/ ctx[8] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_13(ctx);
  					if_block0.c();
  					if_block0.m(div, t1);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*badge*/ ctx[9] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*badge*/ 512) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_12(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t2);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (after_slot) {
  				if (after_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_slot.p(get_slot_context(after_slot_template, ctx, /*$$scope*/ ctx[103], get_after_slot_context), get_slot_changes(after_slot_template, /*$$scope*/ ctx[103], dirty, get_after_slot_changes));
  				}
  			}

  			if (after_end_slot) {
  				if (after_end_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					after_end_slot.p(get_slot_context(after_end_slot_template, ctx, /*$$scope*/ ctx[103], get_after_end_slot_context), get_slot_changes(after_end_slot_template, /*$$scope*/ ctx[103], dirty, get_after_end_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(after_start_slot, local);
  			transition_in(if_block1);
  			transition_in(after_slot, local);
  			transition_in(after_end_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(after_start_slot, local);
  			transition_out(if_block1);
  			transition_out(after_slot, local);
  			transition_out(after_end_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (after_start_slot) after_start_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (after_slot) after_slot.d(detaching);
  			if (after_end_slot) after_end_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_11.name,
  		type: "if",
  		source: "(407:20) {#if hasAfter}",
  		ctx
  	});

  	return block;
  }

  // (410:24) {#if typeof after !== 'undefined'}
  function create_if_block_13(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*after*/ ctx[8]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			add_location(span, file$a, 410, 26, 13913);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*after*/ 256 && t_value !== (t_value = Utils$1.text(/*after*/ ctx[8]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_13.name,
  		type: "if",
  		source: "(410:24) {#if typeof after !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (413:24) {#if typeof badge !== 'undefined'}
  function create_if_block_12(ctx) {
  	let current;

  	const badge_1 = new Badge({
  			props: {
  				color: /*badgeColor*/ ctx[10],
  				$$slots: { default: [create_default_slot$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(badge_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(badge_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const badge_1_changes = {};
  			if (dirty[0] & /*badgeColor*/ 1024) badge_1_changes.color = /*badgeColor*/ ctx[10];

  			if (dirty[0] & /*badge*/ 512 | dirty[3] & /*$$scope*/ 1024) {
  				badge_1_changes.$$scope = { dirty, ctx };
  			}

  			badge_1.$set(badge_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(badge_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(badge_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(badge_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_12.name,
  		type: "if",
  		source: "(413:24) {#if typeof badge !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (414:26) <Badge color={badgeColor}>
  function create_default_slot$1(ctx) {
  	let t_value = Utils$1.text(/*badge*/ ctx[9]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*badge*/ 512 && t_value !== (t_value = Utils$1.text(/*badge*/ ctx[9]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$1.name,
  		type: "slot",
  		source: "(414:26) <Badge color={badgeColor}>",
  		ctx
  	});

  	return block;
  }

  // (421:18) {#if hasSubtitle}
  function create_if_block_10(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "";
  	let t0;
  	let t1;
  	let current;
  	const subtitle_slot_template = /*$$slots*/ ctx[89].subtitle;
  	const subtitle_slot = create_slot(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (subtitle_slot) subtitle_slot.c();
  			attr_dev(div, "class", "item-subtitle");
  			add_location(div, file$a, 421, 20, 14377);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (subtitle_slot) {
  				subtitle_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*subtitle*/ 32) && t0_value !== (t0_value = Utils$1.text(/*subtitle*/ ctx[5]) + "")) set_data_dev(t0, t0_value);

  			if (subtitle_slot) {
  				if (subtitle_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					subtitle_slot.p(get_slot_context(subtitle_slot_template, ctx, /*$$scope*/ ctx[103], get_subtitle_slot_context), get_slot_changes(subtitle_slot_template, /*$$scope*/ ctx[103], dirty, get_subtitle_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(subtitle_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(subtitle_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (subtitle_slot) subtitle_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_10.name,
  		type: "if",
  		source: "(421:18) {#if hasSubtitle}",
  		ctx
  	});

  	return block;
  }

  // (427:18) {#if hasText}
  function create_if_block_9(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*text*/ ctx[3]) + "";
  	let t0;
  	let t1;
  	let current;
  	const text_slot_template = /*$$slots*/ ctx[89].text;
  	const text_slot = create_slot(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (text_slot) text_slot.c();
  			attr_dev(div, "class", "item-text");
  			add_location(div, file$a, 427, 20, 14600);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (text_slot) {
  				text_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*text*/ 8) && t0_value !== (t0_value = Utils$1.text(/*text*/ ctx[3]) + "")) set_data_dev(t0, t0_value);

  			if (text_slot) {
  				if (text_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					text_slot.p(get_slot_context(text_slot_template, ctx, /*$$scope*/ ctx[103], get_text_slot_context), get_slot_changes(text_slot_template, /*$$scope*/ ctx[103], dirty, get_text_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(text_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(text_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (text_slot) text_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_9.name,
  		type: "if",
  		source: "(427:18) {#if hasText}",
  		ctx
  	});

  	return block;
  }

  // (434:18) {#if !(swipeout || accordionItem)}
  function create_if_block_8(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_8.name,
  		type: "if",
  		source: "(434:18) {#if !(swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (437:18) {#if hasFooter}
  function create_if_block_7(ctx) {
  	let div;
  	let t0_value = Utils$1.text(/*footer*/ ctx[7]) + "";
  	let t0;
  	let t1;
  	let current;
  	const footer_slot_template = /*$$slots*/ ctx[89].footer;
  	const footer_slot = create_slot(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context);

  	const block = {
  		c: function create() {
  			div = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (footer_slot) footer_slot.c();
  			attr_dev(div, "class", "item-footer");
  			add_location(div, file$a, 437, 20, 14959);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			append_dev(div, t0);
  			append_dev(div, t1);

  			if (footer_slot) {
  				footer_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*footer*/ 128) && t0_value !== (t0_value = Utils$1.text(/*footer*/ ctx[7]) + "")) set_data_dev(t0, t0_value);

  			if (footer_slot) {
  				if (footer_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					footer_slot.p(get_slot_context(footer_slot_template, ctx, /*$$scope*/ ctx[103], get_footer_slot_context), get_slot_changes(footer_slot_template, /*$$scope*/ ctx[103], dirty, get_footer_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(footer_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(footer_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (footer_slot) footer_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_7.name,
  		type: "if",
  		source: "(437:18) {#if hasFooter}",
  		ctx
  	});

  	return block;
  }

  // (1090:4) {#if (isSortable && sortable !== false && !isSortableOpposite)}
  function create_if_block_3$3(ctx) {
  	let div;

  	const block = {
  		c: function create() {
  			div = element("div");
  			attr_dev(div, "class", "sortable-handler");
  			add_location(div, file$a, 1090, 6, 39925);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$3.name,
  		type: "if",
  		source: "(1090:4) {#if (isSortable && sortable !== false && !isSortableOpposite)}",
  		ctx
  	});

  	return block;
  }

  // (1093:4) {#if (swipeout || accordionItem)}
  function create_if_block_2$3(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[89].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[103], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[3] & /*$$scope*/ 1024) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[103], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[103], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$3.name,
  		type: "if",
  		source: "(1093:4) {#if (swipeout || accordionItem)}",
  		ctx
  	});

  	return block;
  }

  // (361:16) {Utils.text(title)}
  function fallback_block(ctx) {
  	let t_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty[0] & /*title*/ 4 && t_value !== (t_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: fallback_block.name,
  		type: "fallback",
  		source: "(361:16) {Utils.text(title)}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$a(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block$3, create_if_block_1$3, create_else_block$1];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*divider*/ ctx[11] || /*groupTitle*/ ctx[12]) return 0;
  		if (/*isSimple*/ ctx[32]) return 1;
  		return 2;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			if_block.c();
  			if_block_anchor = empty$1();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$a.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$a($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { title = undefined } = $$props;
  	let { text = undefined } = $$props;
  	let { media = undefined } = $$props;
  	let { subtitle = undefined } = $$props;
  	let { header = undefined } = $$props;
  	let { footer = undefined } = $$props;
  	let { tooltip = undefined } = $$props;
  	let { tooltipTrigger = undefined } = $$props;
  	let { link = undefined } = $$props;
  	let { tabLink = undefined } = $$props;
  	let { tabLinkActive = false } = $$props;
  	let { href = undefined } = $$props;
  	let { target = undefined } = $$props;
  	let { after = undefined } = $$props;
  	let { badge = undefined } = $$props;
  	let { badgeColor = undefined } = $$props;
  	let { mediaItem = false } = $$props;
  	let { mediaList = false } = $$props;
  	let { divider = false } = $$props;
  	let { groupTitle = false } = $$props;
  	let { swipeout = false } = $$props;
  	let { swipeoutOpened = false } = $$props;
  	let { sortable = undefined } = $$props;
  	let { sortableOpposite = undefined } = $$props;
  	let { accordionItem = false } = $$props;
  	let { accordionItemOpened = false } = $$props;
  	let { smartSelect = false } = $$props;
  	let { smartSelectParams = undefined } = $$props;
  	let { noChevron = undefined } = $$props;
  	let { chevronCenter = undefined } = $$props;
  	let { checkbox = undefined } = $$props;
  	let { radio = undefined } = $$props;
  	let { radioIcon = undefined } = $$props;
  	let { checked = undefined } = $$props;
  	let { indeterminate = undefined } = $$props;
  	let { name = undefined } = $$props;
  	let { value = undefined } = $$props;
  	let { readonly = undefined } = $$props;
  	let { required = undefined } = $$props;
  	let { disabled = undefined } = $$props;
  	let { virtualListIndex = undefined } = $$props;
  	let el;
  	let linkEl;
  	let innerEl;
  	let inputEl;
  	let f7SmartSelect;
  	let f7Tooltip;

  	/* eslint-enable no-undef */
  	let tooltipText = tooltip;

  	function watchTooltip(newText) {
  		const oldText = tooltipText;
  		if (oldText === newText) return;
  		tooltipText = newText;

  		if (!newText && f7Tooltip) {
  			f7Tooltip.destroy();
  			f7Tooltip = null;
  			return;
  		}

  		if (newText && !f7Tooltip && f7.instance) {
  			f7Tooltip = f7.instance.tooltip.create({
  				targetEl: el,
  				text: newText,
  				trigger: tooltipTrigger
  			});

  			return;
  		}

  		if (!newText || !f7Tooltip) return;
  		f7Tooltip.setText(newText);
  	}

  	let initialWatchedOpened = false;

  	function watchSwipeoutOpened(opened) {
  		if (!initialWatchedOpened) {
  			initialWatchedOpened = true;
  			return;
  		}

  		if (!swipeout) return;

  		if (opened) {
  			f7.instance.swipeout.open(el);
  		} else {
  			f7.instance.swipeout.close(el);
  		}
  	}

  	function onClick(event) {
  		if (event.target.tagName.toLowerCase() !== "input") {
  			dispatch("click", event);
  			if (typeof $$props.onClick === "function") $$props.onClick(event);
  		}
  	}

  	function onSwipeoutOverswipeEnter(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("swipeoutOverswipeEnter");
  		if (typeof $$props.onSwipeoutOverswipeEnter === "function") $$props.onSwipeoutOverswipeEnter();
  	}

  	function onSwipeoutOverswipeExit(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("swipeoutOverswipeExit");
  		if (typeof $$props.onSwipeoutOverswipeExit === "function") $$props.onSwipeoutOverswipeExit();
  	}

  	function onSwipeoutDeleted(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("swipeoutDeleted");
  		if (typeof $$props.onSwipeoutDeleted === "function") $$props.onSwipeoutDeleted();
  	}

  	function onSwipeoutDelete(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("swipeoutDelete");
  		if (typeof $$props.onSwipeoutDelete === "function") $$props.onSwipeoutDelete();
  	}

  	function onSwipeoutClose(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("swipeoutClose");
  		if (typeof $$props.onSwipeoutClose === "function") $$props.onSwipeoutClose();
  	}

  	function onSwipeoutClosed(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("swipeoutClosed");
  		if (typeof $$props.onSwipeoutClosed === "function") $$props.onSwipeoutClosed();
  	}

  	function onSwipeoutOpen(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("swipeoutOpen");
  		if (typeof $$props.onSwipeoutOpen === "function") $$props.onSwipeoutOpen();
  	}

  	function onSwipeoutOpened(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("swipeoutOpened");
  		if (typeof $$props.onSwipeoutOpened === "function") $$props.onSwipeoutOpened();
  	}

  	function onSwipeout(eventEl, progress) {
  		if (eventEl !== el) return;
  		dispatch("swipeout", progress);
  	}

  	function onAccBeforeClose(eventEl, prevent) {
  		if (eventEl !== el) return;
  		dispatch("accordionBeforeClose", [prevent]);
  		if (typeof $$props.onAccordionBeforeClose === "function") $$props.onAccordionBeforeClose(prevent);
  	}

  	function onAccClose(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("accordionClose");
  		if (typeof $$props.onAccordionClose === "function") $$props.onAccordionClose();
  	}

  	function onAccClosed(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("accordionClosed");
  		if (typeof $$props.onAccordionClosed === "function") $$props.onAccordionClosed();
  	}

  	function onAccBeforeOpen(eventEl, prevent) {
  		if (eventEl !== el) return;
  		dispatch("accordionBeforeOpen", [prevent]);
  		if (typeof $$props.onAccordionBeforeOpen === "function") $$props.onAccordionBeforeOpen(prevent);
  	}

  	function onAccOpen(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("accordionOpen");
  		if (typeof $$props.onAccordionOpen === "function") $$props.onAccordionOpen();
  	}

  	function onAccOpened(eventEl) {
  		if (eventEl !== el) return;
  		dispatch("accordionOpened");
  		if (typeof $$props.onAccordionOpened === "function") $$props.onAccordionOpened();
  	}

  	function onChange(event) {
  		dispatch("change", [event]);
  		if (typeof $$props.onChange === "function") $$props.onChange(event);
  	}

  	onMount(() => {
  		if (linkEl && $$props.routeProps) {
  			$$invalidate(26, linkEl.f7RouteProps = $$props.routeProps, linkEl);
  		}

  		if (indeterminate && inputEl) {
  			$$invalidate(28, inputEl.indeterminate = true, inputEl);
  		}

  		f7.ready(() => {
  			if (swipeout) {
  				f7.instance.on("swipeoutOpen", onSwipeoutOpen);
  				f7.instance.on("swipeoutOpened", onSwipeoutOpened);
  				f7.instance.on("swipeoutClose", onSwipeoutClose);
  				f7.instance.on("swipeoutClosed", onSwipeoutClosed);
  				f7.instance.on("swipeoutDelete", onSwipeoutDelete);
  				f7.instance.on("swipeoutDeleted", onSwipeoutDeleted);
  				f7.instance.on("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
  				f7.instance.on("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
  				f7.instance.on("swipeout", onSwipeout);
  			}

  			if (accordionItem) {
  				f7.instance.on("accordionBeforeOpen", onAccBeforeOpen);
  				f7.instance.on("accordionOpen", onAccOpen);
  				f7.instance.on("accordionOpened", onAccOpened);
  				f7.instance.on("accordionBeforeClose", onAccBeforeClose);
  				f7.instance.on("accordionClose", onAccClose);
  				f7.instance.on("accordionClosed", onAccClosed);
  			}

  			if (linkEl && smartSelect) {
  				const ssParams = Utils$1.extend({ el: linkEl }, smartSelectParams || {});
  				f7SmartSelect = f7.instance.smartSelect.create(ssParams);
  			}

  			if (swipeoutOpened) {
  				f7.instance.swipeout.open(el);
  			}

  			if (tooltip) {
  				f7Tooltip = f7.instance.tooltip.create({
  					targetEl: el,
  					text: tooltip,
  					trigger: tooltipTrigger
  				});
  			}
  		});
  	});

  	afterUpdate(() => {
  		if (linkEl && $$props.routeProps) {
  			$$invalidate(26, linkEl.f7RouteProps = $$props.routeProps, linkEl);
  		}

  		if (inputEl) {
  			$$invalidate(28, inputEl.indeterminate = indeterminate, inputEl);
  		}
  	});

  	onDestroy(() => {
  		if (linkEl) {
  			delete linkEl.f7RouteProps;
  		}

  		if (!f7.instance) return;

  		if (swipeout) {
  			f7.instance.off("swipeoutOpen", onSwipeoutOpen);
  			f7.instance.off("swipeoutOpened", onSwipeoutOpened);
  			f7.instance.off("swipeoutClose", onSwipeoutClose);
  			f7.instance.off("swipeoutClosed", onSwipeoutClosed);
  			f7.instance.off("swipeoutDelete", onSwipeoutDelete);
  			f7.instance.off("swipeoutDeleted", onSwipeoutDeleted);
  			f7.instance.off("swipeoutOverswipeEnter", onSwipeoutOverswipeEnter);
  			f7.instance.off("swipeoutOverswipeExit", onSwipeoutOverswipeExit);
  			f7.instance.off("swipeout", onSwipeout);
  		}

  		if (accordionItem) {
  			f7.instance.off("accordionBeforeOpen", onAccBeforeOpen);
  			f7.instance.off("accordionOpen", onAccOpen);
  			f7.instance.off("accordionOpened", onAccOpened);
  			f7.instance.off("accordionBeforeClose", onAccBeforeClose);
  			f7.instance.off("accordionClose", onAccClose);
  			f7.instance.off("accordionClosed", onAccClosed);
  		}

  		if (f7SmartSelect && f7SmartSelect.destroy) {
  			f7SmartSelect.destroy();
  			f7SmartSelect = null;
  		}

  		if (f7Tooltip && f7Tooltip.destroy) {
  			f7Tooltip.destroy();
  			f7Tooltip = null;
  		}
  	});

  	let { $$slots = {}, $$scope } = $$props;

  	validate_slots("List_item", $$slots, [
  		'default','root-start','content-start','media','inner-start','header','before-title','title','after-title','after-start','after','after-end','subtitle','text','inner','footer','inner-end','content','content-end','root','root-end'
  	]);

  	function li_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(25, el = $$value);
  		});
  	}

  	function li_binding_1($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(25, el = $$value);
  		});
  	}

  	function div0_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(27, innerEl = $$value);
  		});
  	}

  	function a_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(26, linkEl = $$value);
  		});
  	}

  	function input_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(28, inputEl = $$value);
  		});
  	}

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(27, innerEl = $$value);
  		});
  	}

  	function div0_binding_1($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(27, innerEl = $$value);
  		});
  	}

  	function div0_binding_2($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(27, innerEl = $$value);
  		});
  	}

  	function a_binding_1($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(26, linkEl = $$value);
  		});
  	}

  	function input_binding_1($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(28, inputEl = $$value);
  		});
  	}

  	function div_binding_1($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(27, innerEl = $$value);
  		});
  	}

  	function div0_binding_3($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(27, innerEl = $$value);
  		});
  	}

  	function li_binding_2($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(25, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(88, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(47, className = $$new_props.class);
  		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
  		if ("text" in $$new_props) $$invalidate(3, text = $$new_props.text);
  		if ("media" in $$new_props) $$invalidate(4, media = $$new_props.media);
  		if ("subtitle" in $$new_props) $$invalidate(5, subtitle = $$new_props.subtitle);
  		if ("header" in $$new_props) $$invalidate(6, header = $$new_props.header);
  		if ("footer" in $$new_props) $$invalidate(7, footer = $$new_props.footer);
  		if ("tooltip" in $$new_props) $$invalidate(48, tooltip = $$new_props.tooltip);
  		if ("tooltipTrigger" in $$new_props) $$invalidate(49, tooltipTrigger = $$new_props.tooltipTrigger);
  		if ("link" in $$new_props) $$invalidate(50, link = $$new_props.link);
  		if ("tabLink" in $$new_props) $$invalidate(51, tabLink = $$new_props.tabLink);
  		if ("tabLinkActive" in $$new_props) $$invalidate(52, tabLinkActive = $$new_props.tabLinkActive);
  		if ("href" in $$new_props) $$invalidate(53, href = $$new_props.href);
  		if ("target" in $$new_props) $$invalidate(54, target = $$new_props.target);
  		if ("after" in $$new_props) $$invalidate(8, after = $$new_props.after);
  		if ("badge" in $$new_props) $$invalidate(9, badge = $$new_props.badge);
  		if ("badgeColor" in $$new_props) $$invalidate(10, badgeColor = $$new_props.badgeColor);
  		if ("mediaItem" in $$new_props) $$invalidate(55, mediaItem = $$new_props.mediaItem);
  		if ("mediaList" in $$new_props) $$invalidate(56, mediaList = $$new_props.mediaList);
  		if ("divider" in $$new_props) $$invalidate(11, divider = $$new_props.divider);
  		if ("groupTitle" in $$new_props) $$invalidate(12, groupTitle = $$new_props.groupTitle);
  		if ("swipeout" in $$new_props) $$invalidate(13, swipeout = $$new_props.swipeout);
  		if ("swipeoutOpened" in $$new_props) $$invalidate(57, swipeoutOpened = $$new_props.swipeoutOpened);
  		if ("sortable" in $$new_props) $$invalidate(14, sortable = $$new_props.sortable);
  		if ("sortableOpposite" in $$new_props) $$invalidate(58, sortableOpposite = $$new_props.sortableOpposite);
  		if ("accordionItem" in $$new_props) $$invalidate(15, accordionItem = $$new_props.accordionItem);
  		if ("accordionItemOpened" in $$new_props) $$invalidate(59, accordionItemOpened = $$new_props.accordionItemOpened);
  		if ("smartSelect" in $$new_props) $$invalidate(60, smartSelect = $$new_props.smartSelect);
  		if ("smartSelectParams" in $$new_props) $$invalidate(61, smartSelectParams = $$new_props.smartSelectParams);
  		if ("noChevron" in $$new_props) $$invalidate(62, noChevron = $$new_props.noChevron);
  		if ("chevronCenter" in $$new_props) $$invalidate(63, chevronCenter = $$new_props.chevronCenter);
  		if ("checkbox" in $$new_props) $$invalidate(16, checkbox = $$new_props.checkbox);
  		if ("radio" in $$new_props) $$invalidate(17, radio = $$new_props.radio);
  		if ("radioIcon" in $$new_props) $$invalidate(64, radioIcon = $$new_props.radioIcon);
  		if ("checked" in $$new_props) $$invalidate(18, checked = $$new_props.checked);
  		if ("indeterminate" in $$new_props) $$invalidate(65, indeterminate = $$new_props.indeterminate);
  		if ("name" in $$new_props) $$invalidate(19, name = $$new_props.name);
  		if ("value" in $$new_props) $$invalidate(20, value = $$new_props.value);
  		if ("readonly" in $$new_props) $$invalidate(21, readonly = $$new_props.readonly);
  		if ("required" in $$new_props) $$invalidate(22, required = $$new_props.required);
  		if ("disabled" in $$new_props) $$invalidate(23, disabled = $$new_props.disabled);
  		if ("virtualListIndex" in $$new_props) $$invalidate(24, virtualListIndex = $$new_props.virtualListIndex);
  		if ("$$scope" in $$new_props) $$invalidate(103, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher,
  		onMount,
  		onDestroy,
  		afterUpdate,
  		getContext,
  		Mixins,
  		Utils: Utils$1,
  		f7,
  		hasSlots,
  		Badge,
  		dispatch,
  		id,
  		style,
  		className,
  		title,
  		text,
  		media,
  		subtitle,
  		header,
  		footer,
  		tooltip,
  		tooltipTrigger,
  		link,
  		tabLink,
  		tabLinkActive,
  		href,
  		target,
  		after,
  		badge,
  		badgeColor,
  		mediaItem,
  		mediaList,
  		divider,
  		groupTitle,
  		swipeout,
  		swipeoutOpened,
  		sortable,
  		sortableOpposite,
  		accordionItem,
  		accordionItemOpened,
  		smartSelect,
  		smartSelectParams,
  		noChevron,
  		chevronCenter,
  		checkbox,
  		radio,
  		radioIcon,
  		checked,
  		indeterminate,
  		name,
  		value,
  		readonly,
  		required,
  		disabled,
  		virtualListIndex,
  		el,
  		linkEl,
  		innerEl,
  		inputEl,
  		f7SmartSelect,
  		f7Tooltip,
  		tooltipText,
  		watchTooltip,
  		initialWatchedOpened,
  		watchSwipeoutOpened,
  		onClick,
  		onSwipeoutOverswipeEnter,
  		onSwipeoutOverswipeExit,
  		onSwipeoutDeleted,
  		onSwipeoutDelete,
  		onSwipeoutClose,
  		onSwipeoutClosed,
  		onSwipeoutOpen,
  		onSwipeoutOpened,
  		onSwipeout,
  		onAccBeforeClose,
  		onAccClose,
  		onAccClosed,
  		onAccBeforeOpen,
  		onAccOpen,
  		onAccOpened,
  		onChange,
  		isMedia,
  		isSortable,
  		isSortableOpposite,
  		isSimple,
  		liClasses,
  		contentClasses,
  		linkClasses,
  		linkAttrs,
  		isLink,
  		hasMedia,
  		hasTitle,
  		hasHeader,
  		hasFooter,
  		hasSubtitle,
  		hasText,
  		hasAfter
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(88, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(47, className = $$new_props.className);
  		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
  		if ("text" in $$props) $$invalidate(3, text = $$new_props.text);
  		if ("media" in $$props) $$invalidate(4, media = $$new_props.media);
  		if ("subtitle" in $$props) $$invalidate(5, subtitle = $$new_props.subtitle);
  		if ("header" in $$props) $$invalidate(6, header = $$new_props.header);
  		if ("footer" in $$props) $$invalidate(7, footer = $$new_props.footer);
  		if ("tooltip" in $$props) $$invalidate(48, tooltip = $$new_props.tooltip);
  		if ("tooltipTrigger" in $$props) $$invalidate(49, tooltipTrigger = $$new_props.tooltipTrigger);
  		if ("link" in $$props) $$invalidate(50, link = $$new_props.link);
  		if ("tabLink" in $$props) $$invalidate(51, tabLink = $$new_props.tabLink);
  		if ("tabLinkActive" in $$props) $$invalidate(52, tabLinkActive = $$new_props.tabLinkActive);
  		if ("href" in $$props) $$invalidate(53, href = $$new_props.href);
  		if ("target" in $$props) $$invalidate(54, target = $$new_props.target);
  		if ("after" in $$props) $$invalidate(8, after = $$new_props.after);
  		if ("badge" in $$props) $$invalidate(9, badge = $$new_props.badge);
  		if ("badgeColor" in $$props) $$invalidate(10, badgeColor = $$new_props.badgeColor);
  		if ("mediaItem" in $$props) $$invalidate(55, mediaItem = $$new_props.mediaItem);
  		if ("mediaList" in $$props) $$invalidate(56, mediaList = $$new_props.mediaList);
  		if ("divider" in $$props) $$invalidate(11, divider = $$new_props.divider);
  		if ("groupTitle" in $$props) $$invalidate(12, groupTitle = $$new_props.groupTitle);
  		if ("swipeout" in $$props) $$invalidate(13, swipeout = $$new_props.swipeout);
  		if ("swipeoutOpened" in $$props) $$invalidate(57, swipeoutOpened = $$new_props.swipeoutOpened);
  		if ("sortable" in $$props) $$invalidate(14, sortable = $$new_props.sortable);
  		if ("sortableOpposite" in $$props) $$invalidate(58, sortableOpposite = $$new_props.sortableOpposite);
  		if ("accordionItem" in $$props) $$invalidate(15, accordionItem = $$new_props.accordionItem);
  		if ("accordionItemOpened" in $$props) $$invalidate(59, accordionItemOpened = $$new_props.accordionItemOpened);
  		if ("smartSelect" in $$props) $$invalidate(60, smartSelect = $$new_props.smartSelect);
  		if ("smartSelectParams" in $$props) $$invalidate(61, smartSelectParams = $$new_props.smartSelectParams);
  		if ("noChevron" in $$props) $$invalidate(62, noChevron = $$new_props.noChevron);
  		if ("chevronCenter" in $$props) $$invalidate(63, chevronCenter = $$new_props.chevronCenter);
  		if ("checkbox" in $$props) $$invalidate(16, checkbox = $$new_props.checkbox);
  		if ("radio" in $$props) $$invalidate(17, radio = $$new_props.radio);
  		if ("radioIcon" in $$props) $$invalidate(64, radioIcon = $$new_props.radioIcon);
  		if ("checked" in $$props) $$invalidate(18, checked = $$new_props.checked);
  		if ("indeterminate" in $$props) $$invalidate(65, indeterminate = $$new_props.indeterminate);
  		if ("name" in $$props) $$invalidate(19, name = $$new_props.name);
  		if ("value" in $$props) $$invalidate(20, value = $$new_props.value);
  		if ("readonly" in $$props) $$invalidate(21, readonly = $$new_props.readonly);
  		if ("required" in $$props) $$invalidate(22, required = $$new_props.required);
  		if ("disabled" in $$props) $$invalidate(23, disabled = $$new_props.disabled);
  		if ("virtualListIndex" in $$props) $$invalidate(24, virtualListIndex = $$new_props.virtualListIndex);
  		if ("el" in $$props) $$invalidate(25, el = $$new_props.el);
  		if ("linkEl" in $$props) $$invalidate(26, linkEl = $$new_props.linkEl);
  		if ("innerEl" in $$props) $$invalidate(27, innerEl = $$new_props.innerEl);
  		if ("inputEl" in $$props) $$invalidate(28, inputEl = $$new_props.inputEl);
  		if ("f7SmartSelect" in $$props) f7SmartSelect = $$new_props.f7SmartSelect;
  		if ("f7Tooltip" in $$props) f7Tooltip = $$new_props.f7Tooltip;
  		if ("tooltipText" in $$props) tooltipText = $$new_props.tooltipText;
  		if ("initialWatchedOpened" in $$props) initialWatchedOpened = $$new_props.initialWatchedOpened;
  		if ("isMedia" in $$props) $$invalidate(29, isMedia = $$new_props.isMedia);
  		if ("isSortable" in $$props) $$invalidate(30, isSortable = $$new_props.isSortable);
  		if ("isSortableOpposite" in $$props) $$invalidate(31, isSortableOpposite = $$new_props.isSortableOpposite);
  		if ("isSimple" in $$props) $$invalidate(32, isSimple = $$new_props.isSimple);
  		if ("liClasses" in $$props) $$invalidate(33, liClasses = $$new_props.liClasses);
  		if ("contentClasses" in $$props) $$invalidate(34, contentClasses = $$new_props.contentClasses);
  		if ("linkClasses" in $$props) $$invalidate(35, linkClasses = $$new_props.linkClasses);
  		if ("linkAttrs" in $$props) $$invalidate(36, linkAttrs = $$new_props.linkAttrs);
  		if ("isLink" in $$props) $$invalidate(37, isLink = $$new_props.isLink);
  		if ("hasMedia" in $$props) $$invalidate(38, hasMedia = $$new_props.hasMedia);
  		if ("hasTitle" in $$props) $$invalidate(39, hasTitle = $$new_props.hasTitle);
  		if ("hasHeader" in $$props) $$invalidate(40, hasHeader = $$new_props.hasHeader);
  		if ("hasFooter" in $$props) $$invalidate(41, hasFooter = $$new_props.hasFooter);
  		if ("hasSubtitle" in $$props) $$invalidate(42, hasSubtitle = $$new_props.hasSubtitle);
  		if ("hasText" in $$props) $$invalidate(43, hasText = $$new_props.hasText);
  		if ("hasAfter" in $$props) $$invalidate(44, hasAfter = $$new_props.hasAfter);
  	};

  	let isMedia;
  	let isSortable;
  	let isSortableOpposite;
  	let isSimple;
  	let liClasses;
  	let contentClasses;
  	let linkClasses;
  	let linkAttrs;
  	let isLink;
  	let hasMedia;
  	let hasTitle;
  	let hasHeader;
  	let hasFooter;
  	let hasSubtitle;
  	let hasText;
  	let hasAfter;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[1] & /*mediaList, mediaItem*/ 50331648) {
  			 $$invalidate(29, isMedia = mediaList || mediaItem || getContext("f7ListMedia"));
  		}

  		if ($$self.$$.dirty[0] & /*sortable*/ 16384) {
  			 $$invalidate(30, isSortable = sortable || getContext("f7ListSortable"));
  		}

  		if ($$self.$$.dirty[1] & /*sortableOpposite*/ 134217728) {
  			 $$invalidate(31, isSortableOpposite = sortableOpposite || getContext("f7ListSortableOpposite"));
  		}

  		 $$invalidate(33, liClasses = Utils$1.classNames(
  			className,
  			{
  				"item-divider": divider,
  				"list-group-title": groupTitle,
  				"media-item": isMedia,
  				swipeout,
  				"accordion-item": accordionItem,
  				"accordion-item-opened": accordionItemOpened,
  				disabled: disabled && !(radio || checkbox),
  				"no-chevron": noChevron,
  				"chevron-center": chevronCenter,
  				"disallow-sorting": sortable === false
  			},
  			Mixins.colorClasses($$props)
  		));

  		 $$invalidate(34, contentClasses = Utils$1.classNames(
  			className,
  			"item-content",
  			{
  				"item-checkbox": checkbox,
  				"item-radio": radio,
  				"item-radio-icon-start": radio && radioIcon === "start",
  				"item-radio-icon-end": radio && radioIcon === "end"
  			},
  			Mixins.colorClasses($$props)
  		));

  		 $$invalidate(35, linkClasses = Utils$1.classNames(
  			{
  				"item-link": true,
  				"smart-select": smartSelect,
  				"tab-link": tabLink || tabLink === "",
  				"tab-link-active": tabLinkActive
  			},
  			Mixins.linkRouterClasses($$props),
  			Mixins.linkActionsClasses($$props)
  		));

  		 $$invalidate(36, linkAttrs = {
  			href: link === true ? "" : link || href,
  			target,
  			"data-tab": Utils$1.isStringProp(tabLink) && tabLink || undefined,
  			...Mixins.linkRouterAttrs($$props),
  			...Mixins.linkActionsAttrs($$props)
  		});

  		if ($$self.$$.dirty[0] & /*accordionItem*/ 32768 | $$self.$$.dirty[1] & /*link, href, smartSelect*/ 541589504) {
  			 $$invalidate(37, isLink = link || href || smartSelect || accordionItem);
  		}

  		if ($$self.$$.dirty[0] & /*media*/ 16) {
  			/* eslint-disable no-undef */
  			 $$invalidate(38, hasMedia = typeof media !== "undefined" || hasSlots(arguments, "media"));
  		}

  		if ($$self.$$.dirty[0] & /*title*/ 4) {
  			 $$invalidate(39, hasTitle = typeof title !== "undefined" || hasSlots(arguments, "title"));
  		}

  		if ($$self.$$.dirty[0] & /*header*/ 64) {
  			 $$invalidate(40, hasHeader = typeof header !== "undefined" || hasSlots(arguments, "header"));
  		}

  		if ($$self.$$.dirty[0] & /*footer*/ 128) {
  			 $$invalidate(41, hasFooter = typeof footer !== "undefined" || hasSlots(arguments, "footer"));
  		}

  		if ($$self.$$.dirty[0] & /*subtitle*/ 32) {
  			 $$invalidate(42, hasSubtitle = typeof subtitle !== "undefined" || hasSlots(arguments, "subtitle"));
  		}

  		if ($$self.$$.dirty[0] & /*text*/ 8) {
  			 $$invalidate(43, hasText = typeof text !== "undefined" || hasSlots(arguments, "text"));
  		}

  		if ($$self.$$.dirty[0] & /*after, badge*/ 768) {
  			 $$invalidate(44, hasAfter = typeof after !== "undefined" || typeof badge !== "undefined" || hasSlots(arguments, "after"));
  		}

  		if ($$self.$$.dirty[1] & /*tooltip*/ 131072) {
  			 watchTooltip(tooltip);
  		}

  		if ($$self.$$.dirty[1] & /*swipeoutOpened*/ 67108864) {
  			 watchSwipeoutOpened(swipeoutOpened);
  		}
  	};

  	 $$invalidate(32, isSimple = getContext("f7ListSimple"));
  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		title,
  		text,
  		media,
  		subtitle,
  		header,
  		footer,
  		after,
  		badge,
  		badgeColor,
  		divider,
  		groupTitle,
  		swipeout,
  		sortable,
  		accordionItem,
  		checkbox,
  		radio,
  		checked,
  		name,
  		value,
  		readonly,
  		required,
  		disabled,
  		virtualListIndex,
  		el,
  		linkEl,
  		innerEl,
  		inputEl,
  		isMedia,
  		isSortable,
  		isSortableOpposite,
  		isSimple,
  		liClasses,
  		contentClasses,
  		linkClasses,
  		linkAttrs,
  		isLink,
  		hasMedia,
  		hasTitle,
  		hasHeader,
  		hasFooter,
  		hasSubtitle,
  		hasText,
  		hasAfter,
  		onClick,
  		onChange,
  		className,
  		tooltip,
  		tooltipTrigger,
  		link,
  		tabLink,
  		tabLinkActive,
  		href,
  		target,
  		mediaItem,
  		mediaList,
  		swipeoutOpened,
  		sortableOpposite,
  		accordionItemOpened,
  		smartSelect,
  		smartSelectParams,
  		noChevron,
  		chevronCenter,
  		radioIcon,
  		indeterminate,
  		f7SmartSelect,
  		f7Tooltip,
  		tooltipText,
  		initialWatchedOpened,
  		dispatch,
  		watchTooltip,
  		watchSwipeoutOpened,
  		onSwipeoutOverswipeEnter,
  		onSwipeoutOverswipeExit,
  		onSwipeoutDeleted,
  		onSwipeoutDelete,
  		onSwipeoutClose,
  		onSwipeoutClosed,
  		onSwipeoutOpen,
  		onSwipeoutOpened,
  		onSwipeout,
  		onAccBeforeClose,
  		onAccClose,
  		onAccClosed,
  		onAccBeforeOpen,
  		onAccOpen,
  		onAccOpened,
  		$$props,
  		$$slots,
  		li_binding,
  		li_binding_1,
  		div0_binding,
  		a_binding,
  		input_binding,
  		div_binding,
  		div0_binding_1,
  		div0_binding_2,
  		a_binding_1,
  		input_binding_1,
  		div_binding_1,
  		div0_binding_3,
  		li_binding_2,
  		$$scope
  	];
  }

  class List_item extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(
  			this,
  			options,
  			instance$a,
  			create_fragment$a,
  			safe_not_equal,
  			{
  				id: 0,
  				style: 1,
  				class: 47,
  				title: 2,
  				text: 3,
  				media: 4,
  				subtitle: 5,
  				header: 6,
  				footer: 7,
  				tooltip: 48,
  				tooltipTrigger: 49,
  				link: 50,
  				tabLink: 51,
  				tabLinkActive: 52,
  				href: 53,
  				target: 54,
  				after: 8,
  				badge: 9,
  				badgeColor: 10,
  				mediaItem: 55,
  				mediaList: 56,
  				divider: 11,
  				groupTitle: 12,
  				swipeout: 13,
  				swipeoutOpened: 57,
  				sortable: 14,
  				sortableOpposite: 58,
  				accordionItem: 15,
  				accordionItemOpened: 59,
  				smartSelect: 60,
  				smartSelectParams: 61,
  				noChevron: 62,
  				chevronCenter: 63,
  				checkbox: 16,
  				radio: 17,
  				radioIcon: 64,
  				checked: 18,
  				indeterminate: 65,
  				name: 19,
  				value: 20,
  				readonly: 21,
  				required: 22,
  				disabled: 23,
  				virtualListIndex: 24
  			},
  			[-1, -1, -1, -1]
  		);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "List_item",
  			options,
  			id: create_fragment$a.name
  		});
  	}

  	get id() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get title() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set title(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get text() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set text(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get media() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set media(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get subtitle() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set subtitle(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get header() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set header(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get footer() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set footer(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tooltip() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tooltip(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tooltipTrigger() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tooltipTrigger(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get link() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set link(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabLink() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabLink(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabLinkActive() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabLinkActive(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get href() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set href(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get target() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set target(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get after() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set after(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get badge() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set badge(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get badgeColor() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set badgeColor(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get mediaItem() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set mediaItem(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get mediaList() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set mediaList(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get divider() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set divider(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get groupTitle() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set groupTitle(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get swipeout() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set swipeout(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get swipeoutOpened() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set swipeoutOpened(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sortable() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sortable(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sortableOpposite() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sortableOpposite(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get accordionItem() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set accordionItem(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get accordionItemOpened() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set accordionItemOpened(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smartSelect() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smartSelect(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smartSelectParams() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smartSelectParams(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noChevron() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noChevron(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get chevronCenter() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set chevronCenter(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get checkbox() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set checkbox(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get radio() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set radio(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get radioIcon() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set radioIcon(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get checked() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set checked(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get indeterminate() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set indeterminate(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get name() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set name(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get value() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set value(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get readonly() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set readonly(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get required() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set required(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get disabled() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set disabled(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get virtualListIndex() {
  		throw new Error("<List_item>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set virtualListIndex(value) {
  		throw new Error("<List_item>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/list.svelte generated by Svelte v3.21.0 */
  const file$b = "node_modules/framework7-svelte/components/list.svelte";
  const get_after_list_slot_changes_1 = dirty => ({});
  const get_after_list_slot_context_1 = ctx => ({});
  const get_list_slot_changes_1 = dirty => ({});
  const get_list_slot_context_1 = ctx => ({});
  const get_before_list_slot_changes_1 = dirty => ({});
  const get_before_list_slot_context_1 = ctx => ({});
  const get_after_list_slot_changes = dirty => ({});
  const get_after_list_slot_context = ctx => ({});
  const get_list_slot_changes = dirty => ({});
  const get_list_slot_context = ctx => ({});
  const get_before_list_slot_changes = dirty => ({});
  const get_before_list_slot_context = ctx => ({});

  // (218:0) {:else}
  function create_else_block_1$1(ctx) {
  	let div;
  	let t0;
  	let current_block_type_index;
  	let if_block;
  	let t1;
  	let div_data_sortable_move_elements_value;
  	let current;
  	const before_list_slot_template = /*$$slots*/ ctx[51]["before-list"];
  	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[50], get_before_list_slot_context_1);
  	const if_block_creators = [create_if_block_2$4, create_else_block_2$1];
  	const if_blocks = [];

  	function select_block_type_2(ctx, dirty) {
  		if (/*hasUlSlots*/ ctx[6] && /*ul*/ ctx[2]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_2(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	const after_list_slot_template = /*$$slots*/ ctx[51]["after-list"];
  	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[50], get_after_list_slot_context_1);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (before_list_slot) before_list_slot.c();
  			t0 = space();
  			if_block.c();
  			t1 = space();
  			if (after_list_slot) after_list_slot.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[7]);

  			attr_dev(div, "data-sortable-move-elements", div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[3] !== "undefined"
  			? /*sortableMoveElements*/ ctx[3].toString()
  			: undefined);

  			add_location(div, file$b, 218, 2, 7085);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (before_list_slot) {
  				before_list_slot.m(div, null);
  			}

  			append_dev(div, t0);
  			if_blocks[current_block_type_index].m(div, null);
  			append_dev(div, t1);

  			if (after_list_slot) {
  				after_list_slot.m(div, null);
  			}

  			/*div_binding*/ ctx[53](div);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (before_list_slot) {
  				if (before_list_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					before_list_slot.p(get_slot_context(before_list_slot_template, ctx, /*$$scope*/ ctx[50], get_before_list_slot_context_1), get_slot_changes(before_list_slot_template, /*$$scope*/ ctx[50], dirty, get_before_list_slot_changes_1));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_2(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(div, t1);
  			}

  			if (after_list_slot) {
  				if (after_list_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					after_list_slot.p(get_slot_context(after_list_slot_template, ctx, /*$$scope*/ ctx[50], get_after_list_slot_context_1), get_slot_changes(after_list_slot_template, /*$$scope*/ ctx[50], dirty, get_after_list_slot_changes_1));
  				}
  			}

  			if (!current || dirty[0] & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty[0] & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty[0] & /*classes*/ 128) {
  				attr_dev(div, "class", /*classes*/ ctx[7]);
  			}

  			if (!current || dirty[0] & /*sortableMoveElements*/ 8 && div_data_sortable_move_elements_value !== (div_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[3] !== "undefined"
  			? /*sortableMoveElements*/ ctx[3].toString()
  			: undefined)) {
  				attr_dev(div, "data-sortable-move-elements", div_data_sortable_move_elements_value);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_list_slot, local);
  			transition_in(if_block);
  			transition_in(after_list_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_list_slot, local);
  			transition_out(if_block);
  			transition_out(after_list_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (before_list_slot) before_list_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (after_list_slot) after_list_slot.d(detaching);
  			/*div_binding*/ ctx[53](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_1$1.name,
  		type: "else",
  		source: "(218:0) {:else}",
  		ctx
  	});

  	return block;
  }

  // (198:0) {#if form}
  function create_if_block$4(ctx) {
  	let form_1;
  	let t0;
  	let current_block_type_index;
  	let if_block;
  	let t1;
  	let form_1_data_sortable_move_elements_value;
  	let current;
  	let dispose;
  	const before_list_slot_template = /*$$slots*/ ctx[51]["before-list"];
  	const before_list_slot = create_slot(before_list_slot_template, ctx, /*$$scope*/ ctx[50], get_before_list_slot_context);
  	const if_block_creators = [create_if_block_1$4, create_else_block$2];
  	const if_blocks = [];

  	function select_block_type_1(ctx, dirty) {
  		if (/*hasUlSlots*/ ctx[6] && /*ul*/ ctx[2]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type_1(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	const after_list_slot_template = /*$$slots*/ ctx[51]["after-list"];
  	const after_list_slot = create_slot(after_list_slot_template, ctx, /*$$scope*/ ctx[50], get_after_list_slot_context);

  	const block = {
  		c: function create() {
  			form_1 = element("form");
  			if (before_list_slot) before_list_slot.c();
  			t0 = space();
  			if_block.c();
  			t1 = space();
  			if (after_list_slot) after_list_slot.c();
  			attr_dev(form_1, "id", /*id*/ ctx[0]);
  			attr_dev(form_1, "style", /*style*/ ctx[1]);
  			attr_dev(form_1, "class", /*classes*/ ctx[7]);

  			attr_dev(form_1, "data-sortable-move-elements", form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[3] !== "undefined"
  			? /*sortableMoveElements*/ ctx[3].toString()
  			: undefined);

  			add_location(form_1, file$b, 198, 2, 6651);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, form_1, anchor);

  			if (before_list_slot) {
  				before_list_slot.m(form_1, null);
  			}

  			append_dev(form_1, t0);
  			if_blocks[current_block_type_index].m(form_1, null);
  			append_dev(form_1, t1);

  			if (after_list_slot) {
  				after_list_slot.m(form_1, null);
  			}

  			/*form_1_binding*/ ctx[52](form_1);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(form_1, "submit", /*onSubmit*/ ctx[8], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (before_list_slot) {
  				if (before_list_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					before_list_slot.p(get_slot_context(before_list_slot_template, ctx, /*$$scope*/ ctx[50], get_before_list_slot_context), get_slot_changes(before_list_slot_template, /*$$scope*/ ctx[50], dirty, get_before_list_slot_changes));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type_1(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(form_1, t1);
  			}

  			if (after_list_slot) {
  				if (after_list_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					after_list_slot.p(get_slot_context(after_list_slot_template, ctx, /*$$scope*/ ctx[50], get_after_list_slot_context), get_slot_changes(after_list_slot_template, /*$$scope*/ ctx[50], dirty, get_after_list_slot_changes));
  				}
  			}

  			if (!current || dirty[0] & /*id*/ 1) {
  				attr_dev(form_1, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty[0] & /*style*/ 2) {
  				attr_dev(form_1, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty[0] & /*classes*/ 128) {
  				attr_dev(form_1, "class", /*classes*/ ctx[7]);
  			}

  			if (!current || dirty[0] & /*sortableMoveElements*/ 8 && form_1_data_sortable_move_elements_value !== (form_1_data_sortable_move_elements_value = typeof /*sortableMoveElements*/ ctx[3] !== "undefined"
  			? /*sortableMoveElements*/ ctx[3].toString()
  			: undefined)) {
  				attr_dev(form_1, "data-sortable-move-elements", form_1_data_sortable_move_elements_value);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_list_slot, local);
  			transition_in(if_block);
  			transition_in(after_list_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_list_slot, local);
  			transition_out(if_block);
  			transition_out(after_list_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(form_1);
  			if (before_list_slot) before_list_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			if (after_list_slot) after_list_slot.d(detaching);
  			/*form_1_binding*/ ctx[52](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$4.name,
  		type: "if",
  		source: "(198:0) {#if form}",
  		ctx
  	});

  	return block;
  }

  // (232:4) {:else}
  function create_else_block_2$1(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[51].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[50], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[50], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[50], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block_2$1.name,
  		type: "else",
  		source: "(232:4) {:else}",
  		ctx
  	});

  	return block;
  }

  // (227:4) {#if hasUlSlots && ul}
  function create_if_block_2$4(ctx) {
  	let ul_1;
  	let t;
  	let current;
  	const list_slot_template = /*$$slots*/ ctx[51].list;
  	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[50], get_list_slot_context_1);
  	const default_slot_template = /*$$slots*/ ctx[51].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[50], null);

  	const block = {
  		c: function create() {
  			ul_1 = element("ul");
  			if (list_slot) list_slot.c();
  			t = space();
  			if (default_slot) default_slot.c();
  			add_location(ul_1, file$b, 227, 4, 7350);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, ul_1, anchor);

  			if (list_slot) {
  				list_slot.m(ul_1, null);
  			}

  			append_dev(ul_1, t);

  			if (default_slot) {
  				default_slot.m(ul_1, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (list_slot) {
  				if (list_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					list_slot.p(get_slot_context(list_slot_template, ctx, /*$$scope*/ ctx[50], get_list_slot_context_1), get_slot_changes(list_slot_template, /*$$scope*/ ctx[50], dirty, get_list_slot_changes_1));
  				}
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[50], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[50], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(list_slot, local);
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(list_slot, local);
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(ul_1);
  			if (list_slot) list_slot.d(detaching);
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$4.name,
  		type: "if",
  		source: "(227:4) {#if hasUlSlots && ul}",
  		ctx
  	});

  	return block;
  }

  // (213:4) {:else}
  function create_else_block$2(ctx) {
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[51].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[50], null);

  	const block = {
  		c: function create() {
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[50], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[50], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$2.name,
  		type: "else",
  		source: "(213:4) {:else}",
  		ctx
  	});

  	return block;
  }

  // (208:4) {#if hasUlSlots && ul}
  function create_if_block_1$4(ctx) {
  	let ul_1;
  	let t;
  	let current;
  	const list_slot_template = /*$$slots*/ ctx[51].list;
  	const list_slot = create_slot(list_slot_template, ctx, /*$$scope*/ ctx[50], get_list_slot_context);
  	const default_slot_template = /*$$slots*/ ctx[51].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[50], null);

  	const block = {
  		c: function create() {
  			ul_1 = element("ul");
  			if (list_slot) list_slot.c();
  			t = space();
  			if (default_slot) default_slot.c();
  			add_location(ul_1, file$b, 208, 4, 6942);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, ul_1, anchor);

  			if (list_slot) {
  				list_slot.m(ul_1, null);
  			}

  			append_dev(ul_1, t);

  			if (default_slot) {
  				default_slot.m(ul_1, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (list_slot) {
  				if (list_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					list_slot.p(get_slot_context(list_slot_template, ctx, /*$$scope*/ ctx[50], get_list_slot_context), get_slot_changes(list_slot_template, /*$$scope*/ ctx[50], dirty, get_list_slot_changes));
  				}
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 524288) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[50], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[50], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(list_slot, local);
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(list_slot, local);
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(ul_1);
  			if (list_slot) list_slot.d(detaching);
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$4.name,
  		type: "if",
  		source: "(208:4) {#if hasUlSlots && ul}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$b(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block$4, create_else_block_1$1];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*form*/ ctx[4]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			if_block.c();
  			if_block_anchor = empty$1();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$b.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$b($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { ul = true } = $$props;
  	let { inset = false } = $$props;
  	let { xsmallInset = false } = $$props;
  	let { smallInset = false } = $$props;
  	let { mediumInset = false } = $$props;
  	let { largeInset = false } = $$props;
  	let { xlargeInset = false } = $$props;
  	let { mediaList = false } = $$props;
  	let { sortable = false } = $$props;
  	let { sortableTapHold = false } = $$props;
  	let { sortableEnabled = false } = $$props;
  	let { sortableMoveElements = undefined } = $$props;
  	let { sortableOpposite = false } = $$props;
  	let { accordionList = false } = $$props;
  	let { accordionOpposite = false } = $$props;
  	let { contactsList = false } = $$props;
  	let { simpleList = false } = $$props;
  	let { linksList = false } = $$props;
  	let { noHairlines = false } = $$props;
  	let { noHairlinesBetween = false } = $$props;
  	let { noHairlinesMd = false } = $$props;
  	let { noHairlinesBetweenMd = false } = $$props;
  	let { noHairlinesIos = false } = $$props;
  	let { noHairlinesBetweenIos = false } = $$props;
  	let { noHairlinesAurora = false } = $$props;
  	let { noHairlinesBetweenAurora = false } = $$props;
  	let { noChevron = false } = $$props;
  	let { chevronCenter = false } = $$props;
  	let { tab = false } = $$props;
  	let { tabActive = false } = $$props;
  	let { form = false } = $$props;
  	let { formStoreData = false } = $$props;
  	let { inlineLabels = false } = $$props;
  	let { virtualList = false } = $$props;
  	let { virtualListParams = undefined } = $$props;
  	let el;
  	let f7VirtualList;
  	setContext("f7ListMedia", mediaList);
  	setContext("f7ListSortable", sortable);
  	setContext("f7ListSortableOpposite", sortableOpposite);
  	setContext("f7ListSimple", simpleList);

  	function onSubmit(event) {
  		dispatch("submit", [event]);
  		if (typeof $$props.onSubmit === "function") $$props.onSubmit(event);
  	}

  	function onSortableEnable(sortableEl) {
  		if (sortableEl !== el) return;
  		dispatch("sortableEnable");
  		if (typeof $$props.onSortableEnable === "function") $$props.onSortableEnable();
  	}

  	function onSortableDisable(sortableEl) {
  		if (sortableEl !== el) return;
  		dispatch("sortableDisable");
  		if (typeof $$props.onSortableDisable === "function") $$props.onSortableDisable();
  	}

  	function onSortableSort(sortableEl, sortData, listEl) {
  		if (sortableEl !== listEl) return;
  		dispatch("sortableSort", [sortData]);
  		if (typeof $$props.onSortableSort === "function") $$props.onSortableSort(sortData);
  	}

  	function onTabShow(tabEl) {
  		if (tabEl !== el) return;
  		dispatch("tabShow");
  		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
  	}

  	function onTabHide(tabEl) {
  		if (tabEl !== el) return;
  		dispatch("tabHide");
  		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
  	}

  	onMount(() => {
  		f7.ready(() => {
  			f7.instance.on("sortableEnable", onSortableEnable);
  			f7.instance.on("sortableDisable", onSortableDisable);
  			f7.instance.on("sortableSort", onSortableSort);
  			f7.instance.on("tabShow", onTabShow);
  			f7.instance.on("tabHide", onTabHide);
  			if (!virtualList) return;
  			const vlParams = virtualListParams || {};
  			if (!vlParams.renderItem && !vlParams.itemTemplate && !vlParams.renderExternal) return;

  			f7VirtualList = f7.instance.virtualList.create(Utils$1.extend(
  				{
  					el,
  					on: {
  						itemBeforeInsert(itemEl, item) {
  							const vl = this;
  							dispatch("virtualItemBeforeInsert", [vl, itemEl, item]);
  							if (typeof $$props.onVirtualItemBeforeInsert === "function") $$props.onVirtualItemBeforeInsert(vl, itemEl, item);
  						},
  						beforeClear(fragment) {
  							const vl = this;
  							dispatch("virtualBeforeClear", [vl, fragment]);
  							if (typeof $$props.onVirtualBeforeClear === "function") $$props.onVirtualBeforeClear(vl, fragment);
  						},
  						itemsBeforeInsert(fragment) {
  							const vl = this;
  							dispatch("virtualItemsBeforeInsert", [vl, fragment]);
  							if (typeof $$props.onVirtualItemsBeforeInsert === "function") $$props.onVirtualItemsBeforeInsert(vl, fragment);
  						},
  						itemsAfterInsert(fragment) {
  							const vl = this;
  							dispatch("virtualItemsAfterInsert", [vl, fragment]);
  							if (typeof $$props.onVirtualItemsAfterInsert === "function") $$props.onVirtualItemsAfterInsert(vl, fragment);
  						}
  					}
  				},
  				vlParams
  			));
  		});
  	});

  	onDestroy(() => {
  		if (!f7.instance) return;
  		f7.instance.off("sortableEnable", onSortableEnable);
  		f7.instance.off("sortableDisable", onSortableDisable);
  		f7.instance.off("sortableSort", onSortableSort);
  		f7.instance.off("tabShow", onTabShow);
  		f7.instance.off("tabHide", onTabHide);
  		if (f7VirtualList && f7VirtualList.destroy) f7VirtualList.destroy();
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("List", $$slots, ['before-list','list','default','after-list']);

  	function form_1_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(5, el = $$value);
  		});
  	}

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(5, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(49, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(9, className = $$new_props.class);
  		if ("ul" in $$new_props) $$invalidate(2, ul = $$new_props.ul);
  		if ("inset" in $$new_props) $$invalidate(10, inset = $$new_props.inset);
  		if ("xsmallInset" in $$new_props) $$invalidate(11, xsmallInset = $$new_props.xsmallInset);
  		if ("smallInset" in $$new_props) $$invalidate(12, smallInset = $$new_props.smallInset);
  		if ("mediumInset" in $$new_props) $$invalidate(13, mediumInset = $$new_props.mediumInset);
  		if ("largeInset" in $$new_props) $$invalidate(14, largeInset = $$new_props.largeInset);
  		if ("xlargeInset" in $$new_props) $$invalidate(15, xlargeInset = $$new_props.xlargeInset);
  		if ("mediaList" in $$new_props) $$invalidate(16, mediaList = $$new_props.mediaList);
  		if ("sortable" in $$new_props) $$invalidate(17, sortable = $$new_props.sortable);
  		if ("sortableTapHold" in $$new_props) $$invalidate(18, sortableTapHold = $$new_props.sortableTapHold);
  		if ("sortableEnabled" in $$new_props) $$invalidate(19, sortableEnabled = $$new_props.sortableEnabled);
  		if ("sortableMoveElements" in $$new_props) $$invalidate(3, sortableMoveElements = $$new_props.sortableMoveElements);
  		if ("sortableOpposite" in $$new_props) $$invalidate(20, sortableOpposite = $$new_props.sortableOpposite);
  		if ("accordionList" in $$new_props) $$invalidate(21, accordionList = $$new_props.accordionList);
  		if ("accordionOpposite" in $$new_props) $$invalidate(22, accordionOpposite = $$new_props.accordionOpposite);
  		if ("contactsList" in $$new_props) $$invalidate(23, contactsList = $$new_props.contactsList);
  		if ("simpleList" in $$new_props) $$invalidate(24, simpleList = $$new_props.simpleList);
  		if ("linksList" in $$new_props) $$invalidate(25, linksList = $$new_props.linksList);
  		if ("noHairlines" in $$new_props) $$invalidate(26, noHairlines = $$new_props.noHairlines);
  		if ("noHairlinesBetween" in $$new_props) $$invalidate(27, noHairlinesBetween = $$new_props.noHairlinesBetween);
  		if ("noHairlinesMd" in $$new_props) $$invalidate(28, noHairlinesMd = $$new_props.noHairlinesMd);
  		if ("noHairlinesBetweenMd" in $$new_props) $$invalidate(29, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
  		if ("noHairlinesIos" in $$new_props) $$invalidate(30, noHairlinesIos = $$new_props.noHairlinesIos);
  		if ("noHairlinesBetweenIos" in $$new_props) $$invalidate(31, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
  		if ("noHairlinesAurora" in $$new_props) $$invalidate(32, noHairlinesAurora = $$new_props.noHairlinesAurora);
  		if ("noHairlinesBetweenAurora" in $$new_props) $$invalidate(33, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
  		if ("noChevron" in $$new_props) $$invalidate(34, noChevron = $$new_props.noChevron);
  		if ("chevronCenter" in $$new_props) $$invalidate(35, chevronCenter = $$new_props.chevronCenter);
  		if ("tab" in $$new_props) $$invalidate(36, tab = $$new_props.tab);
  		if ("tabActive" in $$new_props) $$invalidate(37, tabActive = $$new_props.tabActive);
  		if ("form" in $$new_props) $$invalidate(4, form = $$new_props.form);
  		if ("formStoreData" in $$new_props) $$invalidate(38, formStoreData = $$new_props.formStoreData);
  		if ("inlineLabels" in $$new_props) $$invalidate(39, inlineLabels = $$new_props.inlineLabels);
  		if ("virtualList" in $$new_props) $$invalidate(40, virtualList = $$new_props.virtualList);
  		if ("virtualListParams" in $$new_props) $$invalidate(41, virtualListParams = $$new_props.virtualListParams);
  		if ("$$scope" in $$new_props) $$invalidate(50, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher,
  		onMount,
  		onDestroy,
  		setContext,
  		Mixins,
  		Utils: Utils$1,
  		f7,
  		hasSlots,
  		dispatch,
  		id,
  		style,
  		className,
  		ul,
  		inset,
  		xsmallInset,
  		smallInset,
  		mediumInset,
  		largeInset,
  		xlargeInset,
  		mediaList,
  		sortable,
  		sortableTapHold,
  		sortableEnabled,
  		sortableMoveElements,
  		sortableOpposite,
  		accordionList,
  		accordionOpposite,
  		contactsList,
  		simpleList,
  		linksList,
  		noHairlines,
  		noHairlinesBetween,
  		noHairlinesMd,
  		noHairlinesBetweenMd,
  		noHairlinesIos,
  		noHairlinesBetweenIos,
  		noHairlinesAurora,
  		noHairlinesBetweenAurora,
  		noChevron,
  		chevronCenter,
  		tab,
  		tabActive,
  		form,
  		formStoreData,
  		inlineLabels,
  		virtualList,
  		virtualListParams,
  		el,
  		f7VirtualList,
  		onSubmit,
  		onSortableEnable,
  		onSortableDisable,
  		onSortableSort,
  		onTabShow,
  		onTabHide,
  		hasUlSlots,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(49, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(9, className = $$new_props.className);
  		if ("ul" in $$props) $$invalidate(2, ul = $$new_props.ul);
  		if ("inset" in $$props) $$invalidate(10, inset = $$new_props.inset);
  		if ("xsmallInset" in $$props) $$invalidate(11, xsmallInset = $$new_props.xsmallInset);
  		if ("smallInset" in $$props) $$invalidate(12, smallInset = $$new_props.smallInset);
  		if ("mediumInset" in $$props) $$invalidate(13, mediumInset = $$new_props.mediumInset);
  		if ("largeInset" in $$props) $$invalidate(14, largeInset = $$new_props.largeInset);
  		if ("xlargeInset" in $$props) $$invalidate(15, xlargeInset = $$new_props.xlargeInset);
  		if ("mediaList" in $$props) $$invalidate(16, mediaList = $$new_props.mediaList);
  		if ("sortable" in $$props) $$invalidate(17, sortable = $$new_props.sortable);
  		if ("sortableTapHold" in $$props) $$invalidate(18, sortableTapHold = $$new_props.sortableTapHold);
  		if ("sortableEnabled" in $$props) $$invalidate(19, sortableEnabled = $$new_props.sortableEnabled);
  		if ("sortableMoveElements" in $$props) $$invalidate(3, sortableMoveElements = $$new_props.sortableMoveElements);
  		if ("sortableOpposite" in $$props) $$invalidate(20, sortableOpposite = $$new_props.sortableOpposite);
  		if ("accordionList" in $$props) $$invalidate(21, accordionList = $$new_props.accordionList);
  		if ("accordionOpposite" in $$props) $$invalidate(22, accordionOpposite = $$new_props.accordionOpposite);
  		if ("contactsList" in $$props) $$invalidate(23, contactsList = $$new_props.contactsList);
  		if ("simpleList" in $$props) $$invalidate(24, simpleList = $$new_props.simpleList);
  		if ("linksList" in $$props) $$invalidate(25, linksList = $$new_props.linksList);
  		if ("noHairlines" in $$props) $$invalidate(26, noHairlines = $$new_props.noHairlines);
  		if ("noHairlinesBetween" in $$props) $$invalidate(27, noHairlinesBetween = $$new_props.noHairlinesBetween);
  		if ("noHairlinesMd" in $$props) $$invalidate(28, noHairlinesMd = $$new_props.noHairlinesMd);
  		if ("noHairlinesBetweenMd" in $$props) $$invalidate(29, noHairlinesBetweenMd = $$new_props.noHairlinesBetweenMd);
  		if ("noHairlinesIos" in $$props) $$invalidate(30, noHairlinesIos = $$new_props.noHairlinesIos);
  		if ("noHairlinesBetweenIos" in $$props) $$invalidate(31, noHairlinesBetweenIos = $$new_props.noHairlinesBetweenIos);
  		if ("noHairlinesAurora" in $$props) $$invalidate(32, noHairlinesAurora = $$new_props.noHairlinesAurora);
  		if ("noHairlinesBetweenAurora" in $$props) $$invalidate(33, noHairlinesBetweenAurora = $$new_props.noHairlinesBetweenAurora);
  		if ("noChevron" in $$props) $$invalidate(34, noChevron = $$new_props.noChevron);
  		if ("chevronCenter" in $$props) $$invalidate(35, chevronCenter = $$new_props.chevronCenter);
  		if ("tab" in $$props) $$invalidate(36, tab = $$new_props.tab);
  		if ("tabActive" in $$props) $$invalidate(37, tabActive = $$new_props.tabActive);
  		if ("form" in $$props) $$invalidate(4, form = $$new_props.form);
  		if ("formStoreData" in $$props) $$invalidate(38, formStoreData = $$new_props.formStoreData);
  		if ("inlineLabels" in $$props) $$invalidate(39, inlineLabels = $$new_props.inlineLabels);
  		if ("virtualList" in $$props) $$invalidate(40, virtualList = $$new_props.virtualList);
  		if ("virtualListParams" in $$props) $$invalidate(41, virtualListParams = $$new_props.virtualListParams);
  		if ("el" in $$props) $$invalidate(5, el = $$new_props.el);
  		if ("f7VirtualList" in $$props) f7VirtualList = $$new_props.f7VirtualList;
  		if ("hasUlSlots" in $$props) $$invalidate(6, hasUlSlots = $$new_props.hasUlSlots);
  		if ("classes" in $$props) $$invalidate(7, classes = $$new_props.classes);
  	};

  	let hasUlSlots;
  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(7, classes = Utils$1.classNames(
  			className,
  			"list",
  			{
  				inset,
  				"xsmall-inset": xsmallInset,
  				"small-inset": smallInset,
  				"medium-inset": mediumInset,
  				"large-inset": largeInset,
  				"xlarge-inset": xlargeInset,
  				"media-list": mediaList,
  				"simple-list": simpleList,
  				"links-list": linksList,
  				sortable,
  				"sortable-tap-hold": sortableTapHold,
  				"sortable-enabled": sortableEnabled,
  				"sortable-opposite": sortableOpposite,
  				"accordion-list": accordionList,
  				"accordion-opposite": accordionOpposite,
  				"contacts-list": contactsList,
  				"virtual-list": virtualList,
  				tab,
  				"tab-active": tabActive,
  				"no-hairlines": noHairlines,
  				"no-hairlines-md": noHairlinesMd,
  				"no-hairlines-ios": noHairlinesIos,
  				"no-hairlines-aurora": noHairlinesAurora,
  				"no-hairlines-between": noHairlinesBetween,
  				"no-hairlines-between-md": noHairlinesBetweenMd,
  				"no-hairlines-between-ios": noHairlinesBetweenIos,
  				"no-hairlines-between-aurora": noHairlinesBetweenAurora,
  				"form-store-data": formStoreData,
  				"inline-labels": inlineLabels,
  				"no-chevron": noChevron,
  				"chevron-center": chevronCenter
  			},
  			Mixins.colorClasses($$props)
  		));
  	};

  	 $$invalidate(6, hasUlSlots = hasSlots(arguments, "default") || hasSlots(arguments, "list"));
  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		ul,
  		sortableMoveElements,
  		form,
  		el,
  		hasUlSlots,
  		classes,
  		onSubmit,
  		className,
  		inset,
  		xsmallInset,
  		smallInset,
  		mediumInset,
  		largeInset,
  		xlargeInset,
  		mediaList,
  		sortable,
  		sortableTapHold,
  		sortableEnabled,
  		sortableOpposite,
  		accordionList,
  		accordionOpposite,
  		contactsList,
  		simpleList,
  		linksList,
  		noHairlines,
  		noHairlinesBetween,
  		noHairlinesMd,
  		noHairlinesBetweenMd,
  		noHairlinesIos,
  		noHairlinesBetweenIos,
  		noHairlinesAurora,
  		noHairlinesBetweenAurora,
  		noChevron,
  		chevronCenter,
  		tab,
  		tabActive,
  		formStoreData,
  		inlineLabels,
  		virtualList,
  		virtualListParams,
  		f7VirtualList,
  		dispatch,
  		onSortableEnable,
  		onSortableDisable,
  		onSortableSort,
  		onTabShow,
  		onTabHide,
  		$$props,
  		$$scope,
  		$$slots,
  		form_1_binding,
  		div_binding
  	];
  }

  class List extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(
  			this,
  			options,
  			instance$b,
  			create_fragment$b,
  			safe_not_equal,
  			{
  				id: 0,
  				style: 1,
  				class: 9,
  				ul: 2,
  				inset: 10,
  				xsmallInset: 11,
  				smallInset: 12,
  				mediumInset: 13,
  				largeInset: 14,
  				xlargeInset: 15,
  				mediaList: 16,
  				sortable: 17,
  				sortableTapHold: 18,
  				sortableEnabled: 19,
  				sortableMoveElements: 3,
  				sortableOpposite: 20,
  				accordionList: 21,
  				accordionOpposite: 22,
  				contactsList: 23,
  				simpleList: 24,
  				linksList: 25,
  				noHairlines: 26,
  				noHairlinesBetween: 27,
  				noHairlinesMd: 28,
  				noHairlinesBetweenMd: 29,
  				noHairlinesIos: 30,
  				noHairlinesBetweenIos: 31,
  				noHairlinesAurora: 32,
  				noHairlinesBetweenAurora: 33,
  				noChevron: 34,
  				chevronCenter: 35,
  				tab: 36,
  				tabActive: 37,
  				form: 4,
  				formStoreData: 38,
  				inlineLabels: 39,
  				virtualList: 40,
  				virtualListParams: 41
  			},
  			[-1, -1]
  		);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "List",
  			options,
  			id: create_fragment$b.name
  		});
  	}

  	get id() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ul() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ul(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get inset() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set inset(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get xsmallInset() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set xsmallInset(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get smallInset() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set smallInset(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get mediumInset() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set mediumInset(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get largeInset() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set largeInset(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get xlargeInset() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set xlargeInset(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get mediaList() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set mediaList(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sortable() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sortable(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sortableTapHold() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sortableTapHold(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sortableEnabled() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sortableEnabled(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sortableMoveElements() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sortableMoveElements(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sortableOpposite() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sortableOpposite(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get accordionList() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set accordionList(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get accordionOpposite() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set accordionOpposite(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get contactsList() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set contactsList(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get simpleList() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set simpleList(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get linksList() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set linksList(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlines() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlines(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesBetween() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesBetween(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesMd() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesMd(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesBetweenMd() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesBetweenMd(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesIos() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesIos(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesBetweenIos() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesBetweenIos(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesAurora() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesAurora(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairlinesBetweenAurora() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairlinesBetweenAurora(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noChevron() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noChevron(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get chevronCenter() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set chevronCenter(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tab() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tab(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabActive() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabActive(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get form() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set form(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get formStoreData() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set formStoreData(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get inlineLabels() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set inlineLabels(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get virtualList() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set virtualList(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get virtualListParams() {
  		throw new Error("<List>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set virtualListParams(value) {
  		throw new Error("<List>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/nav-left.svelte generated by Svelte v3.21.0 */
  const file$c = "node_modules/framework7-svelte/components/nav-left.svelte";

  // (58:2) {#if backLink}
  function create_if_block$5(ctx) {
  	let current;

  	const link = new Link({
  			props: {
  				href: /*backLinkUrl*/ ctx[3] || "#",
  				back: true,
  				icon: "icon-back",
  				force: /*backLinkForce*/ ctx[4] || undefined,
  				class: !/*backLinkText*/ ctx[6] ? "icon-only" : undefined,
  				text: /*backLinkText*/ ctx[6],
  				onClick: /*onBackClick*/ ctx[7]
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(link.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(link, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const link_changes = {};
  			if (dirty & /*backLinkUrl*/ 8) link_changes.href = /*backLinkUrl*/ ctx[3] || "#";
  			if (dirty & /*backLinkForce*/ 16) link_changes.force = /*backLinkForce*/ ctx[4] || undefined;
  			if (dirty & /*backLinkText*/ 64) link_changes.class = !/*backLinkText*/ ctx[6] ? "icon-only" : undefined;
  			if (dirty & /*backLinkText*/ 64) link_changes.text = /*backLinkText*/ ctx[6];
  			link.$set(link_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(link.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(link.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(link, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$5.name,
  		type: "if",
  		source: "(58:2) {#if backLink}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$c(ctx) {
  	let div;
  	let t;
  	let current;
  	let if_block = /*backLink*/ ctx[2] && create_if_block$5(ctx);
  	const default_slot_template = /*$$slots*/ ctx[16].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block) if_block.c();
  			t = space();
  			if (default_slot) default_slot.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[5]);
  			add_location(div, file$c, 52, 0, 1350);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block) if_block.m(div, null);
  			append_dev(div, t);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (/*backLink*/ ctx[2]) {
  				if (if_block) {
  					if_block.p(ctx, dirty);

  					if (dirty & /*backLink*/ 4) {
  						transition_in(if_block, 1);
  					}
  				} else {
  					if_block = create_if_block$5(ctx);
  					if_block.c();
  					transition_in(if_block, 1);
  					if_block.m(div, t);
  				}
  			} else if (if_block) {
  				group_outros();

  				transition_out(if_block, 1, 1, () => {
  					if_block = null;
  				});

  				check_outros();
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 32768) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 32) {
  				attr_dev(div, "class", /*classes*/ ctx[5]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block) if_block.d();
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$c.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$c($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { backLink = undefined } = $$props;
  	let { backLinkUrl = undefined } = $$props;
  	let { backLinkForce = undefined } = $$props;
  	let { backLinkShowText = undefined } = $$props;
  	let { sliding = undefined } = $$props;

  	// eslint-disable-next-line
  	let _theme = f7.instance ? f7Theme : null;

  	if (!f7.instance) {
  		f7.ready(() => {
  			$$invalidate(11, _theme = f7Theme);
  		});
  	}

  	function onBackClick() {
  		dispatch("clickBack");
  		if (typeof $$props.onClickBack === "function") $$props.onClickBack();
  		dispatch("backClick");
  		if (typeof $$props.onBackClick === "function") $$props.onBackClick();
  	}

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Nav_left", $$slots, ['default']);

  	$$self.$set = $$new_props => {
  		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
  		if ("backLink" in $$new_props) $$invalidate(2, backLink = $$new_props.backLink);
  		if ("backLinkUrl" in $$new_props) $$invalidate(3, backLinkUrl = $$new_props.backLinkUrl);
  		if ("backLinkForce" in $$new_props) $$invalidate(4, backLinkForce = $$new_props.backLinkForce);
  		if ("backLinkShowText" in $$new_props) $$invalidate(9, backLinkShowText = $$new_props.backLinkShowText);
  		if ("sliding" in $$new_props) $$invalidate(10, sliding = $$new_props.sliding);
  		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher,
  		Mixins,
  		Utils: Utils$1,
  		f7,
  		theme: f7Theme,
  		Link,
  		dispatch,
  		id,
  		style,
  		className,
  		backLink,
  		backLinkUrl,
  		backLinkForce,
  		backLinkShowText,
  		sliding,
  		_theme,
  		onBackClick,
  		classes,
  		needBackLinkText,
  		backLinkText
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
  		if ("backLink" in $$props) $$invalidate(2, backLink = $$new_props.backLink);
  		if ("backLinkUrl" in $$props) $$invalidate(3, backLinkUrl = $$new_props.backLinkUrl);
  		if ("backLinkForce" in $$props) $$invalidate(4, backLinkForce = $$new_props.backLinkForce);
  		if ("backLinkShowText" in $$props) $$invalidate(9, backLinkShowText = $$new_props.backLinkShowText);
  		if ("sliding" in $$props) $$invalidate(10, sliding = $$new_props.sliding);
  		if ("_theme" in $$props) $$invalidate(11, _theme = $$new_props._theme);
  		if ("classes" in $$props) $$invalidate(5, classes = $$new_props.classes);
  		if ("needBackLinkText" in $$props) $$invalidate(12, needBackLinkText = $$new_props.needBackLinkText);
  		if ("backLinkText" in $$props) $$invalidate(6, backLinkText = $$new_props.backLinkText);
  	};

  	let classes;
  	let needBackLinkText;
  	let backLinkText;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(5, classes = Utils$1.classNames(className, "left", { sliding }, Mixins.colorClasses($$props)));

  		if ($$self.$$.dirty & /*backLinkShowText*/ 512) {
  			 $$invalidate(12, needBackLinkText = backLinkShowText);
  		}

  		if ($$self.$$.dirty & /*needBackLinkText, _theme*/ 6144) {
  			 if (typeof needBackLinkText === "undefined") $$invalidate(12, needBackLinkText = _theme && !_theme.md);
  		}

  		if ($$self.$$.dirty & /*backLink, needBackLinkText*/ 4100) {
  			 $$invalidate(6, backLinkText = backLink !== true && needBackLinkText
  			? backLink
  			: undefined);
  		}
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		backLink,
  		backLinkUrl,
  		backLinkForce,
  		classes,
  		backLinkText,
  		onBackClick,
  		className,
  		backLinkShowText,
  		sliding,
  		_theme,
  		needBackLinkText,
  		dispatch,
  		$$props,
  		$$scope,
  		$$slots
  	];
  }

  class Nav_left extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance$c, create_fragment$c, safe_not_equal, {
  			id: 0,
  			style: 1,
  			class: 8,
  			backLink: 2,
  			backLinkUrl: 3,
  			backLinkForce: 4,
  			backLinkShowText: 9,
  			sliding: 10
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Nav_left",
  			options,
  			id: create_fragment$c.name
  		});
  	}

  	get id() {
  		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get backLink() {
  		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set backLink(value) {
  		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get backLinkUrl() {
  		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set backLinkUrl(value) {
  		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get backLinkForce() {
  		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set backLinkForce(value) {
  		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get backLinkShowText() {
  		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set backLinkShowText(value) {
  		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sliding() {
  		throw new Error("<Nav_left>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sliding(value) {
  		throw new Error("<Nav_left>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/nav-right.svelte generated by Svelte v3.21.0 */
  const file$d = "node_modules/framework7-svelte/components/nav-right.svelte";

  function create_fragment$d(ctx) {
  	let div;
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[7].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[6], null);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (default_slot) default_slot.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[2]);
  			add_location(div, file$d, 21, 0, 386);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 64) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[6], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[6], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 4) {
  				attr_dev(div, "class", /*classes*/ ctx[2]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$d.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$d($$self, $$props, $$invalidate) {
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { sliding = undefined } = $$props;
  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Nav_right", $$slots, ['default']);

  	$$self.$set = $$new_props => {
  		$$invalidate(5, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(3, className = $$new_props.class);
  		if ("sliding" in $$new_props) $$invalidate(4, sliding = $$new_props.sliding);
  		if ("$$scope" in $$new_props) $$invalidate(6, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		Mixins,
  		Utils: Utils$1,
  		id,
  		style,
  		className,
  		sliding,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(5, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(3, className = $$new_props.className);
  		if ("sliding" in $$props) $$invalidate(4, sliding = $$new_props.sliding);
  		if ("classes" in $$props) $$invalidate(2, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(2, classes = Utils$1.classNames(className, "right", { sliding }, Mixins.colorClasses($$props)));
  	};

  	$$props = exclude_internal_props($$props);
  	return [id, style, classes, className, sliding, $$props, $$scope, $$slots];
  }

  class Nav_right extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$d, create_fragment$d, safe_not_equal, { id: 0, style: 1, class: 3, sliding: 4 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Nav_right",
  			options,
  			id: create_fragment$d.name
  		});
  	}

  	get id() {
  		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sliding() {
  		throw new Error("<Nav_right>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sliding(value) {
  		throw new Error("<Nav_right>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/nav-title.svelte generated by Svelte v3.21.0 */
  const file$e = "node_modules/framework7-svelte/components/nav-title.svelte";

  // (29:2) {#if typeof title !== 'undefined'}
  function create_if_block_1$5(ctx) {
  	let t_value = Utils$1.text(/*title*/ ctx[2]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*title*/ 4 && t_value !== (t_value = Utils$1.text(/*title*/ ctx[2]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$5.name,
  		type: "if",
  		source: "(29:2) {#if typeof title !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  // (30:2) {#if typeof subtitle !== 'undefined'}
  function create_if_block$6(ctx) {
  	let span;
  	let t_value = Utils$1.text(/*subtitle*/ ctx[3]) + "";
  	let t;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t = text$1(t_value);
  			attr_dev(span, "class", "subtitle");
  			add_location(span, file$e, 30, 4, 609);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*subtitle*/ 8 && t_value !== (t_value = Utils$1.text(/*subtitle*/ ctx[3]) + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$6.name,
  		type: "if",
  		source: "(30:2) {#if typeof subtitle !== 'undefined'}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$e(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let current;
  	let if_block0 = typeof /*title*/ ctx[2] !== "undefined" && create_if_block_1$5(ctx);
  	let if_block1 = typeof /*subtitle*/ ctx[3] !== "undefined" && create_if_block$6(ctx);
  	const default_slot_template = /*$$slots*/ ctx[9].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[8], null);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			if (if_block1) if_block1.c();
  			t1 = space();
  			if (default_slot) default_slot.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[4]);
  			add_location(div, file$e, 23, 0, 453);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t0);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t1);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (typeof /*title*/ ctx[2] !== "undefined") {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);
  				} else {
  					if_block0 = create_if_block_1$5(ctx);
  					if_block0.c();
  					if_block0.m(div, t0);
  				}
  			} else if (if_block0) {
  				if_block0.d(1);
  				if_block0 = null;
  			}

  			if (typeof /*subtitle*/ ctx[3] !== "undefined") {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);
  				} else {
  					if_block1 = create_if_block$6(ctx);
  					if_block1.c();
  					if_block1.m(div, t1);
  				}
  			} else if (if_block1) {
  				if_block1.d(1);
  				if_block1 = null;
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 256) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[8], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[8], dirty, null));
  				}
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 16) {
  				attr_dev(div, "class", /*classes*/ ctx[4]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$e.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$e($$self, $$props, $$invalidate) {
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { title = undefined } = $$props;
  	let { subtitle = undefined } = $$props;
  	let { sliding = undefined } = $$props;
  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Nav_title", $$slots, ['default']);

  	$$self.$set = $$new_props => {
  		$$invalidate(7, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(5, className = $$new_props.class);
  		if ("title" in $$new_props) $$invalidate(2, title = $$new_props.title);
  		if ("subtitle" in $$new_props) $$invalidate(3, subtitle = $$new_props.subtitle);
  		if ("sliding" in $$new_props) $$invalidate(6, sliding = $$new_props.sliding);
  		if ("$$scope" in $$new_props) $$invalidate(8, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		Mixins,
  		Utils: Utils$1,
  		id,
  		style,
  		className,
  		title,
  		subtitle,
  		sliding,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(7, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(5, className = $$new_props.className);
  		if ("title" in $$props) $$invalidate(2, title = $$new_props.title);
  		if ("subtitle" in $$props) $$invalidate(3, subtitle = $$new_props.subtitle);
  		if ("sliding" in $$props) $$invalidate(6, sliding = $$new_props.sliding);
  		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(4, classes = Utils$1.classNames(className, "title", { sliding }, Mixins.colorClasses($$props)));
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		title,
  		subtitle,
  		classes,
  		className,
  		sliding,
  		$$props,
  		$$scope,
  		$$slots
  	];
  }

  class Nav_title extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance$e, create_fragment$e, safe_not_equal, {
  			id: 0,
  			style: 1,
  			class: 5,
  			title: 2,
  			subtitle: 3,
  			sliding: 6
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Nav_title",
  			options,
  			id: create_fragment$e.name
  		});
  	}

  	get id() {
  		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get title() {
  		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set title(value) {
  		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get subtitle() {
  		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set subtitle(value) {
  		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sliding() {
  		throw new Error("<Nav_title>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sliding(value) {
  		throw new Error("<Nav_title>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/navbar.svelte generated by Svelte v3.21.0 */
  const file$f = "node_modules/framework7-svelte/components/navbar.svelte";
  const get_after_inner_slot_changes = dirty => ({});
  const get_after_inner_slot_context = ctx => ({});
  const get_title_large_slot_changes = dirty => ({});
  const get_title_large_slot_context = ctx => ({});
  const get_right_slot_changes = dirty => ({});
  const get_right_slot_context = ctx => ({});
  const get_nav_right_slot_changes = dirty => ({});
  const get_nav_right_slot_context = ctx => ({});
  const get_title_slot_changes$1 = dirty => ({});
  const get_title_slot_context$1 = ctx => ({});
  const get_left_slot_changes = dirty => ({});
  const get_left_slot_context = ctx => ({});
  const get_nav_left_slot_changes = dirty => ({});
  const get_nav_left_slot_context = ctx => ({});
  const get_before_inner_slot_changes = dirty => ({});
  const get_before_inner_slot_context = ctx => ({});

  // (221:4) {#if backLink || hasLeftSlots}
  function create_if_block_3$4(ctx) {
  	let current;

  	const navleft = new Nav_left({
  			props: {
  				backLink: /*backLink*/ ctx[2],
  				backLinkUrl: /*backLinkUrl*/ ctx[3],
  				backLinkForce: /*backLinkForce*/ ctx[4],
  				backLinkShowText: /*backLinkShowText*/ ctx[5],
  				onBackClick: /*onBackClick*/ ctx[17],
  				$$slots: { default: [create_default_slot_2$2] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(navleft.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(navleft, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const navleft_changes = {};
  			if (dirty[0] & /*backLink*/ 4) navleft_changes.backLink = /*backLink*/ ctx[2];
  			if (dirty[0] & /*backLinkUrl*/ 8) navleft_changes.backLinkUrl = /*backLinkUrl*/ ctx[3];
  			if (dirty[0] & /*backLinkForce*/ 16) navleft_changes.backLinkForce = /*backLinkForce*/ ctx[4];
  			if (dirty[0] & /*backLinkShowText*/ 32) navleft_changes.backLinkShowText = /*backLinkShowText*/ ctx[5];

  			if (dirty[1] & /*$$scope*/ 536870912) {
  				navleft_changes.$$scope = { dirty, ctx };
  			}

  			navleft.$set(navleft_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navleft.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navleft.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(navleft, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$4.name,
  		type: "if",
  		source: "(221:4) {#if backLink || hasLeftSlots}",
  		ctx
  	});

  	return block;
  }

  // (222:6) <NavLeft         backLink={backLink}         backLinkUrl={backLinkUrl}         backLinkForce={backLinkForce}         backLinkShowText={backLinkShowText}         onBackClick={onBackClick}       >
  function create_default_slot_2$2(ctx) {
  	let t;
  	let current;
  	const nav_left_slot_template = /*$$slots*/ ctx[58]["nav-left"];
  	const nav_left_slot = create_slot(nav_left_slot_template, ctx, /*$$scope*/ ctx[60], get_nav_left_slot_context);
  	const left_slot_template = /*$$slots*/ ctx[58].left;
  	const left_slot = create_slot(left_slot_template, ctx, /*$$scope*/ ctx[60], get_left_slot_context);

  	const block = {
  		c: function create() {
  			if (nav_left_slot) nav_left_slot.c();
  			t = space();
  			if (left_slot) left_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (nav_left_slot) {
  				nav_left_slot.m(target, anchor);
  			}

  			insert_dev(target, t, anchor);

  			if (left_slot) {
  				left_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (nav_left_slot) {
  				if (nav_left_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					nav_left_slot.p(get_slot_context(nav_left_slot_template, ctx, /*$$scope*/ ctx[60], get_nav_left_slot_context), get_slot_changes(nav_left_slot_template, /*$$scope*/ ctx[60], dirty, get_nav_left_slot_changes));
  				}
  			}

  			if (left_slot) {
  				if (left_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					left_slot.p(get_slot_context(left_slot_template, ctx, /*$$scope*/ ctx[60], get_left_slot_context), get_slot_changes(left_slot_template, /*$$scope*/ ctx[60], dirty, get_left_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(nav_left_slot, local);
  			transition_in(left_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(nav_left_slot, local);
  			transition_out(left_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (nav_left_slot) nav_left_slot.d(detaching);
  			if (detaching) detach_dev(t);
  			if (left_slot) left_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_2$2.name,
  		type: "slot",
  		source: "(222:6) <NavLeft         backLink={backLink}         backLinkUrl={backLinkUrl}         backLinkForce={backLinkForce}         backLinkShowText={backLinkShowText}         onBackClick={onBackClick}       >",
  		ctx
  	});

  	return block;
  }

  // (233:4) {#if title || subtitle || hasTitleSlots}
  function create_if_block_2$5(ctx) {
  	let current;

  	const navtitle = new Nav_title({
  			props: {
  				title: /*title*/ ctx[6],
  				subtitle: /*subtitle*/ ctx[7],
  				$$slots: { default: [create_default_slot_1$2] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(navtitle.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(navtitle, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const navtitle_changes = {};
  			if (dirty[0] & /*title*/ 64) navtitle_changes.title = /*title*/ ctx[6];
  			if (dirty[0] & /*subtitle*/ 128) navtitle_changes.subtitle = /*subtitle*/ ctx[7];

  			if (dirty[1] & /*$$scope*/ 536870912) {
  				navtitle_changes.$$scope = { dirty, ctx };
  			}

  			navtitle.$set(navtitle_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navtitle.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navtitle.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(navtitle, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$5.name,
  		type: "if",
  		source: "(233:4) {#if title || subtitle || hasTitleSlots}",
  		ctx
  	});

  	return block;
  }

  // (234:6) <NavTitle         title={title}         subtitle={subtitle}       >
  function create_default_slot_1$2(ctx) {
  	let current;
  	const title_slot_template = /*$$slots*/ ctx[58].title;
  	const title_slot = create_slot(title_slot_template, ctx, /*$$scope*/ ctx[60], get_title_slot_context$1);

  	const block = {
  		c: function create() {
  			if (title_slot) title_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (title_slot) {
  				title_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (title_slot) {
  				if (title_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					title_slot.p(get_slot_context(title_slot_template, ctx, /*$$scope*/ ctx[60], get_title_slot_context$1), get_slot_changes(title_slot_template, /*$$scope*/ ctx[60], dirty, get_title_slot_changes$1));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(title_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(title_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (title_slot) title_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1$2.name,
  		type: "slot",
  		source: "(234:6) <NavTitle         title={title}         subtitle={subtitle}       >",
  		ctx
  	});

  	return block;
  }

  // (241:4) {#if hasRightSlots}
  function create_if_block_1$6(ctx) {
  	let current;

  	const navright = new Nav_right({
  			props: {
  				$$slots: { default: [create_default_slot$2] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(navright.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(navright, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const navright_changes = {};

  			if (dirty[1] & /*$$scope*/ 536870912) {
  				navright_changes.$$scope = { dirty, ctx };
  			}

  			navright.$set(navright_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navright.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navright.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(navright, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$6.name,
  		type: "if",
  		source: "(241:4) {#if hasRightSlots}",
  		ctx
  	});

  	return block;
  }

  // (242:6) <NavRight>
  function create_default_slot$2(ctx) {
  	let t;
  	let current;
  	const nav_right_slot_template = /*$$slots*/ ctx[58]["nav-right"];
  	const nav_right_slot = create_slot(nav_right_slot_template, ctx, /*$$scope*/ ctx[60], get_nav_right_slot_context);
  	const right_slot_template = /*$$slots*/ ctx[58].right;
  	const right_slot = create_slot(right_slot_template, ctx, /*$$scope*/ ctx[60], get_right_slot_context);

  	const block = {
  		c: function create() {
  			if (nav_right_slot) nav_right_slot.c();
  			t = space();
  			if (right_slot) right_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (nav_right_slot) {
  				nav_right_slot.m(target, anchor);
  			}

  			insert_dev(target, t, anchor);

  			if (right_slot) {
  				right_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (nav_right_slot) {
  				if (nav_right_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					nav_right_slot.p(get_slot_context(nav_right_slot_template, ctx, /*$$scope*/ ctx[60], get_nav_right_slot_context), get_slot_changes(nav_right_slot_template, /*$$scope*/ ctx[60], dirty, get_nav_right_slot_changes));
  				}
  			}

  			if (right_slot) {
  				if (right_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					right_slot.p(get_slot_context(right_slot_template, ctx, /*$$scope*/ ctx[60], get_right_slot_context), get_slot_changes(right_slot_template, /*$$scope*/ ctx[60], dirty, get_right_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(nav_right_slot, local);
  			transition_in(right_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(nav_right_slot, local);
  			transition_out(right_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (nav_right_slot) nav_right_slot.d(detaching);
  			if (detaching) detach_dev(t);
  			if (right_slot) right_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$2.name,
  		type: "slot",
  		source: "(242:6) <NavRight>",
  		ctx
  	});

  	return block;
  }

  // (247:4) {#if largeTitle || hasTitleLargeSlots}
  function create_if_block$7(ctx) {
  	let div1;
  	let div0;
  	let t0_value = Utils$1.text(/*largeTitle*/ ctx[13]) + "";
  	let t0;
  	let t1;
  	let current;
  	const title_large_slot_template = /*$$slots*/ ctx[58]["title-large"];
  	const title_large_slot = create_slot(title_large_slot_template, ctx, /*$$scope*/ ctx[60], get_title_large_slot_context);

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			div0 = element("div");
  			t0 = text$1(t0_value);
  			t1 = space();
  			if (title_large_slot) title_large_slot.c();
  			attr_dev(div0, "class", "title-large-text");
  			add_location(div0, file$f, 248, 8, 7917);
  			attr_dev(div1, "class", "title-large");
  			add_location(div1, file$f, 247, 6, 7883);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			append_dev(div1, div0);
  			append_dev(div0, t0);
  			append_dev(div0, t1);

  			if (title_large_slot) {
  				title_large_slot.m(div0, null);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if ((!current || dirty[0] & /*largeTitle*/ 8192) && t0_value !== (t0_value = Utils$1.text(/*largeTitle*/ ctx[13]) + "")) set_data_dev(t0, t0_value);

  			if (title_large_slot) {
  				if (title_large_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					title_large_slot.p(get_slot_context(title_large_slot_template, ctx, /*$$scope*/ ctx[60], get_title_large_slot_context), get_slot_changes(title_large_slot_template, /*$$scope*/ ctx[60], dirty, get_title_large_slot_changes));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(title_large_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(title_large_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  			if (title_large_slot) title_large_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$7.name,
  		type: "if",
  		source: "(247:4) {#if largeTitle || hasTitleLargeSlots}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$f(ctx) {
  	let div2;
  	let div0;
  	let t0;
  	let t1;
  	let div1;
  	let t2;
  	let t3;
  	let t4;
  	let t5;
  	let t6;
  	let current;
  	const before_inner_slot_template = /*$$slots*/ ctx[58]["before-inner"];
  	const before_inner_slot = create_slot(before_inner_slot_template, ctx, /*$$scope*/ ctx[60], get_before_inner_slot_context);
  	let if_block0 = (/*backLink*/ ctx[2] || /*hasLeftSlots*/ ctx[10]) && create_if_block_3$4(ctx);
  	let if_block1 = (/*title*/ ctx[6] || /*subtitle*/ ctx[7] || /*hasTitleSlots*/ ctx[12]) && create_if_block_2$5(ctx);
  	let if_block2 = /*hasRightSlots*/ ctx[11] && create_if_block_1$6(ctx);
  	let if_block3 = (/*largeTitle*/ ctx[13] || /*hasTitleLargeSlots*/ ctx[14]) && create_if_block$7(ctx);
  	const default_slot_template = /*$$slots*/ ctx[58].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[60], null);
  	const after_inner_slot_template = /*$$slots*/ ctx[58]["after-inner"];
  	const after_inner_slot = create_slot(after_inner_slot_template, ctx, /*$$scope*/ ctx[60], get_after_inner_slot_context);

  	const block = {
  		c: function create() {
  			div2 = element("div");
  			div0 = element("div");
  			t0 = space();
  			if (before_inner_slot) before_inner_slot.c();
  			t1 = space();
  			div1 = element("div");
  			if (if_block0) if_block0.c();
  			t2 = space();
  			if (if_block1) if_block1.c();
  			t3 = space();
  			if (if_block2) if_block2.c();
  			t4 = space();
  			if (if_block3) if_block3.c();
  			t5 = space();
  			if (default_slot) default_slot.c();
  			t6 = space();
  			if (after_inner_slot) after_inner_slot.c();
  			attr_dev(div0, "class", "navbar-bg");
  			add_location(div0, file$f, 217, 2, 7104);
  			attr_dev(div1, "class", /*innerClasses*/ ctx[16]);
  			add_location(div1, file$f, 219, 2, 7172);
  			attr_dev(div2, "id", /*id*/ ctx[0]);
  			attr_dev(div2, "style", /*style*/ ctx[1]);
  			attr_dev(div2, "class", /*classes*/ ctx[15]);
  			attr_dev(div2, "data-f7-slot", /*f7Slot*/ ctx[8]);
  			add_location(div2, file$f, 210, 0, 7010);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div2, anchor);
  			append_dev(div2, div0);
  			append_dev(div2, t0);

  			if (before_inner_slot) {
  				before_inner_slot.m(div2, null);
  			}

  			append_dev(div2, t1);
  			append_dev(div2, div1);
  			if (if_block0) if_block0.m(div1, null);
  			append_dev(div1, t2);
  			if (if_block1) if_block1.m(div1, null);
  			append_dev(div1, t3);
  			if (if_block2) if_block2.m(div1, null);
  			append_dev(div1, t4);
  			if (if_block3) if_block3.m(div1, null);
  			append_dev(div1, t5);

  			if (default_slot) {
  				default_slot.m(div1, null);
  			}

  			append_dev(div2, t6);

  			if (after_inner_slot) {
  				after_inner_slot.m(div2, null);
  			}

  			/*div2_binding*/ ctx[59](div2);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (before_inner_slot) {
  				if (before_inner_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					before_inner_slot.p(get_slot_context(before_inner_slot_template, ctx, /*$$scope*/ ctx[60], get_before_inner_slot_context), get_slot_changes(before_inner_slot_template, /*$$scope*/ ctx[60], dirty, get_before_inner_slot_changes));
  				}
  			}

  			if (/*backLink*/ ctx[2] || /*hasLeftSlots*/ ctx[10]) {
  				if (if_block0) {
  					if_block0.p(ctx, dirty);

  					if (dirty[0] & /*backLink, hasLeftSlots*/ 1028) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_3$4(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div1, t2);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (/*title*/ ctx[6] || /*subtitle*/ ctx[7] || /*hasTitleSlots*/ ctx[12]) {
  				if (if_block1) {
  					if_block1.p(ctx, dirty);

  					if (dirty[0] & /*title, subtitle, hasTitleSlots*/ 4288) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_2$5(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div1, t3);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (/*hasRightSlots*/ ctx[11]) {
  				if (if_block2) {
  					if_block2.p(ctx, dirty);

  					if (dirty[0] & /*hasRightSlots*/ 2048) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_1$6(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(div1, t4);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (/*largeTitle*/ ctx[13] || /*hasTitleLargeSlots*/ ctx[14]) {
  				if (if_block3) {
  					if_block3.p(ctx, dirty);

  					if (dirty[0] & /*largeTitle, hasTitleLargeSlots*/ 24576) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block$7(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(div1, t5);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[60], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[60], dirty, null));
  				}
  			}

  			if (!current || dirty[0] & /*innerClasses*/ 65536) {
  				attr_dev(div1, "class", /*innerClasses*/ ctx[16]);
  			}

  			if (after_inner_slot) {
  				if (after_inner_slot.p && dirty[1] & /*$$scope*/ 536870912) {
  					after_inner_slot.p(get_slot_context(after_inner_slot_template, ctx, /*$$scope*/ ctx[60], get_after_inner_slot_context), get_slot_changes(after_inner_slot_template, /*$$scope*/ ctx[60], dirty, get_after_inner_slot_changes));
  				}
  			}

  			if (!current || dirty[0] & /*id*/ 1) {
  				attr_dev(div2, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty[0] & /*style*/ 2) {
  				attr_dev(div2, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty[0] & /*classes*/ 32768) {
  				attr_dev(div2, "class", /*classes*/ ctx[15]);
  			}

  			if (!current || dirty[0] & /*f7Slot*/ 256) {
  				attr_dev(div2, "data-f7-slot", /*f7Slot*/ ctx[8]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(before_inner_slot, local);
  			transition_in(if_block0);
  			transition_in(if_block1);
  			transition_in(if_block2);
  			transition_in(if_block3);
  			transition_in(default_slot, local);
  			transition_in(after_inner_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(before_inner_slot, local);
  			transition_out(if_block0);
  			transition_out(if_block1);
  			transition_out(if_block2);
  			transition_out(if_block3);
  			transition_out(default_slot, local);
  			transition_out(after_inner_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div2);
  			if (before_inner_slot) before_inner_slot.d(detaching);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (if_block2) if_block2.d();
  			if (if_block3) if_block3.d();
  			if (default_slot) default_slot.d(detaching);
  			if (after_inner_slot) after_inner_slot.d(detaching);
  			/*div2_binding*/ ctx[59](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$f.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$f($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { backLink = undefined } = $$props;
  	let { backLinkUrl = undefined } = $$props;
  	let { backLinkForce = false } = $$props;
  	let { backLinkShowText = undefined } = $$props;
  	let { sliding = true } = $$props;
  	let { title = undefined } = $$props;
  	let { subtitle = undefined } = $$props;
  	let { hidden = false } = $$props;
  	let { noShadow = false } = $$props;
  	let { noHairline = false } = $$props;
  	let { innerClass = undefined } = $$props;
  	let { innerClassName = undefined } = $$props;
  	let { large = false } = $$props;
  	let { largeTransparent = false } = $$props;
  	let { transparent = false } = $$props;
  	let { titleLarge = undefined } = $$props;
  	let { f7Slot = "fixed" } = $$props;
  	let el;

  	// eslint-disable-next-line
  	let _theme = f7.instance ? f7Theme : null;

  	let routerPositionClass = "";
  	let largeCollapsed = false;
  	let routerNavbarRole = null;
  	let routerNavbarRoleDetailRoot = false;
  	let routerNavbarMasterStack = false;
  	let transparentVisible = false;

  	function hide(animate) {
  		f7.navbar.hide(el, animate);
  	}

  	function show(animate) {
  		f7.navbar.show(el, animate);
  	}

  	function size() {
  		f7.navbar.size(el);
  	}

  	if (!f7.instance) {
  		f7.ready(() => {
  			$$invalidate(32, _theme = f7Theme);
  		});
  	}

  	function onHide(navbarEl) {
  		if (el !== navbarEl) return;
  		dispatch("navbarHide");
  		if (typeof $$props.onNavbarHide === "function") $$props.onNavbarHide();
  	}

  	function onShow(navbarEl) {
  		if (el !== navbarEl) return;
  		dispatch("navbarShow");
  		if (typeof $$props.onNavbarShow === "function") $$props.onNavbarShow();
  	}

  	function onNavbarTransparentShow(navbarEl) {
  		if (el !== navbarEl) return;
  		$$invalidate(38, transparentVisible = true);
  		dispatch("navbarTransparentShow");
  		if (typeof $$props.onNavbarTransparentShow === "function") $$props.onNavbarTransparentShow();
  	}

  	function onNavbarTransparentHide(navbarEl) {
  		if (el !== navbarEl) return;
  		$$invalidate(38, transparentVisible = false);
  		dispatch("navbarTransparentHide");
  		if (typeof $$props.onNavbarTransparentHide === "function") $$props.onNavbarTransparentHide();
  	}

  	function onExpand(navbarEl) {
  		if (el !== navbarEl) return;
  		$$invalidate(34, largeCollapsed = false);
  		dispatch("navbarExpand");
  		if (typeof $$props.onNavbarExpand === "function") $$props.onNavbarExpand();
  	}

  	function onCollapse(navbarEl) {
  		if (el !== navbarEl) return;
  		$$invalidate(34, largeCollapsed = true);
  		dispatch("navbarCollapse");
  		if (typeof $$props.onNavbarCollapse === "function") $$props.onNavbarCollapse();
  	}

  	function onNavbarPosition(navbarEl, position) {
  		if (el !== navbarEl) return;
  		$$invalidate(33, routerPositionClass = position ? `navbar-${position}` : position);
  	}

  	function onNavbarRole(navbarEl, rolesData) {
  		if (el !== navbarEl) return;
  		$$invalidate(35, routerNavbarRole = rolesData.role);
  		$$invalidate(36, routerNavbarRoleDetailRoot = rolesData.detailRoot);
  	}

  	function onNavbarMasterStack(navbarEl) {
  		if (el !== navbarEl) return;
  		$$invalidate(37, routerNavbarMasterStack = true);
  	}

  	function onNavbarMasterUnstack(navbarEl) {
  		if (el !== navbarEl) return;
  		$$invalidate(37, routerNavbarMasterStack = false);
  	}

  	function onBackClick() {
  		dispatch("clickBack");
  		if (typeof $$props.onClickBack === "function") $$props.onClickBack();
  	}

  	function mountNavbar() {
  		f7.instance.on("navbarShow", onShow);
  		f7.instance.on("navbarHide", onHide);
  		f7.instance.on("navbarCollapse", onCollapse);
  		f7.instance.on("navbarExpand", onExpand);
  		f7.instance.on("navbarPosition", onNavbarPosition);
  		f7.instance.on("navbarRole", onNavbarRole);
  		f7.instance.on("navbarMasterStack", onNavbarMasterStack);
  		f7.instance.on("navbarMasterUnstack", onNavbarMasterUnstack);
  		f7.instance.on("navbarTransparentShow", onNavbarTransparentShow);
  		f7.instance.on("navbarTransparentHide", onNavbarTransparentHide);
  	}

  	function destroyNavbar() {
  		f7.instance.off("navbarShow", onShow);
  		f7.instance.off("navbarHide", onHide);
  		f7.instance.off("navbarCollapse", onCollapse);
  		f7.instance.off("navbarExpand", onExpand);
  		f7.instance.off("navbarPosition", onNavbarPosition);
  		f7.instance.off("navbarRole", onNavbarRole);
  		f7.instance.off("navbarMasterStack", onNavbarMasterStack);
  		f7.instance.off("navbarMasterUnstack", onNavbarMasterUnstack);
  		f7.instance.off("navbarTransparentShow", onNavbarTransparentShow);
  		f7.instance.off("navbarTransparentHide", onNavbarTransparentHide);
  	}

  	onMount(() => {
  		f7.ready(() => {
  			mountNavbar();
  		});
  	});

  	afterUpdate(() => {
  		if (!f7.instance) return;
  		f7.instance.navbar.size(el);
  	});

  	onDestroy(() => {
  		if (!f7.instance) return;
  		destroyNavbar();
  	});

  	let { $$slots = {}, $$scope } = $$props;

  	validate_slots("Navbar", $$slots, [
  		'before-inner','nav-left','left','title','nav-right','right','title-large','default','after-inner'
  	]);

  	function div2_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(9, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(57, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(18, className = $$new_props.class);
  		if ("backLink" in $$new_props) $$invalidate(2, backLink = $$new_props.backLink);
  		if ("backLinkUrl" in $$new_props) $$invalidate(3, backLinkUrl = $$new_props.backLinkUrl);
  		if ("backLinkForce" in $$new_props) $$invalidate(4, backLinkForce = $$new_props.backLinkForce);
  		if ("backLinkShowText" in $$new_props) $$invalidate(5, backLinkShowText = $$new_props.backLinkShowText);
  		if ("sliding" in $$new_props) $$invalidate(19, sliding = $$new_props.sliding);
  		if ("title" in $$new_props) $$invalidate(6, title = $$new_props.title);
  		if ("subtitle" in $$new_props) $$invalidate(7, subtitle = $$new_props.subtitle);
  		if ("hidden" in $$new_props) $$invalidate(20, hidden = $$new_props.hidden);
  		if ("noShadow" in $$new_props) $$invalidate(21, noShadow = $$new_props.noShadow);
  		if ("noHairline" in $$new_props) $$invalidate(22, noHairline = $$new_props.noHairline);
  		if ("innerClass" in $$new_props) $$invalidate(23, innerClass = $$new_props.innerClass);
  		if ("innerClassName" in $$new_props) $$invalidate(24, innerClassName = $$new_props.innerClassName);
  		if ("large" in $$new_props) $$invalidate(25, large = $$new_props.large);
  		if ("largeTransparent" in $$new_props) $$invalidate(26, largeTransparent = $$new_props.largeTransparent);
  		if ("transparent" in $$new_props) $$invalidate(27, transparent = $$new_props.transparent);
  		if ("titleLarge" in $$new_props) $$invalidate(28, titleLarge = $$new_props.titleLarge);
  		if ("f7Slot" in $$new_props) $$invalidate(8, f7Slot = $$new_props.f7Slot);
  		if ("$$scope" in $$new_props) $$invalidate(60, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher,
  		onMount,
  		onDestroy,
  		afterUpdate,
  		Mixins,
  		Utils: Utils$1,
  		theme: f7Theme,
  		f7,
  		hasSlots,
  		NavLeft: Nav_left,
  		NavTitle: Nav_title,
  		NavRight: Nav_right,
  		dispatch,
  		id,
  		style,
  		className,
  		backLink,
  		backLinkUrl,
  		backLinkForce,
  		backLinkShowText,
  		sliding,
  		title,
  		subtitle,
  		hidden,
  		noShadow,
  		noHairline,
  		innerClass,
  		innerClassName,
  		large,
  		largeTransparent,
  		transparent,
  		titleLarge,
  		f7Slot,
  		el,
  		_theme,
  		routerPositionClass,
  		largeCollapsed,
  		routerNavbarRole,
  		routerNavbarRoleDetailRoot,
  		routerNavbarMasterStack,
  		transparentVisible,
  		hide,
  		show,
  		size,
  		onHide,
  		onShow,
  		onNavbarTransparentShow,
  		onNavbarTransparentHide,
  		onExpand,
  		onCollapse,
  		onNavbarPosition,
  		onNavbarRole,
  		onNavbarMasterStack,
  		onNavbarMasterUnstack,
  		onBackClick,
  		mountNavbar,
  		destroyNavbar,
  		hasLeftSlots,
  		hasRightSlots,
  		hasTitleSlots,
  		largeTitle,
  		hasTitleLargeSlots,
  		addLeftTitleClass,
  		addCenterTitleClass,
  		isLarge,
  		isTransparent,
  		isTransparentVisible,
  		classes,
  		innerClasses
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(57, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(18, className = $$new_props.className);
  		if ("backLink" in $$props) $$invalidate(2, backLink = $$new_props.backLink);
  		if ("backLinkUrl" in $$props) $$invalidate(3, backLinkUrl = $$new_props.backLinkUrl);
  		if ("backLinkForce" in $$props) $$invalidate(4, backLinkForce = $$new_props.backLinkForce);
  		if ("backLinkShowText" in $$props) $$invalidate(5, backLinkShowText = $$new_props.backLinkShowText);
  		if ("sliding" in $$props) $$invalidate(19, sliding = $$new_props.sliding);
  		if ("title" in $$props) $$invalidate(6, title = $$new_props.title);
  		if ("subtitle" in $$props) $$invalidate(7, subtitle = $$new_props.subtitle);
  		if ("hidden" in $$props) $$invalidate(20, hidden = $$new_props.hidden);
  		if ("noShadow" in $$props) $$invalidate(21, noShadow = $$new_props.noShadow);
  		if ("noHairline" in $$props) $$invalidate(22, noHairline = $$new_props.noHairline);
  		if ("innerClass" in $$props) $$invalidate(23, innerClass = $$new_props.innerClass);
  		if ("innerClassName" in $$props) $$invalidate(24, innerClassName = $$new_props.innerClassName);
  		if ("large" in $$props) $$invalidate(25, large = $$new_props.large);
  		if ("largeTransparent" in $$props) $$invalidate(26, largeTransparent = $$new_props.largeTransparent);
  		if ("transparent" in $$props) $$invalidate(27, transparent = $$new_props.transparent);
  		if ("titleLarge" in $$props) $$invalidate(28, titleLarge = $$new_props.titleLarge);
  		if ("f7Slot" in $$props) $$invalidate(8, f7Slot = $$new_props.f7Slot);
  		if ("el" in $$props) $$invalidate(9, el = $$new_props.el);
  		if ("_theme" in $$props) $$invalidate(32, _theme = $$new_props._theme);
  		if ("routerPositionClass" in $$props) $$invalidate(33, routerPositionClass = $$new_props.routerPositionClass);
  		if ("largeCollapsed" in $$props) $$invalidate(34, largeCollapsed = $$new_props.largeCollapsed);
  		if ("routerNavbarRole" in $$props) $$invalidate(35, routerNavbarRole = $$new_props.routerNavbarRole);
  		if ("routerNavbarRoleDetailRoot" in $$props) $$invalidate(36, routerNavbarRoleDetailRoot = $$new_props.routerNavbarRoleDetailRoot);
  		if ("routerNavbarMasterStack" in $$props) $$invalidate(37, routerNavbarMasterStack = $$new_props.routerNavbarMasterStack);
  		if ("transparentVisible" in $$props) $$invalidate(38, transparentVisible = $$new_props.transparentVisible);
  		if ("hasLeftSlots" in $$props) $$invalidate(10, hasLeftSlots = $$new_props.hasLeftSlots);
  		if ("hasRightSlots" in $$props) $$invalidate(11, hasRightSlots = $$new_props.hasRightSlots);
  		if ("hasTitleSlots" in $$props) $$invalidate(12, hasTitleSlots = $$new_props.hasTitleSlots);
  		if ("largeTitle" in $$props) $$invalidate(13, largeTitle = $$new_props.largeTitle);
  		if ("hasTitleLargeSlots" in $$props) $$invalidate(14, hasTitleLargeSlots = $$new_props.hasTitleLargeSlots);
  		if ("addLeftTitleClass" in $$props) $$invalidate(39, addLeftTitleClass = $$new_props.addLeftTitleClass);
  		if ("addCenterTitleClass" in $$props) $$invalidate(40, addCenterTitleClass = $$new_props.addCenterTitleClass);
  		if ("isLarge" in $$props) $$invalidate(41, isLarge = $$new_props.isLarge);
  		if ("isTransparent" in $$props) $$invalidate(42, isTransparent = $$new_props.isTransparent);
  		if ("isTransparentVisible" in $$props) $$invalidate(43, isTransparentVisible = $$new_props.isTransparentVisible);
  		if ("classes" in $$props) $$invalidate(15, classes = $$new_props.classes);
  		if ("innerClasses" in $$props) $$invalidate(16, innerClasses = $$new_props.innerClasses);
  	};

  	let hasLeftSlots;
  	let hasRightSlots;
  	let hasTitleSlots;
  	let largeTitle;
  	let hasTitleLargeSlots;
  	let addLeftTitleClass;
  	let addCenterTitleClass;
  	let isLarge;
  	let isTransparent;
  	let isTransparentVisible;
  	let classes;
  	let innerClasses;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[0] & /*titleLarge, large, title*/ 301989952) {
  			 $$invalidate(13, largeTitle = titleLarge || large && title);
  		}

  		if ($$self.$$.dirty[1] & /*_theme*/ 2) {
  			 $$invalidate(39, addLeftTitleClass = _theme && _theme.ios && f7.instance && !f7.instance.params.navbar.iosCenterTitle);
  		}

  		if ($$self.$$.dirty[1] & /*_theme*/ 2) {
  			 $$invalidate(40, addCenterTitleClass = _theme && _theme.md && f7.instance && f7.instance.params.navbar.mdCenterTitle || _theme && _theme.aurora && f7.instance && f7.instance.params.navbar.auroraCenterTitle);
  		}

  		if ($$self.$$.dirty[0] & /*large, largeTransparent*/ 100663296) {
  			 $$invalidate(41, isLarge = large || largeTransparent);
  		}

  		if ($$self.$$.dirty[0] & /*transparent, largeTransparent*/ 201326592 | $$self.$$.dirty[1] & /*isLarge*/ 1024) {
  			 $$invalidate(42, isTransparent = transparent || isLarge && largeTransparent);
  		}

  		if ($$self.$$.dirty[1] & /*isTransparent, transparentVisible*/ 2176) {
  			 $$invalidate(43, isTransparentVisible = isTransparent && transparentVisible);
  		}

  		 $$invalidate(15, classes = Utils$1.classNames(
  			className,
  			"navbar",
  			routerPositionClass,
  			{
  				"navbar-hidden": hidden,
  				"navbar-large": isLarge,
  				"navbar-large-collapsed": isLarge && largeCollapsed,
  				"navbar-transparent": isTransparent,
  				"navbar-transparent-visible": isTransparentVisible,
  				"navbar-master": routerNavbarRole === "master",
  				"navbar-master-detail": routerNavbarRole === "detail",
  				"navbar-master-detail-root": routerNavbarRoleDetailRoot === true,
  				"navbar-master-stacked": routerNavbarMasterStack === true,
  				"no-shadow": noShadow,
  				"no-hairline": noHairline
  			},
  			Mixins.colorClasses($$props)
  		));

  		if ($$self.$$.dirty[0] & /*innerClass, innerClassName, sliding*/ 25690112 | $$self.$$.dirty[1] & /*addLeftTitleClass, addCenterTitleClass*/ 768) {
  			 $$invalidate(16, innerClasses = Utils$1.classNames("navbar-inner", innerClass, innerClassName, {
  				sliding,
  				"navbar-inner-left-title": addLeftTitleClass,
  				"navbar-inner-centered-title": addCenterTitleClass
  			}));
  		}
  	};

  	 $$invalidate(10, hasLeftSlots = hasSlots(arguments, "nav-left") || hasSlots(arguments, "left"));

  	// eslint-disable-next-line
  	 $$invalidate(11, hasRightSlots = hasSlots(arguments, "nav-right") || hasSlots(arguments, "right"));

  	// eslint-disable-next-line
  	 $$invalidate(12, hasTitleSlots = hasSlots(arguments, "title"));

  	// eslint-disable-next-line
  	 $$invalidate(14, hasTitleLargeSlots = hasSlots(arguments, "title-large"));

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		backLink,
  		backLinkUrl,
  		backLinkForce,
  		backLinkShowText,
  		title,
  		subtitle,
  		f7Slot,
  		el,
  		hasLeftSlots,
  		hasRightSlots,
  		hasTitleSlots,
  		largeTitle,
  		hasTitleLargeSlots,
  		classes,
  		innerClasses,
  		onBackClick,
  		className,
  		sliding,
  		hidden,
  		noShadow,
  		noHairline,
  		innerClass,
  		innerClassName,
  		large,
  		largeTransparent,
  		transparent,
  		titleLarge,
  		hide,
  		show,
  		size,
  		_theme,
  		routerPositionClass,
  		largeCollapsed,
  		routerNavbarRole,
  		routerNavbarRoleDetailRoot,
  		routerNavbarMasterStack,
  		transparentVisible,
  		addLeftTitleClass,
  		addCenterTitleClass,
  		isLarge,
  		isTransparent,
  		isTransparentVisible,
  		dispatch,
  		onHide,
  		onShow,
  		onNavbarTransparentShow,
  		onNavbarTransparentHide,
  		onExpand,
  		onCollapse,
  		onNavbarPosition,
  		onNavbarRole,
  		onNavbarMasterStack,
  		onNavbarMasterUnstack,
  		mountNavbar,
  		destroyNavbar,
  		$$props,
  		$$slots,
  		div2_binding,
  		$$scope
  	];
  }

  class Navbar$2 extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(
  			this,
  			options,
  			instance$f,
  			create_fragment$f,
  			safe_not_equal,
  			{
  				id: 0,
  				style: 1,
  				class: 18,
  				backLink: 2,
  				backLinkUrl: 3,
  				backLinkForce: 4,
  				backLinkShowText: 5,
  				sliding: 19,
  				title: 6,
  				subtitle: 7,
  				hidden: 20,
  				noShadow: 21,
  				noHairline: 22,
  				innerClass: 23,
  				innerClassName: 24,
  				large: 25,
  				largeTransparent: 26,
  				transparent: 27,
  				titleLarge: 28,
  				f7Slot: 8,
  				hide: 29,
  				show: 30,
  				size: 31
  			},
  			[-1, -1]
  		);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Navbar",
  			options,
  			id: create_fragment$f.name
  		});
  	}

  	get id() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get backLink() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set backLink(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get backLinkUrl() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set backLinkUrl(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get backLinkForce() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set backLinkForce(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get backLinkShowText() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set backLinkShowText(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get sliding() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set sliding(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get title() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set title(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get subtitle() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set subtitle(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get hidden() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set hidden(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noShadow() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noShadow(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noHairline() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noHairline(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get innerClass() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set innerClass(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get innerClassName() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set innerClassName(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get large() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set large(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get largeTransparent() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set largeTransparent(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get transparent() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set transparent(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get titleLarge() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set titleLarge(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get f7Slot() {
  		throw new Error("<Navbar>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set f7Slot(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get hide() {
  		return this.$$.ctx[29];
  	}

  	set hide(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get show() {
  		return this.$$.ctx[30];
  	}

  	set show(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get size() {
  		return this.$$.ctx[31];
  	}

  	set size(value) {
  		throw new Error("<Navbar>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/preloader.svelte generated by Svelte v3.21.0 */
  const file$g = "node_modules/framework7-svelte/components/preloader.svelte";

  // (67:2) {:else}
  function create_else_block$3(ctx) {
  	let span;

  	const block = {
  		c: function create() {
  			span = element("span");
  			attr_dev(span, "class", "preloader-inner");
  			add_location(span, file$g, 67, 2, 2042);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$3.name,
  		type: "else",
  		source: "(67:2) {:else}",
  		ctx
  	});

  	return block;
  }

  // (63:36) 
  function create_if_block_2$6(ctx) {
  	let span1;
  	let span0;

  	const block = {
  		c: function create() {
  			span1 = element("span");
  			span0 = element("span");
  			attr_dev(span0, "class", "preloader-inner-circle");
  			add_location(span0, file$g, 64, 4, 1975);
  			attr_dev(span1, "class", "preloader-inner");
  			add_location(span1, file$g, 63, 2, 1940);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span1, anchor);
  			append_dev(span1, span0);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span1);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$6.name,
  		type: "if",
  		source: "(63:36) ",
  		ctx
  	});

  	return block;
  }

  // (48:33) 
  function create_if_block_1$7(ctx) {
  	let span12;
  	let span0;
  	let t0;
  	let span1;
  	let t1;
  	let span2;
  	let t2;
  	let span3;
  	let t3;
  	let span4;
  	let t4;
  	let span5;
  	let t5;
  	let span6;
  	let t6;
  	let span7;
  	let t7;
  	let span8;
  	let t8;
  	let span9;
  	let t9;
  	let span10;
  	let t10;
  	let span11;

  	const block = {
  		c: function create() {
  			span12 = element("span");
  			span0 = element("span");
  			t0 = space();
  			span1 = element("span");
  			t1 = space();
  			span2 = element("span");
  			t2 = space();
  			span3 = element("span");
  			t3 = space();
  			span4 = element("span");
  			t4 = space();
  			span5 = element("span");
  			t5 = space();
  			span6 = element("span");
  			t6 = space();
  			span7 = element("span");
  			t7 = space();
  			span8 = element("span");
  			t8 = space();
  			span9 = element("span");
  			t9 = space();
  			span10 = element("span");
  			t10 = space();
  			span11 = element("span");
  			attr_dev(span0, "class", "preloader-inner-line");
  			add_location(span0, file$g, 49, 4, 1331);
  			attr_dev(span1, "class", "preloader-inner-line");
  			add_location(span1, file$g, 50, 4, 1378);
  			attr_dev(span2, "class", "preloader-inner-line");
  			add_location(span2, file$g, 51, 4, 1425);
  			attr_dev(span3, "class", "preloader-inner-line");
  			add_location(span3, file$g, 52, 4, 1472);
  			attr_dev(span4, "class", "preloader-inner-line");
  			add_location(span4, file$g, 53, 4, 1519);
  			attr_dev(span5, "class", "preloader-inner-line");
  			add_location(span5, file$g, 54, 4, 1566);
  			attr_dev(span6, "class", "preloader-inner-line");
  			add_location(span6, file$g, 55, 4, 1613);
  			attr_dev(span7, "class", "preloader-inner-line");
  			add_location(span7, file$g, 56, 4, 1660);
  			attr_dev(span8, "class", "preloader-inner-line");
  			add_location(span8, file$g, 57, 4, 1707);
  			attr_dev(span9, "class", "preloader-inner-line");
  			add_location(span9, file$g, 58, 4, 1754);
  			attr_dev(span10, "class", "preloader-inner-line");
  			add_location(span10, file$g, 59, 4, 1801);
  			attr_dev(span11, "class", "preloader-inner-line");
  			add_location(span11, file$g, 60, 4, 1848);
  			attr_dev(span12, "class", "preloader-inner");
  			add_location(span12, file$g, 48, 2, 1296);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span12, anchor);
  			append_dev(span12, span0);
  			append_dev(span12, t0);
  			append_dev(span12, span1);
  			append_dev(span12, t1);
  			append_dev(span12, span2);
  			append_dev(span12, t2);
  			append_dev(span12, span3);
  			append_dev(span12, t3);
  			append_dev(span12, span4);
  			append_dev(span12, t4);
  			append_dev(span12, span5);
  			append_dev(span12, t5);
  			append_dev(span12, span6);
  			append_dev(span12, t6);
  			append_dev(span12, span7);
  			append_dev(span12, t7);
  			append_dev(span12, span8);
  			append_dev(span12, t8);
  			append_dev(span12, span9);
  			append_dev(span12, t9);
  			append_dev(span12, span10);
  			append_dev(span12, t10);
  			append_dev(span12, span11);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span12);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$7.name,
  		type: "if",
  		source: "(48:33) ",
  		ctx
  	});

  	return block;
  }

  // (38:2) {#if _theme && _theme.md}
  function create_if_block$8(ctx) {
  	let span5;
  	let span0;
  	let t0;
  	let span2;
  	let span1;
  	let t1;
  	let span4;
  	let span3;

  	const block = {
  		c: function create() {
  			span5 = element("span");
  			span0 = element("span");
  			t0 = space();
  			span2 = element("span");
  			span1 = element("span");
  			t1 = space();
  			span4 = element("span");
  			span3 = element("span");
  			attr_dev(span0, "class", "preloader-inner-gap");
  			add_location(span0, file$g, 39, 4, 1006);
  			attr_dev(span1, "class", "preloader-inner-half-circle");
  			add_location(span1, file$g, 41, 6, 1089);
  			attr_dev(span2, "class", "preloader-inner-left");
  			add_location(span2, file$g, 40, 4, 1047);
  			attr_dev(span3, "class", "preloader-inner-half-circle");
  			add_location(span3, file$g, 44, 6, 1193);
  			attr_dev(span4, "class", "preloader-inner-right");
  			add_location(span4, file$g, 43, 4, 1150);
  			attr_dev(span5, "class", "preloader-inner");
  			add_location(span5, file$g, 38, 2, 971);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span5, anchor);
  			append_dev(span5, span0);
  			append_dev(span5, t0);
  			append_dev(span5, span2);
  			append_dev(span2, span1);
  			append_dev(span5, t1);
  			append_dev(span5, span4);
  			append_dev(span4, span3);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span5);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$8.name,
  		type: "if",
  		source: "(38:2) {#if _theme && _theme.md}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$g(ctx) {
  	let span;

  	function select_block_type(ctx, dirty) {
  		if (/*_theme*/ ctx[1] && /*_theme*/ ctx[1].md) return create_if_block$8;
  		if (/*_theme*/ ctx[1] && /*_theme*/ ctx[1].ios) return create_if_block_1$7;
  		if (/*_theme*/ ctx[1] && /*_theme*/ ctx[1].aurora) return create_if_block_2$6;
  		return create_else_block$3;
  	}

  	let current_block_type = select_block_type(ctx);
  	let if_block = current_block_type(ctx);

  	const block = {
  		c: function create() {
  			span = element("span");
  			if_block.c();
  			attr_dev(span, "id", /*id*/ ctx[0]);
  			attr_dev(span, "style", /*preloaderStyle*/ ctx[2]);
  			attr_dev(span, "class", /*classes*/ ctx[3]);
  			add_location(span, file$g, 36, 0, 887);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			if_block.m(span, null);
  		},
  		p: function update(ctx, [dirty]) {
  			if (current_block_type !== (current_block_type = select_block_type(ctx))) {
  				if_block.d(1);
  				if_block = current_block_type(ctx);

  				if (if_block) {
  					if_block.c();
  					if_block.m(span, null);
  				}
  			}

  			if (dirty & /*id*/ 1) {
  				attr_dev(span, "id", /*id*/ ctx[0]);
  			}

  			if (dirty & /*preloaderStyle*/ 4) {
  				attr_dev(span, "style", /*preloaderStyle*/ ctx[2]);
  			}

  			if (dirty & /*classes*/ 8) {
  				attr_dev(span, "class", /*classes*/ ctx[3]);
  			}
  		},
  		i: noop,
  		o: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  			if_block.d();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$g.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$g($$self, $$props, $$invalidate) {
  	let { class: className = undefined } = $$props;
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { size = undefined } = $$props;

  	// eslint-disable-next-line
  	let _theme = f7.instance ? f7Theme : null;

  	if (!f7.instance) {
  		f7.ready(() => {
  			$$invalidate(1, _theme = f7Theme);
  		});
  	}

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Preloader", $$slots, []);

  	$$self.$set = $$new_props => {
  		$$invalidate(8, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("class" in $$new_props) $$invalidate(4, className = $$new_props.class);
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(5, style = $$new_props.style);
  		if ("size" in $$new_props) $$invalidate(6, size = $$new_props.size);
  	};

  	$$self.$capture_state = () => ({
  		theme: f7Theme,
  		Utils: Utils$1,
  		Mixins,
  		f7,
  		className,
  		id,
  		style,
  		size,
  		_theme,
  		sizeComputed,
  		preloaderStyle,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(8, $$props = assign(assign({}, $$props), $$new_props));
  		if ("className" in $$props) $$invalidate(4, className = $$new_props.className);
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(5, style = $$new_props.style);
  		if ("size" in $$props) $$invalidate(6, size = $$new_props.size);
  		if ("_theme" in $$props) $$invalidate(1, _theme = $$new_props._theme);
  		if ("sizeComputed" in $$props) $$invalidate(7, sizeComputed = $$new_props.sizeComputed);
  		if ("preloaderStyle" in $$props) $$invalidate(2, preloaderStyle = $$new_props.preloaderStyle);
  		if ("classes" in $$props) $$invalidate(3, classes = $$new_props.classes);
  	};

  	let sizeComputed;
  	let preloaderStyle;
  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*size*/ 64) {
  			 $$invalidate(7, sizeComputed = size && typeof size === "string" && size.indexOf("px") >= 0
  			? size.replace("px", "")
  			: size);
  		}

  		if ($$self.$$.dirty & /*style, sizeComputed*/ 160) {
  			 $$invalidate(2, preloaderStyle = ((style || "") + (sizeComputed
  			? `;width: ${sizeComputed}px; height: ${sizeComputed}px; --f7-preloader-size: ${sizeComputed}px`
  			: "")).replace(";;", ";"));
  		}

  		 $$invalidate(3, classes = Utils$1.classNames(className, "preloader", Mixins.colorClasses($$props)));
  	};

  	$$props = exclude_internal_props($$props);
  	return [id, _theme, preloaderStyle, classes, className, style, size];
  }

  class Preloader$2 extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$g, create_fragment$g, safe_not_equal, { class: 4, id: 0, style: 5, size: 6 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Preloader",
  			options,
  			id: create_fragment$g.name
  		});
  	}

  	get class() {
  		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get id() {
  		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get size() {
  		throw new Error("<Preloader>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set size(value) {
  		throw new Error("<Preloader>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/page-content.svelte generated by Svelte v3.21.0 */
  const file$h = "node_modules/framework7-svelte/components/page-content.svelte";

  // (150:2) {#if ptr && ptrPreloader && !ptrBottom}
  function create_if_block_3$5(ctx) {
  	let div1;
  	let t;
  	let div0;
  	let current;
  	const preloader = new Preloader$2({ $$inline: true });

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			create_component(preloader.$$.fragment);
  			t = space();
  			div0 = element("div");
  			attr_dev(div0, "class", "ptr-arrow");
  			add_location(div0, file$h, 152, 6, 4512);
  			attr_dev(div1, "class", "ptr-preloader");
  			add_location(div1, file$h, 150, 4, 4458);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			mount_component(preloader, div1, null);
  			append_dev(div1, t);
  			append_dev(div1, div0);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(preloader.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(preloader.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  			destroy_component(preloader);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$5.name,
  		type: "if",
  		source: "(150:2) {#if ptr && ptrPreloader && !ptrBottom}",
  		ctx
  	});

  	return block;
  }

  // (156:2) {#if infinite && infiniteTop && infinitePreloader}
  function create_if_block_2$7(ctx) {
  	let current;

  	const preloader = new Preloader$2({
  			props: { class: "infinite-scroll-preloader" },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(preloader.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(preloader, target, anchor);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(preloader.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(preloader.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(preloader, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$7.name,
  		type: "if",
  		source: "(156:2) {#if infinite && infiniteTop && infinitePreloader}",
  		ctx
  	});

  	return block;
  }

  // (160:2) {#if infinite && !infiniteTop && infinitePreloader}
  function create_if_block_1$8(ctx) {
  	let current;

  	const preloader = new Preloader$2({
  			props: { class: "infinite-scroll-preloader" },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(preloader.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(preloader, target, anchor);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(preloader.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(preloader.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(preloader, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$8.name,
  		type: "if",
  		source: "(160:2) {#if infinite && !infiniteTop && infinitePreloader}",
  		ctx
  	});

  	return block;
  }

  // (163:2) {#if ptr && ptrPreloader && ptrBottom}
  function create_if_block$9(ctx) {
  	let div1;
  	let t;
  	let div0;
  	let current;
  	const preloader = new Preloader$2({ $$inline: true });

  	const block = {
  		c: function create() {
  			div1 = element("div");
  			create_component(preloader.$$.fragment);
  			t = space();
  			div0 = element("div");
  			attr_dev(div0, "class", "ptr-arrow");
  			add_location(div0, file$h, 165, 6, 4892);
  			attr_dev(div1, "class", "ptr-preloader");
  			add_location(div1, file$h, 163, 4, 4838);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div1, anchor);
  			mount_component(preloader, div1, null);
  			append_dev(div1, t);
  			append_dev(div1, div0);
  			current = true;
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(preloader.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(preloader.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div1);
  			destroy_component(preloader);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$9.name,
  		type: "if",
  		source: "(163:2) {#if ptr && ptrPreloader && ptrBottom}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$h(ctx) {
  	let div;
  	let t0;
  	let t1;
  	let t2;
  	let t3;
  	let div_data_ptr_mousewheel_value;
  	let div_data_infinite_distance_value;
  	let current;
  	let if_block0 = /*ptr*/ ctx[2] && /*ptrPreloader*/ ctx[4] && !/*ptrBottom*/ ctx[5] && create_if_block_3$5(ctx);
  	let if_block1 = /*infinite*/ ctx[7] && /*infiniteTop*/ ctx[8] && /*infinitePreloader*/ ctx[10] && create_if_block_2$7(ctx);
  	const default_slot_template = /*$$slots*/ ctx[34].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[33], null);
  	let if_block2 = /*infinite*/ ctx[7] && !/*infiniteTop*/ ctx[8] && /*infinitePreloader*/ ctx[10] && create_if_block_1$8(ctx);
  	let if_block3 = /*ptr*/ ctx[2] && /*ptrPreloader*/ ctx[4] && /*ptrBottom*/ ctx[5] && create_if_block$9(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (if_block0) if_block0.c();
  			t0 = space();
  			if (if_block1) if_block1.c();
  			t1 = space();
  			if (default_slot) default_slot.c();
  			t2 = space();
  			if (if_block2) if_block2.c();
  			t3 = space();
  			if (if_block3) if_block3.c();
  			attr_dev(div, "class", /*pageContentClasses*/ ctx[12]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "data-ptr-distance", /*ptrDistance*/ ctx[3]);
  			attr_dev(div, "data-ptr-mousewheel", div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[6] || undefined);
  			attr_dev(div, "data-infinite-distance", div_data_infinite_distance_value = /*infiniteDistance*/ ctx[9] || undefined);
  			add_location(div, file$h, 140, 0, 4180);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);
  			if (if_block0) if_block0.m(div, null);
  			append_dev(div, t0);
  			if (if_block1) if_block1.m(div, null);
  			append_dev(div, t1);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			append_dev(div, t2);
  			if (if_block2) if_block2.m(div, null);
  			append_dev(div, t3);
  			if (if_block3) if_block3.m(div, null);
  			/*div_binding*/ ctx[35](div);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*ptr*/ ctx[2] && /*ptrPreloader*/ ctx[4] && !/*ptrBottom*/ ctx[5]) {
  				if (if_block0) {
  					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 52) {
  						transition_in(if_block0, 1);
  					}
  				} else {
  					if_block0 = create_if_block_3$5(ctx);
  					if_block0.c();
  					transition_in(if_block0, 1);
  					if_block0.m(div, t0);
  				}
  			} else if (if_block0) {
  				group_outros();

  				transition_out(if_block0, 1, 1, () => {
  					if_block0 = null;
  				});

  				check_outros();
  			}

  			if (/*infinite*/ ctx[7] && /*infiniteTop*/ ctx[8] && /*infinitePreloader*/ ctx[10]) {
  				if (if_block1) {
  					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 1408) {
  						transition_in(if_block1, 1);
  					}
  				} else {
  					if_block1 = create_if_block_2$7(ctx);
  					if_block1.c();
  					transition_in(if_block1, 1);
  					if_block1.m(div, t1);
  				}
  			} else if (if_block1) {
  				group_outros();

  				transition_out(if_block1, 1, 1, () => {
  					if_block1 = null;
  				});

  				check_outros();
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[1] & /*$$scope*/ 4) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[33], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[33], dirty, null));
  				}
  			}

  			if (/*infinite*/ ctx[7] && !/*infiniteTop*/ ctx[8] && /*infinitePreloader*/ ctx[10]) {
  				if (if_block2) {
  					if (dirty[0] & /*infinite, infiniteTop, infinitePreloader*/ 1408) {
  						transition_in(if_block2, 1);
  					}
  				} else {
  					if_block2 = create_if_block_1$8(ctx);
  					if_block2.c();
  					transition_in(if_block2, 1);
  					if_block2.m(div, t3);
  				}
  			} else if (if_block2) {
  				group_outros();

  				transition_out(if_block2, 1, 1, () => {
  					if_block2 = null;
  				});

  				check_outros();
  			}

  			if (/*ptr*/ ctx[2] && /*ptrPreloader*/ ctx[4] && /*ptrBottom*/ ctx[5]) {
  				if (if_block3) {
  					if (dirty[0] & /*ptr, ptrPreloader, ptrBottom*/ 52) {
  						transition_in(if_block3, 1);
  					}
  				} else {
  					if_block3 = create_if_block$9(ctx);
  					if_block3.c();
  					transition_in(if_block3, 1);
  					if_block3.m(div, null);
  				}
  			} else if (if_block3) {
  				group_outros();

  				transition_out(if_block3, 1, 1, () => {
  					if_block3 = null;
  				});

  				check_outros();
  			}

  			if (!current || dirty[0] & /*pageContentClasses*/ 4096) {
  				attr_dev(div, "class", /*pageContentClasses*/ ctx[12]);
  			}

  			if (!current || dirty[0] & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty[0] & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty[0] & /*ptrDistance*/ 8) {
  				attr_dev(div, "data-ptr-distance", /*ptrDistance*/ ctx[3]);
  			}

  			if (!current || dirty[0] & /*ptrMousewheel*/ 64 && div_data_ptr_mousewheel_value !== (div_data_ptr_mousewheel_value = /*ptrMousewheel*/ ctx[6] || undefined)) {
  				attr_dev(div, "data-ptr-mousewheel", div_data_ptr_mousewheel_value);
  			}

  			if (!current || dirty[0] & /*infiniteDistance*/ 512 && div_data_infinite_distance_value !== (div_data_infinite_distance_value = /*infiniteDistance*/ ctx[9] || undefined)) {
  				attr_dev(div, "data-infinite-distance", div_data_infinite_distance_value);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block0);
  			transition_in(if_block1);
  			transition_in(default_slot, local);
  			transition_in(if_block2);
  			transition_in(if_block3);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block0);
  			transition_out(if_block1);
  			transition_out(default_slot, local);
  			transition_out(if_block2);
  			transition_out(if_block3);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (if_block0) if_block0.d();
  			if (if_block1) if_block1.d();
  			if (default_slot) default_slot.d(detaching);
  			if (if_block2) if_block2.d();
  			if (if_block3) if_block3.d();
  			/*div_binding*/ ctx[35](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$h.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$h($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { tab = false } = $$props;
  	let { tabActive = false } = $$props;
  	let { ptr = false } = $$props;
  	let { ptrDistance = undefined } = $$props;
  	let { ptrPreloader = true } = $$props;
  	let { ptrBottom = false } = $$props;
  	let { ptrMousewheel = false } = $$props;
  	let { infinite = false } = $$props;
  	let { infiniteTop = false } = $$props;
  	let { infiniteDistance = undefined } = $$props;
  	let { infinitePreloader = true } = $$props;
  	let { hideBarsOnScroll = false } = $$props;
  	let { hideNavbarOnScroll = false } = $$props;
  	let { hideToolbarOnScroll = false } = $$props;
  	let { messagesContent = false } = $$props;
  	let { loginScreen = false } = $$props;
  	let { class: className = undefined } = $$props;
  	let pageContentEl;

  	// Event handlers
  	function onPtrPullStart(ptrEl) {
  		if (ptrEl !== pageContentEl) return;
  		dispatch("ptrPullStart");
  		if (typeof $$props.onPtrPullStart === "function") $$props.onPtrPullStart();
  	}

  	function onPtrPullMove(ptrEl) {
  		if (ptrEl !== pageContentEl) return;
  		dispatch("ptrPullMove");
  		if (typeof $$props.onPtrPullMove === "function") $$props.onPtrPullMove();
  	}

  	function onPtrPullEnd(ptrEl) {
  		if (ptrEl !== pageContentEl) return;
  		dispatch("ptrPullEnd");
  		if (typeof $$props.onPtrPullEnd === "function") $$props.onPtrPullEnd();
  	}

  	function onPtrRefresh(ptrEl, done) {
  		if (ptrEl !== pageContentEl) return;
  		dispatch("ptrRefresh", [done]);
  		if (typeof $$props.onPtrRefresh === "function") $$props.onPtrRefresh(done);
  	}

  	function onPtrDone(ptrEl) {
  		if (ptrEl !== pageContentEl) return;
  		dispatch("ptrDone");
  		if (typeof $$props.onPtrDone === "function") $$props.onPtrDone();
  	}

  	function onInfinite(infEl) {
  		if (infEl !== pageContentEl) return;
  		dispatch("infinite");
  		if (typeof $$props.onInfinite === "function") $$props.onInfinite();
  	}

  	function onTabShow(tabEl) {
  		if (pageContentEl !== tabEl) return;
  		dispatch("tabShow");
  		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
  	}

  	function onTabHide(tabEl) {
  		if (pageContentEl !== tabEl) return;
  		dispatch("tabHide");
  		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
  	}

  	function mountPageContent() {
  		if (ptr) {
  			f7.instance.on("ptrPullStart", onPtrPullStart);
  			f7.instance.on("ptrPullMove", onPtrPullMove);
  			f7.instance.on("ptrPullEnd", onPtrPullEnd);
  			f7.instance.on("ptrRefresh", onPtrRefresh);
  			f7.instance.on("ptrDone", onPtrDone);
  		}

  		if (infinite) {
  			f7.instance.on("infinite", onInfinite);
  		}

  		if (tab) {
  			f7.instance.on("tabShow", onTabShow);
  			f7.instance.on("tabHide", onTabHide);
  		}
  	}

  	function destroyPageContent() {
  		if (ptr) {
  			f7.instance.off("ptrPullStart", onPtrPullStart);
  			f7.instance.off("ptrPullMove", onPtrPullMove);
  			f7.instance.off("ptrPullEnd", onPtrPullEnd);
  			f7.instance.off("ptrRefresh", onPtrRefresh);
  			f7.instance.off("ptrDone", onPtrDone);
  		}

  		if (infinite) {
  			f7.instance.off("infinite", onInfinite);
  		}

  		if (tab) {
  			f7.instance.off("tabShow", onTabShow);
  			f7.instance.off("tabHide", onTabHide);
  		}
  	}

  	onMount(() => {
  		f7.ready(() => {
  			mountPageContent();
  		});
  	});

  	onDestroy(() => {
  		if (!f7.instance) return;
  		destroyPageContent();
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Page_content", $$slots, ['default']);

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(11, pageContentEl = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(32, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("tab" in $$new_props) $$invalidate(13, tab = $$new_props.tab);
  		if ("tabActive" in $$new_props) $$invalidate(14, tabActive = $$new_props.tabActive);
  		if ("ptr" in $$new_props) $$invalidate(2, ptr = $$new_props.ptr);
  		if ("ptrDistance" in $$new_props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
  		if ("ptrPreloader" in $$new_props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
  		if ("ptrBottom" in $$new_props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
  		if ("ptrMousewheel" in $$new_props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
  		if ("infinite" in $$new_props) $$invalidate(7, infinite = $$new_props.infinite);
  		if ("infiniteTop" in $$new_props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
  		if ("infiniteDistance" in $$new_props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
  		if ("infinitePreloader" in $$new_props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
  		if ("hideBarsOnScroll" in $$new_props) $$invalidate(15, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
  		if ("hideNavbarOnScroll" in $$new_props) $$invalidate(16, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
  		if ("hideToolbarOnScroll" in $$new_props) $$invalidate(17, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
  		if ("messagesContent" in $$new_props) $$invalidate(18, messagesContent = $$new_props.messagesContent);
  		if ("loginScreen" in $$new_props) $$invalidate(19, loginScreen = $$new_props.loginScreen);
  		if ("class" in $$new_props) $$invalidate(20, className = $$new_props.class);
  		if ("$$scope" in $$new_props) $$invalidate(33, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		onDestroy,
  		createEventDispatcher,
  		Utils: Utils$1,
  		Mixins,
  		f7,
  		Preloader: Preloader$2,
  		dispatch,
  		id,
  		style,
  		tab,
  		tabActive,
  		ptr,
  		ptrDistance,
  		ptrPreloader,
  		ptrBottom,
  		ptrMousewheel,
  		infinite,
  		infiniteTop,
  		infiniteDistance,
  		infinitePreloader,
  		hideBarsOnScroll,
  		hideNavbarOnScroll,
  		hideToolbarOnScroll,
  		messagesContent,
  		loginScreen,
  		className,
  		pageContentEl,
  		onPtrPullStart,
  		onPtrPullMove,
  		onPtrPullEnd,
  		onPtrRefresh,
  		onPtrDone,
  		onInfinite,
  		onTabShow,
  		onTabHide,
  		mountPageContent,
  		destroyPageContent,
  		pageContentClasses
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(32, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("tab" in $$props) $$invalidate(13, tab = $$new_props.tab);
  		if ("tabActive" in $$props) $$invalidate(14, tabActive = $$new_props.tabActive);
  		if ("ptr" in $$props) $$invalidate(2, ptr = $$new_props.ptr);
  		if ("ptrDistance" in $$props) $$invalidate(3, ptrDistance = $$new_props.ptrDistance);
  		if ("ptrPreloader" in $$props) $$invalidate(4, ptrPreloader = $$new_props.ptrPreloader);
  		if ("ptrBottom" in $$props) $$invalidate(5, ptrBottom = $$new_props.ptrBottom);
  		if ("ptrMousewheel" in $$props) $$invalidate(6, ptrMousewheel = $$new_props.ptrMousewheel);
  		if ("infinite" in $$props) $$invalidate(7, infinite = $$new_props.infinite);
  		if ("infiniteTop" in $$props) $$invalidate(8, infiniteTop = $$new_props.infiniteTop);
  		if ("infiniteDistance" in $$props) $$invalidate(9, infiniteDistance = $$new_props.infiniteDistance);
  		if ("infinitePreloader" in $$props) $$invalidate(10, infinitePreloader = $$new_props.infinitePreloader);
  		if ("hideBarsOnScroll" in $$props) $$invalidate(15, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
  		if ("hideNavbarOnScroll" in $$props) $$invalidate(16, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
  		if ("hideToolbarOnScroll" in $$props) $$invalidate(17, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
  		if ("messagesContent" in $$props) $$invalidate(18, messagesContent = $$new_props.messagesContent);
  		if ("loginScreen" in $$props) $$invalidate(19, loginScreen = $$new_props.loginScreen);
  		if ("className" in $$props) $$invalidate(20, className = $$new_props.className);
  		if ("pageContentEl" in $$props) $$invalidate(11, pageContentEl = $$new_props.pageContentEl);
  		if ("pageContentClasses" in $$props) $$invalidate(12, pageContentClasses = $$new_props.pageContentClasses);
  	};

  	let pageContentClasses;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(12, pageContentClasses = Utils$1.classNames(
  			className,
  			"page-content",
  			{
  				tab,
  				"tab-active": tabActive,
  				"ptr-content": ptr,
  				"ptr-bottom": ptrBottom,
  				"infinite-scroll-content": infinite,
  				"infinite-scroll-top": infiniteTop,
  				"hide-bars-on-scroll": hideBarsOnScroll,
  				"hide-navbar-on-scroll": hideNavbarOnScroll,
  				"hide-toolbar-on-scroll": hideToolbarOnScroll,
  				"messages-content": messagesContent,
  				"login-screen-content": loginScreen
  			},
  			Mixins.colorClasses($$props)
  		));
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		ptr,
  		ptrDistance,
  		ptrPreloader,
  		ptrBottom,
  		ptrMousewheel,
  		infinite,
  		infiniteTop,
  		infiniteDistance,
  		infinitePreloader,
  		pageContentEl,
  		pageContentClasses,
  		tab,
  		tabActive,
  		hideBarsOnScroll,
  		hideNavbarOnScroll,
  		hideToolbarOnScroll,
  		messagesContent,
  		loginScreen,
  		className,
  		dispatch,
  		onPtrPullStart,
  		onPtrPullMove,
  		onPtrPullEnd,
  		onPtrRefresh,
  		onPtrDone,
  		onInfinite,
  		onTabShow,
  		onTabHide,
  		mountPageContent,
  		destroyPageContent,
  		$$props,
  		$$scope,
  		$$slots,
  		div_binding
  	];
  }

  class Page_content extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(
  			this,
  			options,
  			instance$h,
  			create_fragment$h,
  			safe_not_equal,
  			{
  				id: 0,
  				style: 1,
  				tab: 13,
  				tabActive: 14,
  				ptr: 2,
  				ptrDistance: 3,
  				ptrPreloader: 4,
  				ptrBottom: 5,
  				ptrMousewheel: 6,
  				infinite: 7,
  				infiniteTop: 8,
  				infiniteDistance: 9,
  				infinitePreloader: 10,
  				hideBarsOnScroll: 15,
  				hideNavbarOnScroll: 16,
  				hideToolbarOnScroll: 17,
  				messagesContent: 18,
  				loginScreen: 19,
  				class: 20
  			},
  			[-1, -1]
  		);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Page_content",
  			options,
  			id: create_fragment$h.name
  		});
  	}

  	get id() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tab() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tab(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabActive() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabActive(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptr() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptr(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptrDistance() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptrDistance(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptrPreloader() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptrPreloader(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptrBottom() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptrBottom(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptrMousewheel() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptrMousewheel(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get infinite() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set infinite(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get infiniteTop() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set infiniteTop(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get infiniteDistance() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set infiniteDistance(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get infinitePreloader() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set infinitePreloader(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get hideBarsOnScroll() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set hideBarsOnScroll(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get hideNavbarOnScroll() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set hideNavbarOnScroll(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get hideToolbarOnScroll() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set hideToolbarOnScroll(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get messagesContent() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set messagesContent(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get loginScreen() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set loginScreen(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Page_content>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Page_content>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/page.svelte generated by Svelte v3.21.0 */
  const file$i = "node_modules/framework7-svelte/components/page.svelte";
  const get_static_slot_changes_1 = dirty => ({});
  const get_static_slot_context_1 = ctx => ({});
  const get_static_slot_changes = dirty => ({});
  const get_static_slot_context = ctx => ({});
  const get_fixed_slot_changes = dirty => ({});
  const get_fixed_slot_context = ctx => ({});

  // (354:2) {:else}
  function create_else_block$4(ctx) {
  	let t;
  	let current;
  	const static_slot_template = /*$$slots*/ ctx[72].static;
  	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[74], get_static_slot_context_1);
  	const default_slot_template = /*$$slots*/ ctx[72].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[74], null);

  	const block = {
  		c: function create() {
  			if (static_slot) static_slot.c();
  			t = space();
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (static_slot) {
  				static_slot.m(target, anchor);
  			}

  			insert_dev(target, t, anchor);

  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (static_slot) {
  				if (static_slot.p && dirty[2] & /*$$scope*/ 4096) {
  					static_slot.p(get_slot_context(static_slot_template, ctx, /*$$scope*/ ctx[74], get_static_slot_context_1), get_slot_changes(static_slot_template, /*$$scope*/ ctx[74], dirty, get_static_slot_changes_1));
  				}
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[2] & /*$$scope*/ 4096) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[74], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[74], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(static_slot, local);
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(static_slot, local);
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (static_slot) static_slot.d(detaching);
  			if (detaching) detach_dev(t);
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$4.name,
  		type: "else",
  		source: "(354:2) {:else}",
  		ctx
  	});

  	return block;
  }

  // (328:2) {#if pageContent}
  function create_if_block$a(ctx) {
  	let current;

  	const pagecontent = new Page_content({
  			props: {
  				ptr: /*ptr*/ ctx[4],
  				ptrDistance: /*ptrDistance*/ ctx[5],
  				ptrPreloader: /*ptrPreloader*/ ctx[6],
  				ptrBottom: /*ptrBottom*/ ctx[7],
  				ptrMousewheel: /*ptrMousewheel*/ ctx[8],
  				infinite: /*infinite*/ ctx[9],
  				infiniteTop: /*infiniteTop*/ ctx[10],
  				infiniteDistance: /*infiniteDistance*/ ctx[11],
  				infinitePreloader: /*infinitePreloader*/ ctx[12],
  				hideBarsOnScroll: /*hideBarsOnScroll*/ ctx[13],
  				hideNavbarOnScroll: /*hideNavbarOnScroll*/ ctx[14],
  				hideToolbarOnScroll: /*hideToolbarOnScroll*/ ctx[15],
  				messagesContent: /*messagesContent*/ ctx[16],
  				loginScreen: /*loginScreen*/ ctx[17],
  				onPtrPullStart: /*onPtrPullStart*/ ctx[20],
  				onPtrPullMove: /*onPtrPullMove*/ ctx[21],
  				onPtrPullEnd: /*onPtrPullEnd*/ ctx[22],
  				onPtrRefresh: /*onPtrRefresh*/ ctx[23],
  				onPtrDone: /*onPtrDone*/ ctx[24],
  				onInfinite: /*onInfinite*/ ctx[25],
  				$$slots: { default: [create_default_slot$3] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(pagecontent.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(pagecontent, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const pagecontent_changes = {};
  			if (dirty[0] & /*ptr*/ 16) pagecontent_changes.ptr = /*ptr*/ ctx[4];
  			if (dirty[0] & /*ptrDistance*/ 32) pagecontent_changes.ptrDistance = /*ptrDistance*/ ctx[5];
  			if (dirty[0] & /*ptrPreloader*/ 64) pagecontent_changes.ptrPreloader = /*ptrPreloader*/ ctx[6];
  			if (dirty[0] & /*ptrBottom*/ 128) pagecontent_changes.ptrBottom = /*ptrBottom*/ ctx[7];
  			if (dirty[0] & /*ptrMousewheel*/ 256) pagecontent_changes.ptrMousewheel = /*ptrMousewheel*/ ctx[8];
  			if (dirty[0] & /*infinite*/ 512) pagecontent_changes.infinite = /*infinite*/ ctx[9];
  			if (dirty[0] & /*infiniteTop*/ 1024) pagecontent_changes.infiniteTop = /*infiniteTop*/ ctx[10];
  			if (dirty[0] & /*infiniteDistance*/ 2048) pagecontent_changes.infiniteDistance = /*infiniteDistance*/ ctx[11];
  			if (dirty[0] & /*infinitePreloader*/ 4096) pagecontent_changes.infinitePreloader = /*infinitePreloader*/ ctx[12];
  			if (dirty[0] & /*hideBarsOnScroll*/ 8192) pagecontent_changes.hideBarsOnScroll = /*hideBarsOnScroll*/ ctx[13];
  			if (dirty[0] & /*hideNavbarOnScroll*/ 16384) pagecontent_changes.hideNavbarOnScroll = /*hideNavbarOnScroll*/ ctx[14];
  			if (dirty[0] & /*hideToolbarOnScroll*/ 32768) pagecontent_changes.hideToolbarOnScroll = /*hideToolbarOnScroll*/ ctx[15];
  			if (dirty[0] & /*messagesContent*/ 65536) pagecontent_changes.messagesContent = /*messagesContent*/ ctx[16];
  			if (dirty[0] & /*loginScreen*/ 131072) pagecontent_changes.loginScreen = /*loginScreen*/ ctx[17];

  			if (dirty[2] & /*$$scope*/ 4096) {
  				pagecontent_changes.$$scope = { dirty, ctx };
  			}

  			pagecontent.$set(pagecontent_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(pagecontent.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(pagecontent.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(pagecontent, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$a.name,
  		type: "if",
  		source: "(328:2) {#if pageContent}",
  		ctx
  	});

  	return block;
  }

  // (329:2) <PageContent     ptr={ptr}     ptrDistance={ptrDistance}     ptrPreloader={ptrPreloader}     ptrBottom={ptrBottom}     ptrMousewheel={ptrMousewheel}     infinite={infinite}     infiniteTop={infiniteTop}     infiniteDistance={infiniteDistance}     infinitePreloader={infinitePreloader}     hideBarsOnScroll={hideBarsOnScroll}     hideNavbarOnScroll={hideNavbarOnScroll}     hideToolbarOnScroll={hideToolbarOnScroll}     messagesContent={messagesContent}     loginScreen={loginScreen}     onPtrPullStart={onPtrPullStart}     onPtrPullMove={onPtrPullMove}     onPtrPullEnd={onPtrPullEnd}     onPtrRefresh={onPtrRefresh}     onPtrDone={onPtrDone}     onInfinite={onInfinite}   >
  function create_default_slot$3(ctx) {
  	let t;
  	let current;
  	const static_slot_template = /*$$slots*/ ctx[72].static;
  	const static_slot = create_slot(static_slot_template, ctx, /*$$scope*/ ctx[74], get_static_slot_context);
  	const default_slot_template = /*$$slots*/ ctx[72].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[74], null);

  	const block = {
  		c: function create() {
  			if (static_slot) static_slot.c();
  			t = space();
  			if (default_slot) default_slot.c();
  		},
  		m: function mount(target, anchor) {
  			if (static_slot) {
  				static_slot.m(target, anchor);
  			}

  			insert_dev(target, t, anchor);

  			if (default_slot) {
  				default_slot.m(target, anchor);
  			}

  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (static_slot) {
  				if (static_slot.p && dirty[2] & /*$$scope*/ 4096) {
  					static_slot.p(get_slot_context(static_slot_template, ctx, /*$$scope*/ ctx[74], get_static_slot_context), get_slot_changes(static_slot_template, /*$$scope*/ ctx[74], dirty, get_static_slot_changes));
  				}
  			}

  			if (default_slot) {
  				if (default_slot.p && dirty[2] & /*$$scope*/ 4096) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[74], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[74], dirty, null));
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(static_slot, local);
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(static_slot, local);
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (static_slot) static_slot.d(detaching);
  			if (detaching) detach_dev(t);
  			if (default_slot) default_slot.d(detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$3.name,
  		type: "slot",
  		source: "(329:2) <PageContent     ptr={ptr}     ptrDistance={ptrDistance}     ptrPreloader={ptrPreloader}     ptrBottom={ptrBottom}     ptrMousewheel={ptrMousewheel}     infinite={infinite}     infiniteTop={infiniteTop}     infiniteDistance={infiniteDistance}     infinitePreloader={infinitePreloader}     hideBarsOnScroll={hideBarsOnScroll}     hideNavbarOnScroll={hideNavbarOnScroll}     hideToolbarOnScroll={hideToolbarOnScroll}     messagesContent={messagesContent}     loginScreen={loginScreen}     onPtrPullStart={onPtrPullStart}     onPtrPullMove={onPtrPullMove}     onPtrPullEnd={onPtrPullEnd}     onPtrRefresh={onPtrRefresh}     onPtrDone={onPtrDone}     onInfinite={onInfinite}   >",
  		ctx
  	});

  	return block;
  }

  function create_fragment$i(ctx) {
  	let div;
  	let t;
  	let current_block_type_index;
  	let if_block;
  	let current;
  	const fixed_slot_template = /*$$slots*/ ctx[72].fixed;
  	const fixed_slot = create_slot(fixed_slot_template, ctx, /*$$scope*/ ctx[74], get_fixed_slot_context);
  	const if_block_creators = [create_if_block$a, create_else_block$4];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*pageContent*/ ctx[3]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (fixed_slot) fixed_slot.c();
  			t = space();
  			if_block.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[19]);
  			attr_dev(div, "data-name", /*name*/ ctx[2]);
  			add_location(div, file$i, 325, 0, 11346);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (fixed_slot) {
  				fixed_slot.m(div, null);
  			}

  			append_dev(div, t);
  			if_blocks[current_block_type_index].m(div, null);
  			/*div_binding*/ ctx[73](div);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (fixed_slot) {
  				if (fixed_slot.p && dirty[2] & /*$$scope*/ 4096) {
  					fixed_slot.p(get_slot_context(fixed_slot_template, ctx, /*$$scope*/ ctx[74], get_fixed_slot_context), get_slot_changes(fixed_slot_template, /*$$scope*/ ctx[74], dirty, get_fixed_slot_changes));
  				}
  			}

  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(div, null);
  			}

  			if (!current || dirty[0] & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty[0] & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty[0] & /*classes*/ 524288) {
  				attr_dev(div, "class", /*classes*/ ctx[19]);
  			}

  			if (!current || dirty[0] & /*name*/ 4) {
  				attr_dev(div, "data-name", /*name*/ ctx[2]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(fixed_slot, local);
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(fixed_slot, local);
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (fixed_slot) fixed_slot.d(detaching);
  			if_blocks[current_block_type_index].d();
  			/*div_binding*/ ctx[73](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$i.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$i($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { name = undefined } = $$props;
  	let { stacked = undefined } = $$props;
  	let { withSubnavbar = undefined } = $$props;
  	let { subnavbar = undefined } = $$props;
  	let { withNavbarLarge = undefined } = $$props;
  	let { navbarLarge = undefined } = $$props;
  	let { noNavbar = undefined } = $$props;
  	let { noToolbar = undefined } = $$props;
  	let { tabs = undefined } = $$props;
  	let { pageContent = true } = $$props;
  	let { noSwipeback = undefined } = $$props;
  	let { ptr = undefined } = $$props;
  	let { ptrDistance = undefined } = $$props;
  	let { ptrPreloader = true } = $$props;
  	let { ptrBottom = undefined } = $$props;
  	let { ptrMousewheel = undefined } = $$props;
  	let { infinite = undefined } = $$props;
  	let { infiniteTop = undefined } = $$props;
  	let { infiniteDistance = undefined } = $$props;
  	let { infinitePreloader = true } = $$props;
  	let { hideBarsOnScroll = undefined } = $$props;
  	let { hideNavbarOnScroll = undefined } = $$props;
  	let { hideToolbarOnScroll = undefined } = $$props;
  	let { messagesContent = undefined } = $$props;
  	let { loginScreen = undefined } = $$props;
  	let { class: className = undefined } = $$props;

  	// State
  	let el;

  	let hasSubnavbar = false;
  	let hasNavbarLarge = false;
  	let hasNavbarLargeCollapsed = false;
  	let hasCardExpandableOpened = false;
  	let routerPositionClass = "";
  	let routerForceUnstack = false;
  	let routerPageRole = null;
  	let routerPageRoleDetailRoot = false;
  	let routerPageMasterStack = false;

  	// Handlers
  	function onPtrPullStart() {
  		dispatch("ptrPullStart");
  		if (typeof $$props.onPtrPullStart === "function") $$props.onPtrPullStart();
  	}

  	function onPtrPullMove() {
  		dispatch("ptrPullMove");
  		if (typeof $$props.onPtrPullMove === "function") $$props.onPtrPullMove();
  	}

  	function onPtrPullEnd() {
  		dispatch("ptrPullEnd");
  		if (typeof $$props.onPtrPullEnd === "function") $$props.onPtrPullEnd();
  	}

  	function onPtrRefresh(done) {
  		dispatch("ptrRefresh", [done]);
  		if (typeof $$props.onPtrRefresh === "function") $$props.onPtrRefresh(done);
  	}

  	function onPtrDone() {
  		dispatch("ptrDone");
  		if (typeof $$props.onPtrDone === "function") $$props.onPtrDone();
  	}

  	function onInfinite() {
  		dispatch("infinite");
  		if (typeof $$props.onInfinite === "function") $$props.onInfinite();
  	}

  	// Main Page Events
  	function onPageMounted(page) {
  		if (el !== page.el) return;
  		dispatch("pageMounted", [page]);
  		if (typeof $$props.onPageMounted === "function") $$props.onPageMounted(page);
  	}

  	function onPageInit(page) {
  		if (el !== page.el) return;

  		if (typeof withSubnavbar === "undefined" && typeof subnavbar === "undefined") {
  			if (page.$navbarEl && page.$navbarEl.length && page.$navbarEl.find(".subnavbar").length || page.$el.children(".navbar").find(".subnavbar").length) {
  				$$invalidate(36, hasSubnavbar = true);
  			}
  		}

  		if (typeof withNavbarLarge === "undefined" && typeof navbarLarge === "undefined") {
  			if (page.$navbarEl && page.$navbarEl.hasClass("navbar-large") || page.$el.children(".navbar-large").length) {
  				$$invalidate(37, hasNavbarLarge = true);
  			}
  		}

  		dispatch("pageInit", [page]);
  		if (typeof $$props.onPageInit === "function") $$props.onPageInit(page);
  	}

  	function onPageReinit(page) {
  		if (el !== page.el) return;
  		dispatch("pageReinit", [page]);
  		if (typeof $$props.onPageReinit === "function") $$props.onPageReinit(page);
  	}

  	function onPageBeforeIn(page) {
  		if (el !== page.el) return;

  		if (!page.swipeBack) {
  			if (page.from === "next") {
  				$$invalidate(40, routerPositionClass = "page-next");
  			}

  			if (page.from === "previous") {
  				$$invalidate(40, routerPositionClass = "page-previous");
  			}
  		}

  		dispatch("pageBeforeIn", [page]);
  		if (typeof $$props.onPageBeforeIn === "function") $$props.onPageBeforeIn(page);
  	}

  	function onPageBeforeOut(page) {
  		if (el !== page.el) return;
  		dispatch("pageBeforeOut", [page]);
  		if (typeof $$props.onPageBeforeOut === "function") $$props.onPageBeforeOut(page);
  	}

  	function onPageAfterOut(page) {
  		if (el !== page.el) return;

  		if (page.to === "next") {
  			$$invalidate(40, routerPositionClass = "page-next");
  		}

  		if (page.to === "previous") {
  			$$invalidate(40, routerPositionClass = "page-previous");
  		}

  		dispatch("pageAfterOut", [page]);
  		if (typeof $$props.onPageAfterOut === "function") $$props.onPageAfterOut(page);
  	}

  	function onPageAfterIn(page) {
  		if (el !== page.el) return;
  		$$invalidate(40, routerPositionClass = "page-current");
  		dispatch("pageAfterIn", [page]);
  		if (typeof $$props.onPageAfterIn === "function") $$props.onPageAfterIn(page);
  	}

  	function onPageBeforeRemove(page) {
  		if (el !== page.el) return;

  		if (page.$navbarEl && page.$navbarEl[0] && page.$navbarEl.parent()[0] && page.$navbarEl.parent()[0] !== el) {
  			page.$el.prepend(page.$navbarEl);
  		}

  		dispatch("pageBeforeRemove", [page]);
  		if (typeof $$props.onPageBeforeRemove === "function") $$props.onPageBeforeRemove(page);
  	}

  	function onPageBeforeUnmount(page) {
  		if (el !== page.el) return;
  		dispatch("pageBeforeUnmount", [page]);
  		if (typeof $$props.onPageBeforeUnmount === "function") $$props.onPageBeforeUnmount(page);
  	}

  	// Helper events
  	function onPageStack(pageEl) {
  		if (el !== pageEl) return;
  		$$invalidate(41, routerForceUnstack = false);
  	}

  	function onPageUnstack(pageEl) {
  		if (el !== pageEl) return;
  		$$invalidate(41, routerForceUnstack = true);
  	}

  	function onPagePosition(pageEl, position) {
  		if (el !== pageEl) return;
  		$$invalidate(40, routerPositionClass = `page-${position}`);
  	}

  	function onPageRole(pageEl, rolesData) {
  		if (el !== pageEl) return;
  		$$invalidate(42, routerPageRole = rolesData.role);
  		$$invalidate(43, routerPageRoleDetailRoot = rolesData.detailRoot);
  	}

  	function onPageMasterStack(pageEl) {
  		if (el !== pageEl) return;
  		$$invalidate(44, routerPageMasterStack = true);
  	}

  	function onPageMasterUnstack(pageEl) {
  		if (el !== pageEl) return;
  		$$invalidate(44, routerPageMasterStack = false);
  	}

  	function onPageNavbarLargeCollapsed(pageEl) {
  		if (el !== pageEl) return;
  		$$invalidate(38, hasNavbarLargeCollapsed = true);
  	}

  	function onPageNavbarLargeExpanded(pageEl) {
  		if (el !== pageEl) return;
  		$$invalidate(38, hasNavbarLargeCollapsed = false);
  	}

  	function onCardOpened(cardEl, pageEl) {
  		if (el !== pageEl) return;
  		$$invalidate(39, hasCardExpandableOpened = true);
  	}

  	function onCardClose(cardEl, pageEl) {
  		if (el !== pageEl) return;
  		$$invalidate(39, hasCardExpandableOpened = false);
  	}

  	function onPageTabShow(pageEl) {
  		if (el !== pageEl) return;
  		dispatch("pageTabShow");
  		if (typeof $$props.onPageTabShow === "function") $$props.onPageTabShow();
  	}

  	function onPageTabHide(pageEl) {
  		if (el !== pageEl) return;
  		dispatch("pageTabHide");
  		if (typeof $$props.onPageTabHide === "function") $$props.onPageTabHide();
  	}

  	// Mount/destroy
  	function mountPage() {
  		f7.instance.on("pageMounted", onPageMounted);
  		f7.instance.on("pageInit", onPageInit);
  		f7.instance.on("pageReinit", onPageReinit);
  		f7.instance.on("pageBeforeIn", onPageBeforeIn);
  		f7.instance.on("pageBeforeOut", onPageBeforeOut);
  		f7.instance.on("pageAfterOut", onPageAfterOut);
  		f7.instance.on("pageAfterIn", onPageAfterIn);
  		f7.instance.on("pageBeforeRemove", onPageBeforeRemove);
  		f7.instance.on("pageBeforeUnmount", onPageBeforeUnmount);
  		f7.instance.on("pageStack", onPageStack);
  		f7.instance.on("pageUnstack", onPageUnstack);
  		f7.instance.on("pagePosition", onPagePosition);
  		f7.instance.on("pageRole", onPageRole);
  		f7.instance.on("pageMasterStack", onPageMasterStack);
  		f7.instance.on("pageMasterUnstack", onPageMasterUnstack);
  		f7.instance.on("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
  		f7.instance.on("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
  		f7.instance.on("cardOpened", onCardOpened);
  		f7.instance.on("cardClose", onCardClose);
  		f7.instance.on("pageTabShow", onPageTabShow);
  		f7.instance.on("pageTabHide", onPageTabHide);
  	}

  	function destroyPage() {
  		f7.instance.off("pageMounted", onPageMounted);
  		f7.instance.off("pageInit", onPageInit);
  		f7.instance.off("pageReinit", onPageReinit);
  		f7.instance.off("pageBeforeIn", onPageBeforeIn);
  		f7.instance.off("pageBeforeOut", onPageBeforeOut);
  		f7.instance.off("pageAfterOut", onPageAfterOut);
  		f7.instance.off("pageAfterIn", onPageAfterIn);
  		f7.instance.off("pageBeforeRemove", onPageBeforeRemove);
  		f7.instance.off("pageBeforeUnmount", onPageBeforeUnmount);
  		f7.instance.off("pageStack", onPageStack);
  		f7.instance.off("pageUnstack", onPageUnstack);
  		f7.instance.off("pagePosition", onPagePosition);
  		f7.instance.off("pageRole", onPageRole);
  		f7.instance.off("pageMasterStack", onPageMasterStack);
  		f7.instance.off("pageMasterUnstack", onPageMasterUnstack);
  		f7.instance.off("pageNavbarLargeCollapsed", onPageNavbarLargeCollapsed);
  		f7.instance.off("pageNavbarLargeExpanded", onPageNavbarLargeExpanded);
  		f7.instance.off("cardOpened", onCardOpened);
  		f7.instance.off("cardClose", onCardClose);
  		f7.instance.off("pageTabShow", onPageTabShow);
  		f7.instance.off("pageTabHide", onPageTabHide);
  	}

  	onMount(() => {
  		f7.ready(() => {
  			if (el) {
  				const dom7 = f7.instance.$;
  				const fixedEls = dom7(el).children(".page-content").children("[data-f7-slot=\"fixed\"]");

  				if (fixedEls.length) {
  					for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
  						dom7(el).prepend(fixedEls[i]);
  					}
  				}
  			}

  			mountPage();
  		});
  	});

  	afterUpdate(() => {
  		if (el && f7.instance) {
  			const dom7 = f7.instance.$;
  			const fixedEls = dom7(el).children(".page-content").children("[data-f7-slot=\"fixed\"]");

  			if (fixedEls.length) {
  				for (let i = fixedEls.length - 1; i >= 0; i -= 1) {
  					dom7(el).prepend(fixedEls[i]);
  				}
  			}
  		}
  	});

  	onDestroy(() => {
  		if (!f7.instance) return;
  		destroyPage();
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Page", $$slots, ['fixed','static','default']);

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(18, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(71, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("name" in $$new_props) $$invalidate(2, name = $$new_props.name);
  		if ("stacked" in $$new_props) $$invalidate(26, stacked = $$new_props.stacked);
  		if ("withSubnavbar" in $$new_props) $$invalidate(27, withSubnavbar = $$new_props.withSubnavbar);
  		if ("subnavbar" in $$new_props) $$invalidate(28, subnavbar = $$new_props.subnavbar);
  		if ("withNavbarLarge" in $$new_props) $$invalidate(29, withNavbarLarge = $$new_props.withNavbarLarge);
  		if ("navbarLarge" in $$new_props) $$invalidate(30, navbarLarge = $$new_props.navbarLarge);
  		if ("noNavbar" in $$new_props) $$invalidate(31, noNavbar = $$new_props.noNavbar);
  		if ("noToolbar" in $$new_props) $$invalidate(32, noToolbar = $$new_props.noToolbar);
  		if ("tabs" in $$new_props) $$invalidate(33, tabs = $$new_props.tabs);
  		if ("pageContent" in $$new_props) $$invalidate(3, pageContent = $$new_props.pageContent);
  		if ("noSwipeback" in $$new_props) $$invalidate(34, noSwipeback = $$new_props.noSwipeback);
  		if ("ptr" in $$new_props) $$invalidate(4, ptr = $$new_props.ptr);
  		if ("ptrDistance" in $$new_props) $$invalidate(5, ptrDistance = $$new_props.ptrDistance);
  		if ("ptrPreloader" in $$new_props) $$invalidate(6, ptrPreloader = $$new_props.ptrPreloader);
  		if ("ptrBottom" in $$new_props) $$invalidate(7, ptrBottom = $$new_props.ptrBottom);
  		if ("ptrMousewheel" in $$new_props) $$invalidate(8, ptrMousewheel = $$new_props.ptrMousewheel);
  		if ("infinite" in $$new_props) $$invalidate(9, infinite = $$new_props.infinite);
  		if ("infiniteTop" in $$new_props) $$invalidate(10, infiniteTop = $$new_props.infiniteTop);
  		if ("infiniteDistance" in $$new_props) $$invalidate(11, infiniteDistance = $$new_props.infiniteDistance);
  		if ("infinitePreloader" in $$new_props) $$invalidate(12, infinitePreloader = $$new_props.infinitePreloader);
  		if ("hideBarsOnScroll" in $$new_props) $$invalidate(13, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
  		if ("hideNavbarOnScroll" in $$new_props) $$invalidate(14, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
  		if ("hideToolbarOnScroll" in $$new_props) $$invalidate(15, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
  		if ("messagesContent" in $$new_props) $$invalidate(16, messagesContent = $$new_props.messagesContent);
  		if ("loginScreen" in $$new_props) $$invalidate(17, loginScreen = $$new_props.loginScreen);
  		if ("class" in $$new_props) $$invalidate(35, className = $$new_props.class);
  		if ("$$scope" in $$new_props) $$invalidate(74, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		afterUpdate,
  		onDestroy,
  		createEventDispatcher,
  		Utils: Utils$1,
  		Mixins,
  		f7,
  		PageContent: Page_content,
  		dispatch,
  		id,
  		style,
  		name,
  		stacked,
  		withSubnavbar,
  		subnavbar,
  		withNavbarLarge,
  		navbarLarge,
  		noNavbar,
  		noToolbar,
  		tabs,
  		pageContent,
  		noSwipeback,
  		ptr,
  		ptrDistance,
  		ptrPreloader,
  		ptrBottom,
  		ptrMousewheel,
  		infinite,
  		infiniteTop,
  		infiniteDistance,
  		infinitePreloader,
  		hideBarsOnScroll,
  		hideNavbarOnScroll,
  		hideToolbarOnScroll,
  		messagesContent,
  		loginScreen,
  		className,
  		el,
  		hasSubnavbar,
  		hasNavbarLarge,
  		hasNavbarLargeCollapsed,
  		hasCardExpandableOpened,
  		routerPositionClass,
  		routerForceUnstack,
  		routerPageRole,
  		routerPageRoleDetailRoot,
  		routerPageMasterStack,
  		onPtrPullStart,
  		onPtrPullMove,
  		onPtrPullEnd,
  		onPtrRefresh,
  		onPtrDone,
  		onInfinite,
  		onPageMounted,
  		onPageInit,
  		onPageReinit,
  		onPageBeforeIn,
  		onPageBeforeOut,
  		onPageAfterOut,
  		onPageAfterIn,
  		onPageBeforeRemove,
  		onPageBeforeUnmount,
  		onPageStack,
  		onPageUnstack,
  		onPagePosition,
  		onPageRole,
  		onPageMasterStack,
  		onPageMasterUnstack,
  		onPageNavbarLargeCollapsed,
  		onPageNavbarLargeExpanded,
  		onCardOpened,
  		onCardClose,
  		onPageTabShow,
  		onPageTabHide,
  		mountPage,
  		destroyPage,
  		forceSubnavbar,
  		forceNavbarLarge,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(71, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("name" in $$props) $$invalidate(2, name = $$new_props.name);
  		if ("stacked" in $$props) $$invalidate(26, stacked = $$new_props.stacked);
  		if ("withSubnavbar" in $$props) $$invalidate(27, withSubnavbar = $$new_props.withSubnavbar);
  		if ("subnavbar" in $$props) $$invalidate(28, subnavbar = $$new_props.subnavbar);
  		if ("withNavbarLarge" in $$props) $$invalidate(29, withNavbarLarge = $$new_props.withNavbarLarge);
  		if ("navbarLarge" in $$props) $$invalidate(30, navbarLarge = $$new_props.navbarLarge);
  		if ("noNavbar" in $$props) $$invalidate(31, noNavbar = $$new_props.noNavbar);
  		if ("noToolbar" in $$props) $$invalidate(32, noToolbar = $$new_props.noToolbar);
  		if ("tabs" in $$props) $$invalidate(33, tabs = $$new_props.tabs);
  		if ("pageContent" in $$props) $$invalidate(3, pageContent = $$new_props.pageContent);
  		if ("noSwipeback" in $$props) $$invalidate(34, noSwipeback = $$new_props.noSwipeback);
  		if ("ptr" in $$props) $$invalidate(4, ptr = $$new_props.ptr);
  		if ("ptrDistance" in $$props) $$invalidate(5, ptrDistance = $$new_props.ptrDistance);
  		if ("ptrPreloader" in $$props) $$invalidate(6, ptrPreloader = $$new_props.ptrPreloader);
  		if ("ptrBottom" in $$props) $$invalidate(7, ptrBottom = $$new_props.ptrBottom);
  		if ("ptrMousewheel" in $$props) $$invalidate(8, ptrMousewheel = $$new_props.ptrMousewheel);
  		if ("infinite" in $$props) $$invalidate(9, infinite = $$new_props.infinite);
  		if ("infiniteTop" in $$props) $$invalidate(10, infiniteTop = $$new_props.infiniteTop);
  		if ("infiniteDistance" in $$props) $$invalidate(11, infiniteDistance = $$new_props.infiniteDistance);
  		if ("infinitePreloader" in $$props) $$invalidate(12, infinitePreloader = $$new_props.infinitePreloader);
  		if ("hideBarsOnScroll" in $$props) $$invalidate(13, hideBarsOnScroll = $$new_props.hideBarsOnScroll);
  		if ("hideNavbarOnScroll" in $$props) $$invalidate(14, hideNavbarOnScroll = $$new_props.hideNavbarOnScroll);
  		if ("hideToolbarOnScroll" in $$props) $$invalidate(15, hideToolbarOnScroll = $$new_props.hideToolbarOnScroll);
  		if ("messagesContent" in $$props) $$invalidate(16, messagesContent = $$new_props.messagesContent);
  		if ("loginScreen" in $$props) $$invalidate(17, loginScreen = $$new_props.loginScreen);
  		if ("className" in $$props) $$invalidate(35, className = $$new_props.className);
  		if ("el" in $$props) $$invalidate(18, el = $$new_props.el);
  		if ("hasSubnavbar" in $$props) $$invalidate(36, hasSubnavbar = $$new_props.hasSubnavbar);
  		if ("hasNavbarLarge" in $$props) $$invalidate(37, hasNavbarLarge = $$new_props.hasNavbarLarge);
  		if ("hasNavbarLargeCollapsed" in $$props) $$invalidate(38, hasNavbarLargeCollapsed = $$new_props.hasNavbarLargeCollapsed);
  		if ("hasCardExpandableOpened" in $$props) $$invalidate(39, hasCardExpandableOpened = $$new_props.hasCardExpandableOpened);
  		if ("routerPositionClass" in $$props) $$invalidate(40, routerPositionClass = $$new_props.routerPositionClass);
  		if ("routerForceUnstack" in $$props) $$invalidate(41, routerForceUnstack = $$new_props.routerForceUnstack);
  		if ("routerPageRole" in $$props) $$invalidate(42, routerPageRole = $$new_props.routerPageRole);
  		if ("routerPageRoleDetailRoot" in $$props) $$invalidate(43, routerPageRoleDetailRoot = $$new_props.routerPageRoleDetailRoot);
  		if ("routerPageMasterStack" in $$props) $$invalidate(44, routerPageMasterStack = $$new_props.routerPageMasterStack);
  		if ("forceSubnavbar" in $$props) $$invalidate(45, forceSubnavbar = $$new_props.forceSubnavbar);
  		if ("forceNavbarLarge" in $$props) $$invalidate(46, forceNavbarLarge = $$new_props.forceNavbarLarge);
  		if ("classes" in $$props) $$invalidate(19, classes = $$new_props.classes);
  	};

  	let forceSubnavbar;
  	let forceNavbarLarge;
  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty[0] & /*subnavbar, withSubnavbar*/ 402653184 | $$self.$$.dirty[1] & /*hasSubnavbar*/ 32) {
  			 $$invalidate(45, forceSubnavbar = typeof subnavbar === "undefined" && typeof withSubnavbar === "undefined"
  			? hasSubnavbar
  			: false);
  		}

  		if ($$self.$$.dirty[0] & /*navbarLarge, withNavbarLarge*/ 1610612736 | $$self.$$.dirty[1] & /*hasNavbarLarge*/ 64) {
  			 $$invalidate(46, forceNavbarLarge = typeof navbarLarge === "undefined" && typeof withNavbarLarge === "undefined"
  			? hasNavbarLarge
  			: false);
  		}

  		 $$invalidate(19, classes = Utils$1.classNames(
  			className,
  			"page",
  			routerPositionClass,
  			{
  				stacked: stacked && !routerForceUnstack,
  				tabs,
  				"page-with-subnavbar": subnavbar || withSubnavbar || forceSubnavbar,
  				"page-with-navbar-large": navbarLarge || withNavbarLarge || forceNavbarLarge,
  				"no-navbar": noNavbar,
  				"no-toolbar": noToolbar,
  				"no-swipeback": noSwipeback,
  				"page-master": routerPageRole === "master",
  				"page-master-detail": routerPageRole === "detail",
  				"page-master-detail-root": routerPageRoleDetailRoot === true,
  				"page-master-stacked": routerPageMasterStack === true,
  				"page-with-navbar-large-collapsed": hasNavbarLargeCollapsed === true,
  				"page-with-card-opened": hasCardExpandableOpened === true,
  				"login-screen-page": loginScreen
  			},
  			Mixins.colorClasses($$props)
  		));
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		name,
  		pageContent,
  		ptr,
  		ptrDistance,
  		ptrPreloader,
  		ptrBottom,
  		ptrMousewheel,
  		infinite,
  		infiniteTop,
  		infiniteDistance,
  		infinitePreloader,
  		hideBarsOnScroll,
  		hideNavbarOnScroll,
  		hideToolbarOnScroll,
  		messagesContent,
  		loginScreen,
  		el,
  		classes,
  		onPtrPullStart,
  		onPtrPullMove,
  		onPtrPullEnd,
  		onPtrRefresh,
  		onPtrDone,
  		onInfinite,
  		stacked,
  		withSubnavbar,
  		subnavbar,
  		withNavbarLarge,
  		navbarLarge,
  		noNavbar,
  		noToolbar,
  		tabs,
  		noSwipeback,
  		className,
  		hasSubnavbar,
  		hasNavbarLarge,
  		hasNavbarLargeCollapsed,
  		hasCardExpandableOpened,
  		routerPositionClass,
  		routerForceUnstack,
  		routerPageRole,
  		routerPageRoleDetailRoot,
  		routerPageMasterStack,
  		forceSubnavbar,
  		forceNavbarLarge,
  		dispatch,
  		onPageMounted,
  		onPageInit,
  		onPageReinit,
  		onPageBeforeIn,
  		onPageBeforeOut,
  		onPageAfterOut,
  		onPageAfterIn,
  		onPageBeforeRemove,
  		onPageBeforeUnmount,
  		onPageStack,
  		onPageUnstack,
  		onPagePosition,
  		onPageRole,
  		onPageMasterStack,
  		onPageMasterUnstack,
  		onPageNavbarLargeCollapsed,
  		onPageNavbarLargeExpanded,
  		onCardOpened,
  		onCardClose,
  		onPageTabShow,
  		onPageTabHide,
  		mountPage,
  		destroyPage,
  		$$props,
  		$$slots,
  		div_binding,
  		$$scope
  	];
  }

  class Page extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(
  			this,
  			options,
  			instance$i,
  			create_fragment$i,
  			safe_not_equal,
  			{
  				id: 0,
  				style: 1,
  				name: 2,
  				stacked: 26,
  				withSubnavbar: 27,
  				subnavbar: 28,
  				withNavbarLarge: 29,
  				navbarLarge: 30,
  				noNavbar: 31,
  				noToolbar: 32,
  				tabs: 33,
  				pageContent: 3,
  				noSwipeback: 34,
  				ptr: 4,
  				ptrDistance: 5,
  				ptrPreloader: 6,
  				ptrBottom: 7,
  				ptrMousewheel: 8,
  				infinite: 9,
  				infiniteTop: 10,
  				infiniteDistance: 11,
  				infinitePreloader: 12,
  				hideBarsOnScroll: 13,
  				hideNavbarOnScroll: 14,
  				hideToolbarOnScroll: 15,
  				messagesContent: 16,
  				loginScreen: 17,
  				class: 35
  			},
  			[-1, -1, -1]
  		);

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Page",
  			options,
  			id: create_fragment$i.name
  		});
  	}

  	get id() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get name() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set name(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get stacked() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set stacked(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get withSubnavbar() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set withSubnavbar(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get subnavbar() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set subnavbar(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get withNavbarLarge() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set withNavbarLarge(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get navbarLarge() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set navbarLarge(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noNavbar() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noNavbar(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noToolbar() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noToolbar(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tabs() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tabs(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get pageContent() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set pageContent(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noSwipeback() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noSwipeback(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptr() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptr(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptrDistance() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptrDistance(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptrPreloader() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptrPreloader(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptrBottom() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptrBottom(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get ptrMousewheel() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set ptrMousewheel(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get infinite() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set infinite(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get infiniteTop() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set infiniteTop(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get infiniteDistance() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set infiniteDistance(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get infinitePreloader() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set infinitePreloader(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get hideBarsOnScroll() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set hideBarsOnScroll(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get hideNavbarOnScroll() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set hideNavbarOnScroll(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get hideToolbarOnScroll() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set hideToolbarOnScroll(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get messagesContent() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set messagesContent(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get loginScreen() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set loginScreen(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Page>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Page>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/row.svelte generated by Svelte v3.21.0 */
  const file$j = "node_modules/framework7-svelte/components/row.svelte";

  // (69:22) 
  function create_if_block_2$8(ctx) {
  	let p;
  	let t;
  	let current;
  	let dispose;
  	const default_slot_template = /*$$slots*/ ctx[16].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
  	let if_block = /*resizable*/ ctx[3] && /*resizableHandler*/ ctx[4] && create_if_block_3$6(ctx);

  	const block = {
  		c: function create() {
  			p = element("p");
  			if (default_slot) default_slot.c();
  			t = space();
  			if (if_block) if_block.c();
  			attr_dev(p, "id", /*id*/ ctx[0]);
  			attr_dev(p, "style", /*style*/ ctx[1]);
  			attr_dev(p, "class", /*classes*/ ctx[6]);
  			add_location(p, file$j, 69, 2, 1576);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, p, anchor);

  			if (default_slot) {
  				default_slot.m(p, null);
  			}

  			append_dev(p, t);
  			if (if_block) if_block.m(p, null);
  			/*p_binding*/ ctx[18](p);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(p, "click", /*onClick*/ ctx[7], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 32768) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
  				}
  			}

  			if (/*resizable*/ ctx[3] && /*resizableHandler*/ ctx[4]) {
  				if (if_block) ; else {
  					if_block = create_if_block_3$6(ctx);
  					if_block.c();
  					if_block.m(p, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(p, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(p, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 64) {
  				attr_dev(p, "class", /*classes*/ ctx[6]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(p);
  			if (default_slot) default_slot.d(detaching);
  			if (if_block) if_block.d();
  			/*p_binding*/ ctx[18](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_2$8.name,
  		type: "if",
  		source: "(69:22) ",
  		ctx
  	});

  	return block;
  }

  // (56:0) {#if tag === 'div'}
  function create_if_block$b(ctx) {
  	let div;
  	let t;
  	let current;
  	let dispose;
  	const default_slot_template = /*$$slots*/ ctx[16].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[15], null);
  	let if_block = /*resizable*/ ctx[3] && /*resizableHandler*/ ctx[4] && create_if_block_1$9(ctx);

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (default_slot) default_slot.c();
  			t = space();
  			if (if_block) if_block.c();
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "class", /*classes*/ ctx[6]);
  			add_location(div, file$j, 56, 2, 1335);
  		},
  		m: function mount(target, anchor, remount) {
  			insert_dev(target, div, anchor);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			append_dev(div, t);
  			if (if_block) if_block.m(div, null);
  			/*div_binding*/ ctx[17](div);
  			current = true;
  			if (remount) dispose();
  			dispose = listen_dev(div, "click", /*onClick*/ ctx[7], false, false, false);
  		},
  		p: function update(ctx, dirty) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 32768) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[15], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[15], dirty, null));
  				}
  			}

  			if (/*resizable*/ ctx[3] && /*resizableHandler*/ ctx[4]) {
  				if (if_block) ; else {
  					if_block = create_if_block_1$9(ctx);
  					if_block.c();
  					if_block.m(div, null);
  				}
  			} else if (if_block) {
  				if_block.d(1);
  				if_block = null;
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*classes*/ 64) {
  				attr_dev(div, "class", /*classes*/ ctx[6]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (default_slot) default_slot.d(detaching);
  			if (if_block) if_block.d();
  			/*div_binding*/ ctx[17](null);
  			dispose();
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$b.name,
  		type: "if",
  		source: "(56:0) {#if tag === 'div'}",
  		ctx
  	});

  	return block;
  }

  // (78:4) {#if resizable && resizableHandler}
  function create_if_block_3$6(ctx) {
  	let span;

  	const block = {
  		c: function create() {
  			span = element("span");
  			attr_dev(span, "class", "resize-handler");
  			add_location(span, file$j, 78, 6, 1734);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_3$6.name,
  		type: "if",
  		source: "(78:4) {#if resizable && resizableHandler}",
  		ctx
  	});

  	return block;
  }

  // (65:4) {#if resizable && resizableHandler}
  function create_if_block_1$9(ctx) {
  	let span;

  	const block = {
  		c: function create() {
  			span = element("span");
  			attr_dev(span, "class", "resize-handler");
  			add_location(span, file$j, 65, 6, 1495);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$9.name,
  		type: "if",
  		source: "(65:4) {#if resizable && resizableHandler}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$j(ctx) {
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;
  	const if_block_creators = [create_if_block$b, create_if_block_2$8];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*tag*/ ctx[2] === "div") return 0;
  		if (/*tag*/ ctx[2] === "p") return 1;
  		return -1;
  	}

  	if (~(current_block_type_index = select_block_type(ctx))) {
  		if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  	}

  	const block = {
  		c: function create() {
  			if (if_block) if_block.c();
  			if_block_anchor = empty$1();
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			if (~current_block_type_index) {
  				if_blocks[current_block_type_index].m(target, anchor);
  			}

  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if (~current_block_type_index) {
  					if_blocks[current_block_type_index].p(ctx, dirty);
  				}
  			} else {
  				if (if_block) {
  					group_outros();

  					transition_out(if_blocks[previous_block_index], 1, 1, () => {
  						if_blocks[previous_block_index] = null;
  					});

  					check_outros();
  				}

  				if (~current_block_type_index) {
  					if_block = if_blocks[current_block_type_index];

  					if (!if_block) {
  						if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  						if_block.c();
  					}

  					transition_in(if_block, 1);
  					if_block.m(if_block_anchor.parentNode, if_block_anchor);
  				} else {
  					if_block = null;
  				}
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (~current_block_type_index) {
  				if_blocks[current_block_type_index].d(detaching);
  			}

  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$j.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$j($$self, $$props, $$invalidate) {
  	const dispatch = createEventDispatcher();
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	let { noGap = false } = $$props;
  	let { tag = "div" } = $$props;
  	let { resizable = false } = $$props;
  	let { resizableFixed = false } = $$props;
  	let { resizableAbsolute = false } = $$props;
  	let { resizableHandler = true } = $$props;
  	let el;

  	function onClick() {
  		dispatch("click");
  		if (typeof $$props.onClick === "function") $$props.onClick();
  	}

  	function onResize(targetEl) {
  		if (el !== targetEl) return;
  		dispatch("gridResize");
  		if (typeof $$props.onGridResize === "function") $$props.onGridResize();
  	}

  	onMount(() => {
  		f7.ready(() => {
  			f7.instance.on("gridResize", onResize);
  		});
  	});

  	onDestroy(() => {
  		if (!f7.instance) return;
  		f7.instance.off("gridResize", onResize);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Row", $$slots, ['default']);

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(5, el = $$value);
  		});
  	}

  	function p_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(5, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(14, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(8, className = $$new_props.class);
  		if ("noGap" in $$new_props) $$invalidate(9, noGap = $$new_props.noGap);
  		if ("tag" in $$new_props) $$invalidate(2, tag = $$new_props.tag);
  		if ("resizable" in $$new_props) $$invalidate(3, resizable = $$new_props.resizable);
  		if ("resizableFixed" in $$new_props) $$invalidate(10, resizableFixed = $$new_props.resizableFixed);
  		if ("resizableAbsolute" in $$new_props) $$invalidate(11, resizableAbsolute = $$new_props.resizableAbsolute);
  		if ("resizableHandler" in $$new_props) $$invalidate(4, resizableHandler = $$new_props.resizableHandler);
  		if ("$$scope" in $$new_props) $$invalidate(15, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		createEventDispatcher,
  		onMount,
  		onDestroy,
  		Mixins,
  		Utils: Utils$1,
  		f7,
  		dispatch,
  		id,
  		style,
  		className,
  		noGap,
  		tag,
  		resizable,
  		resizableFixed,
  		resizableAbsolute,
  		resizableHandler,
  		el,
  		onClick,
  		onResize,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(14, $$props = assign(assign({}, $$props), $$new_props));
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(8, className = $$new_props.className);
  		if ("noGap" in $$props) $$invalidate(9, noGap = $$new_props.noGap);
  		if ("tag" in $$props) $$invalidate(2, tag = $$new_props.tag);
  		if ("resizable" in $$props) $$invalidate(3, resizable = $$new_props.resizable);
  		if ("resizableFixed" in $$props) $$invalidate(10, resizableFixed = $$new_props.resizableFixed);
  		if ("resizableAbsolute" in $$props) $$invalidate(11, resizableAbsolute = $$new_props.resizableAbsolute);
  		if ("resizableHandler" in $$props) $$invalidate(4, resizableHandler = $$new_props.resizableHandler);
  		if ("el" in $$props) $$invalidate(5, el = $$new_props.el);
  		if ("classes" in $$props) $$invalidate(6, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(6, classes = Utils$1.classNames(
  			className,
  			"row",
  			{
  				"no-gap": noGap,
  				resizable,
  				"resizable-fixed": resizableFixed,
  				"resizable-absolute": resizableAbsolute
  			},
  			Mixins.colorClasses($$props)
  		));
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		tag,
  		resizable,
  		resizableHandler,
  		el,
  		classes,
  		onClick,
  		className,
  		noGap,
  		resizableFixed,
  		resizableAbsolute,
  		dispatch,
  		onResize,
  		$$props,
  		$$scope,
  		$$slots,
  		div_binding,
  		p_binding
  	];
  }

  class Row extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance$j, create_fragment$j, safe_not_equal, {
  			id: 0,
  			style: 1,
  			class: 8,
  			noGap: 9,
  			tag: 2,
  			resizable: 3,
  			resizableFixed: 10,
  			resizableAbsolute: 11,
  			resizableHandler: 4
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Row",
  			options,
  			id: create_fragment$j.name
  		});
  	}

  	get id() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get noGap() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set noGap(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get tag() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set tag(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get resizable() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set resizable(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get resizableFixed() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set resizableFixed(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get resizableAbsolute() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set resizableAbsolute(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get resizableHandler() {
  		throw new Error("<Row>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set resizableHandler(value) {
  		throw new Error("<Row>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* node_modules/framework7-svelte/components/view.svelte generated by Svelte v3.21.0 */
  const file$k = "node_modules/framework7-svelte/components/view.svelte";

  function get_each_context$1(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[27] = list[i];
  	return child_ctx;
  }

  // (141:2) {#each pages as page (page.id)}
  function create_each_block$1(key_1, ctx) {
  	let first;
  	let switch_instance_anchor;
  	let current;
  	const switch_instance_spread_levels = [/*page*/ ctx[27].props];
  	var switch_value = /*page*/ ctx[27].component;

  	function switch_props(ctx) {
  		let switch_instance_props = {};

  		for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
  			switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
  		}

  		return {
  			props: switch_instance_props,
  			$$inline: true
  		};
  	}

  	if (switch_value) {
  		var switch_instance = new switch_value(switch_props());
  	}

  	const block = {
  		key: key_1,
  		first: null,
  		c: function create() {
  			first = empty$1();
  			if (switch_instance) create_component(switch_instance.$$.fragment);
  			switch_instance_anchor = empty$1();
  			this.first = first;
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, first, anchor);

  			if (switch_instance) {
  				mount_component(switch_instance, target, anchor);
  			}

  			insert_dev(target, switch_instance_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const switch_instance_changes = (dirty & /*pages*/ 8)
  			? get_spread_update(switch_instance_spread_levels, [get_spread_object(/*page*/ ctx[27].props)])
  			: {};

  			if (switch_value !== (switch_value = /*page*/ ctx[27].component)) {
  				if (switch_instance) {
  					group_outros();
  					const old_component = switch_instance;

  					transition_out(old_component.$$.fragment, 1, 0, () => {
  						destroy_component(old_component, 1);
  					});

  					check_outros();
  				}

  				if (switch_value) {
  					switch_instance = new switch_value(switch_props());
  					create_component(switch_instance.$$.fragment);
  					transition_in(switch_instance.$$.fragment, 1);
  					mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
  				} else {
  					switch_instance = null;
  				}
  			} else if (switch_value) {
  				switch_instance.$set(switch_instance_changes);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			if (switch_instance) transition_in(switch_instance.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			if (switch_instance) transition_out(switch_instance.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(first);
  			if (detaching) detach_dev(switch_instance_anchor);
  			if (switch_instance) destroy_component(switch_instance, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$1.name,
  		type: "each",
  		source: "(141:2) {#each pages as page (page.id)}",
  		ctx
  	});

  	return block;
  }

  function create_fragment$k(ctx) {
  	let div;
  	let t;
  	let each_blocks = [];
  	let each_1_lookup = new Map();
  	let current;
  	const default_slot_template = /*$$slots*/ ctx[25].default;
  	const default_slot = create_slot(default_slot_template, ctx, /*$$scope*/ ctx[24], null);
  	let each_value = /*pages*/ ctx[3];
  	validate_each_argument(each_value);
  	const get_key = ctx => /*page*/ ctx[27].id;
  	validate_each_keys(ctx, each_value, get_each_context$1, get_key);

  	for (let i = 0; i < each_value.length; i += 1) {
  		let child_ctx = get_each_context$1(ctx, each_value, i);
  		let key = get_key(child_ctx);
  		each_1_lookup.set(key, each_blocks[i] = create_each_block$1(key, child_ctx));
  	}

  	const block = {
  		c: function create() {
  			div = element("div");
  			if (default_slot) default_slot.c();
  			t = space();

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			attr_dev(div, "class", /*classes*/ ctx[4]);
  			attr_dev(div, "style", /*style*/ ctx[1]);
  			attr_dev(div, "id", /*id*/ ctx[0]);
  			add_location(div, file$k, 138, 0, 4153);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div, anchor);

  			if (default_slot) {
  				default_slot.m(div, null);
  			}

  			append_dev(div, t);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(div, null);
  			}

  			/*div_binding*/ ctx[26](div);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			if (default_slot) {
  				if (default_slot.p && dirty & /*$$scope*/ 16777216) {
  					default_slot.p(get_slot_context(default_slot_template, ctx, /*$$scope*/ ctx[24], null), get_slot_changes(default_slot_template, /*$$scope*/ ctx[24], dirty, null));
  				}
  			}

  			if (dirty & /*pages*/ 8) {
  				const each_value = /*pages*/ ctx[3];
  				validate_each_argument(each_value);
  				group_outros();
  				validate_each_keys(ctx, each_value, get_each_context$1, get_key);
  				each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block$1, null, get_each_context$1);
  				check_outros();
  			}

  			if (!current || dirty & /*classes*/ 16) {
  				attr_dev(div, "class", /*classes*/ ctx[4]);
  			}

  			if (!current || dirty & /*style*/ 2) {
  				attr_dev(div, "style", /*style*/ ctx[1]);
  			}

  			if (!current || dirty & /*id*/ 1) {
  				attr_dev(div, "id", /*id*/ ctx[0]);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(default_slot, local);

  			for (let i = 0; i < each_value.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(default_slot, local);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div);
  			if (default_slot) default_slot.d(detaching);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].d();
  			}

  			/*div_binding*/ ctx[26](null);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$k.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance_1($$self, $$props, $$invalidate) {
  	let { init = true } = $$props;
  	let { id = undefined } = $$props;
  	let { style = undefined } = $$props;
  	let { class: className = undefined } = $$props;
  	const dispatch = createEventDispatcher();
  	const { main, tab, tabActive } = $$props;
  	let el;
  	let pages = [];
  	let routerData;
  	let f7View;

  	function instance() {
  		return f7View;
  	}

  	function onResize(view, width) {
  		dispatch("viewResize", [width]);
  		if (typeof $$props.onViewResize === "function") $$props.onViewResize(width);
  	}

  	function onSwipeBackMove(data) {
  		dispatch("swipeBackMove", [data]);
  		if (typeof $$props.onSwipeBackMove === "function") $$props.onSwipeBackMove(data);
  	}

  	function onSwipeBackBeforeChange(data) {
  		dispatch("swipeBackBeforeChange", [data]);
  		if (typeof $$props.onSwipeBackBeforeChange === "function") $$props.onSwipeBackBeforeChange(data);
  	}

  	function onSwipeBackAfterChange(data) {
  		dispatch("swipeBackAfterChange", [data]);
  		if (typeof $$props.onSwipeBackAfterChange === "function") $$props.onSwipeBackAfterChange(data);
  	}

  	function onSwipeBackBeforeReset(data) {
  		dispatch("swipeBackBeforeReset", [data]);
  		if (typeof $$props.onSwipeBackBeforeReset === "function") $$props.onSwipeBackBeforeReset(data);
  	}

  	function onSwipeBackAfterReset(data) {
  		dispatch("swipeBackAfterReset", [data]);
  		if (typeof $$props.onSwipeBackAfterReset === "function") $$props.onSwipeBackAfterReset(data);
  	}

  	function onTabShow(tabEl) {
  		if (el !== tabEl) return;
  		dispatch("tabShow");
  		if (typeof $$props.onTabShow === "function") $$props.onTabShow(tabEl);
  	}

  	function onTabHide(tabEl) {
  		if (el !== tabEl) return;
  		dispatch("tabHide");
  		if (typeof $$props.onTabHide === "function") $$props.onTabHide(tabEl);
  	}

  	function onViewInit(view) {
  		f7View = view;
  		routerData.instance = view;
  		dispatch("viewInit", [view]);
  		if (typeof $$props.onViewInit === "function") $$props.onViewInit(view);
  	}

  	onMount(() => {
  		if (!init) return;

  		f7.ready(() => {
  			f7.instance.on("tabShow", onTabShow);
  			f7.instance.on("tabHide", onTabHide);

  			routerData = {
  				el,
  				instance: null,
  				pages,
  				setPages(p) {
  					tick().then(() => {
  						$$invalidate(3, pages = p);
  					});
  				}
  			};

  			f7.routers.views.push(routerData);

  			routerData.instance = f7.instance.views.create(el, {
  				...Utils$1.noUndefinedProps($$props),
  				on: { init: onViewInit }
  			});

  			if (!f7View) f7View = routerData.instance;
  			f7View.on("resize", onResize);
  			f7View.on("swipebackMove", onSwipeBackMove);
  			f7View.on("swipebackBeforeChange", onSwipeBackBeforeChange);
  			f7View.on("swipebackAfterChange", onSwipeBackAfterChange);
  			f7View.on("swipebackBeforeReset", onSwipeBackBeforeReset);
  			f7View.on("swipebackAfterReset", onSwipeBackAfterReset);
  		});
  	});

  	afterUpdate(() => {
  		if (!routerData) return;
  		f7.events.emit("viewRouterDidUpdate", routerData);
  	});

  	onDestroy(() => {
  		if (!init) return;

  		if (f7.instance) {
  			f7.instance.off("tabShow", onTabShow);
  			f7.instance.off("tabHide", onTabHide);
  		}

  		if (f7View) {
  			f7View.off("resize", onResize);
  			f7View.off("swipebackMove", onSwipeBackMove);
  			f7View.off("swipebackBeforeChange", onSwipeBackBeforeChange);
  			f7View.off("swipebackAfterChange", onSwipeBackAfterChange);
  			f7View.off("swipebackBeforeReset", onSwipeBackBeforeReset);
  			f7View.off("swipebackAfterReset", onSwipeBackAfterReset);

  			if (f7View.destroy) {
  				f7View.destroy();
  			}
  		}

  		f7.routers.views.splice(f7.routers.views.indexOf(routerData), 1);
  		f7View = null;
  		routerData = null;
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("View", $$slots, ['default']);

  	function div_binding($$value) {
  		binding_callbacks[$$value ? "unshift" : "push"](() => {
  			$$invalidate(2, el = $$value);
  		});
  	}

  	$$self.$set = $$new_props => {
  		$$invalidate(23, $$props = assign(assign({}, $$props), exclude_internal_props($$new_props)));
  		if ("init" in $$new_props) $$invalidate(5, init = $$new_props.init);
  		if ("id" in $$new_props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$new_props) $$invalidate(1, style = $$new_props.style);
  		if ("class" in $$new_props) $$invalidate(6, className = $$new_props.class);
  		if ("$$scope" in $$new_props) $$invalidate(24, $$scope = $$new_props.$$scope);
  	};

  	$$self.$capture_state = () => ({
  		onMount,
  		onDestroy,
  		afterUpdate,
  		createEventDispatcher,
  		tick,
  		f7,
  		Mixins,
  		Utils: Utils$1,
  		init,
  		id,
  		style,
  		className,
  		dispatch,
  		main,
  		tab,
  		tabActive,
  		el,
  		pages,
  		routerData,
  		f7View,
  		instance,
  		onResize,
  		onSwipeBackMove,
  		onSwipeBackBeforeChange,
  		onSwipeBackAfterChange,
  		onSwipeBackBeforeReset,
  		onSwipeBackAfterReset,
  		onTabShow,
  		onTabHide,
  		onViewInit,
  		classes
  	});

  	$$self.$inject_state = $$new_props => {
  		$$invalidate(23, $$props = assign(assign({}, $$props), $$new_props));
  		if ("init" in $$props) $$invalidate(5, init = $$new_props.init);
  		if ("id" in $$props) $$invalidate(0, id = $$new_props.id);
  		if ("style" in $$props) $$invalidate(1, style = $$new_props.style);
  		if ("className" in $$props) $$invalidate(6, className = $$new_props.className);
  		if ("el" in $$props) $$invalidate(2, el = $$new_props.el);
  		if ("pages" in $$props) $$invalidate(3, pages = $$new_props.pages);
  		if ("routerData" in $$props) routerData = $$new_props.routerData;
  		if ("f7View" in $$props) f7View = $$new_props.f7View;
  		if ("classes" in $$props) $$invalidate(4, classes = $$new_props.classes);
  	};

  	let classes;

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		 $$invalidate(4, classes = Utils$1.classNames(
  			className,
  			"view",
  			{
  				"view-main": main,
  				"tab-active": tabActive,
  				tab
  			},
  			Mixins.colorClasses($$props)
  		));
  	};

  	$$props = exclude_internal_props($$props);

  	return [
  		id,
  		style,
  		el,
  		pages,
  		classes,
  		init,
  		className,
  		instance,
  		routerData,
  		f7View,
  		dispatch,
  		main,
  		tab,
  		tabActive,
  		onResize,
  		onSwipeBackMove,
  		onSwipeBackBeforeChange,
  		onSwipeBackAfterChange,
  		onSwipeBackBeforeReset,
  		onSwipeBackAfterReset,
  		onTabShow,
  		onTabHide,
  		onViewInit,
  		$$props,
  		$$scope,
  		$$slots,
  		div_binding
  	];
  }

  class View$2 extends SvelteComponentDev {
  	constructor(options) {
  		super(options);

  		init(this, options, instance_1, create_fragment$k, safe_not_equal, {
  			init: 5,
  			id: 0,
  			style: 1,
  			class: 6,
  			instance: 7
  		});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "View",
  			options,
  			id: create_fragment$k.name
  		});
  	}

  	get init() {
  		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set init(value) {
  		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get id() {
  		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set id(value) {
  		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get style() {
  		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set style(value) {
  		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get class() {
  		throw new Error("<View>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set class(value) {
  		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	get instance() {
  		return this.$$.ctx[7];
  	}

  	set instance(value) {
  		throw new Error("<View>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /**
   * Framework7 Svelte 5.7.0
   * Build full featured iOS & Android apps using Framework7 & Svelte
   * https://framework7.io/svelte/
   *
   * Copyright 2014-2020 Vladimir Kharlampidi
   *
   * Released under the MIT License
   *
   * Released on: April 25, 2020
   */

  function styleInject(css, ref) {
    if ( ref === void 0 ) ref = {};
    var insertAt = ref.insertAt;

    if (!css || typeof document === 'undefined') { return; }

    var head = document.head || document.getElementsByTagName('head')[0];
    var style = document.createElement('style');
    style.type = 'text/css';

    if (insertAt === 'top') {
      if (head.firstChild) {
        head.insertBefore(style, head.firstChild);
      } else {
        head.appendChild(style);
      }
    } else {
      head.appendChild(style);
    }

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(document.createTextNode(css));
    }
  }

  var css_248z = "/**\n * Framework7 5.7.0\n * Full featured mobile HTML framework for building iOS & Android apps\n * https://framework7.io/\n *\n * Copyright 2014-2020 Vladimir Kharlampidi\n *\n * Released under the MIT License\n *\n * Released on: April 25, 2020\n */\n\n/*====================\n  Core\n  ==================== */\n:root {\n  --f7-theme-color: #007aff;\n  --f7-theme-color-rgb: 0, 122, 255;\n  --f7-theme-color-shade: #0066d6;\n  --f7-theme-color-tint: #298fff;\n  --f7-safe-area-left: 0px;\n  --f7-safe-area-right: 0px;\n  --f7-safe-area-top: 0px;\n  --f7-safe-area-bottom: 0px;\n  --f7-safe-area-outer-left: 0px;\n  --f7-safe-area-outer-right: 0px;\n  --f7-device-pixel-ratio: 1;\n}\n@supports (left: env(safe-area-inset-left)) {\n  :root {\n    --f7-safe-area-top: env(safe-area-inset-top);\n    --f7-safe-area-bottom: env(safe-area-inset-bottom);\n  }\n  :root .ios-left-edge,\n  :root .ios-edges,\n  :root .safe-area-left,\n  :root .safe-areas,\n  :root .popup,\n  :root .sheet-modal,\n  :root .panel-left {\n    --f7-safe-area-left: env(safe-area-inset-left);\n    --f7-safe-area-outer-left: env(safe-area-inset-left);\n  }\n  :root .ios-right-edge,\n  :root .ios-edges,\n  :root .safe-area-right,\n  :root .safe-areas,\n  :root .popup,\n  :root .sheet-modal,\n  :root .panel-right {\n    --f7-safe-area-right: env(safe-area-inset-right);\n    --f7-safe-area-outer-right: env(safe-area-inset-right);\n  }\n  :root .no-safe-areas,\n  :root .no-safe-area-left,\n  :root .no-ios-edges,\n  :root .no-ios-left-edge {\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-outer-left: 0px;\n  }\n  :root .no-safe-areas,\n  :root .no-safe-area-right,\n  :root .no-ios-edges,\n  :root .no-ios-right-edge {\n    --f7-safe-area-right: 0px;\n    --f7-safe-area-outer-right: 0px;\n  }\n}\n@media (-webkit-min-device-pixel-ratio: 2), (min-resolution: 2dppx) {\n  :root {\n    --f7-device-pixel-ratio: 2;\n  }\n}\n@media (-webkit-min-device-pixel-ratio: 3), (min-resolution: 3dppx) {\n  :root {\n    --f7-device-pixel-ratio: 3;\n  }\n}\n/*====================\n  Fonts & Bars\n  ==================== */\n:root {\n  --f7-font-size: 14px;\n  /*\n  --f7-bars-link-color: var(--f7-theme-color);\n  */\n  --f7-bars-bg-image: none;\n  --f7-bars-translucent-opacity: 0.8;\n  --f7-bars-translucent-blur: 20px;\n  --f7-bars-shadow-bottom-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.25) 0%, rgba(0, 0, 0, 0.08) 40%, rgba(0, 0, 0, 0.04) 50%, rgba(0, 0, 0, 0) 90%, rgba(0, 0, 0, 0) 100%);\n  --f7-bars-shadow-top-image: linear-gradient(to top, rgba(0, 0, 0, 0.25) 0%, rgba(0, 0, 0, 0.08) 40%, rgba(0, 0, 0, 0.04) 50%, rgba(0, 0, 0, 0) 90%, rgba(0, 0, 0, 0) 100%);\n  --f7-bars-text-color: #000;\n  --f7-bars-bg-color: #f7f7f8;\n  --f7-bars-bg-color-rgb: 247, 247, 248;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-bars-text-color: #fff;\n}\n.ios {\n  --f7-font-family: -apple-system, SF Pro Text, SF UI Text, system-ui, Helvetica Neue, Helvetica, Arial, sans-serif;\n  --f7-line-height: 1.4;\n  --f7-text-color: #000;\n  --f7-bars-border-color: rgba(0, 0, 0, 0.25);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-text-color: #fff;\n  --f7-bars-bg-color: #121212;\n  --f7-bars-bg-color-rgb: 22, 22, 22;\n  --f7-bars-border-color: rgba(255, 255, 255, 0.16);\n}\n.md {\n  --f7-font-family: Roboto, system-ui, Noto, Helvetica, Arial, sans-serif;\n  --f7-line-height: 1.5;\n  --f7-bars-border-color: transparent;\n  --f7-text-color: #212121;\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-text-color: rgba(255, 255, 255, 0.87);\n  --f7-bars-bg-color: #202020;\n}\n.aurora {\n  --f7-font-family: -apple-system, system-ui, Helvetica, Arial, sans-serif;\n  --f7-line-height: 1.5;\n  --f7-text-color: #000;\n  --f7-bars-border-color: rgba(0, 0, 0, 0.2);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-text-color: #fff;\n  --f7-bars-bg-color: #202020;\n  --f7-bars-border-color: rgba(255, 255, 255, 0.1);\n}\n/*====================\n  Color Themes\n  ==================== */\n.text-color-primary {\n  --f7-theme-color-text-color: var(--f7-theme-color);\n}\n.bg-color-primary {\n  --f7-theme-color-bg-color: var(--f7-theme-color);\n}\n.border-color-primary {\n  --f7-theme-color-border-color: var(--f7-theme-color);\n}\n.ripple-color-primary {\n  --f7-theme-color-ripple-color: rgba(var(--f7-theme-color-rgb), 0.3);\n}\n:root {\n  --f7-color-red: #ff3b30;\n  --f7-color-red-rgb: 255, 59, 48;\n  --f7-color-red-shade: #ff1407;\n  --f7-color-red-tint: #ff6259;\n  --f7-color-green: #4cd964;\n  --f7-color-green-rgb: 76, 217, 100;\n  --f7-color-green-shade: #2cd048;\n  --f7-color-green-tint: #6ee081;\n  --f7-color-blue: #2196f3;\n  --f7-color-blue-rgb: 33, 150, 243;\n  --f7-color-blue-shade: #0c82df;\n  --f7-color-blue-tint: #48a8f5;\n  --f7-color-pink: #ff2d55;\n  --f7-color-pink-rgb: 255, 45, 85;\n  --f7-color-pink-shade: #ff0434;\n  --f7-color-pink-tint: #ff5676;\n  --f7-color-yellow: #ffcc00;\n  --f7-color-yellow-rgb: 255, 204, 0;\n  --f7-color-yellow-shade: #d6ab00;\n  --f7-color-yellow-tint: #ffd429;\n  --f7-color-orange: #ff9500;\n  --f7-color-orange-rgb: 255, 149, 0;\n  --f7-color-orange-shade: #d67d00;\n  --f7-color-orange-tint: #ffa629;\n  --f7-color-purple: #9c27b0;\n  --f7-color-purple-rgb: 156, 39, 176;\n  --f7-color-purple-shade: #7e208f;\n  --f7-color-purple-tint: #b92fd1;\n  --f7-color-deeppurple: #673ab7;\n  --f7-color-deeppurple-rgb: 103, 58, 183;\n  --f7-color-deeppurple-shade: #563098;\n  --f7-color-deeppurple-tint: #7c52c8;\n  --f7-color-lightblue: #5ac8fa;\n  --f7-color-lightblue-rgb: 90, 200, 250;\n  --f7-color-lightblue-shade: #32bbf9;\n  --f7-color-lightblue-tint: #82d5fb;\n  --f7-color-teal: #009688;\n  --f7-color-teal-rgb: 0, 150, 136;\n  --f7-color-teal-shade: #006d63;\n  --f7-color-teal-tint: #00bfad;\n  --f7-color-lime: #cddc39;\n  --f7-color-lime-rgb: 205, 220, 57;\n  --f7-color-lime-shade: #bac923;\n  --f7-color-lime-tint: #d6e25c;\n  --f7-color-deeporange: #ff6b22;\n  --f7-color-deeporange-rgb: 255, 107, 34;\n  --f7-color-deeporange-shade: #f85200;\n  --f7-color-deeporange-tint: #ff864b;\n  --f7-color-gray: #8e8e93;\n  --f7-color-gray-rgb: 142, 142, 147;\n  --f7-color-gray-shade: #79797f;\n  --f7-color-gray-tint: #a3a3a7;\n  --f7-color-white: #ffffff;\n  --f7-color-white-rgb: 255, 255, 255;\n  --f7-color-white-shade: #ebebeb;\n  --f7-color-white-tint: #ffffff;\n  --f7-color-black: #000000;\n  --f7-color-black-rgb: 0, 0, 0;\n  --f7-color-black-shade: #000000;\n  --f7-color-black-tint: #141414;\n}\n.color-theme-red {\n  --f7-theme-color: #ff3b30;\n  --f7-theme-color-rgb: 255, 59, 48;\n  --f7-theme-color-shade: #ff1407;\n  --f7-theme-color-tint: #ff6259;\n}\n.color-theme-green {\n  --f7-theme-color: #4cd964;\n  --f7-theme-color-rgb: 76, 217, 100;\n  --f7-theme-color-shade: #2cd048;\n  --f7-theme-color-tint: #6ee081;\n}\n.color-theme-blue {\n  --f7-theme-color: #2196f3;\n  --f7-theme-color-rgb: 33, 150, 243;\n  --f7-theme-color-shade: #0c82df;\n  --f7-theme-color-tint: #48a8f5;\n}\n.color-theme-pink {\n  --f7-theme-color: #ff2d55;\n  --f7-theme-color-rgb: 255, 45, 85;\n  --f7-theme-color-shade: #ff0434;\n  --f7-theme-color-tint: #ff5676;\n}\n.color-theme-yellow {\n  --f7-theme-color: #ffcc00;\n  --f7-theme-color-rgb: 255, 204, 0;\n  --f7-theme-color-shade: #d6ab00;\n  --f7-theme-color-tint: #ffd429;\n}\n.color-theme-orange {\n  --f7-theme-color: #ff9500;\n  --f7-theme-color-rgb: 255, 149, 0;\n  --f7-theme-color-shade: #d67d00;\n  --f7-theme-color-tint: #ffa629;\n}\n.color-theme-purple {\n  --f7-theme-color: #9c27b0;\n  --f7-theme-color-rgb: 156, 39, 176;\n  --f7-theme-color-shade: #7e208f;\n  --f7-theme-color-tint: #b92fd1;\n}\n.color-theme-deeppurple {\n  --f7-theme-color: #673ab7;\n  --f7-theme-color-rgb: 103, 58, 183;\n  --f7-theme-color-shade: #563098;\n  --f7-theme-color-tint: #7c52c8;\n}\n.color-theme-lightblue {\n  --f7-theme-color: #5ac8fa;\n  --f7-theme-color-rgb: 90, 200, 250;\n  --f7-theme-color-shade: #32bbf9;\n  --f7-theme-color-tint: #82d5fb;\n}\n.color-theme-teal {\n  --f7-theme-color: #009688;\n  --f7-theme-color-rgb: 0, 150, 136;\n  --f7-theme-color-shade: #006d63;\n  --f7-theme-color-tint: #00bfad;\n}\n.color-theme-lime {\n  --f7-theme-color: #cddc39;\n  --f7-theme-color-rgb: 205, 220, 57;\n  --f7-theme-color-shade: #bac923;\n  --f7-theme-color-tint: #d6e25c;\n}\n.color-theme-deeporange {\n  --f7-theme-color: #ff6b22;\n  --f7-theme-color-rgb: 255, 107, 34;\n  --f7-theme-color-shade: #f85200;\n  --f7-theme-color-tint: #ff864b;\n}\n.color-theme-gray {\n  --f7-theme-color: #8e8e93;\n  --f7-theme-color-rgb: 142, 142, 147;\n  --f7-theme-color-shade: #79797f;\n  --f7-theme-color-tint: #a3a3a7;\n}\n.color-theme-white {\n  --f7-theme-color: #ffffff;\n  --f7-theme-color-rgb: 255, 255, 255;\n  --f7-theme-color-shade: #ebebeb;\n  --f7-theme-color-tint: #ffffff;\n}\n.color-theme-black {\n  --f7-theme-color: #000000;\n  --f7-theme-color-rgb: 0, 0, 0;\n  --f7-theme-color-shade: #000000;\n  --f7-theme-color-tint: #141414;\n}\n.color-red {\n  --f7-theme-color: #ff3b30;\n  --f7-theme-color-rgb: 255, 59, 48;\n  --f7-theme-color-shade: #ff1407;\n  --f7-theme-color-tint: #ff6259;\n}\n.text-color-red {\n  --f7-theme-color-text-color: #ff3b30;\n}\n.bg-color-red {\n  --f7-theme-color-bg-color: #ff3b30;\n}\n.border-color-red {\n  --f7-theme-color-border-color: #ff3b30;\n}\n.ripple-color-red,\n.ripple-red {\n  --f7-theme-color-ripple-color: rgba(255, 59, 48, 0.3);\n}\n.color-green {\n  --f7-theme-color: #4cd964;\n  --f7-theme-color-rgb: 76, 217, 100;\n  --f7-theme-color-shade: #2cd048;\n  --f7-theme-color-tint: #6ee081;\n}\n.text-color-green {\n  --f7-theme-color-text-color: #4cd964;\n}\n.bg-color-green {\n  --f7-theme-color-bg-color: #4cd964;\n}\n.border-color-green {\n  --f7-theme-color-border-color: #4cd964;\n}\n.ripple-color-green,\n.ripple-green {\n  --f7-theme-color-ripple-color: rgba(76, 217, 100, 0.3);\n}\n.color-blue {\n  --f7-theme-color: #2196f3;\n  --f7-theme-color-rgb: 33, 150, 243;\n  --f7-theme-color-shade: #0c82df;\n  --f7-theme-color-tint: #48a8f5;\n}\n.text-color-blue {\n  --f7-theme-color-text-color: #2196f3;\n}\n.bg-color-blue {\n  --f7-theme-color-bg-color: #2196f3;\n}\n.border-color-blue {\n  --f7-theme-color-border-color: #2196f3;\n}\n.ripple-color-blue,\n.ripple-blue {\n  --f7-theme-color-ripple-color: rgba(33, 150, 243, 0.3);\n}\n.color-pink {\n  --f7-theme-color: #ff2d55;\n  --f7-theme-color-rgb: 255, 45, 85;\n  --f7-theme-color-shade: #ff0434;\n  --f7-theme-color-tint: #ff5676;\n}\n.text-color-pink {\n  --f7-theme-color-text-color: #ff2d55;\n}\n.bg-color-pink {\n  --f7-theme-color-bg-color: #ff2d55;\n}\n.border-color-pink {\n  --f7-theme-color-border-color: #ff2d55;\n}\n.ripple-color-pink,\n.ripple-pink {\n  --f7-theme-color-ripple-color: rgba(255, 45, 85, 0.3);\n}\n.color-yellow {\n  --f7-theme-color: #ffcc00;\n  --f7-theme-color-rgb: 255, 204, 0;\n  --f7-theme-color-shade: #d6ab00;\n  --f7-theme-color-tint: #ffd429;\n}\n.text-color-yellow {\n  --f7-theme-color-text-color: #ffcc00;\n}\n.bg-color-yellow {\n  --f7-theme-color-bg-color: #ffcc00;\n}\n.border-color-yellow {\n  --f7-theme-color-border-color: #ffcc00;\n}\n.ripple-color-yellow,\n.ripple-yellow {\n  --f7-theme-color-ripple-color: rgba(255, 204, 0, 0.3);\n}\n.color-orange {\n  --f7-theme-color: #ff9500;\n  --f7-theme-color-rgb: 255, 149, 0;\n  --f7-theme-color-shade: #d67d00;\n  --f7-theme-color-tint: #ffa629;\n}\n.text-color-orange {\n  --f7-theme-color-text-color: #ff9500;\n}\n.bg-color-orange {\n  --f7-theme-color-bg-color: #ff9500;\n}\n.border-color-orange {\n  --f7-theme-color-border-color: #ff9500;\n}\n.ripple-color-orange,\n.ripple-orange {\n  --f7-theme-color-ripple-color: rgba(255, 149, 0, 0.3);\n}\n.color-purple {\n  --f7-theme-color: #9c27b0;\n  --f7-theme-color-rgb: 156, 39, 176;\n  --f7-theme-color-shade: #7e208f;\n  --f7-theme-color-tint: #b92fd1;\n}\n.text-color-purple {\n  --f7-theme-color-text-color: #9c27b0;\n}\n.bg-color-purple {\n  --f7-theme-color-bg-color: #9c27b0;\n}\n.border-color-purple {\n  --f7-theme-color-border-color: #9c27b0;\n}\n.ripple-color-purple,\n.ripple-purple {\n  --f7-theme-color-ripple-color: rgba(156, 39, 176, 0.3);\n}\n.color-deeppurple {\n  --f7-theme-color: #673ab7;\n  --f7-theme-color-rgb: 103, 58, 183;\n  --f7-theme-color-shade: #563098;\n  --f7-theme-color-tint: #7c52c8;\n}\n.text-color-deeppurple {\n  --f7-theme-color-text-color: #673ab7;\n}\n.bg-color-deeppurple {\n  --f7-theme-color-bg-color: #673ab7;\n}\n.border-color-deeppurple {\n  --f7-theme-color-border-color: #673ab7;\n}\n.ripple-color-deeppurple,\n.ripple-deeppurple {\n  --f7-theme-color-ripple-color: rgba(103, 58, 183, 0.3);\n}\n.color-lightblue {\n  --f7-theme-color: #5ac8fa;\n  --f7-theme-color-rgb: 90, 200, 250;\n  --f7-theme-color-shade: #32bbf9;\n  --f7-theme-color-tint: #82d5fb;\n}\n.text-color-lightblue {\n  --f7-theme-color-text-color: #5ac8fa;\n}\n.bg-color-lightblue {\n  --f7-theme-color-bg-color: #5ac8fa;\n}\n.border-color-lightblue {\n  --f7-theme-color-border-color: #5ac8fa;\n}\n.ripple-color-lightblue,\n.ripple-lightblue {\n  --f7-theme-color-ripple-color: rgba(90, 200, 250, 0.3);\n}\n.color-teal {\n  --f7-theme-color: #009688;\n  --f7-theme-color-rgb: 0, 150, 136;\n  --f7-theme-color-shade: #006d63;\n  --f7-theme-color-tint: #00bfad;\n}\n.text-color-teal {\n  --f7-theme-color-text-color: #009688;\n}\n.bg-color-teal {\n  --f7-theme-color-bg-color: #009688;\n}\n.border-color-teal {\n  --f7-theme-color-border-color: #009688;\n}\n.ripple-color-teal,\n.ripple-teal {\n  --f7-theme-color-ripple-color: rgba(0, 150, 136, 0.3);\n}\n.color-lime {\n  --f7-theme-color: #cddc39;\n  --f7-theme-color-rgb: 205, 220, 57;\n  --f7-theme-color-shade: #bac923;\n  --f7-theme-color-tint: #d6e25c;\n}\n.text-color-lime {\n  --f7-theme-color-text-color: #cddc39;\n}\n.bg-color-lime {\n  --f7-theme-color-bg-color: #cddc39;\n}\n.border-color-lime {\n  --f7-theme-color-border-color: #cddc39;\n}\n.ripple-color-lime,\n.ripple-lime {\n  --f7-theme-color-ripple-color: rgba(205, 220, 57, 0.3);\n}\n.color-deeporange {\n  --f7-theme-color: #ff6b22;\n  --f7-theme-color-rgb: 255, 107, 34;\n  --f7-theme-color-shade: #f85200;\n  --f7-theme-color-tint: #ff864b;\n}\n.text-color-deeporange {\n  --f7-theme-color-text-color: #ff6b22;\n}\n.bg-color-deeporange {\n  --f7-theme-color-bg-color: #ff6b22;\n}\n.border-color-deeporange {\n  --f7-theme-color-border-color: #ff6b22;\n}\n.ripple-color-deeporange,\n.ripple-deeporange {\n  --f7-theme-color-ripple-color: rgba(255, 107, 34, 0.3);\n}\n.color-gray {\n  --f7-theme-color: #8e8e93;\n  --f7-theme-color-rgb: 142, 142, 147;\n  --f7-theme-color-shade: #79797f;\n  --f7-theme-color-tint: #a3a3a7;\n}\n.text-color-gray {\n  --f7-theme-color-text-color: #8e8e93;\n}\n.bg-color-gray {\n  --f7-theme-color-bg-color: #8e8e93;\n}\n.border-color-gray {\n  --f7-theme-color-border-color: #8e8e93;\n}\n.ripple-color-gray,\n.ripple-gray {\n  --f7-theme-color-ripple-color: rgba(142, 142, 147, 0.3);\n}\n.color-white {\n  --f7-theme-color: #ffffff;\n  --f7-theme-color-rgb: 255, 255, 255;\n  --f7-theme-color-shade: #ebebeb;\n  --f7-theme-color-tint: #ffffff;\n}\n.text-color-white {\n  --f7-theme-color-text-color: #ffffff;\n}\n.bg-color-white {\n  --f7-theme-color-bg-color: #ffffff;\n}\n.border-color-white {\n  --f7-theme-color-border-color: #ffffff;\n}\n.ripple-color-white,\n.ripple-white {\n  --f7-theme-color-ripple-color: rgba(255, 255, 255, 0.3);\n}\n.color-black {\n  --f7-theme-color: #000000;\n  --f7-theme-color-rgb: 0, 0, 0;\n  --f7-theme-color-shade: #000000;\n  --f7-theme-color-tint: #141414;\n}\n.text-color-black {\n  --f7-theme-color-text-color: #000000;\n}\n.bg-color-black {\n  --f7-theme-color-bg-color: #000000;\n}\n.border-color-black {\n  --f7-theme-color-border-color: #000000;\n}\n.ripple-color-black,\n.ripple-black {\n  --f7-theme-color-ripple-color: rgba(0, 0, 0, 0.3);\n}\n@font-face {\n  font-family: 'framework7-core-icons';\n  src: url(\"data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAA0sABAAAAAAGRAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAANEAAAABoAAAAci1jrz0dERUYAAAsIAAAAIwAAACQAfQBXR1BPUwAADOAAAAAuAAAANuAY7+xHU1VCAAALLAAAAbMAAAQuAxQJ5U9TLzIAAAHcAAAASgAAAGBRKF+WY21hcAAAAowAAACIAAABYt6F0cBjdnQgAAADFAAAAAQAAAAEABEBRGdhc3AAAAsAAAAACAAAAAj//wADZ2x5ZgAAA6wAAASlAAAKBIq7ZiloZWFkAAABbAAAADAAAAA2FnYC32hoZWEAAAGcAAAAIAAAACQHgQM9aG10eAAAAigAAABhAAABJC+cAAFsb2NhAAADGAAAAJQAAACURlRI+G1heHAAAAG8AAAAHwAAACAAjwBMbmFtZQAACFQAAAFTAAAC2WC6Sihwb3N0AAAJqAAAAVYAAAJ2B5LxL3jaY2BkYGAA4iKuLVLx/DZfGbiZGEDgZk2iIYz+/+NfL0sa02cgl4MBLA0AJsoLsnjaY2BkYGD6/K+XQY8l7f8PBgaWNAagCArwBACRVQXFeNpjYGRgYPBkkGZgYQABJiBmZACJOTDogQQADdEA3AB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPabPjMUwNYwHwEoUGMQAQ7UMZAAAeNpj2M0gyAACqxgGNWAMAGIdID4A5OwD0rOA+BBI7P9PhuNAMSBmSYOK+wKxExCfBWIJoNzZ/z8Y3YBsF6g4kM2UBpFjBNJMb/7/Z9gNZBtDzGY6CzGHCcQHigMA2dAWtwAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIB3gIAAioCPAJSAmQChAKUAqQC1gLsAv4DHgMwA0IDYANyA5YDtAPEA+oD/AQWBEYEZgR4BIoEsgTIBOIFAnja7VXBTyNVGP++Ke106XamnbYztYeVlukMRmWl03ZwLdAIeCCKZgOKXBY2m15Es8S03lpuSzaSGsOGQPZGoomegI0mmwjVC5uNdZPGgzGc8MDG4ImLmyxTvzfTKmX/A7PJe/O995vXN7/3+37fK3AQBIB1nAYX8NC/hXA5t813wV+pLY/7ILft4mgIWy4Guxm8zXvwaW4bGW4EjaBuBHuDy58VCjhtfRtEg3ZDajW70yg4wMbPsefY/x7jzmAuQl/nbBi6qF/A93CWKkyECCgAUsITllPZtJaSw56ElnabuoiKqX8zlctN5e4uTEwsTOCo/6YgLAqLmM9NDQ1NvT/B4CfCTT8DHQ7NH9Ggj0gAyYTIsZ1GUNfS2dSLKKOOiH/4emTf3p5PjvsOxW2OO/TJPb7dPYYeig7n5hHW8Cu6B16gXRRez+ie3gTbQ46EeSXBWBJbzC9pS3z/yPj8/O3rffx3c2Njc6MrS1olwvfN356fHx/u50fnRkfnbF6gwS6d1w0Q4mlLc7dUUjc2MGsHaHE/wQ1cAS99NRJnixQeN6wHVbVeV6u/p53YWgt+/AlvsP1MVFA3qyiqVr2qTrciYPMJafEyaUH3mZkdQaIfJkmZvJdRcyOdnM68u8vOfyg+Qtch04TmjhLsG2HYdzibREY39zfVSkX9np7lZOf7DFFV+NbrZLmi2jpaK10F7gR8LL9JnRYoJmXU1LkelQtIak+XFOC4/H52v93esH6xTtfW0IUpdK2t/blvtl+ZTw/+ha1TtuxZzZhgdP+auMF0Mr6osYCDJGBbszy+g3nw0EThB2g1vqQeLKqEUeh921mzgG+iBgEaMblsrWz3mFlMC/wyL1MXZG+x6EVNYBOGCXyxyNtnhlms0+/ZfwcMYTzizsQjWLcMrJ8Yxrph2JxrGKW8kG5JZLpitAnRx4+jNScQj+bf8CH8iq+CAECZU2QRBSQmZlaZmOsOBLo/doc8V/yCePHzL8Vun/i1F/m8eNEvOGe4hm8RB+Y1chGvb9qJQc0O4HgcZByj3Pmp+oCSd8bhnpa/j2dCM+pr5uTkJ5NbM8PDM8NLH4RmLtFs0hy4MsKQTr2Yw6jIbHvxrPA6xJKFtbZUpRJhnTxJBPKGw/Paplouq3YdrnAFPCElQwDpAJELeBJI52k76Z51754FzVih0G55hJ2dJuzg+hkQOjXPIPMqQvToKFrDluLtmirgp+RXQN4WzqaFhWpVbTd898yE8tS09rhjrgYxAHfQ1i9oDrMi49GjJ3TsJ9+kFBxU08mfpXRIkqyHkVgsZD2UMCRlpI+441gyGTsN19k8zd5yIcxKBq1scboE9/E60zfrePG/Qr7fab/+gHfZG6YekB03Or8fp/tQsz1vW95E49EN6eoPGLbD+buJ3To63UhqsYizFEqlll+as1yd0+AC8wvlwmDJ6E2EzlR1Y/VOo3FndbWcLVOrsOcr2NdoWL818G7FLJfNiv08X7f2N+OZuF5n9Wo9wMEqrrBh2q5bF+PHGcSP1RTlJphxqop1zjitO52USS/Z7bxuAceWrJadPwMy5C2ev+V1rIhXn9HtH4d0614AAAB42q2QvU7DMBSFj9u0EgyIgewe26qJnA79G6nUpQtiyB5S01ht4sqNVFW8DBsbIxtPwcLEzltw7RqJoQNDI135y/G59rkGcIVXMBy/Du49M4R48dzAJT48N5GwW88BQvbsuYVr9um5jbARkpMFF/R357osM/Tw5LmBG7x7buIBX54D9FjtuQXO3jy3Sf/GDBpbHGCgsEKBGpwy5+jSOoBAggn6xCk2yLAkV0llSFmQOyOyeklnKLeLmd4ejFoVNe/kXT4QyaTP0022VKUyfFFkZpOVW7Uk5yM121aJPYUwWGOEiK62LImU4wo7spqslHtt1qMo10ZGKtcVySe9fw1zJ9ZuNTSfdFPFNBfHlOr/EY7+BENSx1S/b4O5ruq5NivJB7HgU34yKunJMBpH9jnOMXhKPkP7yvk4ZbFpYrfa2ZBKs1O64kIksRCCn+HSH1E3hiEAeNptkAlPwkAUhGfAAxAsyCV4/hbjfd+3aWq7SiN0yXY5/rzRhVKhiZs06b5v3rzZhxTG5+cbxH/nyHxECmkUUUYFVdRQxyoaaGIN69jBLvawjwMcGu0xTnCKM5zjApe4wjVucIs73OMBj3jCM17wijemmOYc57nARWaYZY5LzLPAZVosssQVlllhlTXWucoGm1zjOje4yS1u50LhKLdl+zIsuS3RVzKwlf/Z0qNKdgI7nhWztvjQ5l5wlJKD+LZkqPv1Lofmv5hQGpNCwjY/i2uB1P6H7zraNxW3LUMx6rAi83eptewYy6xyPF+OSDnu9uQgsJ2ekspZDKUahwgHflcoOxBDbf0FijS5uK/XLUzeFIHSFEwq+dkRlifaQgtbyV7gzczoKtHPTphZRlcrO8o8m3G8gKlplMcIisk9m5UlphjFcmQW88z4haZeSXZG3r8TK74rAAAAAAAB//8AAnjaY2BkYGDgAWIZIGYCQmYGTQZGBi0GDyCbBSzGAAANdgDVAHjadVJJTgJBFH1FdwKOIKB0lEEGwSDOs+KsaDyDGzYaE+LCEA/gwjMY4zlcegbjEYwLb4HvVwM9hXS6q/q9V/+/+v9DARhGFjWoVrP9gAhMIuh0IIxq3d81icH+I2fqNQJl/CKMJJ5C7dC3YRolow6D+Dwa2EAUeT5ZlLmb4Frkk0Waf2kkqBh38XlYmEKKCptdwpiLnWGOyT4XxSyu8Yg3fOJHmaqsGupWPat39aG+1B+uqE7xndPnM77oMZQ0nufulNG8SieTW7cV0CW0s4xPV+c9vboScj7NQkDjdmcRK2CFukG+bMV5QOGv4CLXQTGE3+3ycUzr7lR8PlfZgUEZzjAaOGv7WusywawHAaZXw2WMBKKJwz3OZLCaMl9V9v+CHpM6epFvVGtKVCX6Xg65G6SQ+McY8vCCyXSv85YyrRZ9W3QV03vbQZx6iZ3sZ5ETJ6xVkfGlgs7UOvwmM8UYXZAeHiZSYx9vOMkveMU+YyT1+Thv7e3FEStU5rkcFZIlx6/UZceHZ7hW6KTKyrlj2Rlr+r4OKve9ZDUlhzNZ23TWQ+yKiNM4dxmdt/APtJZExAB42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPpmTaIhjAYAPREFnQAA\") format(\"woff\");\n  font-weight: 400;\n  font-style: normal;\n}\n@font-face {\n  font-family: 'framework7-skeleton';\n  src: url(\"data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAYQAA0AAAAAEcQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAF9AAAABkAAAAciVvoDU9TLzIAAAGcAAAASwAAAGBRtV1jY21hcAAAAfwAAAC8AAABamglddJjdnQgAAACuAAAAAQAAAAEABEBRGdhc3AAAAXsAAAACAAAAAj //wADZ2x5ZgAAA2wAAACUAAAJjHCzhiRoZWFkAAABMAAAAC4AAAA2ERr/HWhoZWEAAAFgAAAAGgAAACQC8ADFaG10eAAAAegAAAATAAAAtAMAABFsb2NhAAACvAAAAK4AAACuaNBmhG1heHAAAAF8AAAAHwAAACAAmgA5bmFtZQAABAAAAAFQAAACuLf6wytwb3N0AAAFUAAAAJkAAADOCKMIc3jaY2BkYGAA4lUx8ibx/DZfGbiZGEDgRu39AAT9/wAjA+MBIJeDASwNACBICpsAAHjaY2BkYGA88P8Agx6QAQSMYIQCWABQZgK3AAB42mNgZGBgCGPgYGBiAAEQycgAEnNg0AMJAAANJwDUAHjaY2BhZGCcwMDKwMDow5jGwMDgDqW/MkgytDAwMDGwcjLAACMDEghIc01haGBQYKhlPPD/AIMe4wEGB5gaxgNAHgNQjhEA6dgLvQB42mNkYBBkAAJGKB4KAAAOfQAVAHjaY2BgYGaAYBkGRgYQSAHyGMF8FgYPIM3HwMHAxMDGoMSgxWDNEMsQz1D7/z9QXIFBjUGHwRHIT/z////j/w/+3/9/6//N/zeg5iABRjYGuCAjE5BgQlcAdAILK5DBxs7BycXAzcPLxy8gKCQsIiomLiEpBVYjLSMrJ6+gqKSsoqqmrqGppa2jq6dvYGhkbGJqZs5gwWBpZW1ja2fv4Ojk7OLq5u7h6eXt4+vnHxAYFBwSyjDgAABJLiG7ABEBRAAAACoAKgAqADgARgBUAGIAcAB+AIwAmgCoALYAxADYAOYA9AECARABHgEsAToBSAFWAWQBcgGAAY4BnAGqAbgBxgHUAeIB8AH+AgwCGgIoAjYCRAJSAmACbgJ8AooCmAKmArQCwgLQAt4C8gMAAw4DHAMqAzgDRgNUA2IDcAN+A4wDmgOoA7YDxAPSA+AD7gP8BAoEGAQmBDQEQgRQBF4EbAR6BIgEnASqBLgExgAAeNpjYGIQZGBgmMkYysDMwM6gt5GRQd9mEzsLw1ujjWysd2w2MTMBmQwbmUHCrCDhTexsjH9sNjGCxI0FjQXVjQWVBTvK09IYQ/+tFmQ0BprGyMDw/wAjA+MBoJkMooKKgowMDkwM/xgYRuVwyjEhybFDZBXBKv4zQFVBVI6G36jcqNyo3GiZMSo3Kjes8hQAx51w5njapZC9agJBFIXP+EfSBMEXmEoU3GVcBNFWsLEJKbYKhEUnOrjryrggkgfIQ6RMnzZVHiBNijxM6pydHUiRFAEXLvebc8+duXcBXOEFAtXXw41ngQ6ePddwgXfPdYRCeW6gIx49N9EWb55b1L/oFI1Lnq5dV8kCXTx4rqGNV8913OLTcwNdcee5CSmePLeof2CGHHucYGGwxgYFJGdeos8cQWGICQbkGCkSrOjKGJbKgu6EVOoZ7zCuilm+P1mz3hSyt+zLSA0nAxmnycpkxsrFJrFpku3Nis57NpetGkcOYbHFGAEOzJqXao6SY0ebTTJ9zO12HBy2OtVFTvGX66c0d0LhsuVO2m0ScheJKeN/z1beESuRi+pPYJ7vinlu11pGoZJT+cdwVEdBFJSbn7djzLql1/iBlBsidLlcBrG2B8MHlRqGSil51nPfEi6AO3jaXc5ZM4IBAEbhp9RF1FhCRbmyVNYskSXG0CaEQvaf2j/LN112bt6Zc/HOETZiOJAJJmSc15ENmxARFTNpSlzCtBmz5iTNW7AoJR08LFmWlbNi1Zp1G/IKijZt2bZj156SfQcOHSk7dqLi1JlzF6ouXbl241ZNXUNTy522ew8edTx59qKrF3S9edf34dOXbz9+/f0DgycTFgAAAAAAAAH//wACeNpjYGBgZACCGwmaOWC69n4AjAYARC0G1wAAAA==\") format(\"woff\");\n  font-weight: 300, 400, 500, 600, 700;\n  font-style: normal, italic;\n}\nhtml,\nbody,\n.framework7-root {\n  position: relative;\n  height: 100%;\n  width: 100%;\n  overflow-x: hidden;\n}\nbody {\n  margin: 0;\n  padding: 0;\n  width: 100%;\n  background: #fff;\n  overflow: hidden;\n  -webkit-text-size-adjust: 100%;\n  -webkit-font-smoothing: antialiased;\n  font-family: var(--f7-font-family);\n  font-size: var(--f7-font-size);\n  line-height: var(--f7-line-height);\n  color: var(--f7-text-color);\n}\n.theme-dark {\n  color: var(--f7-text-color);\n}\n.framework7-root {\n  overflow: hidden;\n  box-sizing: border-box;\n}\n.framework7-initializing *,\n.framework7-initializing *:before,\n.framework7-initializing *:after {\n  transition-duration: 0ms !important;\n}\n.device-ios,\n.device-android {\n  cursor: pointer;\n}\n.device-ios {\n  touch-action: manipulation;\n}\n@media (width: 1024px) and (height: 691px) and (orientation: landscape) {\n  html,\n  body,\n  .framework7-root {\n    height: 671px;\n  }\n}\n@media (width: 1024px) and (height: 692px) and (orientation: landscape) {\n  html,\n  body,\n  .framework7-root {\n    height: 672px;\n  }\n}\n* {\n  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);\n  -webkit-touch-callout: none;\n}\na,\ninput,\ntextarea,\nselect {\n  outline: 0;\n}\na {\n  cursor: pointer;\n  text-decoration: none;\n  color: var(--f7-theme-color);\n}\n.link,\n.item-link {\n  cursor: pointer;\n}\np {\n  margin: 1em 0;\n}\n.disabled {\n  opacity: 0.55 !important;\n  pointer-events: none !important;\n}\nhtml.device-full-viewport,\nhtml.device-full-viewport body {\n  height: 100vh;\n}\n.ios .md-only,\n.ios .if-md,\n.ios .aurora-only,\n.ios .if-aurora,\n.ios .if-not-ios,\n.ios .not-ios {\n  display: none !important;\n}\n@media (width: 1024px) and (height: 691px) and (orientation: landscape) {\n  .ios,\n  .ios body,\n  .ios .framework7-root {\n    height: 671px;\n  }\n}\n@media (width: 1024px) and (height: 692px) and (orientation: landscape) {\n  .ios,\n  .ios body,\n  .ios .framework7-root {\n    height: 672px;\n  }\n}\n.md .ios-only,\n.md .if-ios,\n.md .aurora-only,\n.md .if-aurora,\n.md .if-not-md,\n.md .not-md {\n  display: none !important;\n}\n.aurora .ios-only,\n.aurora .if-ios,\n.aurora .md-only,\n.aurora .if-md,\n.aurora .if-not-aurora,\n.aurora .not-aurora {\n  display: none !important;\n}\n/* === Statusbar === */\n/* === Views === */\n.views,\n.view {\n  position: relative;\n  height: 100%;\n  z-index: 5000;\n  overflow: hidden;\n  box-sizing: border-box;\n}\n.framework7-root > .view,\n.framework7-root > .views {\n  height: calc(100% - var(--f7-appbar-app-offset, 0px));\n}\n.view-resize-handler {\n  width: 6px;\n  height: 100%;\n  position: absolute;\n  left: var(--f7-page-master-width);\n  margin-left: -3px;\n  top: 0;\n  cursor: col-resize;\n  z-index: 1000;\n  display: none;\n}\n.view-master-detail .view-resize-handler {\n  display: block;\n}\n/* === Pages === */\n:root {\n  --f7-page-master-width: 320px;\n  --f7-page-master-border-color: rgba(0, 0, 0, 0.1);\n  --f7-page-master-border-width: 1px;\n  --f7-page-swipeback-transition-duration: 300ms;\n  --f7-page-parallax-transition-duration: 500ms;\n  --f7-page-cover-transition-duration: 450ms;\n  --f7-page-dive-transition-duration: 500ms;\n  --f7-page-fade-transition-duration: 500ms;\n  --f7-page-flip-transition-duration: 700ms;\n  --f7-page-push-transition-duration: 500ms;\n  /*\n  --f7-page-content-extra-padding-top: 0px;\n  --f7-page-content-extra-padding-bottom: 0px;\n  */\n}\n.ios {\n  --f7-page-transition-duration: 400ms;\n  --f7-page-bg-color: #efeff4;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-page-bg-color: #000;\n}\n.md {\n  --f7-page-transition-duration: 250ms;\n  --f7-page-bg-color: #fff;\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-page-bg-color: #121212;\n}\n.aurora {\n  --f7-page-transition-duration: 400ms;\n  --f7-page-bg-color: #f3f3f3;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-page-bg-color: #121212;\n}\n.theme-dark {\n  --f7-page-master-border-color: rgba(255, 255, 255, 0.1);\n}\n.pages {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n}\n.page {\n  box-sizing: border-box;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  transform: none;\n  background-color: var(--f7-page-bg-color);\n  z-index: 1;\n}\n.page.stacked {\n  display: none;\n}\n.page-with-navbar-large-collapsed {\n  --f7-navbar-large-collapse-progress: 1;\n}\n.page-previous {\n  pointer-events: none;\n}\n.page-content {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  box-sizing: border-box;\n  height: 100%;\n  position: relative;\n  z-index: 1;\n  padding-top: calc(var(--f7-page-navbar-offset, 0px) + var(--f7-page-toolbar-top-offset, 0px) + var(--f7-page-subnavbar-offset, 0px) + var(--f7-page-searchbar-offset, 0px) + var(--f7-page-content-extra-padding-top, 0px));\n  padding-bottom: calc(var(--f7-page-toolbar-bottom-offset, 0px) + var(--f7-safe-area-bottom) + var(--f7-page-content-extra-padding-bottom, 0px));\n}\n.page-transitioning,\n.page-transitioning .page-shadow-effect,\n.page-transitioning .page-opacity-effect {\n  transition-duration: var(--f7-page-transition-duration);\n}\n.page-transitioning-swipeback,\n.page-transitioning-swipeback .page-shadow-effect,\n.page-transitioning-swipeback .page-opacity-effect {\n  transition-duration: var(--f7-page-swipeback-transition-duration);\n}\n.router-transition-forward .page-next,\n.router-transition-backward .page-next,\n.router-transition-forward .page-current,\n.router-transition-backward .page-current,\n.router-transition-forward .page-previous:not(.stacked),\n.router-transition-backward .page-previous:not(.stacked) {\n  pointer-events: none;\n}\n.page-shadow-effect {\n  position: absolute;\n  top: 0;\n  width: 16px;\n  bottom: 0;\n  z-index: -1;\n  content: '';\n  opacity: 0;\n  right: 100%;\n  background: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) 10%, rgba(0, 0, 0, 0.01) 50%, rgba(0, 0, 0, 0.2) 100%);\n}\n.page-opacity-effect {\n  position: absolute;\n  left: 0;\n  top: 0;\n  background: rgba(0, 0, 0, 0.1);\n  width: 100%;\n  bottom: 0;\n  content: '';\n  opacity: 0;\n  z-index: 10000;\n}\n.ios .page-previous {\n  transform: translate3d(-20%, 0, 0);\n}\n.ios .page-next {\n  transform: translate3d(100%, 0, 0);\n}\n.ios .page-previous .page-opacity-effect {\n  opacity: 1;\n}\n.ios .page-previous:after {\n  opacity: 1;\n}\n.ios .page-current .page-shadow-effect {\n  opacity: 1;\n}\n.ios .router-transition-forward .page-next {\n  animation: ios-page-next-to-current var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-forward .page-next:before {\n  position: absolute;\n  top: 0;\n  width: 16px;\n  bottom: 0;\n  z-index: -1;\n  content: '';\n  opacity: 0;\n  right: 100%;\n  background: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) 10%, rgba(0, 0, 0, 0.01) 50%, rgba(0, 0, 0, 0.2) 100%);\n  animation: ios-page-element-fade-in var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-forward .page-current {\n  animation: ios-page-current-to-previous var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-forward .page-current:after {\n  position: absolute;\n  left: 0;\n  top: 0;\n  background: rgba(0, 0, 0, 0.1);\n  width: 100%;\n  bottom: 0;\n  content: '';\n  opacity: 0;\n  z-index: 10000;\n  animation: ios-page-element-fade-in var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-backward .page-previous {\n  animation: ios-page-previous-to-current var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-backward .page-previous:after {\n  position: absolute;\n  left: 0;\n  top: 0;\n  background: rgba(0, 0, 0, 0.1);\n  width: 100%;\n  bottom: 0;\n  content: '';\n  opacity: 0;\n  z-index: 10000;\n  animation: ios-page-element-fade-out var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-backward .page-current {\n  animation: ios-page-current-to-next var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-backward .page-current:before {\n  position: absolute;\n  top: 0;\n  width: 16px;\n  bottom: 0;\n  z-index: -1;\n  content: '';\n  opacity: 0;\n  right: 100%;\n  background: linear-gradient(to right, rgba(0, 0, 0, 0) 0%, rgba(0, 0, 0, 0) 10%, rgba(0, 0, 0, 0.01) 50%, rgba(0, 0, 0, 0.2) 100%);\n  animation: ios-page-element-fade-out var(--f7-page-transition-duration) forwards;\n}\n@keyframes ios-page-next-to-current {\n  from {\n    transform: translate3d(100%, 0, 0);\n  }\n  to {\n    transform: translate3d(0%, 0, 0);\n  }\n}\n@keyframes ios-page-previous-to-current {\n  from {\n    transform: translate3d(-20%, 0, 0);\n  }\n  to {\n    transform: translate3d(0%, 0, 0);\n  }\n}\n@keyframes ios-page-current-to-previous {\n  from {\n    transform: translate3d(0, 0, 0);\n  }\n  to {\n    transform: translate3d(-20%, 0, 0);\n  }\n}\n@keyframes ios-page-current-to-next {\n  from {\n    transform: translate3d(0, 0, 0);\n  }\n  to {\n    transform: translate3d(100%, 0, 0);\n  }\n}\n@keyframes ios-page-element-fade-in {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes ios-page-element-fade-out {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n.md .page-next {\n  transform: translate3d(0, 56px, 0);\n  opacity: 0;\n  pointer-events: none;\n}\n.md .page-next.page-next-on-right {\n  transform: translate3d(100%, 0, 0);\n}\n.md .router-transition-forward .page-next {\n  animation: md-page-next-to-current var(--f7-page-transition-duration) forwards;\n}\n.md .router-transition-forward .page-current {\n  animation: none;\n}\n.md .router-transition-backward .page-current {\n  animation: md-page-current-to-next var(--f7-page-transition-duration) forwards;\n}\n.md .router-transition-backward .page-previous {\n  animation: none;\n}\n@keyframes md-page-next-to-current {\n  from {\n    transform: translate3d(0, 56px, 0);\n    opacity: 0;\n  }\n  to {\n    transform: translate3d(0, 0px, 0);\n    opacity: 1;\n  }\n}\n@keyframes md-page-current-to-next {\n  from {\n    transform: translate3d(0, 0, 0);\n    opacity: 1;\n  }\n  to {\n    transform: translate3d(0, 56px, 0);\n    opacity: 0;\n  }\n}\n.aurora .page-next {\n  pointer-events: none;\n  transform: translate3d(100%, 0px, 0);\n}\n.aurora .page-next.page-next-on-right {\n  transform: translate3d(100%, 0, 0);\n}\n.aurora .page-previous .page-opacity-effect {\n  opacity: 1;\n}\n.aurora .page-previous:after {\n  opacity: 1;\n}\n.aurora .router-transition-forward .page-next {\n  animation: aurora-page-next-to-current var(--f7-page-transition-duration) forwards;\n}\n.aurora .router-transition-forward .page-current {\n  animation: none;\n}\n.aurora .router-transition-forward .page-current:after {\n  position: absolute;\n  left: 0;\n  top: 0;\n  background: rgba(0, 0, 0, 0.1);\n  width: 100%;\n  bottom: 0;\n  content: '';\n  opacity: 0;\n  z-index: 10000;\n  animation: aurora-page-element-fade-in var(--f7-page-transition-duration) forwards;\n}\n.aurora .router-transition-backward .page-current {\n  animation: aurora-page-current-to-next var(--f7-page-transition-duration) forwards;\n}\n.aurora .router-transition-backward .page-previous {\n  animation: none;\n}\n.aurora .router-transition-backward .page-previous:after {\n  position: absolute;\n  left: 0;\n  top: 0;\n  background: rgba(0, 0, 0, 0.1);\n  width: 100%;\n  bottom: 0;\n  content: '';\n  opacity: 0;\n  z-index: 10000;\n  animation: aurora-page-element-fade-out var(--f7-page-transition-duration) forwards;\n}\n@keyframes aurora-page-next-to-current {\n  from {\n    transform: translate3d(100%, 0, 0);\n  }\n  to {\n    transform: translate3d(0, 0px, 0);\n  }\n}\n@keyframes aurora-page-current-to-next {\n  from {\n    transform: translate3d(0, 0, 0);\n  }\n  to {\n    transform: translate3d(100%, 0, 0);\n  }\n}\n@keyframes aurora-page-element-fade-in {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes aurora-page-element-fade-out {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n.view:not(.view-master-detail) .page-master-stacked {\n  display: none;\n}\n.view:not(.view-master-detail) .navbar-master-stacked {\n  display: none;\n}\n.view-master-detail .page-master,\n.view-master-detail .navbar-master {\n  width: var(--f7-page-master-width);\n  --f7-safe-area-right: 0px;\n  --f7-safe-area-outer-right: 0px;\n  border-right: var(--f7-page-master-border-width) solid var(--f7-page-master-border-color);\n}\n.view-master-detail .page-master-detail,\n.view-master-detail .navbar-master-detail {\n  width: calc(100% - var(--f7-page-master-width));\n  --f7-safe-area-left: 0px;\n  --f7-safe-area-outer-left: 0px;\n  left: var(--f7-page-master-width);\n}\n.view-master-detail .page-master {\n  z-index: 2;\n  transform: none;\n  pointer-events: auto;\n}\n.view-master-detail .page-master:before,\n.view-master-detail .page-master:after {\n  display: none;\n}\n.view-master-detail.router-transition .page-master {\n  animation: none;\n}\n.md .router-transition-custom .page-previous,\n.ios .router-transition-custom .page-previous,\n.aurora .router-transition-custom .page-previous,\n.md .router-transition-custom .page-next,\n.ios .router-transition-custom .page-next,\n.aurora .router-transition-custom .page-next {\n  opacity: 1;\n  transform: none;\n}\n.router-transition-f7-circle-forward:after,\n.router-transition-f7-circle-backward:after {\n  content: '';\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  width: 100vmax;\n  height: 100vmax;\n  margin-left: -50vmax;\n  margin-top: -50vmax;\n  background: var(--f7-page-bg-color);\n  z-index: 100;\n}\n.router-transition-f7-circle-forward:after {\n  transform: scale(0);\n  border-radius: 50%;\n  animation: f7-circle-circle-in 400ms forwards;\n}\n.router-transition-f7-circle-forward .page-next {\n  opacity: 0 !important;\n  transform: scale(0.9) !important;\n  animation: f7-circle-next-to-current 300ms forwards;\n  animation-delay: 300ms;\n  z-index: 150;\n}\n.router-transition-f7-circle-backward:after {\n  animation: f7-circle-circle-out 300ms forwards;\n  animation-delay: 350ms;\n}\n.router-transition-f7-circle-backward .page-current {\n  animation: f7-circle-current-to-next 700ms forwards;\n  z-index: 150;\n}\n@keyframes f7-circle-circle-in {\n  from {\n    transform: scale(0);\n    border-radius: 50%;\n  }\n  50% {\n    border-radius: 50%;\n  }\n  to {\n    transform: scale(1);\n    border-radius: 0%;\n  }\n}\n@keyframes f7-circle-circle-out {\n  from {\n    transform: scale(1);\n    border-radius: 0%;\n  }\n  50% {\n    border-radius: 50%;\n  }\n  to {\n    transform: scale(0);\n    border-radius: 50%;\n  }\n}\n@keyframes f7-circle-next-to-current {\n  from {\n    transform: scale(0.9);\n    opacity: 0;\n  }\n  40% {\n    transform: scale(1.035);\n    opacity: 1;\n  }\n  to {\n    transform: scale(1);\n    opacity: 1;\n  }\n}\n@keyframes f7-circle-current-to-next {\n  from {\n    transform: scale(1);\n    opacity: 1;\n  }\n  34% {\n    transform: scale(1.035);\n    opacity: 1;\n  }\n  57% {\n    transform: scale(0.9);\n    opacity: 0;\n  }\n  to {\n    transform: scale(0.9);\n    opacity: 0;\n  }\n}\n.router-transition-f7-cover-v-forward,\n.router-transition-f7-cover-v-backward {\n  background: #000;\n  perspective: 1200px;\n}\n.router-transition-f7-cover-v-forward .page-next {\n  animation: f7-cover-v-next-to-current var(--f7-page-cover-transition-duration) forwards;\n}\n.router-transition-f7-cover-v-forward .page-current {\n  animation: f7-cover-v-current-to-prev var(--f7-page-cover-transition-duration) forwards;\n}\n.router-transition-f7-cover-v-backward .page-current {\n  animation: f7-cover-v-current-to-next var(--f7-page-cover-transition-duration) forwards;\n}\n.router-transition-f7-cover-v-backward .page-previous {\n  animation: f7-cover-v-prev-to-current var(--f7-page-cover-transition-duration) forwards;\n}\n@keyframes f7-cover-v-next-to-current {\n  from {\n    transform: translateY(100%);\n  }\n  to {\n    transform: translateY(0%);\n  }\n}\n@keyframes f7-cover-v-current-to-next {\n  from {\n    transform: translateY(0%);\n  }\n  to {\n    transform: translateY(100%);\n  }\n}\n@keyframes f7-cover-v-current-to-prev {\n  from {\n    transform: translateZ(0);\n    opacity: 1;\n  }\n  to {\n    transform: translateZ(-300px);\n    opacity: 0.5;\n  }\n}\n@keyframes f7-cover-v-prev-to-current {\n  from {\n    transform: translateZ(-300px);\n    opacity: 0.5;\n  }\n  to {\n    transform: translateZ(0);\n    opacity: 1;\n  }\n}\n.router-transition-f7-cover-forward,\n.router-transition-f7-cover-backward {\n  background: #000;\n  perspective: 1200px;\n}\n.router-transition-f7-cover-forward .page-next {\n  animation: f7-cover-next-to-current var(--f7-page-cover-transition-duration) forwards;\n}\n.router-transition-f7-cover-forward .page-current {\n  animation: f7-cover-current-to-prev var(--f7-page-cover-transition-duration) forwards;\n}\n.router-transition-f7-cover-backward .page-current {\n  animation: f7-cover-current-to-next var(--f7-page-cover-transition-duration) forwards;\n}\n.router-transition-f7-cover-backward .page-previous {\n  animation: f7-cover-prev-to-current var(--f7-page-cover-transition-duration) forwards;\n}\n@keyframes f7-cover-next-to-current {\n  from {\n    transform: translateX(100%);\n  }\n  to {\n    transform: translateX(0%);\n  }\n}\n@keyframes f7-cover-current-to-next {\n  from {\n    transform: translateX(0%);\n  }\n  to {\n    transform: translateX(100%);\n  }\n}\n@keyframes f7-cover-current-to-prev {\n  from {\n    transform: translateZ(0);\n    opacity: 1;\n  }\n  to {\n    transform: translateZ(-300px);\n    opacity: 0.5;\n  }\n}\n@keyframes f7-cover-prev-to-current {\n  from {\n    transform: translateZ(-300px);\n    opacity: 0.5;\n  }\n  to {\n    transform: translateZ(0);\n    opacity: 1;\n  }\n}\n.router-transition-f7-dive-forward,\n.router-transition-f7-dive-backward {\n  background: var(--f7-page-bg-color);\n  perspective: 1200px;\n}\n.router-transition-f7-dive-forward .page-next {\n  animation: f7-dive-next-to-current var(--f7-page-dive-transition-duration) forwards;\n}\n.router-transition-f7-dive-forward .page-current {\n  animation: f7-dive-current-to-prev var(--f7-page-dive-transition-duration) forwards;\n}\n.router-transition-f7-dive-backward .page-current {\n  animation: f7-dive-current-to-next var(--f7-page-dive-transition-duration) forwards;\n}\n.router-transition-f7-dive-backward .page-previous {\n  animation: f7-dive-prev-to-current var(--f7-page-dive-transition-duration) forwards;\n}\n@keyframes f7-dive-next-to-current {\n  from {\n    opacity: 0;\n    transform: translateZ(-150px);\n  }\n  50% {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n    transform: translateZ(0px);\n  }\n}\n@keyframes f7-dive-current-to-next {\n  from {\n    opacity: 1;\n    transform: translateZ(0px);\n  }\n  50% {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n    transform: translateZ(-150px);\n  }\n}\n@keyframes f7-dive-current-to-prev {\n  from {\n    transform: translateZ(0px);\n    opacity: 1;\n  }\n  50% {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n    transform: translateZ(150px);\n  }\n}\n@keyframes f7-dive-prev-to-current {\n  from {\n    opacity: 0;\n    transform: translateZ(150px);\n  }\n  50% {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n    transform: translateZ(0px);\n  }\n}\n.router-transition-f7-fade-forward,\n.router-transition-f7-fade-backward {\n  background: var(--f7-page-bg-color);\n}\n.router-transition-f7-fade-forward .page-next {\n  opacity: 0 !important;\n  animation: f7-fade-in var(--f7-page-fade-transition-duration) forwards;\n}\n.router-transition-f7-fade-forward .page-current {\n  animation: f7-fade-out var(--f7-page-fade-transition-duration) forwards;\n}\n.router-transition-f7-fade-backward .page-current {\n  animation: f7-fade-out var(--f7-page-fade-transition-duration) forwards;\n}\n.router-transition-f7-fade-backward .page-previous {\n  animation: f7-fade-in var(--f7-page-fade-transition-duration) forwards;\n}\n@keyframes f7-fade-in {\n  from {\n    opacity: 0;\n  }\n  50% {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes f7-fade-out {\n  from {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n.router-transition-f7-flip-forward,\n.router-transition-f7-flip-backward {\n  background: #000;\n  perspective: 1200px;\n}\n.router-transition-f7-flip-forward .page,\n.router-transition-f7-flip-backward .page {\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.router-transition-f7-flip-forward .page-next {\n  animation: f7-flip-next-to-current var(--f7-page-flip-transition-duration) forwards;\n}\n.router-transition-f7-flip-forward .page-current {\n  animation: f7-flip-current-to-prev var(--f7-page-flip-transition-duration) forwards;\n}\n.router-transition-f7-flip-backward .page-current {\n  animation: f7-flip-current-to-next var(--f7-page-flip-transition-duration) forwards;\n}\n.router-transition-f7-flip-backward .page-previous {\n  animation: f7-flip-prev-to-current var(--f7-page-flip-transition-duration) forwards;\n}\n@keyframes f7-flip-next-to-current {\n  from {\n    border-radius: 30px;\n    transform: translateZ(-100vmax) rotateY(180deg);\n  }\n  to {\n    border-radius: 0;\n    transform: translateZ(0px) rotateY(0deg);\n  }\n}\n@keyframes f7-flip-current-to-next {\n  from {\n    border-radius: 0px;\n    transform: translateZ(0px) rotateY(0deg);\n  }\n  to {\n    border-radius: 30px;\n    transform: translateZ(-100vmax) rotateY(180deg);\n  }\n}\n@keyframes f7-flip-current-to-prev {\n  from {\n    border-radius: 0px;\n    transform: translateZ(0px) rotateY(0deg);\n  }\n  to {\n    border-radius: 30px;\n    transform: translateZ(-100vmax) rotateY(-180deg);\n  }\n}\n@keyframes f7-flip-prev-to-current {\n  from {\n    border-radius: 30px;\n    transform: translateZ(-100vmax) rotateY(-180deg);\n  }\n  to {\n    border-radius: 0px;\n    transform: translateZ(0px) rotateY(0deg);\n  }\n}\n.router-transition-f7-parallax-forward .page-next {\n  animation: f7-parallax-next-to-current var(--f7-page-parallax-transition-duration) forwards;\n}\n.router-transition-f7-parallax-forward .page-current {\n  animation: f7-parallax-current-to-prev var(--f7-page-parallax-transition-duration) forwards;\n}\n.router-transition-f7-parallax-backward .page-current {\n  animation: f7-parallax-current-to-next var(--f7-page-parallax-transition-duration) forwards;\n}\n.router-transition-f7-parallax-backward .page-previous {\n  animation: f7-parallax-prev-to-current var(--f7-page-parallax-transition-duration) forwards;\n}\n@keyframes f7-parallax-next-to-current {\n  from {\n    transform: translateX(100%);\n  }\n  to {\n    transform: translateX(0%);\n  }\n}\n@keyframes f7-parallax-current-to-next {\n  from {\n    transform: translateX(0%);\n  }\n  to {\n    transform: translateX(100%);\n  }\n}\n@keyframes f7-parallax-current-to-prev {\n  from {\n    transform: translateX(0%);\n  }\n  to {\n    transform: translateX(-20%);\n  }\n}\n@keyframes f7-parallax-prev-to-current {\n  from {\n    transform: translateX(-20%);\n  }\n  to {\n    transform: translateX(0%);\n  }\n}\n.router-transition-f7-push-forward .page-next {\n  animation: f7-push-next-to-current var(--f7-page-push-transition-duration) forwards;\n}\n.router-transition-f7-push-forward .page-current {\n  animation: f7-push-current-to-prev var(--f7-page-push-transition-duration) forwards;\n}\n.router-transition-f7-push-backward .page-current {\n  animation: f7-push-current-to-next var(--f7-page-push-transition-duration) forwards;\n}\n.router-transition-f7-push-backward .page-previous {\n  animation: f7-push-prev-to-current var(--f7-page-push-transition-duration) forwards;\n}\n@keyframes f7-push-next-to-current {\n  from {\n    transform: translateX(100%);\n  }\n  to {\n    transform: translateX(0%);\n  }\n}\n@keyframes f7-push-current-to-next {\n  from {\n    transform: translateX(0%);\n  }\n  to {\n    transform: translateX(100%);\n  }\n}\n@keyframes f7-push-current-to-prev {\n  from {\n    transform: translateX(0%);\n  }\n  to {\n    transform: translateX(-100%);\n  }\n}\n@keyframes f7-push-prev-to-current {\n  from {\n    transform: translateX(-100%);\n  }\n  to {\n    transform: translateX(0%);\n  }\n}\n/* === Link === */\n:root {\n  --f7-link-highlight-black: rgba(0, 0, 0, 0.1);\n  --f7-link-highlight-white: rgba(255, 255, 255, 0.15);\n  --f7-link-highlight-color: var(--f7-link-highlight-black);\n}\n.theme-dark {\n  --f7-link-highlight-color: var(--f7-link-highlight-white);\n}\n.link,\n.tab-link {\n  display: inline-flex;\n  align-items: center;\n  align-content: center;\n  justify-content: center;\n  position: relative;\n  box-sizing: border-box;\n  z-index: 1;\n}\n.link i + span,\n.link i + i,\n.link span + i,\n.link span + span {\n  margin-left: 4px;\n}\n.ios .link {\n  transition: opacity 300ms;\n}\n.ios .link.active-state {\n  opacity: 0.3;\n  transition-duration: 0ms;\n}\n.aurora .link {\n  transition: opacity 300ms;\n}\n.aurora .link.active-state {\n  opacity: 0.3;\n  transition-duration: 0ms;\n}\n/* === Navbar === */\n:root {\n  /*\n  --f7-navbar-bg-color: var(--f7-bars-bg-color);\n  --f7-navbar-bg-color-rgb: var(--f7-bars-bg-color-rgb);\n  --f7-navbar-bg-image: var(--f7-bars-bg-image);\n  --f7-navbar-border-color: var(--f7-bars-border-color);\n  --f7-navbar-link-color: var(--f7-bars-link-color);\n  --f7-navbar-text-color: var(--f7-bars-text-color);\n  */\n  --f7-navbar-hide-show-transition-duration: 400ms;\n  --f7-navbar-title-line-height: 1.2;\n  --f7-navbar-title-font-size: inherit;\n  --f7-navbar-subtitle-text-align: inherit;\n  --f7-navbar-large-title-line-height: 1.2;\n  --f7-navbar-large-title-text-color: inherit;\n  --f7-navbar-large-title-padding-left: 16px;\n  --f7-navbar-large-title-padding-right: 16px;\n}\n.ios {\n  --f7-navbar-height: 44px;\n  --f7-navbar-tablet-height: 44px;\n  --f7-navbar-font-size: 17px;\n  --f7-navbar-inner-padding-left: 8px;\n  --f7-navbar-inner-padding-right: 8px;\n  --f7-navbar-title-font-weight: 600;\n  --f7-navbar-title-margin-left: 0;\n  --f7-navbar-title-margin-right: 0;\n  --f7-navbar-title-text-align: center;\n  --f7-navbar-subtitle-font-size: 10px;\n  --f7-navbar-subtitle-line-height: 1;\n  --f7-navbar-shadow-image: none;\n  --f7-navbar-large-title-height: 52px;\n  --f7-navbar-large-title-font-size: 34px;\n  --f7-navbar-large-title-font-weight: 700;\n  --f7-navbar-large-title-letter-spacing: -0.03em;\n  --f7-navbar-large-title-padding-vertical: 6px;\n  /*\n  --f7-navbar-link-height: var(--f7-navbar-height);\n  --f7-navbar-link-line-height: var(--f7-navbar-height);\n  */\n  --f7-navbar-subtitle-text-color: rgba(0, 0, 0, 0.55);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-navbar-subtitle-text-color: rgba(255, 255, 255, 0.55);\n}\n.md {\n  --f7-navbar-height: 56px;\n  --f7-navbar-tablet-height: 64px;\n  --f7-navbar-font-size: 20px;\n  --f7-navbar-inner-padding-left: 0px;\n  --f7-navbar-inner-padding-right: 0px;\n  --f7-navbar-title-font-weight: 500;\n  --f7-navbar-title-margin-left: 16px;\n  --f7-navbar-title-margin-right: 16px;\n  --f7-navbar-title-text-align: left;\n  --f7-navbar-subtitle-font-size: 14px;\n  --f7-navbar-subtitle-line-height: 1.2;\n  --f7-navbar-shadow-image: var(--f7-bars-shadow-bottom-image);\n  --f7-navbar-large-title-font-size: 34px;\n  --f7-navbar-large-title-height: 56px;\n  --f7-navbar-large-title-font-weight: 500;\n  --f7-navbar-large-title-letter-spacing: 0;\n  --f7-navbar-large-title-padding-vertical: 8px;\n  /*\n  --f7-navbar-link-height: var(--f7-navbar-height);\n  --f7-navbar-link-line-height: var(--f7-navbar-height);\n  */\n  --f7-navbar-subtitle-text-color: rgba(0, 0, 0, 0.85);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-navbar-subtitle-text-color: rgba(255, 255, 255, 0.85);\n}\n.aurora {\n  --f7-navbar-height: 38px;\n  --f7-navbar-tablet-height: 38px;\n  --f7-navbar-font-size: 14px;\n  --f7-navbar-inner-padding-left: 16px;\n  --f7-navbar-inner-padding-right: 16px;\n  --f7-navbar-title-font-weight: 600;\n  --f7-navbar-title-margin-left: 0;\n  --f7-navbar-title-margin-right: 0;\n  --f7-navbar-title-text-align: center;\n  --f7-navbar-subtitle-font-size: 12px;\n  --f7-navbar-subtitle-line-height: 1;\n  --f7-navbar-shadow-image: none;\n  --f7-navbar-large-title-height: 38px;\n  --f7-navbar-large-title-font-size: 26px;\n  --f7-navbar-large-title-font-weight: bold;\n  --f7-navbar-large-title-letter-spacing: -0.03em;\n  --f7-navbar-large-title-padding-vertical: 4px;\n  --f7-navbar-link-height: auto;\n  --f7-navbar-link-line-height: inherit;\n  --f7-navbar-subtitle-text-color: rgba(0, 0, 0, 0.6);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-navbar-subtitle-text-color: rgba(255, 255, 255, 0.5);\n}\n.navbars,\n.navbar {\n  z-index: 500;\n  left: 0;\n  top: 0;\n  width: 100%;\n}\n.navbars {\n  position: absolute;\n}\n.navbars .navbar {\n  z-index: auto;\n}\n.navbar {\n  --f7-navbar-large-collapse-progress: 0;\n  position: relative;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  box-sizing: border-box;\n  margin: 0;\n  height: calc(var(--f7-navbar-height) + var(--f7-safe-area-top));\n  color: var(--f7-navbar-text-color, var(--f7-bars-text-color));\n  font-size: var(--f7-navbar-font-size);\n}\n.navbar.stacked {\n  display: none;\n}\n.navbar b {\n  font-weight: 500;\n}\n.navbar a {\n  color: var(--f7-navbar-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n}\n.navbar a.link {\n  display: flex;\n  justify-content: flex-start;\n  line-height: var(--f7-navbar-link-line-height, var(--f7-navbar-height));\n  height: var(--f7-navbar-link-height, var(--f7-navbar-height));\n}\n.navbar .title,\n.navbar .left,\n.navbar .right {\n  position: relative;\n  z-index: 10;\n}\n.navbar .title {\n  position: relative;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  flex-shrink: 10;\n  font-weight: var(--f7-navbar-title-font-weight);\n  display: inline-block;\n  line-height: var(--f7-navbar-title-line-height);\n  text-align: var(--f7-navbar-title-text-align);\n  font-size: var(--f7-navbar-title-font-size);\n  margin-left: var(--f7-navbar-title-margin-left);\n  margin-right: var(--f7-navbar-title-margin-left);\n}\n.navbar .subtitle {\n  display: block;\n  color: var(--f7-navbar-subtitle-text-color);\n  font-weight: normal;\n  font-size: var(--f7-navbar-subtitle-font-size);\n  line-height: var(--f7-navbar-subtitle-line-height);\n  text-align: var(--f7-navbar-subtitle-text-align);\n}\n.navbar .left,\n.navbar .right {\n  flex-shrink: 0;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n.navbar .right:first-child {\n  position: absolute;\n  height: 100%;\n}\n.navbar.no-hairline .navbar-bg:after,\n.navbar.no-border .navbar-bg:after,\n.navbar .no-hairline .navbar-bg:after,\n.navbar .no-border .navbar-bg:after {\n  display: none !important;\n}\n.navbar.no-hairline .title-large:after,\n.navbar.no-border .title-large:after,\n.navbar .no-hairline .title-large:after,\n.navbar .no-border .title-large:after {\n  display: none !important;\n}\n.navbar.no-shadow .navbar-bg:before,\n.navbar .no-shadow .navbar-bg:before {\n  display: none !important;\n}\n.navbar.navbar-hidden .navbar-bg:before,\n.navbar-hidden .navbar .navbar-bg:before {\n  opacity: 0 !important;\n}\n.navbar-bg {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 0;\n  background: var(--f7-navbar-bg-color);\n  background-image: var(--f7-navbar-bg-image, var(--f7-bars-bg-image));\n  background-color: var(--f7-navbar-bg-color, var(--f7-bars-bg-color));\n  transition-property: transform;\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-bars .navbar-bg {\n    background-color: rgba(var(--f7-navbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)), var(--f7-bars-translucent-opacity));\n    -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n            backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n  }\n}\n.navbar-bg:after,\n.navbar-bg:before {\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.navbar-bg:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-navbar-border-color, var(--f7-bars-border-color));\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.navbar-bg:before {\n  content: '';\n  position: absolute;\n  right: 0;\n  width: 100%;\n  top: 100%;\n  bottom: auto;\n  height: 8px;\n  pointer-events: none;\n  background: var(--f7-navbar-shadow-image);\n}\n.navbar-bg:after {\n  z-index: 1;\n}\n@media (min-width: 768px) and (min-height: 600px) {\n  :root {\n    --f7-navbar-height: var(--f7-navbar-tablet-height);\n  }\n}\n.navbar-transitioning,\n.navbar-transitioning .left,\n.navbar-transitioning .title,\n.navbar-transitioning .right,\n.navbar-transitioning .title-large-text,\n.navbar-transitioning .navbar-bg,\n.navbar-transitioning .subnavbar,\n.navbar-transitioning .navbar-bg:before {\n  transition-duration: var(--f7-navbar-hide-show-transition-duration);\n}\n.navbar-page-transitioning {\n  transition-duration: var(--f7-page-swipeback-transition-duration) !important;\n}\n.navbar-page-transitioning .title-large-text,\n.navbar-page-transitioning .navbar-bg {\n  transition-duration: var(--f7-page-swipeback-transition-duration) !important;\n}\n.navbar-hidden {\n  transform: translate3d(0, calc(-1 * var(--f7-navbar-height)), 0);\n}\n.navbar-hidden .navbar-inner {\n  pointer-events: none;\n}\n.navbar-hidden .navbar-inner > .left,\n.navbar-hidden .navbar-inner > .title,\n.navbar-hidden .navbar-inner > .right {\n  opacity: 0 !important;\n}\n.navbar-hidden .subnavbar {\n  pointer-events: auto;\n}\n.navbar-hidden-statusbar {\n  transform: translate3d(0, calc(-1 * var(--f7-navbar-height) - var(--f7-safe-area-top)), 0);\n}\n.navbar-large-hidden .navbar-large {\n  --f7-navbar-large-collapse-progress: 1;\n}\n.navbar-inner {\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  padding: var(--f7-safe-area-top) calc(var(--f7-navbar-inner-padding-right) + var(--f7-safe-area-right)) 0 calc(var(--f7-navbar-inner-padding-left) + var(--f7-safe-area-left));\n  transform: translate3d(0, 0, 0);\n  z-index: 10;\n}\n.views > .navbar,\n.view > .navbar,\n.page > .navbar,\n.navbars > .navbar {\n  position: absolute;\n}\n.navbar-transparent:not(.navbar-large):not(.navbar-transparent-visible):not(.with-searchbar-expandable-enabled) .navbar-bg,\n.navbar-transparent:not(.navbar-large):not(.navbar-transparent-visible):not(.with-searchbar-expandable-enabled) .title {\n  opacity: 0;\n}\n.navbar-large .navbar-bg {\n  height: calc(100% + var(--f7-navbar-large-title-height));\n  transform: translate3d(0px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0);\n}\n.navbar-large-transparent .navbar-bg,\n.navbar-large.navbar-transparent .navbar-bg {\n  opacity: var(--f7-navbar-large-collapse-progress);\n  height: 100%;\n  transform: none;\n}\n.ios .router-navbar-transition-to-large .navbar-bg,\n.ios .router-navbar-transition-from-large .navbar-bg,\n.navbar-bg.ios-swipeback-navbar-bg-large,\n.navbar-large-transparent .navbar-bg.ios-swipeback-navbar-bg-large,\n.navbar-large.navbar-transparent .navbar-bg.ios-swipeback-navbar-bg-large {\n  height: calc(100% + var(--f7-navbar-large-title-height));\n  transform: translate3d(0px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0);\n}\n.ios .navbar:not(.navbar-large) .navbar-bg {\n  --f7-navbar-large-collapse-progress: 1;\n}\n.navbar-large .title {\n  opacity: var(--f7-navbar-large-collapse-progress);\n}\n.navbar-large-collapsed {\n  --f7-navbar-large-collapse-progress: 1;\n}\n.navbar-large-collapsed .title-large {\n  pointer-events: none;\n}\n.navbar .title-large {\n  box-sizing: border-box;\n  position: absolute;\n  left: 0;\n  right: 0;\n  top: 100%;\n  display: flex;\n  align-items: flex-end;\n  white-space: nowrap;\n  overflow: hidden;\n  height: var(--f7-navbar-large-title-height);\n  z-index: 5;\n}\n.navbar .title-large-text {\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  color: var(--f7-navbar-large-title-text-color);\n  letter-spacing: var(--f7-navbar-large-title-letter-spacing);\n  font-size: var(--f7-navbar-large-title-font-size);\n  font-weight: var(--f7-navbar-large-title-font-weight);\n  line-height: var(--f7-navbar-large-title-line-height);\n  padding-left: calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left));\n  padding-right: calc(var(--f7-navbar-large-title-padding-right) + var(--f7-safe-area-right));\n  padding-top: var(--f7-navbar-large-title-padding-vertical);\n  padding-bottom: var(--f7-navbar-large-title-padding-vertical);\n  box-sizing: border-box;\n  overflow: hidden;\n  width: 100%;\n  transform: translate3d(0px, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0);\n  transform-origin: calc(var(--f7-navbar-large-title-padding-left) + var(--f7-safe-area-left)) center;\n}\n.navbar-no-title-large-transition .title-large-text {\n  transition-duration: 0ms;\n}\n.navbar ~ *,\n.navbars ~ * {\n  --f7-page-navbar-offset: calc(var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.navbar ~ * .page-with-navbar-large,\n.navbar ~ .page-with-navbar-large,\n.navbars ~ * .page-with-navbar-large,\n.navbars ~ .page-with-navbar-large,\n.page-with-navbar-large .navbar ~ * {\n  --f7-page-navbar-offset: calc(var(--f7-navbar-height) + var(--f7-navbar-large-title-height) + var(--f7-safe-area-top));\n}\n.page.no-navbar,\n.page.no-navbar .navbar ~ * {\n  --f7-page-navbar-offset: var(--f7-safe-area-top);\n}\n.ios {\n  --f7-navbarLeftTextOffset: calc(4px + 12px + var(--f7-navbar-inner-padding-left));\n  --f7-navbarTitleLargeOffset: var(--f7-navbar-large-title-padding-left);\n  --f7-navbar-large-transparent-bg-center: translateX(0);\n  --f7-navbar-large-bg-center-top: translateX(0) translateY(calc(-1 * var(--f7-navbar-large-title-height)));\n  --f7-navbar-large-bg-center-bottom: translateX(0) translateY(0);\n  --f7-navbar-large-transparent-bg-left: translateX(-100%);\n  --f7-navbar-large-bg-left-top: translateX(-100%) translateY(calc(-1 * var(--f7-navbar-large-title-height)));\n  --f7-navbar-large-bg-left-bottom: translateX(-100%) translateY(0);\n  --f7-navbar-large-bg-right-top: translateX(100%) translateY(calc(-1 * var(--f7-navbar-large-title-height)));\n  --f7-navbar-large-bg-right-bottom: translateX(100%) translateY(0);\n}\n.ios .navbar a.icon-only {\n  width: 44px;\n  margin: 0;\n  justify-content: center;\n}\n.ios .navbar .left a + a,\n.ios .navbar .right a + a {\n  margin-left: 16px;\n}\n.ios .navbar b {\n  font-weight: 600;\n}\n.ios .navbar .left {\n  margin-right: 10px;\n}\n.ios .navbar .right {\n  margin-left: 10px;\n}\n.ios .navbar .right:first-child {\n  right: calc(8px + var(--f7-safe-area-right));\n}\n.ios .navbar-inner {\n  justify-content: space-between;\n}\n.ios .navbar-inner-left-title {\n  justify-content: flex-start;\n}\n.ios .navbar-inner-left-title .right {\n  margin-left: auto;\n}\n.ios .navbar-inner-left-title .title {\n  text-align: left;\n  margin-right: 10px;\n}\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .left,\n.ios .view:not(.view-master-detail) .navbar-previous .left,\n.ios .navbar-next .left,\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .title,\n.ios .view:not(.view-master-detail) .navbar-previous .title,\n.ios .navbar-next .title,\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .right,\n.ios .view:not(.view-master-detail) .navbar-previous .right,\n.ios .navbar-next .right,\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .subnavbar,\n.ios .view:not(.view-master-detail) .navbar-previous .subnavbar,\n.ios .navbar-next .subnavbar,\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .fading,\n.ios .view:not(.view-master-detail) .navbar-previous .fading,\n.ios .navbar-next .fading {\n  opacity: 0;\n}\n.ios .view-master-detail .navbar-previous:not(.navbar-master),\n.ios .view:not(.view-master-detail) .navbar-previous {\n  pointer-events: none;\n}\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .title-large,\n.ios .view:not(.view-master-detail) .navbar-previous .title-large {\n  opacity: 0;\n  transition-duration: 0ms;\n}\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .title-large .title-large-text,\n.ios .view:not(.view-master-detail) .navbar-previous .title-large .title-large-text {\n  transform: scale(0.5);\n  transition-duration: 0ms;\n}\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .subnavbar.sliding,\n.ios .view:not(.view-master-detail) .navbar-previous .subnavbar.sliding,\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .sliding .subnavbar,\n.ios .view:not(.view-master-detail) .navbar-previous .sliding .subnavbar {\n  opacity: 1;\n  transform: translate3d(-100%, 0, 0);\n}\n.ios .view:not(.view-master-detail) .navbar-previous .navbar-bg,\n.ios .view-master-detail .navbar-previous:not(.navbar-master) .navbar-bg {\n  transform: translateX(-100%);\n}\n.ios .navbar-next {\n  pointer-events: none;\n}\n.ios .navbar-next .navbar-bg {\n  transform: translateX(100%);\n}\n.ios .navbar-next .title-large .title-large-text {\n  transition-duration: 0ms;\n  transform: translateX(100%) translateY(calc(-1 * var(--f7-navbar-large-title-height)));\n}\n.ios .navbar-next .subnavbar.sliding,\n.ios .navbar-next .sliding .subnavbar {\n  opacity: 1;\n  transform: translate3d(100%, 0, 0);\n}\n.ios .router-transition .navbar,\n.ios .router-transition .navbar-bg {\n  transition-duration: var(--f7-page-transition-duration);\n}\n.ios .router-transition .navbar-bg {\n  animation-duration: var(--f7-page-transition-duration);\n  animation-fill-mode: forwards;\n}\n.ios .router-transition .title-large,\n.ios .router-transition .title-large-text {\n  transition-duration: 0ms;\n}\n.ios .router-transition .navbar-current .left,\n.ios .router-transition .navbar-current .title,\n.ios .router-transition .navbar-current .right,\n.ios .router-transition .navbar-current .subnavbar {\n  animation: ios-navbar-element-fade-out var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition .navbar-current .sliding.left,\n.ios .router-transition .navbar-current .sliding.left .icon + span,\n.ios .router-transition .navbar-current .sliding.title,\n.ios .router-transition .navbar-current .sliding.right,\n.ios .router-transition .navbar-current .sliding .left,\n.ios .router-transition .navbar-current .sliding .left .icon + span,\n.ios .router-transition .navbar-current .sliding .title,\n.ios .router-transition .navbar-current .sliding .right {\n  transition-duration: var(--f7-page-transition-duration);\n  opacity: 0 !important;\n  animation: none;\n}\n.ios .router-transition .navbar-current .sliding .subnavbar,\n.ios .router-transition .navbar-current .sliding.subnavbar {\n  transition-duration: var(--f7-page-transition-duration);\n  animation: none;\n  opacity: 1;\n}\n.ios .router-transition-forward .navbar-next .left,\n.ios .router-transition-backward .navbar-previous .left,\n.ios .router-transition-forward .navbar-next .title,\n.ios .router-transition-backward .navbar-previous .title,\n.ios .router-transition-forward .navbar-next .right,\n.ios .router-transition-backward .navbar-previous .right,\n.ios .router-transition-forward .navbar-next .subnavbar,\n.ios .router-transition-backward .navbar-previous .subnavbar {\n  animation: ios-navbar-element-fade-in var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-forward .navbar-next .sliding.left,\n.ios .router-transition-backward .navbar-previous .sliding.left,\n.ios .router-transition-forward .navbar-next .sliding.left .icon + span,\n.ios .router-transition-backward .navbar-previous .sliding.left .icon + span,\n.ios .router-transition-forward .navbar-next .sliding.title,\n.ios .router-transition-backward .navbar-previous .sliding.title,\n.ios .router-transition-forward .navbar-next .sliding.right,\n.ios .router-transition-backward .navbar-previous .sliding.right,\n.ios .router-transition-forward .navbar-next .sliding .left,\n.ios .router-transition-backward .navbar-previous .sliding .left,\n.ios .router-transition-forward .navbar-next .sliding .left .icon + span,\n.ios .router-transition-backward .navbar-previous .sliding .left .icon + span,\n.ios .router-transition-forward .navbar-next .sliding .title,\n.ios .router-transition-backward .navbar-previous .sliding .title,\n.ios .router-transition-forward .navbar-next .sliding .right,\n.ios .router-transition-backward .navbar-previous .sliding .right,\n.ios .router-transition-forward .navbar-next .sliding .subnavbar,\n.ios .router-transition-backward .navbar-previous .sliding .subnavbar {\n  transition-duration: var(--f7-page-transition-duration);\n  animation: none;\n  transform: translate3d(0, 0, 0) !important;\n  opacity: 1 !important;\n}\n.ios .router-transition-forward .navbar-next.navbar-transparent:not(.navbar-large):not(.navbar-transparent-visible) .title,\n.ios .router-transition-backward .navbar-previous.navbar-transparent:not(.navbar-large):not(.navbar-transparent-visible) .title {\n  animation: none;\n}\n.ios .router-transition-forward .navbar-next.navbar-transparent:not(.navbar-large):not(.navbar-transparent-visible) .sliding.title,\n.ios .router-transition-backward .navbar-previous.navbar-transparent:not(.navbar-large):not(.navbar-transparent-visible) .sliding.title,\n.ios .router-transition-forward .navbar-next.navbar-transparent:not(.navbar-large):not(.navbar-transparent-visible) .sliding .title,\n.ios .router-transition-backward .navbar-previous.navbar-transparent:not(.navbar-large):not(.navbar-transparent-visible) .sliding .title {\n  opacity: 0 !important;\n}\n.ios .router-transition-backward .navbar-previous.with-searchbar-expandable-enabled-no-transition .left,\n.ios .router-transition-backward .navbar-previous.with-searchbar-expandable-enabled .left,\n.ios .router-transition-backward .navbar-previous.with-searchbar-expandable-enabled-no-transition .title,\n.ios .router-transition-backward .navbar-previous.with-searchbar-expandable-enabled .title,\n.ios .router-transition-backward .navbar-previous.with-searchbar-expandable-enabled-no-transition .right,\n.ios .router-transition-backward .navbar-previous.with-searchbar-expandable-enabled .right,\n.ios .router-transition-backward .navbar-previous.with-searchbar-expandable-enabled-no-transition .subnavbar,\n.ios .router-transition-backward .navbar-previous.with-searchbar-expandable-enabled .subnavbar {\n  animation: none;\n}\n.ios .router-transition-forward .navbar-current.router-navbar-transition-from-large.router-navbar-transition-to-large .title-large,\n.ios .router-transition-forward .navbar-current.router-navbar-transition-from-large:not(.router-navbar-transition-to-large) .title-large {\n  overflow: visible;\n}\n.ios .router-transition-forward .navbar-current.router-navbar-transition-from-large.router-navbar-transition-to-large .title-large .title-large-text,\n.ios .router-transition-forward .navbar-current.router-navbar-transition-from-large:not(.router-navbar-transition-to-large) .title-large .title-large-text {\n  animation: ios-navbar-large-title-text-slide-up var(--f7-page-transition-duration) forwards, ios-navbar-large-title-text-fade-out var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-forward .navbar-next.router-navbar-transition-from-large .left .back span {\n  animation: ios-navbar-back-text-next-to-current var(--f7-page-transition-duration) forwards;\n  transition: none;\n  transform-origin: left center;\n}\n.ios .router-transition-forward .navbar-next.router-navbar-transition-from-large.router-navbar-transition-to-large .title-large {\n  overflow: visible;\n}\n.ios .router-transition-forward .navbar-next.router-navbar-transition-from-large.router-navbar-transition-to-large .title-large .title-large-text {\n  animation: ios-navbar-large-title-text-slide-left var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-forward .navbar-next.router-navbar-transition-to-large:not(.router-navbar-transition-from-large) .title-large .title-large-text {\n  animation: ios-navbar-large-title-text-slide-left var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-forward .navbar-next.navbar-large:not(.navbar-large-collapsed) .title,\n.ios .router-transition-forward .navbar-current.navbar-large:not(.navbar-large-collapsed) .title {\n  animation: none;\n  opacity: 0 !important;\n  transition-duration: 0;\n}\n.ios .router-transition-backward .navbar-current.router-navbar-transition-to-large .left .back span {\n  animation: ios-navbar-back-text-current-to-previous var(--f7-page-transition-duration) forwards;\n  transition: none;\n  transform-origin: left center;\n}\n.ios .router-transition-backward .navbar-current.router-navbar-transition-from-large.router-navbar-transition-to-large .title-large {\n  overflow: visible;\n}\n.ios .router-transition-backward .navbar-current.router-navbar-transition-from-large.router-navbar-transition-to-large .title-large .title-large-text {\n  animation: ios-navbar-large-title-text-slide-right var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-backward .navbar-current.router-navbar-transition-from-large:not(.router-navbar-transition-to-large) .title-large .title-large-text {\n  animation: ios-navbar-large-title-text-slide-right var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-backward .navbar-current.router-navbar-transition-to-large:not(.router-navbar-transition-from-large) .title-large {\n  opacity: 0;\n}\n.ios .router-transition-backward .navbar-previous.router-navbar-transition-from-large.router-navbar-transition-to-large .title-large,\n.ios .router-transition-backward .navbar-previous.router-navbar-transition-to-large:not(.router-navbar-transition-from-large) .title-large {\n  overflow: visible;\n  opacity: 1;\n}\n.ios .router-transition-backward .navbar-previous.router-navbar-transition-from-large.router-navbar-transition-to-large .title-large .title-large-text,\n.ios .router-transition-backward .navbar-previous.router-navbar-transition-to-large:not(.router-navbar-transition-from-large) .title-large .title-large-text {\n  animation: ios-navbar-large-title-text-slide-down var(--f7-page-transition-duration) forwards, ios-navbar-large-title-text-fade-in var(--f7-page-transition-duration) forwards;\n}\n.ios .router-transition-backward .navbar-current.navbar-large:not(.navbar-large-collapsed) .title,\n.ios .router-transition-backward .navbar-previous.navbar-large:not(.navbar-large-collapsed) .title {\n  animation: none;\n  opacity: 0 !important;\n  transition-duration: 0;\n}\n.ios .router-transition-forward .navbar-current .navbar-bg {\n  animation-name: ios-navbar-bg-from-cb-to-lb;\n}\n.ios .router-transition-forward .navbar-current.router-navbar-transition-from-large.router-navbar-transition-to-large .navbar-bg {\n  animation-name: ios-navbar-bg-from-cb-to-lb;\n}\n.ios .router-transition-forward .navbar-current.router-navbar-transition-from-large:not(.router-navbar-transition-to-large) .navbar-bg {\n  animation-name: ios-navbar-bg-from-cb-to-lt;\n}\n.ios .router-transition-forward .navbar-current:not(.router-navbar-transition-from-large).router-navbar-transition-to-large .navbar-bg {\n  animation-name: ios-navbar-bg-from-ct-to-lb;\n}\n.ios .router-transition-forward .navbar-current.navbar-large-collapsed:not(.router-navbar-transition-to-large) .navbar-bg {\n  animation-name: ios-navbar-bg-from-ct-to-lt;\n}\n.ios .router-transition-forward .navbar-current.navbar-large-collapsed.navbar-large-transparent:not(.router-navbar-transition-to-large) .navbar-bg,\n.ios .router-transition-forward .navbar-current.navbar-large-collapsed.navbar-large.navbar-transparent:not(.router-navbar-transition-to-large) .navbar-bg {\n  animation-name: ios-navbar-transparent-bg-from-c-to-l;\n}\n.ios .router-transition-forward .navbar-next .navbar-bg {\n  animation-name: ios-navbar-bg-from-rb-to-cb;\n}\n.ios .router-transition-forward .navbar-next.router-navbar-transition-from-large.router-navbar-transition-to-large .navbar-bg {\n  animation-name: ios-navbar-bg-from-rb-to-cb;\n}\n.ios .router-transition-forward .navbar-next.router-navbar-transition-from-large:not(.router-navbar-transition-to-large) .navbar-bg {\n  animation-name: ios-navbar-bg-from-rb-to-ct;\n}\n.ios .router-transition-forward .navbar-next:not(.router-navbar-transition-from-large).router-navbar-transition-to-large .navbar-bg {\n  animation-name: ios-navbar-bg-from-rt-to-cb;\n}\n.ios .router-transition-backward .navbar-current .navbar-bg {\n  animation-name: ios-navbar-bg-from-cb-to-rb;\n}\n.ios .router-transition-backward .navbar-current:not(.router-navbar-transition-from-large).router-navbar-transition-to-large .navbar-bg {\n  animation-name: ios-navbar-bg-from-ct-to-rb;\n}\n.ios .router-transition-backward .navbar-current.router-navbar-transition-from-large:not(.router-navbar-transition-to-large) .navbar-bg {\n  animation-name: ios-navbar-bg-from-cb-to-rt;\n}\n.ios .router-transition-backward .navbar-current.navbar-large-collapsed .navbar-bg {\n  animation-name: ios-navbar-bg-from-ct-to-rt;\n}\n.ios .router-transition-backward .navbar-current.navbar-large-collapsed.navbar-large-transparent .navbar-bg,\n.ios .router-transition-backward .navbar-current.navbar-large-collapsed.navbar-large.navbar-transparent .navbar-bg {\n  animation-name: ios-navbar-bg-from-cb-to-rb;\n}\n.ios .router-transition-backward .navbar-current.navbar-large-collapsed.router-navbar-transition-to-large .navbar-bg {\n  animation-name: ios-navbar-bg-from-ct-to-rb;\n}\n.ios .router-transition-backward .navbar-previous .navbar-bg {\n  animation-name: ios-navbar-bg-from-lb-to-cb;\n}\n.ios .router-transition-backward .navbar-previous:not(.router-navbar-transition-from-large).router-navbar-transition-to-large .navbar-bg {\n  animation-name: ios-navbar-bg-from-lt-to-cb;\n}\n.ios .router-transition-backward .navbar-previous.router-navbar-transition-from-large:not(.router-navbar-transition-to-large) .navbar-bg {\n  animation-name: ios-navbar-bg-from-lb-to-ct;\n}\n.ios .router-transition-backward .navbar-previous.navbar-large-collapsed .navbar-bg {\n  animation-name: ios-navbar-bg-from-lt-to-ct;\n}\n.ios .router-transition-backward .navbar-previous.navbar-large-collapsed.navbar-large-transparent .navbar-bg,\n.ios .router-transition-backward .navbar-previous.navbar-large-collapsed.navbar-large.navbar-transparent .navbar-bg {\n  animation-name: ios-navbar-transparent-bg-from-l-to-c;\n}\n.ios .router-transition-backward .navbar-previous.navbar-large-collapsed.navbar-large-transparent.router-navbar-transition-from-large .navbar-bg,\n.ios .router-transition-backward .navbar-previous.navbar-large-collapsed.navbar-large.navbar-transparent.router-navbar-transition-from-large .navbar-bg {\n  animation-name: ios-navbar-bg-from-lb-to-ct;\n}\n.view-master-detail .navbars {\n  z-index: auto;\n}\n.view-master-detail .page-master {\n  z-index: 525;\n}\n.view-master-detail .navbar-master .navbar-inner,\n.view-master-detail .navbar-master .navbar-bg {\n  z-index: 550;\n}\n.view-master-detail .navbar-master-detail .navbar-inner,\n.view-master-detail .navbar-master-detail .navbar-bg {\n  z-index: 500;\n}\n.view-master-detail .navbar-master.navbar-previous {\n  pointer-events: auto;\n}\n.view-master-detail .navbar-master.navbar-previous .left,\n.view-master-detail .navbar-master.navbar-previous:not(.navbar-large) .title,\n.view-master-detail .navbar-master.navbar-previous .right,\n.view-master-detail .navbar-master.navbar-previous .subnavbar {\n  opacity: 1;\n}\n.view-master-detail.router-transition .navbar-master .left,\n.view-master-detail.router-transition .navbar-master .left .icon + span,\n.view-master-detail.router-transition .navbar-master:not(.navbar-large) .title,\n.view-master-detail.router-transition .navbar-master .right,\n.view-master-detail.router-transition .navbar-master .subnavbar,\n.view-master-detail.router-transition .navbar-master .fading {\n  opacity: 1 !important;\n  transition-duration: 0ms;\n  transform: none !important;\n  animation: none !important;\n}\n.view-master-detail.router-transition .navbar-master .navbar-bg {\n  transition-duration: 0ms;\n  animation: none !important;\n}\n.view-master-detail.router-transition .navbar-master.navbar-large .title {\n  opacity: calc(-1 + 2 * var(--f7-navbar-large-collapse-progress)) !important;\n  transition-duration: 0ms;\n  transform: none !important;\n  animation: none !important;\n}\n.view-master-detail.router-transition .navbar-master.navbar-large .title-large,\n.view-master-detail.router-transition .navbar-master.navbar-large .title-large-text {\n  transition-duration: 0ms;\n  animation: none !important;\n}\n.view-master-detail.router-transition .navbar-master.navbar-large-transparent .navbar-bg,\n.view-master-detail.router-transition .navbar-master.navbar-large.navbar-transparent .navbar-bg {\n  height: 100% !important;\n  opacity: var(--f7-navbar-large-collapse-progress) !important;\n}\n@keyframes ios-navbar-element-fade-in {\n  0% {\n    opacity: 0;\n  }\n  25% {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes ios-navbar-element-fade-out {\n  from {\n    opacity: 1;\n  }\n  75% {\n    opacity: 0;\n  }\n  to {\n    opacity: 0;\n  }\n}\n@keyframes ios-navbar-large-title-text-slide-up {\n  0% {\n    transform: translateX(0px) translateY(0%) scale(1);\n  }\n  100% {\n    transform: translateX(calc(var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset))) translateY(calc(-1 * var(--f7-navbar-large-title-height) + var(--f7-navbar-large-title-padding-vertical))) scale(0.5);\n  }\n}\n@keyframes ios-navbar-large-title-text-slide-down {\n  0% {\n    transform: translateX(calc(var(--f7-navbarLeftTextOffset) - var(--f7-navbarTitleLargeOffset))) translateY(calc(-1 * var(--f7-navbar-large-title-height) + var(--f7-navbar-large-title-padding-vertical) / 2)) scale(0.5);\n  }\n  100% {\n    transform: translateX(0px) translateY(0%) scale(1);\n  }\n}\n@keyframes ios-navbar-large-title-text-slide-left {\n  0% {\n    transform: translateX(100%);\n  }\n  100% {\n    transform: translateX(0%);\n  }\n}\n@keyframes ios-navbar-large-title-text-slide-right {\n  0% {\n    transform: translateX(0%);\n  }\n  100% {\n    transform: translateX(100%);\n  }\n}\n@keyframes ios-navbar-large-title-text-fade-out {\n  0% {\n    opacity: 1;\n  }\n  80% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 0;\n  }\n}\n@keyframes ios-navbar-large-title-text-fade-in {\n  0% {\n    opacity: 0;\n  }\n  20% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes ios-navbar-back-text-current-to-previous {\n  0% {\n    opacity: 1;\n    transform: translateY(0px) translateX(0px) scale(1);\n  }\n  80% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 0;\n    transform: translateX(calc(var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset))) translateY(calc(1 * var(--f7-navbar-large-title-height) - var(--f7-navbar-large-title-padding-vertical) / 2)) scale(2);\n  }\n}\n@keyframes ios-navbar-back-text-next-to-current {\n  0% {\n    opacity: 0;\n    transform: translateX(calc(var(--f7-navbarTitleLargeOffset) - var(--f7-navbarLeftTextOffset))) translateY(calc(1 * var(--f7-navbar-large-title-height) + var(--f7-navbar-large-title-padding-vertical) / 2)) scale(2);\n  }\n  20% {\n    opacity: 0;\n  }\n  100% {\n    opacity: 1;\n    transform: translateX(0px) translateY(0px) scale(1);\n  }\n}\n@keyframes ios-navbar-bg-from-cb-to-lb {\n  from {\n    transform: var(--f7-navbar-large-bg-center-bottom);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-left-bottom);\n  }\n}\n@keyframes ios-navbar-bg-from-cb-to-lt {\n  from {\n    transform: var(--f7-navbar-large-bg-center-bottom);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-left-top);\n  }\n}\n@keyframes ios-navbar-bg-from-ct-to-lb {\n  from {\n    transform: var(--f7-navbar-large-bg-center-top);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-left-bottom);\n  }\n}\n@keyframes ios-navbar-bg-from-ct-to-lt {\n  from {\n    transform: var(--f7-navbar-large-bg-center-top);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-left-top);\n  }\n}\n@keyframes ios-navbar-bg-from-rb-to-cb {\n  from {\n    transform: var(--f7-navbar-large-bg-right-bottom);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-center-bottom);\n  }\n}\n@keyframes ios-navbar-bg-from-rb-to-ct {\n  from {\n    transform: var(--f7-navbar-large-bg-right-bottom);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-center-top);\n  }\n}\n@keyframes ios-navbar-bg-from-rt-to-cb {\n  from {\n    transform: var(--f7-navbar-large-bg-right-top);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-center-bottom);\n  }\n}\n@keyframes ios-navbar-bg-from-cb-to-rb {\n  from {\n    transform: var(--f7-navbar-large-bg-center-bottom);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-right-bottom);\n  }\n}\n@keyframes ios-navbar-bg-from-ct-to-rb {\n  from {\n    transform: var(--f7-navbar-large-bg-center-top);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-right-bottom);\n  }\n}\n@keyframes ios-navbar-bg-from-cb-to-rt {\n  from {\n    transform: var(--f7-navbar-large-bg-center-bottom);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-right-top);\n  }\n}\n@keyframes ios-navbar-bg-from-ct-to-rt {\n  from {\n    transform: var(--f7-navbar-large-bg-center-top);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-right-top);\n  }\n}\n@keyframes ios-navbar-bg-from-lb-to-cb {\n  from {\n    transform: var(--f7-navbar-large-bg-left-bottom);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-center-bottom);\n  }\n}\n@keyframes ios-navbar-bg-from-lt-to-cb {\n  from {\n    transform: var(--f7-navbar-large-bg-left-top);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-center-bottom);\n  }\n}\n@keyframes ios-navbar-bg-from-lb-to-ct {\n  from {\n    transform: var(--f7-navbar-large-bg-left-bottom);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-center-top);\n  }\n}\n@keyframes ios-navbar-bg-from-lt-to-ct {\n  from {\n    transform: var(--f7-navbar-large-bg-left-top);\n  }\n  to {\n    transform: var(--f7-navbar-large-bg-center-top);\n  }\n}\n@keyframes ios-navbar-transparent-bg-from-l-to-c {\n  from {\n    transform: var(--f7-navbar-large-transparent-bg-left);\n  }\n  to {\n    transform: var(--f7-navbar-large-transparent-bg-center);\n  }\n}\n@keyframes ios-navbar-transparent-bg-from-c-to-l {\n  from {\n    transform: var(--f7-navbar-large-transparent-bg-center);\n  }\n  to {\n    transform: var(--f7-navbar-large-transparent-bg-left);\n  }\n}\n.md .navbar a.link {\n  padding: 0 16px;\n  min-width: 48px;\n}\n.md .navbar a.link:before {\n  content: '';\n  width: 152%;\n  height: 152%;\n  position: absolute;\n  left: -26%;\n  top: -26%;\n  background-image: radial-gradient(circle at center, var(--f7-link-highlight-color) 66%, rgba(255, 255, 255, 0) 66%);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 100% 100%;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 600ms;\n}\n.md .navbar a.link.active-state:before {\n  opacity: 1;\n  transition-duration: 150ms;\n}\n.md .navbar a.icon-only {\n  min-width: 0;\n  flex-shrink: 0;\n  width: 56px;\n}\n.md .navbar .right {\n  margin-left: auto;\n}\n.md .navbar .right:first-child {\n  right: var(--f7-safe-area-right);\n}\n.md .navbar-inner {\n  justify-content: flex-start;\n  overflow: hidden;\n}\n.md .navbar-large:not(.navbar-large-collapsed) .navbar-inner {\n  overflow: visible;\n}\n.md .page.page-with-subnavbar .navbar-inner {\n  overflow: visible;\n}\n.md .navbar-inner-centered-title {\n  justify-content: space-between;\n}\n.md .navbar-inner-centered-title .right {\n  margin-left: 0;\n}\n.md .navbar-inner-centered-title .title {\n  text-align: center;\n}\n.aurora .navbar a.icon-only {\n  margin: 0;\n  justify-content: center;\n}\n.aurora .navbar .left a + a,\n.aurora .navbar .right a + a {\n  margin-left: 10px;\n}\n.aurora .navbar b {\n  font-weight: bold;\n}\n.aurora .navbar .left {\n  margin-right: 10px;\n}\n.aurora .navbar .right {\n  margin-left: 10px;\n}\n.aurora .navbar .right:first-child {\n  right: calc(16px + var(--f7-safe-area-right));\n}\n.aurora .navbar-inner {\n  justify-content: space-between;\n}\n.aurora .navbar-inner-left-title {\n  justify-content: flex-start;\n}\n.aurora .navbar-inner-left-title .right {\n  margin-left: auto;\n}\n.aurora .navbar-inner-left-title .title {\n  text-align: left;\n  margin-right: 10px;\n}\n/* === Toolbar === */\n:root {\n  /*\n  --f7-toolbar-bg-color: var(--f7-bars-bg-color);\n  --f7-toolbar-bg-color-rgb: var(--f7-bars-bg-color-rgb);\n  --f7-toolbar-bg-image: var(--f7-bars-bg-image);\n  --f7-toolbar-border-color: var(--f7-bars-border-color);\n  --f7-toolbar-link-color: var(--f7-bars-link-color);\n  --f7-toolbar-text-color: var(--f7-bars-text-color);\n  --f7-tabbar-link-active-color: var(--f7-theme-color);\n  */\n  --f7-tabbar-link-active-bg-color: transparent;\n  --f7-tabbar-label-text-transform: none;\n  --f7-toolbar-hide-show-transition-duration: 400ms;\n}\n.ios {\n  --f7-toolbar-height: 44px;\n  --f7-toolbar-font-size: 17px;\n  --f7-toolbar-inner-padding-left: 8px;\n  --f7-toolbar-inner-padding-right: 8px;\n  /*\n  --f7-toolbar-link-height: var(--f7-toolbar-height);\n  --f7-toolbar-link-line-height: var(--f7-toolbar-height);\n  */\n  --f7-tabbar-labels-height: 50px;\n  --f7-tabbar-labels-tablet-height: 50px;\n  --f7-toolbar-top-shadow-image: none;\n  --f7-toolbar-bottom-shadow-image: none;\n  --f7-tabbar-icon-size: 28px;\n  --f7-tabbar-link-text-transform: none;\n  --f7-tabbar-link-font-weight: 400;\n  --f7-tabbar-link-letter-spacing: 0;\n  --f7-tabbar-label-font-size: 12px;\n  --f7-tabbar-label-tablet-font-size: 14px;\n  --f7-tabbar-label-font-weight: 500;\n  --f7-tabbar-label-letter-spacing: 0.01;\n  --f7-tabbar-link-inactive-color: rgba(0, 0, 0, 0.4);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-tabbar-link-inactive-color: rgba(255, 255, 255, 0.54);\n}\n.md {\n  --f7-toolbar-height: 48px;\n  --f7-toolbar-font-size: 14px;\n  --f7-toolbar-inner-padding-left: 0px;\n  --f7-toolbar-inner-padding-right: 0px;\n  /*\n  --f7-toolbar-link-height: var(--f7-toolbar-height);\n  --f7-toolbar-link-line-height: var(--f7-toolbar-height);\n  */\n  --f7-tabbar-labels-height: 56px;\n  --f7-tabbar-labels-tablet-height: 56px;\n  /*\n  --f7-tabbar-link-active-border-color: var(--f7-theme-color);\n  */\n  --f7-toolbar-top-shadow-image: var(--f7-bars-shadow-bottom-image);\n  --f7-toolbar-bottom-shadow-image: var(--f7-bars-shadow-top-image);\n  --f7-tabbar-icon-size: 24px;\n  --f7-tabbar-link-text-transform: uppercase;\n  --f7-tabbar-link-font-weight: 500;\n  --f7-tabbar-link-letter-spacing: 0.03em;\n  --f7-tabbar-label-font-size: 14px;\n  --f7-tabbar-label-tablet-font-size: 14px;\n  --f7-tabbar-label-font-weight: 400;\n  --f7-tabbar-label-letter-spacing: 0;\n  --f7-tabbar-link-inactive-color: rgba(0, 0, 0, 0.54);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-tabbar-link-inactive-color: rgba(255, 255, 255, 0.54);\n}\n.aurora {\n  --f7-toolbar-height: 38px;\n  --f7-toolbar-font-size: 14px;\n  --f7-toolbar-inner-padding-left: 16px;\n  --f7-toolbar-inner-padding-right: 16px;\n  --f7-toolbar-link-height: auto;\n  --f7-toolbar-link-line-height: inherit;\n  --f7-tabbar-labels-height: 44px;\n  --f7-tabbar-labels-tablet-height: 44px;\n  --f7-tabbar-link-inactive-bg-color: rgba(0, 0, 0, 0.2);\n  --f7-toolbar-top-shadow-image: none;\n  --f7-toolbar-bottom-shadow-image: none;\n  --f7-tabbar-icon-size: 18px;\n  --f7-tabbar-link-text-transform: none;\n  --f7-tabbar-link-font-weight: 400;\n  --f7-tabbar-link-letter-spacing: 0;\n  --f7-tabbar-label-font-size: 12px;\n  --f7-tabbar-label-tablet-font-size: 12px;\n  --f7-tabbar-label-font-weight: 500;\n  --f7-tabbar-label-letter-spacing: 0.01;\n  --f7-tabbar-link-inactive-color: rgba(0, 0, 0, 0.5);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-tabbar-link-inactive-color: rgba(255, 255, 255, 0.5);\n}\n.toolbar {\n  width: 100%;\n  position: relative;\n  margin: 0;\n  transform: translate3d(0, 0, 0);\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  z-index: 600;\n  box-sizing: border-box;\n  left: 0;\n  height: var(--f7-toolbar-height);\n  background-image: var(--f7-toolbar-bg-image, var(--f7-bars-bg-image));\n  background-color: var(--f7-toolbar-bg-color, var(--f7-bars-bg-color));\n  color: var(--f7-toolbar-text-color, var(--f7-bars-text-color));\n  font-size: var(--f7-toolbar-font-size);\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-bars .toolbar {\n    background-color: rgba(var(--f7-toolbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)), var(--f7-bars-translucent-opacity));\n    -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n            backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n  }\n}\n.toolbar b {\n  font-weight: 600;\n}\n.toolbar a {\n  color: var(--f7-toolbar-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n  box-sizing: border-box;\n  flex-shrink: 1;\n  position: relative;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.toolbar .link {\n  display: flex;\n  line-height: var(--f7-toolbar-link-line-height, var(--f7-toolbar-height));\n  height: var(--f7-toolbar-link-height, var(--f7-toolbar-height));\n}\n.toolbar i.icon {\n  display: block;\n}\n.toolbar:after,\n.toolbar:before {\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.views > .toolbar,\n.view > .toolbar,\n.page > .toolbar {\n  position: absolute;\n}\n.toolbar-top,\n.ios .toolbar-top-ios,\n.md .toolbar-top-md,\n.aurora .toolbar-top-aurora {\n  top: 0;\n}\n.toolbar-top .tab-link-highlight,\n.ios .toolbar-top-ios .tab-link-highlight,\n.md .toolbar-top-md .tab-link-highlight,\n.aurora .toolbar-top-aurora .tab-link-highlight {\n  bottom: 0;\n}\n.toolbar-top.no-hairline:after,\n.ios .toolbar-top-ios.no-hairline:after,\n.md .toolbar-top-md.no-hairline:after,\n.aurora .toolbar-top-aurora.no-hairline:after,\n.toolbar-top.no-border:after,\n.ios .toolbar-top-ios.no-border:after,\n.md .toolbar-top-md.no-border:after,\n.aurora .toolbar-top-aurora.no-border:after {\n  display: none !important;\n}\n.toolbar-top.no-shadow:before,\n.ios .toolbar-top-ios.no-shadow:before,\n.md .toolbar-top-md.no-shadow:before,\n.aurora .toolbar-top-aurora.no-shadow:before,\n.toolbar-top.toolbar-hidden:before,\n.ios .toolbar-top-ios.toolbar-hidden:before,\n.md .toolbar-top-md.toolbar-hidden:before,\n.aurora .toolbar-top-aurora.toolbar-hidden:before {\n  display: none !important;\n}\n.toolbar-top:after,\n.ios .toolbar-top-ios:after,\n.md .toolbar-top-md:after,\n.aurora .toolbar-top-aurora:after,\n.toolbar-top:before,\n.ios .toolbar-top-ios:before,\n.md .toolbar-top-md:before,\n.aurora .toolbar-top-aurora:before {\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.toolbar-top:after,\n.ios .toolbar-top-ios:after,\n.md .toolbar-top-md:after,\n.aurora .toolbar-top-aurora:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-toolbar-border-color, var(--f7-bars-border-color));\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.toolbar-top:before,\n.ios .toolbar-top-ios:before,\n.md .toolbar-top-md:before,\n.aurora .toolbar-top-aurora:before {\n  content: '';\n  position: absolute;\n  right: 0;\n  width: 100%;\n  top: 100%;\n  bottom: auto;\n  height: 8px;\n  pointer-events: none;\n  background: var(--f7-toolbar-top-shadow-image);\n}\n.toolbar-bottom,\n.ios .toolbar-bottom-ios,\n.md .toolbar-bottom-md,\n.aurora .toolbar-bottom-aurora {\n  bottom: 0;\n  height: calc(var(--f7-toolbar-height) + var(--f7-safe-area-bottom));\n}\n.toolbar-bottom .tab-link-highlight,\n.ios .toolbar-bottom-ios .tab-link-highlight,\n.md .toolbar-bottom-md .tab-link-highlight,\n.aurora .toolbar-bottom-aurora .tab-link-highlight {\n  top: 0;\n}\n.toolbar-bottom .toolbar-inner,\n.ios .toolbar-bottom-ios .toolbar-inner,\n.md .toolbar-bottom-md .toolbar-inner,\n.aurora .toolbar-bottom-aurora .toolbar-inner {\n  height: auto;\n  top: 0;\n  bottom: var(--f7-safe-area-bottom);\n}\n.toolbar-bottom.no-hairline:before,\n.ios .toolbar-bottom-ios.no-hairline:before,\n.md .toolbar-bottom-md.no-hairline:before,\n.aurora .toolbar-bottom-aurora.no-hairline:before,\n.toolbar-bottom.no-border:before,\n.ios .toolbar-bottom-ios.no-border:before,\n.md .toolbar-bottom-md.no-border:before,\n.aurora .toolbar-bottom-aurora.no-border:before {\n  display: none !important;\n}\n.toolbar-bottom.no-shadow:after,\n.ios .toolbar-bottom-ios.no-shadow:after,\n.md .toolbar-bottom-md.no-shadow:after,\n.aurora .toolbar-bottom-aurora.no-shadow:after,\n.toolbar-bottom.toolbar-hidden:after,\n.ios .toolbar-bottom-ios.toolbar-hidden:after,\n.md .toolbar-bottom-md.toolbar-hidden:after,\n.aurora .toolbar-bottom-aurora.toolbar-hidden:after {\n  display: none !important;\n}\n.toolbar-bottom:before,\n.ios .toolbar-bottom-ios:before,\n.md .toolbar-bottom-md:before,\n.aurora .toolbar-bottom-aurora:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-toolbar-border-color, var(--f7-bars-border-color));\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.toolbar-bottom:after,\n.ios .toolbar-bottom-ios:after,\n.md .toolbar-bottom-md:after,\n.aurora .toolbar-bottom-aurora:after {\n  content: '';\n  position: absolute;\n  right: 0;\n  width: 100%;\n  bottom: 100%;\n  height: 8px;\n  top: auto;\n  pointer-events: none;\n  background: var(--f7-toolbar-bottom-shadow-image);\n  transform: translate3d(0, 0, 0);\n}\n.toolbar-inner {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: space-between;\n  box-sizing: border-box;\n  align-items: center;\n  align-content: center;\n  overflow: hidden;\n  padding: 0 calc(var(--f7-toolbar-inner-padding-right) + var(--f7-safe-area-right)) 0 calc(var(--f7-toolbar-inner-padding-left) + var(--f7-safe-area-left));\n}\n.views > .tabbar,\n.views > .tabbar-labels {\n  z-index: 5001;\n}\n.tabbar a,\n.tabbar-labels a {\n  color: var(--f7-tabbar-link-inactive-color);\n}\n.tabbar .tab-link:not(.tab-link-active),\n.tabbar-labels .tab-link:not(.tab-link-active) {\n  background-color: var(--f7-tabbar-link-inactive-bg-color, transparent);\n}\n.tabbar .link,\n.tabbar-labels .link {\n  line-height: 1.4;\n}\n.tabbar .tab-link,\n.tabbar-labels .tab-link,\n.tabbar .link,\n.tabbar-labels .link {\n  height: 100%;\n  width: 100%;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  text-transform: var(--f7-tabbar-link-text-transform);\n  font-weight: var(--f7-tabbar-link-font-weight);\n  letter-spacing: var(--f7-tabbar-link-letter-spacing);\n  overflow: hidden;\n}\n.tabbar .tab-link-active,\n.tabbar-labels .tab-link-active {\n  color: var(--f7-tabbar-link-active-color, var(--f7-theme-color));\n  background-color: var(--f7-tabbar-link-active-bg-color, transparent);\n}\n.tabbar i.icon,\n.tabbar-labels i.icon {\n  font-size: var(--f7-tabbar-icon-size);\n  height: var(--f7-tabbar-icon-size);\n  line-height: var(--f7-tabbar-icon-size);\n}\n.tabbar-labels {\n  --f7-toolbar-height: var(--f7-tabbar-labels-height);\n}\n.tabbar-labels .tab-link,\n.tabbar-labels .link {\n  height: 100%;\n  justify-content: space-between;\n  align-items: center;\n}\n.tabbar-labels .tabbar-label {\n  display: block;\n  line-height: 1;\n  margin: 0;\n  position: relative;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  font-size: var(--f7-tabbar-label-font-size);\n  text-transform: var(--f7-tabbar-label-text-transform);\n  font-weight: var(--f7-tabbar-label-font-weight);\n  letter-spacing: var(--f7-tabbar-label-letter-spacing);\n}\n@media (min-width: 768px) and (min-height: 600px) {\n  :root {\n    --f7-tabbar-labels-height: var(--f7-tabbar-labels-tablet-height);\n    --f7-tabbar-label-font-size: var(--f7-tabbar-label-tablet-font-size);\n  }\n}\n.tabbar-scrollable .toolbar-inner {\n  justify-content: flex-start;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.tabbar-scrollable .toolbar-inner::-webkit-scrollbar {\n  display: none !important;\n  width: 0 !important;\n  height: 0 !important;\n  -webkit-appearance: none;\n  opacity: 0 !important;\n}\n.tabbar-scrollable .tab-link,\n.tabbar-scrollable .link {\n  width: auto;\n  flex-shrink: 0;\n}\n.toolbar-transitioning,\n.navbar-transitioning + .toolbar,\n.navbar-transitioning ~ * .toolbar {\n  transition-duration: var(--f7-toolbar-hide-show-transition-duration);\n}\n.toolbar-bottom ~ *,\n.ios .toolbar-bottom-ios ~ *,\n.md .toolbar-bottom-md ~ *,\n.aurora .toolbar-bottom-aurora ~ * {\n  --f7-page-toolbar-bottom-offset: var(--f7-toolbar-height);\n}\n.toolbar-bottom.tabbar-labels ~ *,\n.ios .toolbar-bottom-ios.tabbar-labels ~ *,\n.md .toolbar-bottom-md.tabbar-labels ~ *,\n.aurora .toolbar-bottom-aurora.tabbar-labels ~ * {\n  --f7-page-toolbar-bottom-offset: var(--f7-tabbar-labels-height);\n}\n.toolbar-bottom.toolbar-hidden,\n.ios .toolbar-bottom-ios.toolbar-hidden,\n.md .toolbar-bottom-md.toolbar-hidden,\n.aurora .toolbar-bottom-aurora.toolbar-hidden {\n  transform: translate3d(0, 100%, 0);\n}\n.toolbar-top ~ *,\n.ios .toolbar-top-ios ~ *,\n.md .toolbar-top-md ~ *,\n.aurora .toolbar-top-aurora ~ * {\n  --f7-page-toolbar-top-offset: var(--f7-toolbar-height);\n}\n.toolbar-top.tabbar-labels ~ *,\n.ios .toolbar-top-ios.tabbar-labels ~ *,\n.md .toolbar-top-md.tabbar-labels ~ *,\n.aurora .toolbar-top-aurora.tabbar-labels ~ * {\n  --f7-page-toolbar-top-offset: var(--f7-tabbar-labels-height);\n}\n.toolbar-top.toolbar-hidden,\n.ios .toolbar-top-ios.toolbar-hidden,\n.md .toolbar-top-md.toolbar-hidden,\n.aurora .toolbar-top-aurora.toolbar-hidden {\n  transform: translate3d(0, -100%, 0);\n}\n.navbar ~ .toolbar-top,\n.navbars ~ .toolbar-top,\n.ios .navbar ~ .toolbar-top-ios,\n.ios .navbars ~ .toolbar-top-ios,\n.md .navbar ~ .toolbar-top-md,\n.aurora .navbar ~ .toolbar-top-aurora,\n.navbar ~ * .toolbar-top,\n.navbars ~ * .toolbar-top,\n.ios .navbar ~ * .toolbar-top-ios,\n.ios .navbars ~ * .toolbar-top-ios,\n.md .navbar ~ * .toolbar-top-md,\n.aurora .navbar ~ * .toolbar-top-aurora,\n.navbar ~ .page:not(.no-navbar) .toolbar-top,\n.navbars ~ .page:not(.no-navbar) .toolbar-top,\n.ios .navbar ~ .page:not(.no-navbar) .toolbar-top-ios,\n.ios .navbars ~ .page:not(.no-navbar) .toolbar-top-ios,\n.md .navbar ~ .page:not(.no-navbar) .toolbar-top-md,\n.aurora .navbar ~ .page:not(.no-navbar) .toolbar-top-aurora {\n  top: calc(var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.navbar ~ .toolbar-top.toolbar-hidden,\n.navbars ~ .toolbar-top.toolbar-hidden,\n.ios .navbar ~ .toolbar-top-ios.toolbar-hidden,\n.ios .navbars ~ .toolbar-top-ios.toolbar-hidden,\n.md .navbar ~ .toolbar-top-md.toolbar-hidden,\n.aurora .navbar ~ .toolbar-top-aurora.toolbar-hidden,\n.navbar ~ * .toolbar-top.toolbar-hidden,\n.navbars ~ * .toolbar-top.toolbar-hidden,\n.ios .navbar ~ * .toolbar-top-ios.toolbar-hidden,\n.ios .navbars ~ * .toolbar-top-ios.toolbar-hidden,\n.md .navbar ~ * .toolbar-top-md.toolbar-hidden,\n.aurora .navbar ~ * .toolbar-top-aurora.toolbar-hidden,\n.navbar ~ .page:not(.no-navbar) .toolbar-top.toolbar-hidden,\n.navbars ~ .page:not(.no-navbar) .toolbar-top.toolbar-hidden,\n.ios .navbar ~ .page:not(.no-navbar) .toolbar-top-ios.toolbar-hidden,\n.ios .navbars ~ .page:not(.no-navbar) .toolbar-top-ios.toolbar-hidden,\n.md .navbar ~ .page:not(.no-navbar) .toolbar-top-md.toolbar-hidden,\n.aurora .navbar ~ .page:not(.no-navbar) .toolbar-top-aurora.toolbar-hidden {\n  transform: translate3d(0, calc(-1 * (var(--f7-navbar-height) + var(--f7-toolbar-height) + var(--f7-safe-area-top))), 0);\n}\n.navbar ~ .toolbar-top.toolbar-hidden.tabbar-labels,\n.navbars ~ .toolbar-top.toolbar-hidden.tabbar-labels,\n.ios .navbar ~ .toolbar-top-ios.toolbar-hidden.tabbar-labels,\n.ios .navbars ~ .toolbar-top-ios.toolbar-hidden.tabbar-labels,\n.md .navbar ~ .toolbar-top-md.toolbar-hidden.tabbar-labels,\n.aurora .navbar ~ .toolbar-top-aurora.toolbar-hidden.tabbar-labels,\n.navbar ~ * .toolbar-top.toolbar-hidden.tabbar-labels,\n.navbars ~ * .toolbar-top.toolbar-hidden.tabbar-labels,\n.ios .navbar ~ * .toolbar-top-ios.toolbar-hidden.tabbar-labels,\n.ios .navbars ~ * .toolbar-top-ios.toolbar-hidden.tabbar-labels,\n.md .navbar ~ * .toolbar-top-md.toolbar-hidden.tabbar-labels,\n.aurora .navbar ~ * .toolbar-top-aurora.toolbar-hidden.tabbar-labels,\n.navbar ~ .page:not(.no-navbar) .toolbar-top.toolbar-hidden.tabbar-labels,\n.navbars ~ .page:not(.no-navbar) .toolbar-top.toolbar-hidden.tabbar-labels,\n.ios .navbar ~ .page:not(.no-navbar) .toolbar-top-ios.toolbar-hidden.tabbar-labels,\n.ios .navbars ~ .page:not(.no-navbar) .toolbar-top-ios.toolbar-hidden.tabbar-labels,\n.md .navbar ~ .page:not(.no-navbar) .toolbar-top-md.toolbar-hidden.tabbar-labels,\n.aurora .navbar ~ .page:not(.no-navbar) .toolbar-top-aurora.toolbar-hidden.tabbar-labels {\n  transform: translate3d(0, calc(-1 * (var(--f7-navbar-height) + var(--f7-tabbar-labels-height) + var(--f7-safe-area-top))), 0);\n}\n.navbar-hidden + .toolbar-top:not(.toolbar-hidden),\n.ios .navbar-hidden + .toolbar-top-ios:not(.toolbar-hidden),\n.md .navbar-hidden + .toolbar-top-md:not(.toolbar-hidden),\n.aurora .navbar-hidden + .toolbar-top-aurora:not(.toolbar-hidden),\n.navbar-hidden ~ * .toolbar-top:not(.toolbar-hidden),\n.ios .navbar-hidden ~ * .toolbar-top-ios:not(.toolbar-hidden),\n.md .navbar-hidden ~ * .toolbar-top-md:not(.toolbar-hidden),\n.aurora .navbar-hidden ~ * .toolbar-top-aurora:not(.toolbar-hidden) {\n  transform: translate3d(0, calc(0px - var(--f7-navbar-height)), 0);\n}\n.navbar-large-hidden + .toolbar-top:not(.toolbar-hidden),\n.ios .navbar-large-hidden + .toolbar-top-ios:not(.toolbar-hidden),\n.md .navbar-large-hidden + .toolbar-top-md:not(.toolbar-hidden),\n.navbar-large-hidden ~ * .toolbar-top:not(.toolbar-hidden),\n.ios .navbar-large-hidden ~ * .toolbar-top-ios:not(.toolbar-hidden),\n.md .navbar-large-hidden ~ * .toolbar-top-md:not(.toolbar-hidden),\n.aurora .navbar-large-hidden ~ * .toolbar-top-aurora:not(.toolbar-hidden) {\n  transform: translate3d(0, calc(0px - var(--f7-navbar-height) - var(--f7-navbar-large-title-height)), 0);\n}\n.ios .toolbar a.icon-only {\n  min-height: var(--f7-toolbar-height);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: 0;\n  min-width: 44px;\n}\n.ios .tabbar-labels .tab-link,\n.ios .tabbar-labels .link {\n  padding-top: 4px;\n  padding-bottom: 4px;\n}\n.ios .tabbar-labels .tab-link i + span,\n.ios .tabbar-labels .link i + span {\n  margin: 0;\n}\n@media (min-width: 768px) and (min-height: 600px) {\n  .ios .tabbar .tab-link,\n  .ios .tabbar-labels .tab-link,\n  .ios .tabbar .link,\n  .ios .tabbar-labels .link {\n    justify-content: center;\n    flex-direction: row;\n  }\n  .ios .tabbar .tab-link i + span,\n  .ios .tabbar-labels .tab-link i + span,\n  .ios .tabbar .link i + span,\n  .ios .tabbar-labels .link i + span {\n    margin-left: 5px;\n  }\n}\n.ios .tabbar-scrollable .toolbar-inner {\n  justify-content: flex-start;\n}\n.ios .tabbar-scrollable .tab-link,\n.ios .tabbar-scrollable .link {\n  padding: 0 8px;\n}\n.md .toolbar .link {\n  justify-content: center;\n  padding: 0 16px;\n  min-width: 48px;\n}\n.md .toolbar .link:before {\n  content: '';\n  width: 152%;\n  height: 152%;\n  position: absolute;\n  left: -26%;\n  top: -26%;\n  background-image: radial-gradient(circle at center, var(--f7-link-highlight-color) 66%, rgba(255, 255, 255, 0) 66%);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 100% 100%;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 600ms;\n}\n.md .toolbar .link.active-state:before {\n  opacity: 1;\n  transition-duration: 150ms;\n}\n.md .toolbar a.icon-only {\n  min-width: 0;\n  flex-shrink: 0;\n}\n.md .tabbar .tab-link,\n.md .tabbar-labels .tab-link,\n.md .tabbar .link,\n.md .tabbar-labels .link {\n  padding-left: 0;\n  padding-right: 0;\n}\n.md .tabbar a.icon-only,\n.md .tabbar-labels a.icon-only {\n  flex-shrink: initial;\n}\n.md .tabbar .tab-link,\n.md .tabbar-labels .tab-link {\n  transition-duration: 300ms;\n  overflow: hidden;\n  position: relative;\n}\n.md .tabbar .tab-link-highlight,\n.md .tabbar-labels .tab-link-highlight {\n  position: absolute;\n  height: 2px;\n  background: var(--f7-tabbar-link-active-border-color, var(--f7-theme-color));\n  transition-duration: 300ms;\n  left: 0;\n}\n.md .tabbar-labels .tab-link,\n.md .tabbar-labels .link {\n  padding-top: 7px;\n  padding-bottom: 7px;\n}\n.md .tabbar-label {\n  max-width: 100%;\n  overflow: hidden;\n  line-height: 1.2;\n}\n.md .tabbar-scrollable .toolbar-inner {\n  overflow: auto;\n}\n.md .tabbar-scrollable .tab-link,\n.md .tabbar-scrollable .link {\n  padding: 0 16px;\n}\n.aurora .toolbar a.icon-only {\n  min-height: var(--f7-toolbar-height);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: 0;\n}\n.aurora .tabbar .toolbar-inner,\n.aurora .tabbar-labels .toolbar-inner {\n  padding-left: 0;\n  padding-right: 0;\n}\n.aurora .tabbar .tab-link,\n.aurora .tabbar-labels .tab-link,\n.aurora .tabbar .link,\n.aurora .tabbar-labels .link {\n  transition-duration: 200ms;\n}\n.aurora .tabbar-labels .tab-link,\n.aurora .tabbar-labels .link {\n  padding-top: 5px;\n  padding-bottom: 5px;\n}\n.aurora .tabbar-labels .tab-link i + span,\n.aurora .tabbar-labels .link i + span {\n  margin: 0;\n}\n.aurora .tabbar-scrollable .toolbar-inner {\n  justify-content: flex-start;\n}\n.aurora .tabbar-scrollable .tab-link,\n.aurora .tabbar-scrollable .link {\n  padding: 0 16px;\n}\n/* === Subnavbar === */\n:root {\n  /*\n  --f7-subnavbar-bg-image: var(--f7-bars-bg-image);\n  --f7-subnavbar-bg-color: var(--f7-bars-bg-color);\n  --f7-subnavbar-bg-color-rgb: var(--f7-bars-bg-color-rgb);\n  --f7-subnavbar-border-color: var(--f7-bars-border-color);\n  --f7-subnavbar-link-color: var(--f7-bars-link-color);\n  --f7-subnavbar-text-color: var(--f7-bars-text-color);\n  */\n  --f7-subnavbar-title-line-height: 1.2;\n}\n.ios {\n  --f7-subnavbar-height: 44px;\n  --f7-subnavbar-inner-padding-left: 8px;\n  --f7-subnavbar-inner-padding-right: 8px;\n  --f7-subnavbar-title-font-size: 34px;\n  --f7-subnavbar-title-font-weight: 700;\n  --f7-subnavbar-title-letter-spacing: -0.03em;\n  --f7-subnavbar-title-margin-left: 8px;\n  --f7-subnavbar-shadow-image: none;\n  /*\n  --f7-subnavbar-link-height: var(--f7-subnavbar-height);\n  --f7-subnavbar-link-line-height: var(--f7-subnavbar-height);\n  */\n}\n.md {\n  --f7-subnavbar-height: 48px;\n  --f7-subnavbar-inner-padding-left: 16px;\n  --f7-subnavbar-inner-padding-right: 16px;\n  --f7-subnavbar-title-font-size: 20px;\n  --f7-subnavbar-title-font-weight: 500;\n  --f7-subnavbar-title-letter-spacing: 0;\n  --f7-subnavbar-title-margin-left: 0px;\n  --f7-subnavbar-shadow-image: var(--f7-bars-shadow-bottom-image);\n  /*\n  --f7-subnavbar-link-height: var(--f7-subnavbar-height);\n  --f7-subnavbar-link-line-height: var(--f7-subnavbar-height);\n  */\n}\n.aurora {\n  --f7-subnavbar-height: 38px;\n  --f7-subnavbar-inner-padding-left: 16px;\n  --f7-subnavbar-inner-padding-right: 16px;\n  --f7-subnavbar-title-font-size: 26px;\n  --f7-subnavbar-title-font-weight: bold;\n  --f7-subnavbar-title-letter-spacing: -0.03em;\n  --f7-subnavbar-title-margin-left: 0px;\n  --f7-subnavbar-shadow-image: none;\n  --f7-subnavbar-link-height: auto;\n  --f7-subnavbar-link-line-height: inherit;\n}\n.subnavbar {\n  width: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 600;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  background-image: var(--f7-subnavbar-bg-image, var(--f7-bars-bg-image));\n  background-color: var(--f7-subnavbar-bg-color, var(--f7-bars-bg-color));\n  color: var(--f7-subnavbar-text-color, var(--f7-bars-text-color));\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-bars .subnavbar {\n    background-color: rgba(var(--f7-subnavbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)), var(--f7-bars-translucent-opacity));\n    -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n            backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n  }\n}\n.subnavbar .subnavbar-title {\n  position: relative;\n  overflow: hidden;\n  text-overflow: ellpsis;\n  white-space: nowrap;\n  font-size: var(--f7-subnavbar-title-font-size);\n  font-weight: var(--f7-subnavbar-title-font-weight);\n  text-align: left;\n  display: inline-block;\n  line-height: var(--f7-subnavbar-title-line-height);\n  letter-spacing: var(--f7-subnavbar-title-letter-spacing);\n  margin-left: var(--f7-subnavbar-title-margin-left);\n}\n.subnavbar .left,\n.subnavbar .right {\n  flex-shrink: 0;\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n.subnavbar .right:first-child {\n  position: absolute;\n  height: 100%;\n}\n.subnavbar a {\n  color: var(--f7-subnavbar-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n}\n.subnavbar a.link {\n  line-height: var(--f7-subnavbar-link-line-height, var(--f7-subnavbar-height));\n  height: var(--f7-subnavbar-link-height, var(--f7-subnavbar-height));\n}\n.subnavbar a.icon-only {\n  min-width: var(--f7-subnavbar-height);\n}\n.subnavbar.no-hairline:after,\n.subnavbar.no-border:after {\n  display: none !important;\n}\n.subnavbar.no-shadow:before,\n.subnavbar.navbar-hidden:before {\n  display: none !important;\n}\n.subnavbar:after,\n.subnavbar:before {\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.subnavbar:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-subnavbar-border-color, var(--f7-bars-border-color));\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.subnavbar:before {\n  content: '';\n  position: absolute;\n  right: 0;\n  width: 100%;\n  top: 100%;\n  bottom: auto;\n  height: 8px;\n  pointer-events: none;\n  background: var(--f7-subnavbar-shadow-image);\n}\n.subnavbar-inner {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  justify-content: space-between;\n  overflow: hidden;\n  padding: 0 calc(var(--f7-subnavbar-inner-padding-left) + var(--f7-safe-area-right)) 0 calc(var(--f7-subnavbar-inner-padding-right) + var(--f7-safe-area-left));\n}\n.subnavbar-inner.stacked {\n  display: none;\n}\n.navbar .subnavbar {\n  top: 100%;\n}\n.views > .subnavbar,\n.view > .subnavbar,\n.page > .subnavbar {\n  position: absolute;\n}\n.navbar ~ * .subnavbar,\n.navbars ~ * .subnavbar,\n.page-with-subnavbar .navbar ~ .subnavbar,\n.page-with-subnavbar .navbar ~ * .subnavbar,\n.navbar ~ .page-with-subnavbar:not(.no-navbar) .subnavbar,\n.navbar ~ .subnavbar,\n.navbars ~ .page-with-subnavbar:not(.no-navbar) .subnavbar,\n.navbars ~ .subnavbar {\n  top: calc(var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.navbar ~ .page-with-navbar-large:not(.no-navbar) .subnavbar,\n.navbars ~ .page-with-navbar-large:not(.no-navbar) .subnavbar,\n.page-with-subnavbar.page-with-navbar-large .navbar ~ .subnavbar,\n.page-with-subnavbar.page-with-navbar-large .navbar ~ * .subnavbar,\n.navbar .title-large ~ .subnavbar {\n  top: calc(var(--f7-navbar-height) + var(--f7-navbar-large-title-height) + var(--f7-safe-area-top));\n  transform: translate3d(0, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0);\n}\n.page-with-subnavbar,\n.subnavbar ~ * {\n  --f7-page-subnavbar-offset: var(--f7-subnavbar-height);\n}\n.ios .subnavbar {\n  height: calc(var(--f7-subnavbar-height) + 1px);\n  margin-top: -1px;\n  padding-top: 1px;\n}\n.ios .subnavbar .title {\n  align-self: flex-start;\n  flex-shrink: 10;\n}\n.ios .subnavbar .left a + a,\n.ios .subnavbar .right a + a {\n  margin-left: 16px;\n}\n.ios .subnavbar .left {\n  margin-right: 10px;\n}\n.ios .subnavbar .right {\n  margin-left: 10px;\n}\n.ios .subnavbar .right:first-child {\n  right: 8px;\n}\n.ios .subnavbar a.link {\n  justify-content: flex-start;\n}\n.ios .subnavbar a.icon-only {\n  justify-content: center;\n  margin: 0;\n}\n.md .subnavbar {\n  height: var(--f7-subnavbar-height);\n}\n.md .subnavbar .right {\n  margin-left: auto;\n}\n.md .subnavbar .right:first-child {\n  right: 16px;\n}\n.md .subnavbar a.link {\n  justify-content: center;\n  padding: 0 16px;\n}\n.md .subnavbar a.link:before {\n  content: '';\n  width: 152%;\n  height: 152%;\n  position: absolute;\n  left: -26%;\n  top: -26%;\n  background-image: radial-gradient(circle at center, var(--f7-link-highlight-color) 66%, rgba(255, 255, 255, 0) 66%);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 100% 100%;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 600ms;\n}\n.md .subnavbar a.link.active-state:before {\n  opacity: 1;\n  transition-duration: 150ms;\n}\n.md .subnavbar a.icon-only {\n  flex-shrink: 0;\n}\n.md .subnavbar-inner > a.link:first-child {\n  margin-left: calc(-1 * var(--f7-subnavbar-inner-padding-left));\n}\n.md .subnavbar-inner > a.link:last-child {\n  margin-right: calc(-1 * var(--f7-subnavbar-inner-padding-right));\n}\n.aurora .subnavbar {\n  height: calc(var(--f7-subnavbar-height) + 1px);\n  margin-top: -1px;\n  padding-top: 1px;\n}\n.aurora .subnavbar .title {\n  align-self: flex-start;\n  flex-shrink: 10;\n}\n.aurora .subnavbar .left a + a,\n.aurora .subnavbar .right a + a {\n  margin-left: 10px;\n}\n.aurora .subnavbar .left {\n  margin-right: 10px;\n}\n.aurora .subnavbar .right {\n  margin-left: 10px;\n}\n.aurora .subnavbar .right:first-child {\n  right: 16px;\n}\n.aurora .subnavbar a.link {\n  justify-content: flex-start;\n}\n.aurora .subnavbar a.icon-only {\n  justify-content: center;\n  margin: 0;\n}\n/* === Content Block === */\n:root {\n  --f7-block-padding-horizontal: 16px;\n  --f7-block-padding-vertical: 16px;\n  --f7-block-font-size: inherit;\n  --f7-block-text-color: inherit;\n  --f7-block-header-margin: 10px;\n  --f7-block-footer-margin: 10px;\n  --f7-block-header-font-size: 14px;\n  --f7-block-footer-font-size: 14px;\n  --f7-block-title-text-transform: none;\n  --f7-block-title-white-space: nowrap;\n  --f7-block-title-medium-text-transform: none;\n  --f7-block-title-large-text-transform: none;\n  --f7-block-inset-side-margin: 16px;\n  --f7-block-title-medium-text-color: #000;\n  --f7-block-title-large-text-color: #000;\n  --f7-block-strong-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-block-title-text-color: #fff;\n  --f7-block-strong-border-color: rgba(255, 255, 255, 0.15);\n  --f7-block-title-medium-text-color: #fff;\n  --f7-block-title-large-text-color: #fff;\n  --f7-block-strong-bg-color: #1c1c1d;\n}\n.ios {\n  --f7-block-margin-vertical: 35px;\n  --f7-block-strong-border-color: rgba(0, 0, 0, 0.22);\n  --f7-block-title-text-color: #000;\n  --f7-block-title-font-size: 16px;\n  --f7-block-title-font-weight: 600;\n  --f7-block-title-line-height: 20px;\n  --f7-block-title-margin-bottom: 10px;\n  --f7-block-title-medium-font-size: 22px;\n  --f7-block-title-medium-font-weight: bold;\n  --f7-block-title-medium-line-height: 1.4;\n  --f7-block-title-large-font-size: 30px;\n  --f7-block-title-large-font-weight: bold;\n  --f7-block-title-large-line-height: 1.3;\n  --f7-block-inset-border-radius: 8px;\n  --f7-block-strong-text-color: #000;\n  --f7-block-header-text-color: rgba(0, 0, 0, 0.45);\n  --f7-block-footer-text-color: rgba(0, 0, 0, 0.45);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-block-header-text-color: rgba(255, 255, 255, 0.55);\n  --f7-block-footer-text-color: rgba(255, 255, 255, 0.55);\n  --f7-block-strong-text-color: #fff;\n}\n.md {\n  --f7-block-margin-vertical: 32px;\n  --f7-block-strong-text-color: inherit;\n  --f7-block-strong-border-color: rgba(0, 0, 0, 0.12);\n  --f7-block-title-font-size: inherit;\n  --f7-block-title-text-color: rgba(0, 0, 0, 0.54);\n  --f7-block-title-font-weight: 500;\n  --f7-block-title-line-height: 16px;\n  --f7-block-title-margin-bottom: 16px;\n  --f7-block-title-medium-font-size: 24px;\n  --f7-block-title-medium-font-weight: 500;\n  --f7-block-title-medium-line-height: 1.3;\n  --f7-block-title-large-font-size: 34px;\n  --f7-block-title-large-font-weight: 500;\n  --f7-block-title-large-line-height: 1.2;\n  --f7-block-inset-border-radius: 4px;\n  --f7-block-header-text-color: rgba(0, 0, 0, 0.54);\n  --f7-block-footer-text-color: rgba(0, 0, 0, 0.54);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-block-header-text-color: rgba(255, 255, 255, 0.54);\n  --f7-block-footer-text-color: rgba(255, 255, 255, 0.54);\n}\n.aurora {\n  --f7-block-margin-vertical: 15px;\n  --f7-block-strong-border-color: rgba(0, 0, 0, 0.12);\n  --f7-block-title-font-size: inherit;\n  --f7-block-title-text-color: rgba(0, 0, 0, 0.7);\n  --f7-block-title-font-weight: 600;\n  --f7-block-title-line-height: 1.5;\n  --f7-block-title-margin-bottom: 5px;\n  --f7-block-title-medium-font-size: 20px;\n  --f7-block-title-medium-font-weight: 600;\n  --f7-block-title-medium-line-height: 1.4;\n  --f7-block-title-large-font-size: 28px;\n  --f7-block-title-large-font-weight: bold;\n  --f7-block-title-large-line-height: 1.3;\n  --f7-block-inset-border-radius: 4px;\n  --f7-block-strong-text-color: inherit;\n  --f7-block-header-text-color: rgba(0, 0, 0, 0.6);\n  --f7-block-footer-text-color: rgba(0, 0, 0, 0.6);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-block-header-text-color: rgba(255, 255, 255, 0.54);\n  --f7-block-footer-text-color: rgba(255, 255, 255, 0.54);\n  --f7-block-strong-text-color: #fff;\n}\n.block {\n  box-sizing: border-box;\n  position: relative;\n  z-index: 1;\n  color: var(--f7-block-text-color);\n  margin: var(--f7-block-margin-vertical) 0;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: calc(var(--f7-block-padding-horizontal) + var(--f7-safe-area-left));\n  padding-right: calc(var(--f7-block-padding-horizontal) + var(--f7-safe-area-right));\n  font-size: var(--f7-block-font-size);\n}\n.block.no-hairlines:before,\n.block.no-hairlines ul:before,\n.md .block.no-hairlines-md:before,\n.md .block.no-hairlines-md ul:before,\n.ios .block.no-hairlines-ios:before,\n.ios .block.no-hairlines-ios ul:before,\n.aurora .block.no-hairlines-aurora:before,\n.aurora .block.no-hairlines-aurora ul:before,\n.block.no-hairlines:after,\n.block.no-hairlines ul:after,\n.md .block.no-hairlines-md:after,\n.md .block.no-hairlines-md ul:after,\n.ios .block.no-hairlines-ios:after,\n.ios .block.no-hairlines-ios ul:after,\n.aurora .block.no-hairlines-aurora:after,\n.aurora .block.no-hairlines-aurora ul:after {\n  display: none !important;\n}\n.block.no-hairline-top:before,\n.block.no-hairline-top ul:before,\n.md .block.no-hairline-top-md:before,\n.md .block.no-hairline-top-md ul:before,\n.ios .block.no-hairline-top-ios:before,\n.ios .block.no-hairline-top-ios ul:before,\n.aurora .block.no-hairline-top-aurora:before,\n.aurora .block.no-hairline-top-aurora ul:before {\n  display: none !important;\n}\n.block.no-hairline-bottom:after,\n.block.no-hairline-bottom ul:after,\n.md .block.no-hairline-bottom-md:after,\n.md .block.no-hairline-bottom-md ul:after,\n.ios .block.no-hairline-bottom-ios:after,\n.ios .block.no-hairline-bottom-ios ul:after,\n.aurora .block.no-hairline-bottom-aurora:after,\n.aurora .block.no-hairline-bottom-aurora ul:after {\n  display: none !important;\n}\n.block > h1:first-child,\n.block > h2:first-child,\n.block > h3:first-child,\n.block > h4:first-child,\n.block > p:first-child {\n  margin-top: 0;\n}\n.block > h1:last-child,\n.block > h2:last-child,\n.block > h3:last-child,\n.block > h4:last-child,\n.block > p:last-child {\n  margin-bottom: 0;\n}\n.block-strong {\n  color: var(--f7-block-strong-text-color);\n  padding-top: var(--f7-block-padding-vertical);\n  padding-bottom: var(--f7-block-padding-vertical);\n  background-color: var(--f7-block-strong-bg-color);\n}\n.block-strong:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-block-strong-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.block-strong:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-block-strong-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.block-title {\n  position: relative;\n  overflow: hidden;\n  margin: 0;\n  white-space: var(--f7-block-title-white-space);\n  text-overflow: ellipsis;\n  text-transform: var(--f7-block-title-text-transform);\n  color: var(--f7-block-title-text-color);\n  font-size: var(--f7-block-title-font-size, inherit);\n  font-weight: var(--f7-block-title-font-weight);\n  line-height: var(--f7-block-title-line-height);\n  margin-top: var(--f7-block-margin-vertical);\n  margin-bottom: var(--f7-block-title-margin-bottom);\n  margin-left: calc(var(--f7-block-padding-horizontal) + var(--f7-safe-area-left));\n  margin-right: calc(var(--f7-block-padding-horizontal) + var(--f7-safe-area-right));\n}\n.block-title + .list,\n.block-title + .block,\n.block-title + .card,\n.block-title + .timeline,\n.block-title + .block-header {\n  margin-top: 0px;\n}\n.block-title-medium {\n  font-size: var(--f7-block-title-medium-font-size);\n  text-transform: var(--f7-block-title-medium-text-transform);\n  color: var(--f7-block-title-medium-text-color);\n  font-weight: var(--f7-block-title-medium-font-weight);\n  line-height: var(--f7-block-title-medium-line-height);\n}\n.block-title-large {\n  font-size: var(--f7-block-title-large-font-size);\n  text-transform: var(--f7-block-title-large-text-transform);\n  color: var(--f7-block-title-large-text-color);\n  font-weight: var(--f7-block-title-large-font-weight);\n  line-height: var(--f7-block-title-large-line-height);\n}\n.block > .block-title:first-child,\n.list > .block-title:first-child {\n  margin-top: 0;\n  margin-left: 0;\n  margin-right: 0;\n}\n.block-header {\n  color: var(--f7-block-header-text-color);\n  font-size: var(--f7-block-header-font-size);\n  margin-bottom: var(--f7-block-header-margin);\n  margin-top: var(--f7-block-margin-vertical);\n}\n.block-header + .list,\n.block-header + .block,\n.block-header + .card,\n.block-header + .timeline {\n  margin-top: var(--f7-block-header-margin);\n}\n.block-footer {\n  color: var(--f7-block-footer-text-color);\n  font-size: var(--f7-block-footer-font-size);\n  margin-top: var(--f7-block-footer-margin);\n  margin-bottom: var(--f7-block-margin-vertical);\n}\n.block-footer,\n.block-header {\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: calc(var(--f7-block-padding-horizontal) + var(--f7-safe-area-left));\n  padding-right: calc(var(--f7-block-padding-horizontal) + var(--f7-safe-area-right));\n}\n.block-footer ul:first-child,\n.block-header ul:first-child,\n.block-footer p:first-child,\n.block-header p:first-child,\n.block-footer h1:first-child,\n.block-header h1:first-child,\n.block-footer h2:first-child,\n.block-header h2:first-child,\n.block-footer h3:first-child,\n.block-header h3:first-child,\n.block-footer h4:first-child,\n.block-header h4:first-child {\n  margin-top: 0;\n}\n.block-footer ul:last-child,\n.block-header ul:last-child,\n.block-footer p:last-child,\n.block-header p:last-child,\n.block-footer h1:last-child,\n.block-header h1:last-child,\n.block-footer h2:last-child,\n.block-header h2:last-child,\n.block-footer h3:last-child,\n.block-header h3:last-child,\n.block-footer h4:last-child,\n.block-header h4:last-child {\n  margin-bottom: 0;\n}\n.block-footer ul:first-child:last-child,\n.block-header ul:first-child:last-child,\n.block-footer p:first-child:last-child,\n.block-header p:first-child:last-child,\n.block-footer h1:first-child:last-child,\n.block-header h1:first-child:last-child,\n.block-footer h2:first-child:last-child,\n.block-header h2:first-child:last-child,\n.block-footer h3:first-child:last-child,\n.block-header h3:first-child:last-child,\n.block-footer h4:first-child:last-child,\n.block-header h4:first-child:last-child {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.list .block-header,\n.block .block-header,\n.card .block-header,\n.timeline .block-header {\n  margin-top: 0;\n}\n.list .block-footer,\n.block .block-footer,\n.card .block-footer,\n.timeline .block-footer {\n  margin-bottom: 0;\n}\n.list + .block-footer,\n.block + .block-footer,\n.card + .block-footer,\n.timeline + .block-footer {\n  margin-top: calc(-1 * (var(--f7-block-margin-vertical) - var(--f7-block-footer-margin)));\n}\n.block + .block-footer {\n  margin-top: calc(-1 * (var(--f7-block-margin-vertical) - var(--f7-block-footer-margin)));\n  margin-bottom: var(--f7-block-margin-vertical);\n}\n.block .block-header,\n.block .block-footer {\n  padding: 0;\n}\n.block.inset {\n  border-radius: var(--f7-block-inset-border-radius);\n  margin-left: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-left));\n  margin-right: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-right));\n  --f7-safe-area-left: 0px;\n  --f7-safe-area-right: 0px;\n}\n.block-strong.inset:before,\n.block-strong.inset:after {\n  display: none !important;\n}\n@media (min-width: 480px) {\n  .block.xsmall-inset {\n    border-radius: var(--f7-block-inset-border-radius);\n    margin-left: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-right));\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .block-strong.xsmall-inset:before,\n  .block-strong.xsmall-inset:after {\n    display: none !important;\n  }\n}\n@media (min-width: 568px) {\n  .block.small-inset {\n    border-radius: var(--f7-block-inset-border-radius);\n    margin-left: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-right));\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .block-strong.small-inset:before,\n  .block-strong.small-inset:after {\n    display: none !important;\n  }\n}\n@media (min-width: 768px) {\n  .block.medium-inset {\n    border-radius: var(--f7-block-inset-border-radius);\n    margin-left: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-right));\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .block-strong.medium-inset:before,\n  .block-strong.medium-inset:after {\n    display: none !important;\n  }\n}\n@media (min-width: 1024px) {\n  .block.large-inset {\n    border-radius: var(--f7-block-inset-border-radius);\n    margin-left: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-right));\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .block-strong.large-inset:before,\n  .block-strong.large-inset:after {\n    display: none !important;\n  }\n}\n@media (min-width: 1200px) {\n  .block.xlarge-inset {\n    border-radius: var(--f7-block-inset-border-radius);\n    margin-left: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-block-inset-side-margin) + var(--f7-safe-area-outer-right));\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .block-strong.xlarge-inset:before,\n  .block-strong.xlarge-inset:after {\n    display: none !important;\n  }\n}\n/* === List View === */\n:root {\n  --f7-list-inset-side-margin: 16px;\n  --f7-list-item-cell-margin: 16px;\n  --f7-list-item-padding-horizontal: 16px;\n  --f7-list-media-item-padding-horizontal: 16px;\n  --f7-list-item-text-max-lines: 2;\n  --f7-list-chevron-icon-font-size: 20px;\n  --f7-list-item-title-font-size: inherit;\n  --f7-list-item-title-font-weight: 400;\n  --f7-list-item-title-text-color: inherit;\n  --f7-list-item-title-line-height: inherit;\n  --f7-list-item-title-white-space: nowrap;\n  --f7-list-item-subtitle-font-weight: 400;\n  --f7-list-item-subtitle-text-color: inherit;\n  --f7-list-item-subtitle-line-height: inherit;\n  --f7-list-item-text-font-weight: 400;\n  --f7-list-item-after-font-weight: 400;\n  --f7-list-item-header-text-color: inherit;\n  --f7-list-item-header-font-size: 12px;\n  --f7-list-item-header-font-weight: 400;\n  --f7-list-item-header-line-height: 1.2;\n  --f7-list-item-footer-font-size: 12px;\n  --f7-list-item-footer-font-weight: 400;\n  --f7-list-item-footer-line-height: 1.2;\n  --f7-list-button-font-size: inherit;\n  --f7-list-button-font-weight: 400;\n  --f7-list-item-divider-line-height: inherit;\n  --f7-list-group-title-line-height: inherit;\n  --f7-list-bg-color: #fff;\n  --f7-list-chevron-icon-color: rgba(0, 0, 0, 0.2);\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-list-button-border-color: rgba(255, 255, 255, 0.15);\n  --f7-list-bg-color: #1c1c1d;\n  --f7-list-border-color: rgba(255, 255, 255, 0.15);\n  --f7-list-item-border-color: rgba(255, 255, 255, 0.15);\n  --f7-list-item-divider-border-color: rgba(255, 255, 255, 0.15);\n  --f7-list-item-divider-bg-color: #232323;\n  --f7-list-group-title-bg-color: #232323;\n  --f7-list-chevron-icon-color: rgba(255, 255, 255, 0.3);\n}\n.ios {\n  --f7-list-in-list-padding-left: 30px;\n  --f7-list-inset-border-radius: 8px;\n  --f7-list-margin-vertical: 35px;\n  --f7-list-font-size: 17px;\n  --f7-list-chevron-icon-area: 20px;\n  --f7-list-border-color: rgba(0, 0, 0, 0.22);\n  --f7-list-item-border-color: rgba(0, 0, 0, 0.22);\n  --f7-list-link-pressed-bg-color: rgba(0, 0, 0, 0.15);\n  --f7-list-item-subtitle-font-size: 15px;\n  --f7-list-item-text-font-size: 15px;\n  --f7-list-item-text-line-height: 21px;\n  --f7-list-item-after-font-size: inherit;\n  --f7-list-item-after-line-height: inherit;\n  --f7-list-item-after-padding: 5px;\n  --f7-list-item-min-height: 44px;\n  --f7-list-item-media-margin: 16px;\n  --f7-list-item-media-icons-margin: 5px;\n  --f7-list-item-padding-vertical: 8px;\n  --f7-list-media-item-padding-vertical: 10px;\n  --f7-list-media-item-title-font-weight: 600;\n  /*\n  --f7-list-button-text-color: var(--f7-theme-color);\n  */\n  --f7-list-button-text-align: center;\n  --f7-list-button-border-color: rgba(0, 0, 0, 0.22);\n  --f7-list-item-divider-height: 31px;\n  --f7-list-item-divider-font-size: inherit;\n  --f7-list-item-divider-font-weight: 400;\n  --f7-list-item-divider-bg-color: rgba(0, 0, 0, 0.03);\n  --f7-list-item-divider-border-color: rgba(0, 0, 0, 0.22);\n  --f7-list-group-title-height: 31px;\n  --f7-list-group-title-font-size: inherit;\n  --f7-list-group-title-font-weight: 400;\n  --f7-list-group-title-bg-color: #f7f7f7;\n  --f7-list-item-after-text-color: rgba(0, 0, 0, 0.45);\n  --f7-list-item-footer-text-color: rgba(0, 0, 0, 0.45);\n  --f7-list-item-text-text-color: rgba(0, 0, 0, 0.45);\n  --f7-list-item-divider-text-color: rgba(0, 0, 0, 0.45);\n  --f7-list-group-title-text-color: rgba(0, 0, 0, 0.45);\n  --f7-list-button-pressed-bg-color: rgba(0, 0, 0, 0.15);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-list-item-after-text-color: rgba(255, 255, 255, 0.55);\n  --f7-list-item-header-text-color: rgba(255, 255, 255, 0.55);\n  --f7-list-item-footer-text-color: rgba(255, 255, 255, 0.55);\n  --f7-list-item-text-text-color: rgba(255, 255, 255, 0.55);\n  --f7-list-item-divider-text-color: rgba(255, 255, 255, 0.55);\n  --f7-list-group-title-text-color: rgba(255, 255, 255, 0.55);\n  --f7-list-link-pressed-bg-color: rgba(255, 255, 255, 0.08);\n  --f7-list-button-pressed-bg-color: rgba(255, 255, 255, 0.08);\n}\n.md {\n  --f7-list-in-list-padding-left: 40px;\n  --f7-list-inset-border-radius: 4px;\n  --f7-list-margin-vertical: 32px;\n  --f7-list-font-size: 16px;\n  --f7-list-chevron-icon-area: 26px;\n  --f7-list-border-color: rgba(0, 0, 0, 0.12);\n  --f7-list-item-border-color: rgba(0, 0, 0, 0.12);\n  --f7-list-item-subtitle-font-size: 14px;\n  --f7-list-item-text-font-size: 14px;\n  --f7-list-item-text-line-height: 20px;\n  --f7-list-item-after-font-size: 14px;\n  --f7-list-item-after-line-height: inherit;\n  --f7-list-item-after-padding: 8px;\n  --f7-list-item-min-height: 48px;\n  --f7-list-item-media-margin: 16px;\n  --f7-list-item-media-icons-margin: 8px;\n  --f7-list-item-padding-vertical: 8px;\n  --f7-list-media-item-padding-vertical: 14px;\n  /*\n  --f7-list-media-item-title-font-weight: var(--f7-list-item-title-font-weight);\n  */\n  --f7-list-button-text-align: left;\n  --f7-list-button-border-color: transparent;\n  --f7-list-item-divider-height: 48px;\n  --f7-list-item-divider-font-size: 14px;\n  --f7-list-item-divider-font-weight: 400;\n  --f7-list-item-divider-bg-color: #f4f4f4;\n  --f7-list-item-divider-border-color: transparent;\n  --f7-list-group-title-height: 48px;\n  --f7-list-group-title-font-size: 14px;\n  --f7-list-group-title-font-weight: 400;\n  --f7-list-group-title-bg-color: #f4f4f4;\n  --f7-list-link-pressed-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-list-item-text-text-color: rgba(0, 0, 0, 0.54);\n  --f7-list-item-after-text-color: rgba(0, 0, 0, 0.54);\n  --f7-list-item-footer-text-color: rgba(0, 0, 0, 0.5);\n  --f7-list-button-text-color: #212121;\n  --f7-list-button-pressed-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-list-item-divider-text-color: rgba(0, 0, 0, 0.54);\n  --f7-list-group-title-text-color: rgba(0, 0, 0, 0.54);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-list-button-text-color: #fff;\n  --f7-list-item-divider-text-color: #fff;\n  --f7-list-group-title-text-color: #fff;\n  --f7-list-link-pressed-bg-color: rgba(255, 255, 255, 0.05);\n  --f7-list-button-pressed-bg-color: rgba(255, 255, 255, 0.05);\n  --f7-list-item-text-text-color: rgba(255, 255, 255, 0.54);\n  --f7-list-item-after-text-color: rgba(255, 255, 255, 0.54);\n  --f7-list-item-footer-text-color: rgba(255, 255, 255, 0.54);\n}\n.aurora {\n  --f7-list-in-list-padding-left: 16px;\n  --f7-list-inset-border-radius: 4px;\n  --f7-list-margin-vertical: 15px;\n  --f7-list-font-size: 14px;\n  --f7-list-chevron-icon-area: 15px;\n  --f7-list-chevron-icon-font-size: 16px;\n  --f7-list-border-color: rgba(0, 0, 0, 0.12);\n  --f7-list-item-border-color: rgba(0, 0, 0, 0.12);\n  --f7-list-item-title-line-height: 1.3;\n  --f7-list-item-subtitle-font-size: 14px;\n  --f7-list-item-subtitle-line-height: 1.3;\n  --f7-list-item-text-font-size: 12px;\n  --f7-list-item-text-line-height: 16px;\n  --f7-list-item-after-font-size: 13px;\n  --f7-list-item-after-line-height: 1.2;\n  --f7-list-item-after-padding: 5px;\n  --f7-list-item-min-height: 32px;\n  --f7-list-item-media-margin: 10px;\n  --f7-list-item-media-icons-margin: 5px;\n  --f7-list-item-padding-vertical: 5px;\n  --f7-list-media-item-padding-vertical: 5px;\n  --f7-list-media-item-title-font-weight: 600;\n  /*\n  --f7-list-button-text-color: var(--f7-theme-color);\n  */\n  --f7-list-button-text-align: center;\n  --f7-list-button-border-color: rgba(0, 0, 0, 0.12);\n  --f7-list-item-divider-height: 19px;\n  --f7-list-item-divider-font-size: inherit;\n  --f7-list-item-divider-font-weight: 500;\n  --f7-list-item-divider-bg-color: rgba(0, 0, 0, 0.03);\n  --f7-list-item-divider-border-color: transparent;\n  --f7-list-group-title-height: 19px;\n  --f7-list-group-title-font-size: inherit;\n  --f7-list-group-title-font-weight: 500;\n  --f7-list-group-title-bg-color: #f7f7f7;\n  --f7-list-link-pressed-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-list-link-hover-bg-color: rgba(0, 0, 0, 0.03);\n  --f7-list-item-text-text-color: rgba(0, 0, 0, 0.6);\n  --f7-list-item-after-text-color: rgba(0, 0, 0, 0.5);\n  --f7-list-item-footer-text-color: rgba(0, 0, 0, 0.6);\n  --f7-list-button-pressed-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-list-button-hover-bg-color: rgba(0, 0, 0, 0.03);\n  --f7-list-item-divider-text-color: rgba(0, 0, 0, 0.6);\n  --f7-list-group-title-text-color: rgba(0, 0, 0, 0.6);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-list-item-text-text-color: rgba(255, 255, 255, 0.54);\n  --f7-list-item-after-text-color: rgba(255, 255, 255, 0.54);\n  --f7-list-item-footer-text-color: rgba(255, 255, 255, 0.54);\n  --f7-list-item-divider-text-color: rgba(255, 255, 255, 0.6);\n  --f7-list-group-title-text-color: rgba(255, 255, 255, 0.6);\n  --f7-list-link-pressed-bg-color: rgba(255, 255, 255, 0.05);\n  --f7-list-link-hover-bg-color: rgba(255, 255, 255, 0.03);\n  --f7-list-button-pressed-bg-color: rgba(255, 255, 255, 0.05);\n  --f7-list-button-hover-bg-color: rgba(255, 255, 255, 0.03);\n}\n:root {\n  --f7-list-chevron-icon-left: 'chevron_left';\n  --f7-list-chevron-icon-right: 'chevron_right';\n}\n.aurora {\n  --f7-list-chevron-icon-left: 'chevron_left_aurora';\n  --f7-list-chevron-icon-right: 'chevron_right_aurora';\n}\n.list {\n  position: relative;\n  z-index: 1;\n  font-size: var(--f7-list-font-size);\n  margin: var(--f7-list-margin-vertical) 0;\n}\n.list ul {\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  position: relative;\n  background: var(--f7-list-bg-color);\n}\n.list ul:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-list-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.list ul:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-list-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.list ul ul {\n  padding-left: calc(var(--f7-list-item-padding-horizontal) + var(--f7-list-in-list-padding-left));\n}\n.list ul ul:before,\n.list ul ul:after {\n  display: none !important;\n}\n.list li {\n  position: relative;\n  box-sizing: border-box;\n}\n.list .item-media {\n  display: flex;\n  flex-shrink: 0;\n  flex-wrap: nowrap;\n  align-items: center;\n  box-sizing: border-box;\n  padding-bottom: var(--f7-list-item-padding-vertical);\n  padding-top: var(--f7-list-item-padding-vertical);\n}\n.list .item-media + .item-inner {\n  margin-left: var(--f7-list-item-media-margin);\n}\n.list .item-media i + i,\n.list .item-media i + img {\n  margin-left: var(--f7-list-item-media-icons-margin);\n}\n.list .item-after {\n  padding-left: var(--f7-list-item-after-padding);\n}\n.list .item-inner {\n  position: relative;\n  width: 100%;\n  min-width: 0;\n  display: flex;\n  justify-content: space-between;\n  box-sizing: border-box;\n  align-items: center;\n  align-self: stretch;\n  padding-top: var(--f7-list-item-padding-vertical);\n  padding-bottom: var(--f7-list-item-padding-vertical);\n  min-height: var(--f7-list-item-min-height);\n  padding-right: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.list .item-title {\n  min-width: 0;\n  flex-shrink: 1;\n  white-space: var(--f7-list-item-title-white-space);\n  position: relative;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  max-width: 100%;\n  font-size: var(--f7-list-item-title-font-size);\n  font-weight: var(--f7-list-item-title-font-weight);\n  color: var(--f7-list-item-title-text-color);\n  line-height: var(--f7-list-item-title-line-height);\n}\n.list .item-after {\n  white-space: nowrap;\n  flex-shrink: 0;\n  display: flex;\n  font-size: var(--f7-list-item-after-font-size);\n  font-weight: var(--f7-list-item-after-font-weight);\n  color: var(--f7-list-item-after-text-color);\n  line-height: var(--f7-list-item-after-line-height);\n  margin-left: auto;\n}\n.list .item-header,\n.list .item-footer {\n  white-space: normal;\n}\n.list .item-header {\n  color: var(--f7-list-item-header-text-color);\n  font-size: var(--f7-list-item-header-font-size);\n  font-weight: var(--f7-list-item-header-font-weight);\n  line-height: var(--f7-list-item-header-line-height);\n}\n.list .item-footer {\n  color: var(--f7-list-item-footer-text-color);\n  font-size: var(--f7-list-item-footer-font-size);\n  font-weight: var(--f7-list-item-footer-font-weight);\n  line-height: var(--f7-list-item-footer-line-height);\n}\n.list .item-link,\n.list .list-button {\n  transition-duration: 300ms;\n  transition-property: background-color;\n  display: block;\n  position: relative;\n  overflow: hidden;\n  z-index: 0;\n}\n.list .item-link {\n  color: inherit;\n}\n.list .item-link.active-state {\n  background-color: var(--f7-list-link-pressed-bg-color);\n}\n.list .item-link .item-inner {\n  padding-right: calc(var(--f7-list-chevron-icon-area) + var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.list .item-content {\n  display: flex;\n  justify-content: space-between;\n  box-sizing: border-box;\n  align-items: center;\n  min-height: var(--f7-list-item-min-height);\n  padding-left: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-left));\n}\n.list .item-subtitle {\n  position: relative;\n  overflow: hidden;\n  white-space: nowrap;\n  max-width: 100%;\n  text-overflow: ellipsis;\n  font-size: var(--f7-list-item-subtitle-font-size);\n  font-weight: var(--f7-list-item-subtitle-font-weight);\n  color: var(--f7-list-item-subtitle-text-color);\n  line-height: var(--f7-list-item-subtitle-line-height);\n}\n.list .item-text {\n  position: relative;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  /* autoprefixer: ignore next */\n  -webkit-line-clamp: var(--f7-list-item-text-max-lines);\n  /* autoprefixer: ignore next */\n  -webkit-box-orient: vertical;\n  display: -webkit-box;\n  font-size: var(--f7-list-item-text-font-size);\n  font-weight: var(--f7-list-item-text-font-weight);\n  color: var(--f7-list-item-text-text-color);\n  line-height: var(--f7-list-item-text-line-height);\n  max-height: calc(var(--f7-list-item-text-line-height) * var(--f7-list-item-text-max-lines));\n}\n.list .item-title-row {\n  position: relative;\n  display: flex;\n  justify-content: space-between;\n  box-sizing: border-box;\n}\n.list .item-title-row .item-after {\n  align-self: center;\n}\n.list .item-row {\n  display: flex;\n  justify-content: space-between;\n  box-sizing: border-box;\n}\n.list .item-cell {\n  display: block;\n  align-self: center;\n  box-sizing: border-box;\n  width: 100%;\n  min-width: 0;\n  margin-left: var(--f7-list-item-cell-margin);\n  flex-shrink: 1;\n}\n.list .item-cell:first-child {\n  margin-left: 0;\n}\n.list .ripple-wave + .item-cell {\n  margin-left: 0;\n}\n.list li:last-child .list-button:after {\n  display: none !important;\n}\n.list li:last-child > .item-inner:after,\n.list li:last-child li:last-child > .item-inner:after,\n.list li:last-child > .item-content > .item-inner:after,\n.list li:last-child li:last-child > .item-content > .item-inner:after,\n.list li:last-child > .swipeout-content > .item-content > .item-inner:after,\n.list li:last-child li:last-child > .swipeout-content > .item-content > .item-inner:after,\n.list li:last-child > .item-link > .item-content > .item-inner:after,\n.list li:last-child li:last-child > .item-link > .item-content > .item-inner:after {\n  display: none !important;\n}\n.list li li:last-child .item-inner:after,\n.list li:last-child li .item-inner:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-list-item-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.list.no-hairlines:before,\n.list.no-hairlines ul:before,\n.md .list.no-hairlines-md:before,\n.md .list.no-hairlines-md ul:before,\n.ios .list.no-hairlines-ios:before,\n.ios .list.no-hairlines-ios ul:before,\n.aurora .list.no-hairlines-aurora:before,\n.aurora .list.no-hairlines-aurora ul:before,\n.list.no-hairlines:after,\n.list.no-hairlines ul:after,\n.md .list.no-hairlines-md:after,\n.md .list.no-hairlines-md ul:after,\n.ios .list.no-hairlines-ios:after,\n.ios .list.no-hairlines-ios ul:after,\n.aurora .list.no-hairlines-aurora:after,\n.aurora .list.no-hairlines-aurora ul:after {\n  display: none !important;\n}\n.list.no-hairline-top:before,\n.list.no-hairline-top ul:before,\n.md .list.no-hairline-top-md:before,\n.md .list.no-hairline-top-md ul:before,\n.ios .list.no-hairline-top-ios:before,\n.ios .list.no-hairline-top-ios ul:before,\n.aurora .list.no-hairline-top-aurora:before,\n.aurora .list.no-hairline-top-aurora ul:before {\n  display: none !important;\n}\n.list.no-hairline-bottom:after,\n.list.no-hairline-bottom ul:after,\n.md .list.no-hairline-bottom-md:after,\n.md .list.no-hairline-bottom-md ul:after,\n.ios .list.no-hairline-bottom-ios:after,\n.ios .list.no-hairline-bottom-ios ul:after,\n.aurora .list.no-hairline-bottom-aurora:after,\n.aurora .list.no-hairline-bottom-aurora ul:after {\n  display: none !important;\n}\n.list.no-hairlines-between .item-inner:after,\n.md .list.no-hairlines-between-md .item-inner:after,\n.ios .list.no-hairlines-between-ios .item-inner:after,\n.aurora .list.no-hairlines-between-aurora .item-inner:after,\n.list.no-hairlines-between .list-button:after,\n.md .list.no-hairlines-between-md .list-button:after,\n.ios .list.no-hairlines-between-ios .list-button:after,\n.aurora .list.no-hairlines-between-aurora .list-button:after,\n.list.no-hairlines-between .item-divider:after,\n.md .list.no-hairlines-between-md .item-divider:after,\n.ios .list.no-hairlines-between-ios .item-divider:after,\n.aurora .list.no-hairlines-between-aurora .item-divider:after,\n.list.no-hairlines-between .list-group-title:after,\n.md .list.no-hairlines-between-md .list-group-title:after,\n.ios .list.no-hairlines-between-ios .list-group-title:after,\n.aurora .list.no-hairlines-between-aurora .list-group-title:after,\n.list.no-hairlines-between .list-group-title:after,\n.md .list.no-hairlines-between-md .list-group-title:after,\n.ios .list.no-hairlines-between-ios .list-group-title:after,\n.aurora .list.no-hairlines-between-aurora .list-group-title:after {\n  display: none !important;\n}\n.list.no-hairlines-between.simple-list li:after,\n.md .list.no-hairlines-between-md.simple-list li:after,\n.ios .list.no-hairlines-between-ios.simple-list li:after,\n.aurora .list.no-hairlines-between-aurora.simple-list li:after {\n  display: none !important;\n}\n.list.no-hairlines-between.links-list a:after,\n.md .list.no-hairlines-between-md.links-list a:after,\n.ios .list.no-hairlines-between-ios.links-list a:after,\n.aurora .list.no-hairlines-between-aurora.links-list a:after {\n  display: none !important;\n}\n.list-button {\n  padding: 0 var(--f7-list-item-padding-horizontal);\n  line-height: var(--f7-list-item-min-height);\n  color: var(--f7-list-button-text-color, var(--f7-theme-color));\n  font-size: var(--f7-list-button-font-size);\n  font-weight: var(--f7-list-button-font-weight);\n  text-align: var(--f7-list-button-text-align);\n}\n.list-button:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-list-button-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.list-button.active-state {\n  background-color: var(--f7-list-button-pressed-bg-color);\n}\n.list-button[class*=\"color-\"] {\n  --f7-list-button-text-color: var(--f7-theme-color);\n}\n.simple-list li {\n  position: relative;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: 100%;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  align-content: center;\n  line-height: var(--f7-list-item-min-height);\n  height: var(--f7-list-item-min-height);\n  padding-left: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-left));\n  padding-right: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.simple-list li:after {\n  left: var(--f7-list-item-padding-horizontal);\n  width: auto;\n  left: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-left));\n  right: 0;\n}\n.simple-list li:last-child:after {\n  display: none !important;\n}\n.links-list li {\n  z-index: 1;\n}\n.links-list a {\n  transition-duration: 300ms;\n  transition-property: background-color;\n  display: block;\n  position: relative;\n  overflow: hidden;\n  display: flex;\n  align-items: center;\n  align-content: center;\n  justify-content: space-between;\n  box-sizing: border-box;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  max-width: 100%;\n  height: var(--f7-list-item-min-height);\n  color: inherit;\n}\n.links-list a .ripple-wave {\n  z-index: 0;\n}\n.links-list a:after {\n  width: auto;\n}\n.links-list a.active-state {\n  background-color: var(--f7-list-link-pressed-bg-color);\n}\n.links-list a {\n  padding-left: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-left));\n  padding-right: calc(var(--f7-list-chevron-icon-area) + var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.links-list a:after {\n  left: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-left));\n  right: 0;\n}\n.links-list li:last-child a:after {\n  display: none !important;\n}\n.simple-list li:after,\n.links-list a:after,\n.list .item-inner:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-list-item-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.media-list,\nli.media-item {\n  --f7-list-item-padding-vertical: var(--f7-list-media-item-padding-vertical);\n  --f7-list-item-padding-horizontal: var(--f7-list-media-item-padding-horizontal);\n}\n.media-list .item-title,\nli.media-item .item-title {\n  font-weight: var(--f7-list-media-item-title-font-weight, var(--f7-list-item-title-font-weight, inherit));\n}\n.media-list .item-inner,\nli.media-item .item-inner {\n  display: block;\n  align-self: stretch;\n}\n.media-list .item-media,\nli.media-item .item-media {\n  align-self: flex-start;\n}\n.media-list .item-media img,\nli.media-item .item-media img {\n  display: block;\n}\n.media-list .item-link .item-inner,\nli.media-item .item-link .item-inner {\n  padding-right: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.media-list .item-link .item-title-row,\nli.media-item .item-link .item-title-row {\n  padding-right: calc(var(--f7-list-chevron-icon-area));\n}\n.media-list.chevron-center .item-link .item-inner,\n.media-list .chevron-center .item-link .item-inner,\n.media-list .item-link.chevron-center .item-inner,\nli.media-item.chevron-center .item-link .item-inner,\nli.media-item .item-link.chevron-center .item-inner,\nli.media-item .chevron-center .item-link .item-inner {\n  padding-right: calc(var(--f7-list-chevron-icon-area) + var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.media-list.chevron-center .item-title-row,\n.media-list .chevron-center .item-title-row,\nli.media-item.chevron-center .item-title-row,\nli.media-item .chevron-center .item-title-row {\n  padding-right: 0;\n}\n.list .item-link .item-inner:before,\n.links-list a:before,\n.media-list .item-link .item-title-row:before,\nli.media-item .item-link .item-title-row:before,\n.media-list.chevron-center .item-link .item-inner:before,\n.media-list .chevron-center .item-link .item-inner:before,\n.media-list .item-link.chevron-center .item-inner:before,\nli.media-item.chevron-center .item-link .item-inner:before,\nli.media-item .chevron-center .item-link .item-inner:before,\nli.media-item .item-link.chevron-center .item-inner:before {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  position: absolute;\n  top: 50%;\n  width: 8px;\n  height: 14px;\n  margin-top: -7px;\n  font-size: var(--f7-list-chevron-icon-font-size);\n  line-height: 14px;\n  color: var(--f7-list-chevron-icon-color);\n  pointer-events: none;\n  right: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n  content: var(--f7-list-chevron-icon-right);\n}\n.media-list.chevron-center .item-title-row:before,\n.media-list .chevron-center .item-title-row:before,\nli.media-item.chevron-center .item-title-row:before,\nli.media-item .chevron-center .item-title-row:before {\n  display: none;\n}\n.media-list .item-link .item-inner:before,\nli.media-item .item-link .item-inner:before {\n  display: none;\n}\n.media-list .item-link .item-title-row:before,\nli.media-item .item-link .item-title-row:before {\n  right: 0;\n}\n.list-group ul:after,\n.list-group ul:before {\n  z-index: 25 !important;\n}\n.list-group + .list-group ul:before {\n  display: none !important;\n}\nli.item-divider,\n.item-divider,\nli.list-group-title {\n  white-space: nowrap;\n  position: relative;\n  max-width: 100%;\n  text-overflow: ellipsis;\n  overflow: hidden;\n  z-index: 15;\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-left));\n  padding-right: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n  box-sizing: border-box;\n  display: flex;\n  align-items: center;\n  align-content: center;\n}\nli.item-divider:after,\n.item-divider:after,\nli.list-group-title:after {\n  display: none !important;\n}\nli.item-divider,\n.item-divider {\n  margin-top: -1px;\n  height: var(--f7-list-item-divider-height);\n  color: var(--f7-list-item-divider-text-color);\n  font-size: var(--f7-list-item-divider-font-size);\n  font-weight: var(--f7-list-item-divider-font-weight);\n  background-color: var(--f7-list-item-divider-bg-color);\n  line-height: var(--f7-list-item-divider-line-height);\n}\nli.item-divider:before,\n.item-divider:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-list-item-divider-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\nli.list-group-title,\n.list li.list-group-title {\n  position: relative;\n  position: -webkit-sticky;\n  position: sticky;\n  top: 0;\n  margin-top: 0;\n  z-index: 20;\n  height: var(--f7-list-group-title-height);\n  color: var(--f7-list-group-title-text-color);\n  font-size: var(--f7-list-group-title-font-size);\n  font-weight: var(--f7-list-group-title-font-weight);\n  background-color: var(--f7-list-group-title-bg-color);\n  line-height: var(--f7-list-group-title-line-height);\n}\n.page-with-navbar-large li.list-group-title,\n.page-with-navbar-large .list li.list-group-title {\n  top: calc(-1 * var(--f7-navbar-large-title-height));\n}\n.list.inset {\n  margin-left: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-left));\n  margin-right: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-right));\n  border-radius: var(--f7-list-inset-border-radius);\n  --f7-safe-area-left: 0px;\n  --f7-safe-area-right: 0px;\n}\n.list.inset .block-title {\n  margin-left: 0;\n  margin-right: 0;\n}\n.list.inset ul {\n  border-radius: var(--f7-list-inset-border-radius);\n}\n.list.inset ul:before,\n.list.inset ul:after {\n  display: none !important;\n}\n.list.inset li.swipeout:first-child,\n.list.inset li:first-child > a {\n  border-radius: var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius) 0 0;\n}\n.list.inset li.swipeout:last-child,\n.list.inset li:last-child > a {\n  border-radius: 0 0 var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius);\n}\n.list.inset li.swipeout:first-child:last-child,\n.list.inset li:first-child:last-child > a {\n  border-radius: var(--f7-list-inset-border-radius);\n}\n@media (min-width: 480px) {\n  .list.xsmall-inset {\n    margin-left: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-right));\n    border-radius: var(--f7-list-inset-border-radius);\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .list.xsmall-inset .block-title {\n    margin-left: 0;\n    margin-right: 0;\n  }\n  .list.xsmall-inset ul {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n  .list.xsmall-inset ul:before,\n  .list.xsmall-inset ul:after {\n    display: none !important;\n  }\n  .list.xsmall-inset li:first-child > a {\n    border-radius: var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius) 0 0;\n  }\n  .list.xsmall-inset li:last-child > a {\n    border-radius: 0 0 var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius);\n  }\n  .list.xsmall-inset li:first-child:last-child > a {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n}\n@media (min-width: 568px) {\n  .list.small-inset {\n    margin-left: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-right));\n    border-radius: var(--f7-list-inset-border-radius);\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .list.small-inset .block-title {\n    margin-left: 0;\n    margin-right: 0;\n  }\n  .list.small-inset ul {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n  .list.small-inset ul:before,\n  .list.small-inset ul:after {\n    display: none !important;\n  }\n  .list.small-inset li:first-child > a {\n    border-radius: var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius) 0 0;\n  }\n  .list.small-inset li:last-child > a {\n    border-radius: 0 0 var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius);\n  }\n  .list.small-inset li:first-child:last-child > a {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n}\n@media (min-width: 768px) {\n  .list.medium-inset {\n    margin-left: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-right));\n    border-radius: var(--f7-list-inset-border-radius);\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .list.medium-inset .block-title {\n    margin-left: 0;\n    margin-right: 0;\n  }\n  .list.medium-inset ul {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n  .list.medium-inset ul:before,\n  .list.medium-inset ul:after {\n    display: none !important;\n  }\n  .list.medium-inset li:first-child > a {\n    border-radius: var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius) 0 0;\n  }\n  .list.medium-inset li:last-child > a {\n    border-radius: 0 0 var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius);\n  }\n  .list.medium-inset li:first-child:last-child > a {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n}\n@media (min-width: 1024px) {\n  .list.large-inset {\n    margin-left: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-right));\n    border-radius: var(--f7-list-inset-border-radius);\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .list.large-inset .block-title {\n    margin-left: 0;\n    margin-right: 0;\n  }\n  .list.large-inset ul {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n  .list.large-inset ul:before,\n  .list.large-inset ul:after {\n    display: none !important;\n  }\n  .list.large-inset li:first-child > a {\n    border-radius: var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius) 0 0;\n  }\n  .list.large-inset li:last-child > a {\n    border-radius: 0 0 var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius);\n  }\n  .list.large-inset li:first-child:last-child > a {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n}\n@media (min-width: 1200px) {\n  .list.xlarge-inset {\n    margin-left: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-left));\n    margin-right: calc(var(--f7-list-inset-side-margin) + var(--f7-safe-area-outer-right));\n    border-radius: var(--f7-list-inset-border-radius);\n    --f7-safe-area-left: 0px;\n    --f7-safe-area-right: 0px;\n  }\n  .list.xlarge-inset .block-title {\n    margin-left: 0;\n    margin-right: 0;\n  }\n  .list.xlarge-inset ul {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n  .list.xlarge-inset ul:before,\n  .list.xlarge-inset ul:after {\n    display: none !important;\n  }\n  .list.xlarge-inset li:first-child > a {\n    border-radius: var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius) 0 0;\n  }\n  .list.xlarge-inset li:last-child > a {\n    border-radius: 0 0 var(--f7-list-inset-border-radius) var(--f7-list-inset-border-radius);\n  }\n  .list.xlarge-inset li:first-child:last-child > a {\n    border-radius: var(--f7-list-inset-border-radius);\n  }\n}\n.list.no-chevron,\n.list .no-chevron {\n  --f7-list-chevron-icon-color: transparent;\n  --f7-list-chevron-icon-area: 0px;\n}\n.ios .item-link.active-state .item-inner:after,\n.ios .list-button.active-state:after,\n.ios .links-list a.active-state:after {\n  background-color: transparent;\n}\n.ios .links-list a.active-state,\n.ios .list .item-link.active-state,\n.ios .list .list-button.active-state {\n  transition-duration: 0ms;\n}\n.md .list .item-media {\n  min-width: 40px;\n}\n.aurora .list .item-media {\n  min-width: 18px;\n}\n.aurora .links-list a,\n.aurora .list .item-link,\n.aurora .list .list-button {\n  transition-duration: 0ms;\n}\n.aurora.device-desktop .links-list a:hover:not(.active-state):not(.no-hover),\n.aurora.device-desktop .list .item-link:hover:not(.active-state):not(.no-hover) {\n  background: var(--f7-list-link-hover-bg-color);\n}\n.aurora.device-desktop .list .list-button:hover:not(.active-state):not(.no-hover) {\n  background: var(--f7-list-button-hover-bg-color);\n}\n/* === Badge === */\n:root {\n  --f7-badge-text-color: #fff;\n  --f7-badge-bg-color: #8e8e93;\n  --f7-badge-padding: 0 4px;\n  --f7-badge-in-icon-size: 16px;\n  --f7-badge-in-icon-font-size: 10px;\n  --f7-badge-font-weight: normal;\n  --f7-badge-font-size: 12px;\n}\n.ios {\n  --f7-badge-size: 20px;\n}\n.md {\n  --f7-badge-size: 18px;\n}\n.aurora {\n  --f7-badge-size: 18px;\n  --f7-badge-font-weight: 600;\n  --f7-badge-in-icon-size: 15px;\n}\n.badge {\n  display: inline-flex;\n  align-items: center;\n  align-content: center;\n  justify-content: center;\n  color: var(--f7-badge-text-color);\n  background: var(--f7-badge-bg-color);\n  position: relative;\n  box-sizing: border-box;\n  text-align: center;\n  vertical-align: middle;\n  font-weight: var(--f7-badge-font-weight);\n  font-size: var(--f7-badge-font-size);\n  border-radius: var(--f7-badge-size);\n  padding: var(--f7-badge-padding);\n  height: var(--f7-badge-size);\n  min-width: var(--f7-badge-size);\n}\n.icon .badge,\n.f7-icons .badge,\n.framework7-icons .badge,\n.material-icons .badge {\n  position: absolute;\n  left: 100%;\n  margin-left: -10px;\n  top: -2px;\n  font-family: var(--f7-font-family);\n  --f7-badge-font-size: var(--f7-badge-in-icon-font-size);\n  --f7-badge-size: var(--f7-badge-in-icon-size);\n}\n.badge[class*=\"color-\"] {\n  --f7-badge-bg-color: var(--f7-theme-color);\n}\n:root {\n  --f7-button-min-width: 32px;\n  --f7-button-bg-color: transparent;\n  --f7-button-border-width: 0px;\n  /*\n  --f7-button-text-color: var(--f7-theme-color);\n  --f7-button-pressed-text-color: var(--f7-button-text-color, var(--f7-theme-color));\n  --f7-button-border-color: var(--f7-theme-color);\n  --f7-button-fill-text-color: #fff;\n  --f7-button-fill-bg-color: var(--f7-theme-color);\n  --f7-button-outline-border-color: var(--f7-theme-color);\n  */\n  --f7-button-outline-border-width: 2px;\n  --f7-button-raised-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0,0,0,0.24);\n  --f7-button-raised-pressed-box-shadow: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0,0,0,0.23);\n  --f7-segmented-raised-divider-color: rgba(0, 0, 0, 0.1);\n  --f7-segmented-strong-padding: 2px;\n  --f7-segmented-strong-between-buttons: 4px;\n  --f7-segmented-strong-button-font-weight: 500;\n  --f7-segmented-strong-button-active-box-shadow: 0px 2px 2px rgba(0, 0, 0, 0.25);\n  --f7-segmented-strong-bg-color: rgba(0, 0, 0, 0.07);\n  --f7-segmented-strong-button-text-color: #000;\n  --f7-segmented-strong-button-pressed-bg-color: rgba(0, 0, 0, 0.07);\n  --f7-segmented-strong-button-hover-bg-color: rgba(0, 0, 0, 0.04);\n  --f7-segmented-strong-button-active-text-color: #000;\n  --f7-segmented-strong-button-active-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-segmented-strong-bg-color: rgba(255, 255, 255, 0.1);\n  --f7-segmented-strong-button-pressed-bg-color: rgba(255, 255, 255, 0.04);\n  --f7-segmented-strong-button-hover-bg-color: rgba(255, 255, 255, 0.02);\n  --f7-segmented-strong-button-active-bg-color: rgba(255, 255, 255, 0.14);\n  --f7-segmented-strong-button-text-color: #fff;\n  --f7-segmented-strong-button-active-text-color: #fff;\n}\n.ios {\n  --f7-button-font-size: 13px;\n  --f7-button-height: 28px;\n  --f7-button-padding-horizontal: 10px;\n  --f7-button-border-radius: 5px;\n  --f7-button-font-weight: 600;\n  --f7-button-letter-spacing: 0;\n  --f7-button-text-transform: uppercase;\n  /*\n  --f7-button-pressed-bg-color: rgba(var(--f7-theme-color-rgb), .15);\n  --f7-button-fill-pressed-bg-color: var(--f7-theme-color-tint);\n  */\n  --f7-button-large-height: 44px;\n  --f7-button-large-font-size: 17px;\n  --f7-button-large-font-weight: 500;\n  --f7-button-large-text-transform: none;\n  --f7-button-small-height: 26px;\n  --f7-button-small-font-size: 13px;\n  --f7-button-small-font-weight: 600;\n  --f7-button-small-text-transform: uppercase;\n  --f7-button-small-outline-border-width: 2px;\n  --f7-segmented-strong-button-text-transform: none;\n  --f7-segmented-strong-button-active-font-weight: 600;\n}\n.md {\n  --f7-button-font-size: 14px;\n  --f7-button-height: 36px;\n  --f7-button-padding-horizontal: 8px;\n  --f7-button-border-radius: 4px;\n  --f7-button-font-weight: 500;\n  --f7-button-letter-spacing: 0.03em;\n  --f7-button-text-transform: uppercase;\n  /*\n  --f7-button-fill-pressed-bg-color: var(--f7-theme-color-shade);\n  */\n  --f7-button-large-height: 48px;\n  --f7-button-large-font-size: 14px;\n  --f7-button-large-font-weight: 500;\n  --f7-button-large-text-transform: uppercase;\n  --f7-button-small-height: 28px;\n  --f7-button-small-font-size: 12px;\n  --f7-button-small-font-weight: 500;\n  --f7-button-small-text-transform: uppercase;\n  --f7-button-small-outline-border-width: 2px;\n  --f7-segmented-strong-button-text-transform: uppercase;\n  --f7-segmented-strong-button-active-font-weight: 500;\n  --f7-button-pressed-bg-color: rgba(0, 0, 0, 0.1);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-button-pressed-bg-color: rgba(255, 255, 255, 0.1);\n}\n.aurora {\n  /*\n  --f7-button-hover-bg-color: rgba(var(--f7-theme-color-rgb), .07);\n  --f7-button-fill-hover-bg-color: var(--f7-theme-color-tint);\n  */\n  --f7-button-font-size: 14px;\n  --f7-button-height: 28px;\n  --f7-button-min-width: 24px;\n  --f7-button-padding-horizontal: 10px;\n  --f7-button-border-radius: 4px;\n  --f7-button-font-weight: 500;\n  --f7-button-letter-spacing: 0.02;\n  --f7-button-text-transform: none;\n  /*\n  --f7-button-pressed-bg-color: rgba(var(--f7-theme-color-rgb), .15);\n  --f7-button-fill-pressed-bg-color: var(--f7-theme-color-shade);\n  */\n  --f7-button-large-height: 34px;\n  --f7-button-large-font-size: 14px;\n  --f7-button-large-font-weight: 600;\n  --f7-button-large-text-transform: none;\n  --f7-button-small-height: 24px;\n  --f7-button-small-font-size: 12px;\n  --f7-button-small-font-weight: 600;\n  --f7-button-small-text-transform: none;\n  --f7-button-small-outline-border-width: 1px;\n  --f7-segmented-strong-button-text-transform: none;\n  --f7-segmented-strong-button-active-font-weight: 600;\n}\nbutton {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  width: 100%;\n}\n.button {\n  text-decoration: none;\n  text-align: center;\n  display: block;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  background: none;\n  margin: 0;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  position: relative;\n  overflow: hidden;\n  font-family: inherit;\n  cursor: pointer;\n  outline: 0;\n  box-sizing: border-box;\n  vertical-align: middle;\n  justify-content: center;\n  align-items: center;\n  border: var(--f7-button-border-width, 0px) solid var(--f7-button-border-color, var(--f7-theme-color));\n  font-size: var(--f7-button-font-size);\n  color: var(--f7-button-text-color, var(--f7-theme-color));\n  height: var(--f7-button-height);\n  line-height: calc(var(--f7-button-height) - var(--f7-button-border-width, 0) * 2);\n  padding: var(--f7-button-padding-vertical, 0px) var(--f7-button-padding-horizontal);\n  border-radius: var(--f7-button-border-radius);\n  min-width: var(--f7-button-min-width);\n  font-weight: var(--f7-button-font-weight);\n  letter-spacing: var(--f7-button-letter-spacing);\n  text-transform: var(--f7-button-text-transform);\n  background-color: var(--f7-button-bg-color);\n  box-shadow: var(--f7-button-box-shadow);\n}\n.button.active-state {\n  background-color: var(--f7-button-pressed-bg-color, rgba(var(--f7-theme-color-rgb), 0.15));\n  color: var(--f7-button-pressed-text-color, var(--f7-button-text-color, var(--f7-theme-color)));\n}\ninput[type=\"submit\"].button,\ninput[type=\"button\"].button {\n  width: 100%;\n}\n.button > i + span,\n.button > span + span,\n.button > span + i,\n.button > i + i {\n  margin-left: 4px;\n}\n.subnavbar .button,\n.navbar .button,\n.toolbar .button,\n.searchbar .button,\n.appbar .button {\n  color: var(--f7-button-text-color, var(--f7-theme-color));\n}\n.button-round,\n.ios .button-round-ios,\n.md .button-round-md,\n.aurora .button-round-aurora {\n  --f7-button-border-radius: var(--f7-button-height);\n}\n.button-fill,\n.ios .button-fill-ios,\n.md .button-fill-md,\n.aurora .button-fill-aurora,\n.button-active,\n.button.tab-link-active {\n  --f7-button-bg-color: var(--f7-button-fill-bg-color, var(--f7-theme-color));\n  --f7-button-text-color: var(--f7-button-fill-text-color, #fff);\n  --f7-touch-ripple-color: var(--f7-touch-ripple-white);\n}\n.button-fill,\n.ios .button-fill-ios,\n.md .button-fill-md,\n.aurora .button-fill-aurora {\n  --f7-button-pressed-bg-color: var(--f7-button-fill-pressed-bg-color);\n}\n.button-active,\n.button.tab-link-active {\n  --f7-button-pressed-bg-color: var(--f7-button-bg-color);\n}\n.button-outline,\n.ios .button-outline-ios,\n.md .button-outline-md,\n.aurora .button-outline-aurora {\n  --f7-button-border-color: var(--f7-button-outline-border-color, var(--f7-theme-color));\n  --f7-button-border-width: var(--f7-button-outline-border-width);\n}\n.button-large,\n.ios .button-large-ios,\n.md .button-large-md,\n.aurora .button-large-aurora {\n  --f7-button-height: var(--f7-button-large-height);\n  --f7-button-font-size: var(--f7-button-large-font-size);\n  --f7-button-font-weight: var(--f7-button-large-font-weight);\n  --f7-button-text-transform: var(--f7-button-large-text-transform);\n}\n.button-small,\n.ios .button-small-ios,\n.md .button-small-md,\n.aurora .button-small-aurora {\n  --f7-button-outline-border-width: var(--f7-button-small-outline-border-width);\n  --f7-button-height: var(--f7-button-small-height);\n  --f7-button-font-size: var(--f7-button-small-font-size);\n  --f7-button-font-weight: var(--f7-button-small-font-weight);\n  --f7-button-text-transform: var(--f7-button-small-text-transform);\n}\n.ios .button-small.button-fill,\n.ios .button-small-ios.button-fill,\n.ios .button-small.button-fill-ios {\n  --f7-button-border-width: var(--f7-button-small-outline-border-width);\n  --f7-button-pressed-text-color: var(--f7-theme-color);\n  --f7-button-pressed-bg-color: transparent;\n}\n.segmented {\n  align-self: center;\n  display: flex;\n  flex-wrap: nowrap;\n  border-radius: var(--f7-button-border-radius);\n  box-shadow: var(--f7-button-box-shadow);\n  box-sizing: border-box;\n}\n.segmented .button,\n.segmented button {\n  width: 100%;\n  flex-shrink: 1;\n  min-width: 0;\n  border-radius: 0;\n}\n.segmented .button:first-child {\n  border-radius: var(--f7-button-border-radius) 0 0 var(--f7-button-border-radius);\n}\n.segmented .button:not(.button-outline):first-child {\n  border-left: none;\n}\n.segmented .button.button-outline:nth-child(n + 2) {\n  border-left: none;\n}\n.segmented .button:last-child {\n  border-radius: 0 var(--f7-button-border-radius) var(--f7-button-border-radius) 0;\n}\n.segmented .button-round:first-child {\n  border-radius: var(--f7-button-height) 0 0 var(--f7-button-height);\n}\n.segmented .button-round:last-child {\n  border-radius: 0 var(--f7-button-height) var(--f7-button-height) 0;\n}\n.segmented .button:first-child:last-child {\n  border-radius: var(--f7-button-border-radius);\n}\n.segmented-raised,\n.ios .segmented-raised-ios,\n.md .segmented-raised-md,\n.aurora .segmented-raised-aurora {\n  box-shadow: var(--f7-button-raised-box-shadow);\n}\n.segmented-raised .button:not(.button-outline),\n.ios .segmented-raised-ios .button:not(.button-outline),\n.md .segmented-raised-md .button:not(.button-outline),\n.aurora .segmented-raised-aurora .button:not(.button-outline) {\n  border-left: 1px solid var(--f7-segmented-raised-divider-color);\n}\n.button-raised,\n.ios .button-raised-ios,\n.md .button-raised-md,\n.aurora .button-raised-aurora {\n  --f7-button-box-shadow: var(--f7-button-raised-box-shadow);\n}\n.button-raised.active-state,\n.ios .button-raised-ios.active-state,\n.md .button-raised-md.active-state,\n.aurora .button-raised-aurora.active-state {\n  --f7-button-box-shadow: var(--f7-button-raised-pressed-box-shadow);\n}\n.segmented-strong,\n.ios .segmented-strong-ios,\n.md .segmented-strong-md,\n.aurora .segmented-strong-aurora {\n  --f7-button-bg-color: transparent;\n  --f7-button-hover-bg-color: var(--f7-segmented-strong-button-hover-bg-color);\n  --f7-button-text-color: var(--f7-segmented-strong-button-text-color);\n  --f7-button-font-weight: var(--f7-segmented-strong-button-font-weight);\n  --f7-button-text-transform: var(--f7-segmented-strong-button-text-transform);\n  --f7-button-pressed-bg-color: var(--f7-segmented-strong-button-pressed-bg-color);\n  position: relative;\n  background: var(--f7-segmented-strong-bg-color);\n  border-radius: calc(var(--f7-button-border-radius) + 2px);\n  box-shadow: none;\n  padding: var(--f7-segmented-strong-padding);\n  overflow: hidden;\n}\n.segmented-strong .button,\n.ios .segmented-strong-ios .button,\n.md .segmented-strong-md .button,\n.aurora .segmented-strong-aurora .button {\n  z-index: 1;\n}\n.segmented-strong .button,\n.ios .segmented-strong-ios .button,\n.md .segmented-strong-md .button,\n.aurora .segmented-strong-aurora .button,\n.segmented-strong .button:first-child,\n.ios .segmented-strong-ios .button:first-child,\n.md .segmented-strong-md .button:first-child,\n.aurora .segmented-strong-aurora .button:first-child,\n.segmented-strong .button:last-child,\n.ios .segmented-strong-ios .button:last-child,\n.md .segmented-strong-md .button:last-child,\n.aurora .segmented-strong-aurora .button:last-child {\n  border-radius: var(--f7-button-border-radius);\n}\n.segmented-strong .button + .button,\n.ios .segmented-strong-ios .button + .button,\n.md .segmented-strong-md .button + .button,\n.aurora .segmented-strong-aurora .button + .button {\n  margin-left: var(--f7-segmented-strong-between-buttons);\n}\n.segmented-strong .button.button-active,\n.ios .segmented-strong-ios .button.button-active,\n.md .segmented-strong-md .button.button-active,\n.aurora .segmented-strong-aurora .button.button-active,\n.segmented-strong .button.tab-link-active,\n.ios .segmented-strong-ios .button.tab-link-active,\n.md .segmented-strong-md .button.tab-link-active,\n.aurora .segmented-strong-aurora .button.tab-link-active {\n  --f7-button-hover-bg-color: transparent;\n  --f7-button-bg-color: transparent;\n  --f7-button-text-color: var(--f7-segmented-strong-button-active-text-color);\n  --f7-button-font-weight: var(--f7-segmented-strong-button-active-font-weight);\n}\n.segmented-strong .segmented-highlight,\n.ios .segmented-strong-ios .segmented-highlight,\n.md .segmented-strong-md .segmented-highlight,\n.aurora .segmented-strong-aurora .segmented-highlight {\n  --f7-segmented-highlight-num: 1;\n  --f7-segmented-highlight-active: 0;\n  --f7-segmented-highlight-padding: calc(var(--f7-segmented-strong-padding) * 2);\n  --f7-segmented-highlight-between: var(--f7-segmented-strong-between-buttons);\n  --f7-segmented-highlight-width: calc((100% - var(--f7-segmented-highlight-padding) - var(--f7-segmented-highlight-between) * (var(--f7-segmented-highlight-num) - 1)) / var(--f7-segmented-highlight-num));\n  position: absolute;\n  background-color: var(--f7-segmented-strong-button-active-bg-color);\n  border-radius: var(--f7-button-border-radius);\n  box-shadow: var(--f7-segmented-strong-button-active-box-shadow);\n  left: var(--f7-segmented-strong-padding);\n  top: var(--f7-segmented-strong-padding);\n  height: calc(100% - var(--f7-segmented-strong-padding) * 2);\n  width: var(--f7-segmented-highlight-width);\n  z-index: 0;\n  transform: translateX(calc(var(--f7-segmented-highlight-active) * 100% + var(--f7-segmented-highlight-active) * var(--f7-segmented-highlight-between)));\n  transition: 200ms;\n}\n.button:nth-child(2) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 2;\n}\n.button:nth-child(3) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 3;\n}\n.button:nth-child(4) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 4;\n}\n.button:nth-child(5) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 5;\n}\n.button:nth-child(6) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 6;\n}\n.button:nth-child(7) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 7;\n}\n.button:nth-child(8) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 8;\n}\n.button:nth-child(9) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 9;\n}\n.button:nth-child(10) ~ .segmented-highlight {\n  --f7-segmented-highlight-num: 10;\n}\n.button-active:nth-child(2) ~ .segmented-highlight,\n.tab-link-active:nth-child(2) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 1;\n}\n.button-active:nth-child(3) ~ .segmented-highlight,\n.tab-link-active:nth-child(3) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 2;\n}\n.button-active:nth-child(4) ~ .segmented-highlight,\n.tab-link-active:nth-child(4) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 3;\n}\n.button-active:nth-child(5) ~ .segmented-highlight,\n.tab-link-active:nth-child(5) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 4;\n}\n.button-active:nth-child(6) ~ .segmented-highlight,\n.tab-link-active:nth-child(6) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 5;\n}\n.button-active:nth-child(7) ~ .segmented-highlight,\n.tab-link-active:nth-child(7) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 6;\n}\n.button-active:nth-child(8) ~ .segmented-highlight,\n.tab-link-active:nth-child(8) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 7;\n}\n.button-active:nth-child(9) ~ .segmented-highlight,\n.tab-link-active:nth-child(9) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 8;\n}\n.button-active:nth-child(10) ~ .segmented-highlight,\n.tab-link-active:nth-child(10) ~ .segmented-highlight {\n  --f7-segmented-highlight-active: 9;\n}\n.segmented-round,\n.ios .segmented-round-ios,\n.md .segmented-round-md,\n.aurora .segmented-round-aurora {\n  border-radius: var(--f7-button-height);\n}\n.segmented-round .segmented-highlight,\n.ios .segmented-round-ios .segmented-highlight,\n.md .segmented-round-md .segmented-highlight,\n.aurora .segmented-round-aurora .segmented-highlight {\n  border-radius: var(--f7-button-height);\n}\n.subnavbar .segmented {\n  width: 100%;\n}\n.ios .button {\n  transition-duration: 100ms;\n}\n.ios .button-fill,\n.ios .button-fill-ios {\n  --f7-button-pressed-bg-color: var(--f7-button-fill-pressed-bg-color, var(--f7-theme-color-tint));\n}\n.ios .button-small,\n.ios .button-small-ios {\n  transition-duration: 200ms;\n}\n.md .button {\n  transition-duration: 300ms;\n  transform: translate3d(0, 0, 0);\n}\n.md .button-fill,\n.md .button-fill-md {\n  --f7-button-pressed-bg-color: var(--f7-button-fill-pressed-bg-color, var(--f7-theme-color-shade));\n}\n.aurora .button {\n  transition-duration: 100ms;\n  transform: translate3d(0, 0, 0);\n}\n.aurora.device-desktop .button:not(.active-state):not(.no-hover):hover {\n  background-color: var(--f7-button-hover-bg-color, rgba(var(--f7-theme-color-rgb), 0.07));\n}\n.aurora .button-fill,\n.aurora .button-fill-aurora {\n  --f7-button-pressed-bg-color: var(--f7-button-fill-pressed-bg-color, var(--f7-theme-color-shade));\n}\n.aurora .button-fill,\n.aurora .button-active,\n.aurora .button.tab-link-active,\n.aurora .button-fill-aurora {\n  --f7-button-hover-bg-color: var(--f7-button-fill-hover-bg-color, var(--f7-theme-color-tint));\n}\n/* === Touch Ripple === */\n:root {\n  --f7-touch-ripple-black: rgba(0, 0, 0, 0.1);\n  --f7-touch-ripple-white: rgba(255, 255, 255, 0.3);\n  --f7-touch-ripple-color: var(--f7-touch-ripple-black);\n}\n.theme-dark {\n  --f7-touch-ripple-color: var(--f7-touch-ripple-white);\n}\n.ripple,\n.fab a,\n.link,\n.item-link,\n.list-button,\n.button,\n.dialog-button,\n.tab-link,\n.radio,\n.checkbox,\n.actions-button,\n.speed-dial-buttons a {\n  -webkit-user-select: none;\n  -moz-user-select: none;\n       user-select: none;\n}\n.ripple-wave {\n  left: 0;\n  top: 0;\n  position: absolute !important;\n  border-radius: 50%;\n  pointer-events: none;\n  z-index: -1;\n  padding: 0;\n  margin: 0;\n  font-size: 0;\n  transform: translate3d(0px, 0px, 0) scale(0);\n  transition-duration: 1400ms;\n  background-color: var(--f7-touch-ripple-color);\n}\n.ripple-wave.ripple-wave-fill {\n  transition-duration: 300ms;\n  opacity: 0.35;\n}\n.ripple-wave.ripple-wave-out {\n  transition-duration: 600ms;\n  opacity: 0;\n}\n.button-fill .ripple-wave,\n.picker-calendar-day .ripple-wave,\n.menu .ripple-wave {\n  z-index: 1;\n}\n.checkbox .ripple-wave,\n.radio .ripple-wave,\n.data-table .sortable-cell .ripple-wave {\n  z-index: 0;\n}\n[class*=\"ripple-color-\"] {\n  --f7-touch-ripple-color: var(--f7-theme-color-ripple-color);\n}\n/* === Icon === */\n.f7-icons,\n.material-icons {\n  width: 1em;\n  height: 1em;\n}\ni.icon {\n  display: inline-block;\n  vertical-align: middle;\n  background-size: 100% auto;\n  background-position: center;\n  background-repeat: no-repeat;\n  font-style: normal;\n  position: relative;\n}\n.icon-back:after,\n.icon-prev:after,\n.icon-forward:after,\n.icon-next:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n}\n.icon[class*=\"color-\"] {\n  color: var(--f7-theme-color);\n}\n.ios .icon-back,\n.ios .icon-prev,\n.ios .icon-forward,\n.ios .icon-next {\n  width: 12px;\n  height: 20px;\n  line-height: 20px;\n}\n.ios .icon-back:after,\n.ios .icon-prev:after,\n.ios .icon-forward:after,\n.ios .icon-next:after {\n  line-height: inherit;\n}\n.ios .icon-prev:after,\n.ios .icon-next:after {\n  font-size: 16px;\n}\n.ios .icon-back:after,\n.ios .icon-prev:after {\n  content: 'chevron_left_ios';\n}\n.ios .icon-forward:after,\n.ios .icon-next:after {\n  content: 'chevron_right_ios';\n}\n.md .icon-back,\n.md .icon-forward,\n.md .icon-next,\n.md .icon-prev {\n  width: 24px;\n  height: 24px;\n}\n.md .icon-back:after,\n.md .icon-forward:after,\n.md .icon-next:after,\n.md .icon-prev:after {\n  line-height: 1.2;\n}\n.md .icon-back:after {\n  content: 'arrow_left_md';\n}\n.md .icon-forward:after {\n  content: 'arrow_right_md';\n}\n.md .icon-next:after {\n  content: 'chevron_right_md';\n}\n.md .icon-prev:after {\n  content: 'chevron_left_md';\n}\n.aurora .f7-icons,\n.aurora .material-icons {\n  font-size: 18px;\n}\n.aurora .icon-back,\n.aurora .icon-prev,\n.aurora .icon-forward,\n.aurora .icon-next {\n  width: 9px;\n  height: 14px;\n  line-height: 14px;\n}\n.aurora .icon-back:after,\n.aurora .icon-prev:after,\n.aurora .icon-forward:after,\n.aurora .icon-next:after {\n  line-height: inherit;\n}\n.aurora .icon-back:after,\n.aurora .icon-prev:after {\n  content: 'chevron_left_aurora';\n}\n.aurora .icon-forward:after,\n.aurora .icon-next:after {\n  content: 'chevron_right_aurora';\n}\n.custom-modal-backdrop {\n  z-index: 10500;\n}\n.custom-modal-backdrop,\n.actions-backdrop,\n.dialog-backdrop,\n.popover-backdrop,\n.popup-backdrop,\n.preloader-backdrop,\n.sheet-backdrop,\n.fab-backdrop {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(0, 0, 0, 0.4);\n  z-index: 13000;\n  visibility: hidden;\n  opacity: 0;\n  transition-duration: 400ms;\n}\n.custom-modal-backdrop.not-animated,\n.actions-backdrop.not-animated,\n.dialog-backdrop.not-animated,\n.popover-backdrop.not-animated,\n.popup-backdrop.not-animated,\n.preloader-backdrop.not-animated,\n.sheet-backdrop.not-animated,\n.fab-backdrop.not-animated {\n  transition-duration: 0ms;\n}\n.custom-modal-backdrop.backdrop-in,\n.actions-backdrop.backdrop-in,\n.dialog-backdrop.backdrop-in,\n.popover-backdrop.backdrop-in,\n.popup-backdrop.backdrop-in,\n.preloader-backdrop.backdrop-in,\n.sheet-backdrop.backdrop-in,\n.fab-backdrop.backdrop-in {\n  visibility: visible;\n  opacity: 1;\n}\n/* === Appbar === */\n:root {\n  /*\n  --f7-appbar-offset: var(--f7-appbar-height);\n  --f7-appbar-extra-offset: 0px;\n  --f7-appbar-bg-color: var(--f7-bars-bg-color);\n  --f7-appbar-bg-color-rgb: var(--f7-bars-bg-color-rgb);\n  --f7-appbar-bg-image: var(--f7-bars-bg-image);\n  --f7-appbar-border-color: var(--f7-bars-border-color);\n  --f7-appbar-link-color: var(--f7-bars-link-color);\n  --f7-appbar-text-color: var(--f7-bars-text-color);\n  */\n  --f7-appbar-shadow-image: none;\n}\n.ios {\n  --f7-appbar-height: 44px;\n  --f7-appbar-inner-padding-left: 8px;\n  --f7-appbar-inner-padding-right: 8px;\n}\n.md {\n  --f7-appbar-height: 48px;\n  --f7-appbar-inner-padding-left: 16px;\n  --f7-appbar-inner-padding-right: 16px;\n}\n.aurora {\n  --f7-appbar-height: 38px;\n  --f7-appbar-inner-padding-left: 16px;\n  --f7-appbar-inner-padding-right: 16px;\n}\n.appbar {\n  position: relative;\n  left: 0;\n  top: 0;\n  width: 100%;\n  z-index: 500;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  box-sizing: border-box;\n  margin: 0;\n  transform: translate3d(0, 0, 0);\n  height: calc(var(--f7-appbar-height) + var(--f7-safe-area-top));\n  background-image: var(--f7-appbar-bg-image, var(--f7-bars-bg-image));\n  background-color: var(--f7-appbar-bg-color, var(--f7-bars-bg-color));\n  color: var(--f7-appbar-text-color, var(--f7-bars-text-color));\n  font-size: var(--f7-appbar-font-size);\n  z-index: 7000;\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-bars .appbar {\n    background-color: rgba(var(--f7-appbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)), var(--f7-bars-translucent-opacity));\n    -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n            backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n  }\n}\n.appbar .panel ~ .appbar {\n  z-index: 5500;\n}\n.appbar a {\n  color: var(--f7-appbar-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n}\n.appbar a.link {\n  display: flex;\n  justify-content: flex-start;\n  line-height: var(--f7-appbar-link-line-height, var(--f7-appbar-height));\n  height: var(--f7-appbar-link-height, var(--f7-appbar-height));\n}\n.appbar .left,\n.appbar .center,\n.appbar .right {\n  display: flex;\n  align-items: center;\n}\n.appbar.no-hairline:after,\n.appbar.no-border:after {\n  display: none !important;\n}\n.appbar.no-hairline .title-large:after,\n.appbar.no-border .title-large:after {\n  display: none !important;\n}\n.appbar.no-shadow:before {\n  display: none !important;\n}\n.appbar:after,\n.appbar:before {\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.appbar:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-appbar-border-color, var(--f7-bars-border-color));\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.appbar:before {\n  content: '';\n  position: absolute;\n  right: 0;\n  width: 100%;\n  top: 100%;\n  bottom: auto;\n  height: 8px;\n  pointer-events: none;\n  background: var(--f7-appbar-shadow-image);\n}\n.appbar:after {\n  z-index: 1;\n}\n.appbar ~ * {\n  --f7-appbar-app-offset: calc(var(--f7-appbar-height) + var(--f7-appbar-extra-offset, 0px) + var(--f7-safe-area-top));\n}\n.appbar ~ .views,\n.appbar ~ .view,\n.appbar ~ .appbar {\n  --f7-safe-area-top: 0px;\n}\n.appbar ~ .panel .view,\n.appbar ~ .panel .page,\n.appbar ~ .panel .page-content {\n  --f7-safe-area-top: 0px;\n}\n.appbar-inner {\n  position: absolute;\n  left: 0;\n  top: var(--f7-safe-area-top);\n  width: 100%;\n  height: var(--f7-appbar-height);\n  display: flex;\n  align-items: center;\n  justify-content: space-between;\n  box-sizing: border-box;\n  padding: 0 calc(var(--f7-appbar-inner-padding-right) + var(--f7-safe-area-right)) 0 calc(var(--f7-appbar-inner-padding-left) + var(--f7-safe-area-left));\n}\n.appbar-inner.stacked {\n  display: none;\n}\n/* === Dialog === */\n:root {\n  --f7-dialog-button-text-color: var(--f7-theme-color);\n  --f7-dialog-button-text-align: center;\n  --f7-dialog-input-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-dialog-text-color: #fff;\n}\n.ios {\n  --f7-dialog-box-shadow: none;\n  --f7-dialog-width: 270px;\n  --f7-dialog-inner-padding: 16px;\n  --f7-dialog-border-radius: 13px;\n  --f7-dialog-text-align: center;\n  --f7-dialog-font-size: 14px;\n  --f7-dialog-title-text-color: inherit;\n  --f7-dialog-title-font-size: 18px;\n  --f7-dialog-title-font-weight: 600;\n  --f7-dialog-title-line-height: inherit;\n  --f7-dialog-button-font-size: 17px;\n  --f7-dialog-button-height: 44px;\n  --f7-dialog-button-letter-spacing: 0;\n  --f7-dialog-button-font-weight: 400;\n  --f7-dialog-button-text-transform: none;\n  --f7-dialog-input-border-radius: 4px;\n  --f7-dialog-input-font-size: 14px;\n  --f7-dialog-input-height: 32px;\n  --f7-dialog-input-border-width: 1px;\n  --f7-dialog-input-placeholder-color: #a9a9a9;\n  --f7-dialog-preloader-size: 34px;\n  --f7-dialog-bg-color: rgba(255, 255, 255, 0.95);\n  --f7-dialog-bg-color-rgb: 255, 255, 255;\n  --f7-dialog-text-color: #000;\n  --f7-dialog-button-pressed-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-dialog-input-border-color: rgba(0, 0, 0, 0.3);\n  --f7-dialog-border-divider-color: rgba(0, 0, 0, 0.2);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-dialog-bg-color: rgba(45, 45, 45, 0.95);\n  --f7-dialog-bg-color-rgb: 45, 45, 45;\n  --f7-dialog-button-pressed-bg-color: rgba(0, 0, 0, 0.2);\n  --f7-dialog-border-divider-color: rgba(255, 255, 255, 0.15);\n  --f7-dialog-input-border-color: rgba(255, 255, 255, 0.15);\n  --f7-dialog-input-bg-color: rgba(0, 0, 0, 0.5);\n}\n.md {\n  --f7-dialog-box-shadow: var(--f7-elevation-24);\n  --f7-dialog-width: 280px;\n  --f7-dialog-inner-padding: 24px;\n  --f7-dialog-border-radius: 4px;\n  --f7-dialog-text-align: left;\n  --f7-dialog-font-size: 16px;\n  --f7-dialog-title-font-size: 20px;\n  --f7-dialog-title-font-weight: 500;\n  --f7-dialog-title-line-height: 1.3;\n  --f7-dialog-button-font-size: 14px;\n  --f7-dialog-button-height: 36px;\n  --f7-dialog-button-letter-spacing: 0.03em;\n  --f7-dialog-button-font-weight: 500;\n  --f7-dialog-button-text-transform: uppercase;\n  --f7-dialog-input-border-radius: 0px;\n  --f7-dialog-input-font-size: 16px;\n  --f7-dialog-input-height: 36px;\n  --f7-dialog-input-border-color: transparent;\n  --f7-dialog-input-border-width: 0px;\n  --f7-dialog-preloader-size: 32px;\n  --f7-dialog-bg-color: #fff;\n  --f7-dialog-text-color: rgba(0, 0, 0, 0.54);\n  --f7-dialog-title-text-color: #212121;\n  --f7-dialog-button-pressed-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-dialog-input-placeholder-color: rgba(0, 0, 0, 0.35);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-dialog-bg-color: #1c1c1d;\n  --f7-dialog-title-text-color: #fff;\n  --f7-dialog-button-pressed-bg-color: rgba(255, 255, 255, 0.1);\n  --f7-dialog-input-bg-color: transparent;\n  --f7-dialog-input-placeholder-color: rgba(255, 255, 255, 0.54);\n}\n.aurora {\n  --f7-dialog-box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.15), 0 25px 30px 0 rgba(0,0,0,0.35);\n  --f7-dialog-width: 300px;\n  --f7-dialog-inner-padding: 20px;\n  --f7-dialog-border-radius: 4px;\n  --f7-dialog-text-align: left;\n  --f7-dialog-font-size: 14px;\n  --f7-dialog-title-font-size: 14px;\n  --f7-dialog-title-font-weight: 700;\n  --f7-dialog-title-line-height: inherit;\n  --f7-dialog-button-font-size: 13px;\n  --f7-dialog-button-height: 28px;\n  --f7-dialog-button-letter-spacing: 0;\n  --f7-dialog-button-font-weight: 500;\n  --f7-dialog-button-text-transform: none;\n  /*\n  --f7-dialog-button-pressed-bg-color: var(--f7-theme-color-shade);\n  --f7-dialog-button-hover-bg-color: var(--f7-theme-color-tint);\n  */\n  --f7-dialog-input-border-radius: 4px;\n  --f7-dialog-input-font-size: 13px;\n  --f7-dialog-input-height: 24px;\n  --f7-dialog-input-border-width: 1px;\n  --f7-dialog-preloader-size: 24px;\n  --f7-dialog-bg-color: #fff;\n  --f7-dialog-title-text-color: inherit;\n  --f7-dialog-text-color: #000;\n  --f7-dialog-button-text-color: #fff;\n  --f7-dialog-input-border-color: rgba(0, 0, 0, 0.12);\n  --f7-dialog-input-placeholder-color: rgba(0, 0, 0, 0.32);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-dialog-bg-color: #1c1c1d;\n  --f7-dialog-title-text-color: #fff;\n  --f7-dialog-input-bg-color: rgba(0, 0, 0, 0.25);\n  --f7-dialog-input-placeholder-color: rgba(255, 255, 255, 0.54);\n  --f7-dialog-input-border-color: rgba(255, 255, 255, 0.15);\n}\n.dialog {\n  position: absolute;\n  z-index: 13500;\n  left: 50%;\n  margin-top: 0;\n  top: 50%;\n  overflow: hidden;\n  opacity: 0;\n  transform: translate3d(0, -50%, 0) scale(1.185);\n  transition-property: transform, opacity;\n  display: none;\n  transition-duration: 400ms;\n  box-shadow: var(--f7-dialog-box-shadow);\n  width: var(--f7-dialog-width);\n  margin-left: calc(-1 * var(--f7-dialog-width) / 2);\n  border-radius: var(--f7-dialog-border-radius);\n  text-align: var(--f7-dialog-text-align);\n  color: var(--f7-dialog-text-color);\n  font-size: var(--f7-dialog-font-size);\n  background: var(--f7-dialog-bg-color);\n  will-change: transform, opacity;\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-modals .dialog {\n    background-color: rgba(var(--f7-dialog-bg-color-rgb), 0.8);\n    -webkit-backdrop-filter: saturate(180%) blur(20px);\n            backdrop-filter: saturate(180%) blur(20px);\n  }\n}\n.dialog.modal-in {\n  opacity: 1;\n  transform: translate3d(0, -50%, 0) scale(1);\n}\n.dialog.modal-out {\n  opacity: 0;\n  z-index: 13499;\n}\n.dialog.not-animated {\n  transition-duration: 0ms;\n}\n.dialog-inner {\n  position: relative;\n  padding: var(--f7-dialog-inner-padding);\n}\n.dialog-title {\n  color: var(--f7-dialog-title-text-color);\n  font-size: var(--f7-dialog-title-font-size);\n  font-weight: var(--f7-dialog-title-font-weight);\n  line-height: var(--f7-dialog-title-line-height);\n}\n.dialog-buttons {\n  position: relative;\n  display: flex;\n}\n.dialog-buttons-vertical .dialog-buttons {\n  display: block;\n  height: auto !important;\n}\n.dialog-button {\n  box-sizing: border-box;\n  overflow: hidden;\n  position: relative;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  color: var(--f7-dialog-button-text-color);\n  font-size: var(--f7-dialog-button-font-size);\n  height: var(--f7-dialog-button-height);\n  line-height: var(--f7-dialog-button-height);\n  letter-spacing: var(--f7-dialog-button-letter-spacing);\n  text-align: var(--f7-dialog-button-text-align);\n  font-weight: var(--f7-dialog-button-font-weight);\n  text-transform: var(--f7-dialog-button-text-transform);\n  display: block;\n  cursor: pointer;\n}\n.dialog-button.active-state {\n  background-color: var(--f7-dialog-button-pressed-bg-color);\n}\n.dialog-no-buttons .dialog-buttons {\n  display: none;\n}\n.dialog-input-field {\n  position: relative;\n}\ninput.dialog-input[type] {\n  box-sizing: border-box;\n  margin: 0;\n  margin-top: 15px;\n  border-radius: var(--f7-dialog-input-border-radius);\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  width: 100%;\n  display: block;\n  font-family: inherit;\n  box-shadow: none;\n  font-size: var(--f7-dialog-input-font-size);\n  height: var(--f7-dialog-input-height);\n  background-color: var(--f7-dialog-input-bg-color);\n  border: var(--f7-dialog-input-border-width) solid var(--f7-dialog-input-border-color);\n}\ninput.dialog-input[type]::-webkit-input-placeholder {\n  color: var(--f7-dialog-input-placeholder-color);\n}\ninput.dialog-input[type]::placeholder {\n  color: var(--f7-dialog-input-placeholder-color);\n}\n.dialog-input-double input.dialog-input {\n  border-radius: var(--f7-dialog-input-border-radius) var(--f7-dialog-input-border-radius) 0 0;\n}\n.dialog-input-double + .dialog-input-double input.dialog-input {\n  border-radius: 0 0 var(--f7-dialog-input-border-radius) var(--f7-dialog-input-border-radius);\n}\n.dialog-preloader .preloader {\n  --f7-preloader-size: var(--f7-dialog-preloader-size);\n}\nhtml.with-modal-dialog .page-content {\n  overflow: hidden;\n  -webkit-overflow-scrolling: auto;\n}\n.ios .dialog.modal-out {\n  transform: translate3d(0, -50%, 0) scale(1);\n}\n.ios .dialog-inner {\n  border-radius: var(--f7-dialog-border-radius) var(--f7-dialog-border-radius) 0 0;\n}\n.ios .dialog-inner:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-dialog-border-divider-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.ios .dialog-title + .dialog-text {\n  margin-top: 5px;\n}\n.ios .dialog-buttons {\n  height: 44px;\n  justify-content: center;\n}\n.ios .dialog-button {\n  width: 100%;\n  padding: 0 5px;\n  -webkit-box-flex: 1;\n  -ms-flex: 1;\n}\n.ios .dialog-button:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-dialog-border-divider-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: 0;\n  bottom: auto;\n  left: auto;\n  width: 1px;\n  height: 100%;\n  transform-origin: 100% 50%;\n  transform: scaleX(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.ios .dialog-button:first-child {\n  border-radius: 0 0 0 var(--f7-dialog-border-radius);\n}\n.ios .dialog-button:last-child {\n  border-radius: 0 0 var(--f7-dialog-border-radius) 0;\n}\n.ios .dialog-button:last-child:after {\n  display: none !important;\n}\n.ios .dialog-button:first-child:last-child {\n  border-radius: 0 0 var(--f7-dialog-border-radius) var(--f7-dialog-border-radius);\n}\n.ios .dialog-button.dialog-button-bold {\n  font-weight: 500;\n}\n.ios .dialog-button[class*=\"color-\"] {\n  --f7-dialog-button-text-color: var(--f7-theme-color);\n}\n.ios .dialog-buttons-vertical .dialog-buttons {\n  height: auto;\n}\n.ios .dialog-buttons-vertical .dialog-button {\n  border-radius: 0;\n}\n.ios .dialog-buttons-vertical .dialog-button:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-dialog-border-divider-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.ios .dialog-buttons-vertical .dialog-button:last-child {\n  border-radius: 0 0 var(--f7-dialog-border-radius) var(--f7-dialog-border-radius);\n}\n.ios .dialog-buttons-vertical .dialog-button:last-child:after {\n  display: none !important;\n}\n.ios .dialog-no-buttons .dialog-inner {\n  border-radius: var(--f7-dialog-border-radius);\n}\n.ios .dialog-no-buttons .dialog-inner:after {\n  display: none !important;\n}\n.ios .dialog-input-field {\n  margin-top: 15px;\n}\n.ios .dialog-input {\n  padding: 0 5px;\n}\n.ios .dialog-input + .dialog-input {\n  margin-top: 5px;\n}\n.ios .dialog-input-double + .dialog-input-double {\n  margin-top: 0;\n}\n.ios .dialog-input-double + .dialog-input-double .dialog-input {\n  border-top: 0;\n  margin-top: 0;\n}\n.ios .dialog-preloader .dialog-title ~ .preloader,\n.ios .dialog-preloader .dialog-text ~ .preloader {\n  margin-top: 15px;\n}\n.ios .dialog-progress .dialog-title ~ .progressbar,\n.ios .dialog-progress .dialog-text ~ .progressbar,\n.ios .dialog-progress .dialog-title ~ .progressbar-infinite,\n.ios .dialog-progress .dialog-text ~ .progressbar-infinite {\n  margin-top: 15px;\n}\n.md .dialog.modal-out {\n  transform: translate3d(0, -50%, 0) scale(0.815);\n}\n.md .dialog-title + .dialog-text {\n  margin-top: 20px;\n}\n.md .dialog-text {\n  line-height: 1.5;\n}\n.md .dialog-buttons {\n  height: 48px;\n  padding: 6px 8px;\n  overflow: hidden;\n  box-sizing: border-box;\n  justify-content: flex-end;\n}\n.md .dialog-button {\n  border-radius: 4px;\n  min-width: 64px;\n  padding: 0 8px;\n  border: none;\n  transition-duration: 300ms;\n  transform: translate3d(0, 0, 0);\n}\n.md .dialog-button.dialog-button-bold {\n  font-weight: 700;\n}\n.md .dialog-button + .dialog-button {\n  margin-left: 4px;\n}\n.md .dialog-button[class*=\"color-\"] {\n  --f7-dialog-button-text-color: var(--f7-theme-color);\n}\n.md .dialog-buttons-vertical .dialog-buttons {\n  padding: 0 0 8px 0;\n}\n.md .dialog-buttons-vertical .dialog-button {\n  margin-left: 0;\n  text-align: right;\n  height: 48px;\n  line-height: 48px;\n  border-radius: 0;\n  padding-left: 16px;\n  padding-right: 16px;\n}\n.md .dialog-input {\n  padding: 0;\n  transition-duration: 200ms;\n  position: relative;\n}\n.md .dialog-input + .dialog-input {\n  margin-top: 16px;\n}\n.md .dialog-preloader .dialog-title,\n.md .dialog-progress .dialog-title,\n.md .dialog-preloader .dialog-inner,\n.md .dialog-progress .dialog-inner {\n  text-align: center;\n}\n.md .dialog-preloader .dialog-title ~ .preloader,\n.md .dialog-preloader .dialog-text ~ .preloader {\n  margin-top: 20px;\n}\n.md .dialog-progress .dialog-title ~ .progressbar,\n.md .dialog-progress .dialog-text ~ .progressbar,\n.md .dialog-progress .dialog-title ~ .progressbar-infinite,\n.md .dialog-progress .dialog-text ~ .progressbar-infinite {\n  margin-top: 16px;\n}\n.aurora .dialog.modal-out {\n  transform: translate3d(0, -50%, 0) scale(0.815);\n}\n.aurora .dialog-title + .dialog-text {\n  margin-top: 10px;\n}\n.aurora .dialog-text {\n  line-height: 1.5;\n}\n.aurora .dialog-buttons {\n  padding: var(--f7-dialog-inner-padding);\n  padding-top: 0;\n  overflow: hidden;\n  box-sizing: border-box;\n  justify-content: flex-end;\n}\n.aurora .dialog-button {\n  border-radius: 4px;\n  min-width: 64px;\n  padding: 0 10px;\n  border: none;\n  transition-duration: 300ms;\n  transform: translate3d(0, 0, 0);\n  background: var(--f7-theme-color);\n}\n.aurora .dialog-button.dialog-button-bold {\n  font-weight: 600;\n}\n.aurora .dialog-button + .dialog-button {\n  margin-left: 16px;\n}\n.aurora .dialog-button.active-state {\n  background-color: var(--f7-dialog-button-pressed-bg-color, var(--f7-theme-color-shade));\n}\n.aurora.device-desktop .dialog-button:not(.active-state):not(.no-hover):hover {\n  background-color: var(--f7-dialog-button-hover-bg-color, var(--f7-theme-color-tint));\n}\n.aurora .dialog-buttons-vertical .dialog-buttons {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-end;\n}\n.aurora .dialog-buttons-vertical .dialog-button {\n  margin-left: 0;\n  flex-shrink: 0;\n}\n.aurora .dialog-buttons-vertical .dialog-button + .dialog-button {\n  margin-top: 5px;\n}\n.aurora .dialog-input-field {\n  margin-top: 10px;\n}\n.aurora .dialog-input-field input.dialog-input {\n  margin-top: 0;\n}\n.aurora .dialog-input {\n  padding: 0 4px;\n  transition-duration: 200ms;\n  position: relative;\n}\n.aurora .dialog-input + .dialog-input {\n  margin-top: 10px;\n}\n.aurora .dialog-input-double + .dialog-input-double {\n  margin-top: 0;\n}\n.aurora .dialog-input-double + .dialog-input-double .dialog-input {\n  border-top: 0;\n  margin-top: 0;\n}\n.aurora .dialog-preloader .dialog-title,\n.aurora .dialog-progress .dialog-title,\n.aurora .dialog-preloader .dialog-inner,\n.aurora .dialog-progress .dialog-inner {\n  text-align: center;\n}\n.aurora .dialog-preloader .dialog-title ~ .preloader,\n.aurora .dialog-preloader .dialog-text ~ .preloader {\n  margin-top: 10px;\n}\n.aurora .dialog-progress .dialog-title ~ .progressbar,\n.aurora .dialog-progress .dialog-text ~ .progressbar,\n.aurora .dialog-progress .dialog-title ~ .progressbar-infinite,\n.aurora .dialog-progress .dialog-text ~ .progressbar-infinite {\n  margin-top: 15px;\n}\n/* === Popup === */\n:root {\n  --f7-popup-border-radius: 0px;\n  --f7-popup-tablet-width: 630px;\n  --f7-popup-tablet-height: 630px;\n  --f7-popup-transition-duration: 400ms;\n  --f7-popup-push-border-radius: 10px;\n  --f7-popup-push-offset: var(--f7-safe-area-top);\n  /*\n  --f7-popup-tablet-border-radius: var(--f7-popup-border-radius);\n  */\n}\n.ios {\n  --f7-popup-tablet-border-radius: 5px;\n  --f7-popup-box-shadow: none;\n}\n.md {\n  --f7-popup-tablet-border-radius: 4px;\n  --f7-popup-box-shadow: 0px 20px 44px rgba(0, 0, 0, 0.5);\n}\n.aurora {\n  --f7-popup-tablet-border-radius: 4px;\n  --f7-popup-box-shadow: 0px 20px 44px rgba(0, 0, 0, 0.5);\n}\n.popup-backdrop {\n  z-index: 10500;\n}\n.popup {\n  position: absolute;\n  left: 0;\n  top: 0px;\n  width: 100%;\n  height: 100%;\n  display: none;\n  box-sizing: border-box;\n  transition-property: transform;\n  transform: translate3d(0, 100%, 0);\n  background: #fff;\n  z-index: 11000;\n  overflow: hidden;\n  border-radius: var(--f7-popup-border-radius);\n}\n.theme-dark .popup,\n.popup.theme-dark {\n  background: #000;\n}\n.popup.modal-in,\n.popup.modal-out {\n  transition-duration: var(--f7-popup-transition-duration);\n}\n.popup.not-animated {\n  transition-duration: 0ms;\n}\n.popup.modal-in {\n  display: block;\n  transform: translate3d(0, 0, 0);\n}\n.popup.modal-out {\n  transform: translate3d(0, 100%, 0);\n}\n.popup.swipe-close-to-top.modal-out {\n  transform: translate3d(0, -100%, 0);\n}\n@media (min-width: 630px) and (min-height: 630px) {\n  .popup:not(.popup-tablet-fullscreen) {\n    --f7-safe-area-top: 0px;\n    --f7-safe-area-bottom: 0px;\n    width: var(--f7-popup-tablet-width);\n    height: var(--f7-popup-tablet-height);\n    left: 50%;\n    top: 50%;\n    margin-left: calc(-1 * var(--f7-popup-tablet-width) / 2);\n    margin-top: calc(-1 * var(--f7-popup-tablet-height) / 2);\n    transform: translate3d(0, 100vh, 0);\n    box-shadow: var(--f7-popup-box-shadow);\n    border-radius: var(--f7-popup-tablet-border-radius, var(--f7-popup-border-radius));\n  }\n  .popup:not(.popup-tablet-fullscreen).modal-in {\n    transform: translate3d(0, 0, 0);\n  }\n  .popup:not(.popup-tablet-fullscreen).modal-out {\n    transform: translate3d(0, 100vh, 0);\n  }\n  .popup:not(.popup-tablet-fullscreen).swipe-close-to-top.modal-out {\n    transform: translate3d(0, -100vh, 0);\n  }\n  .popup:not(.popup-tablet-fullscreen).popup-behind {\n    transform: translate3d(0, 0, 0) scale(0.9);\n  }\n}\nhtml.with-modal-popup .framework7-root > .views .page-content,\nhtml.with-modal-popup .framework7-root > .view .page-content,\nhtml.with-modal-popup .framework7-root > .panel .page-content {\n  overflow: hidden;\n  -webkit-overflow-scrolling: auto;\n}\nhtml.with-modal-popup-push .popup-push,\nhtml.with-modal-popup-push-closing .popup-push {\n  top: calc(var(--f7-popup-push-offset) + 10px);\n  height: calc(100% - var(--f7-popup-push-offset) - 10px);\n  border-radius: var(--f7-popup-push-border-radius) var(--f7-popup-push-border-radius) 0 0;\n  --f7-safe-area-top: 0px;\n}\nhtml.with-modal-popup-push .popup-push .view,\nhtml.with-modal-popup-push-closing .popup-push .view,\nhtml.with-modal-popup-push .popup-push .page,\nhtml.with-modal-popup-push-closing .popup-push .page {\n  --f7-safe-area-top: 0px;\n}\nhtml.with-modal-popup-push .framework7-root,\nhtml.with-modal-popup-push-closing .framework7-root {\n  background: #000;\n}\nhtml.with-modal-popup-push .framework7-root > .views,\nhtml.with-modal-popup-push-closing .framework7-root > .views,\nhtml.with-modal-popup-push .framework7-root > .view,\nhtml.with-modal-popup-push-closing .framework7-root > .view {\n  transition-duration: var(--f7-popup-transition-duration);\n}\nhtml.with-modal-popup-push.theme-dark .framework7-root > .views:after,\nhtml.with-modal-popup-push-closing.theme-dark .framework7-root > .views:after,\nhtml.with-modal-popup-push.theme-dark .framework7-root > .view:after,\nhtml.with-modal-popup-push-closing.theme-dark .framework7-root > .view:after,\nhtml.with-modal-popup-push .theme-dark .framework7-root > .views:after,\nhtml.with-modal-popup-push-closing .theme-dark .framework7-root > .views:after,\nhtml.with-modal-popup-push .theme-dark .framework7-root > .view:after,\nhtml.with-modal-popup-push-closing .theme-dark .framework7-root > .view:after,\nhtml.with-modal-popup-push .theme-dark.framework7-root > .views:after,\nhtml.with-modal-popup-push-closing .theme-dark.framework7-root > .views:after,\nhtml.with-modal-popup-push .theme-dark.framework7-root > .view:after,\nhtml.with-modal-popup-push-closing .theme-dark.framework7-root > .view:after,\nhtml.with-modal-popup-push .framework7-root > .views.theme-dark:after,\nhtml.with-modal-popup-push-closing .framework7-root > .views.theme-dark:after,\nhtml.with-modal-popup-push .framework7-root > .view.theme-dark:after,\nhtml.with-modal-popup-push-closing .framework7-root > .view.theme-dark:after {\n  content: '';\n  position: absolute;\n  pointer-events: none;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(255, 255, 255, 0.1);\n  z-index: 13000;\n  border-radius: var(--f7-popup-push-border-radius) var(--f7-popup-push-border-radius) 0 0;\n  opacity: 1;\n  animation: popup-dark-push-overlay-fade-in var(--f7-popup-transition-duration) forwards;\n}\nhtml.with-modal-popup-push .framework7-root > .views,\nhtml.with-modal-popup-push .framework7-root > .view {\n  border-radius: var(--f7-popup-push-border-radius) var(--f7-popup-push-border-radius) 0 0;\n  transform: translate3d(0, 0, 0px) scale(var(--f7-popup-push-scale, 1));\n}\nhtml.with-modal-popup-push .popup:after {\n  content: '';\n  pointer-events: none;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(0, 0, 0, 0.4);\n  z-index: 13000;\n  transition-duration: var(--f7-popup-transition-duration);\n  border-radius: var(--f7-popup-push-border-radius) var(--f7-popup-push-border-radius) 0 0;\n  opacity: 0;\n}\nhtml.with-modal-popup-push.theme-dark .popup:after,\nhtml.with-modal-popup-push .theme-dark .popup:after,\nhtml.with-modal-popup-push .theme-dark.popup:after {\n  background: rgba(255, 255, 255, 0.05);\n}\nhtml.with-modal-popup-push .popup-behind {\n  transform: translate3d(0, 0px, 0px) scale(var(--f7-popup-push-scale, 1));\n}\nhtml.with-modal-popup-push .popup-behind:not(.popup-push) {\n  border-radius: var(--f7-popup-push-border-radius) var(--f7-popup-push-border-radius) 0 0;\n}\nhtml.with-modal-popup-push .popup-behind.popup-push {\n  transform: translate3d(0, calc(0px - var(--f7-popup-push-offset) - 10px), 0px) scale(var(--f7-popup-push-scale, 1));\n}\nhtml.with-modal-popup-push .popup-behind:after {\n  opacity: 1;\n  pointer-events: auto;\n}\nhtml.with-modal-popup-push-closing.theme-dark .framework7-root > .views:after,\nhtml.with-modal-popup-push-closing.theme-dark .framework7-root > .view:after,\nhtml.with-modal-popup-push-closing .theme-dark .framework7-root > .views:after,\nhtml.with-modal-popup-push-closing .theme-dark .framework7-root > .view:after,\nhtml.with-modal-popup-push-closing .theme-dark.framework7-root > .views:after,\nhtml.with-modal-popup-push-closing .theme-dark.framework7-root > .view:after,\nhtml.with-modal-popup-push-closing .framework7-root > .views.theme-dark:after,\nhtml.with-modal-popup-push-closing .framework7-root > .view.theme-dark:after {\n  animation: popup-dark-push-overlay-fade-out var(--f7-popup-transition-duration) forwards;\n}\n@keyframes popup-dark-push-overlay-fade-in {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes popup-dark-push-overlay-fade-out {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n/* === Login Screen === */\n:root {\n  --f7-login-screen-blocks-max-width: 480px;\n  /*\n   --f7-login-screen-list-button-text-color: var(--f7-theme-color);\n   */\n  --f7-login-screen-title-text-align: center;\n  --f7-login-screen-title-text-color: inherit;\n  --f7-login-screen-title-letter-spacing: 0;\n  --f7-login-screen-title-font-weight: 600;\n  --f7-login-screen-title-font-size: 28px;\n  --f7-login-screen-content-bg-color: #fff;\n  --f7-login-screen-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-login-screen-bg-color: #121212;\n  --f7-login-screen-content-bg-color: #121212;\n}\n.ios {\n  --f7-login-screen-blocks-margin-vertical: 25px;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-login-screen-bg-color: #000;\n  --f7-login-screen-content-bg-color: #000;\n}\n.md {\n  --f7-login-screen-blocks-margin-vertical: 24px;\n}\n.aurora {\n  --f7-login-screen-blocks-margin-vertical: 15px;\n}\n.login-screen {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  display: none;\n  box-sizing: border-box;\n  transition-property: transform;\n  transform: translate3d(0, 100%, 0);\n  background: var(--f7-login-screen-bg-color);\n  z-index: 11000;\n}\n.login-screen.modal-in,\n.login-screen.modal-out {\n  transition-duration: 400ms;\n}\n.login-screen.not-animated {\n  transition-duration: 0ms;\n}\n.login-screen.modal-in {\n  display: block;\n  transform: translate3d(0, 0, 0);\n}\n.login-screen.modal-out {\n  transform: translate3d(0, 100%, 0);\n}\n.login-screen-content,\n.login-screen-page,\n.login-screen .page {\n  background: var(--f7-login-screen-content-bg-color);\n}\n.login-screen-content .list-button,\n.login-screen-page .list-button {\n  text-align: center;\n  color: var(--f7-login-screen-list-button-text-color, var(--f7-theme-color));\n}\n.login-screen-content .login-screen-title,\n.login-screen-page .login-screen-title,\n.login-screen-content .list,\n.login-screen-page .list,\n.login-screen-content .block,\n.login-screen-page .block {\n  margin: var(--f7-login-screen-blocks-margin-vertical) auto;\n}\n.login-screen-content .login-screen-title,\n.login-screen-page .login-screen-title,\n.login-screen-content .list,\n.login-screen-page .list,\n.login-screen-content .block,\n.login-screen-page .block,\n.login-screen-content .block-footer,\n.login-screen-page .block-footer,\n.login-screen-content .block-header,\n.login-screen-page .block-header {\n  max-width: var(--f7-login-screen-blocks-max-width);\n}\n.login-screen-content .list ul,\n.login-screen-page .list ul {\n  background: none;\n}\n.login-screen-content .list ul:before,\n.login-screen-page .list ul:before,\n.login-screen-content .list ul:after,\n.login-screen-page .list ul:after {\n  display: none !important;\n}\n.login-screen-content .block-footer,\n.login-screen-page .block-footer,\n.login-screen-content .block-header,\n.login-screen-page .block-header {\n  text-align: center;\n  margin-left: auto;\n  margin-right: auto;\n}\n.login-screen-title {\n  text-align: var(--f7-login-screen-title-text-align);\n  font-size: var(--f7-login-screen-title-font-size);\n  font-weight: var(--f7-login-screen-title-font-weight);\n  color: var(--f7-login-screen-title-text-color);\n  letter-spacing: var(--f7-login-screen-title-letter-spacing);\n}\n.login-screen-page,\n.login-screen > .view > .page,\n.login-screen > .page {\n  display: flex;\n  flex-direction: column;\n}\n.login-screen-page .page-content,\n.login-screen > .view > .page .page-content,\n.login-screen > .page .page-content,\n.login-screen-page .login-screen-content,\n.login-screen > .view > .page .login-screen-content,\n.login-screen > .page .login-screen-content {\n  margin-top: auto;\n  margin-bottom: auto;\n  height: auto;\n  max-height: 100%;\n  width: 100%;\n}\n.theme-dark .login-screen-content .list ul,\n.theme-dark .login-screen-content .block-strong,\n.theme-dark .login-screen-page .list ul,\n.theme-dark .login-screen-page .block-strong,\n.theme-dark.login-screen-page .list ul,\n.theme-dark.login-screen-page .block-strong {\n  background-color: transparent;\n}\n/* === Popover === */\n:root {\n  --f7-popover-width: 260px;\n}\n.ios {\n  --f7-popover-border-radius: 13px;\n  --f7-popover-box-shadow: none;\n  --f7-popover-actions-icon-size: 28px;\n  --f7-popover-bg-color: rgba(255, 255, 255, 0.95);\n  --f7-popover-actions-label-text-color: rgba(0, 0, 0, 0.45);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-popover-bg-color: rgba(30, 30, 30, 0.95);\n  --f7-popover-actions-label-text-color: rgba(255, 255, 255, 0.55);\n}\n.md {\n  --f7-popover-border-radius: 4px;\n  --f7-popover-box-shadow: var(--f7-elevation-8);\n  --f7-popover-actions-icon-size: 24px;\n  --f7-popover-bg-color: #fff;\n  --f7-popover-actions-label-text-color: rgba(0, 0, 0, 0.54);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-popover-bg-color: #1c1c1d;\n  --f7-popover-actions-label-text-color: rgba(255, 255, 255, 0.54);\n}\n.aurora {\n  --f7-popover-width: 200px;\n  --f7-popover-border-radius: 4px;\n  --f7-popover-box-shadow: 0 0 3px 0 rgba(0, 0, 0, 0.1), 0 5px 11px 0 rgba(0,0,0,0.28);\n  --f7-popover-actions-icon-size: 24px;\n  --f7-popover-bg-color: #fff;\n  --f7-popover-actions-label-text-color: rgba(0, 0, 0, 0.6);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-popover-bg-color: #1c1c1d;\n  --f7-popover-actions-label-text-color: rgba(255, 255, 255, 0.6);\n}\n.popover {\n  width: var(--f7-popover-width);\n  z-index: 13500;\n  margin: 0;\n  top: 0;\n  opacity: 0;\n  left: 0;\n  position: absolute;\n  display: none;\n  transition-duration: 300ms;\n  background-color: var(--f7-popover-bg-color);\n  border-radius: var(--f7-popover-border-radius);\n  box-shadow: var(--f7-popover-box-shadow);\n  will-change: transform, opacity;\n}\n.popover .list {\n  margin: 0;\n}\n.popover .list ul {\n  background: none;\n}\n.popover .list:first-child ul:before {\n  display: none !important;\n}\n.popover .list:last-child ul:after {\n  display: none !important;\n}\n.popover .list:first-child ul {\n  border-radius: var(--f7-popover-border-radius) var(--f7-popover-border-radius) 0 0;\n}\n.popover .list:first-child li:first-child,\n.popover .list:first-child li:first-child a,\n.popover .list:first-child li:first-child > label {\n  border-radius: var(--f7-popover-border-radius) var(--f7-popover-border-radius) 0 0;\n}\n.popover .list:last-child ul {\n  border-radius: 0 0 var(--f7-popover-border-radius) var(--f7-popover-border-radius);\n}\n.popover .list:last-child li:last-child,\n.popover .list:last-child li:last-child a,\n.popover .list:last-child li:last-child > label {\n  border-radius: 0 0 var(--f7-popover-border-radius) var(--f7-popover-border-radius);\n}\n.popover .list:first-child:last-child li:first-child:last-child,\n.popover .list:first-child:last-child li:first-child:last-child a,\n.popover .list:first-child:last-child li:first-child:last-child > label,\n.popover .list:first-child:last-child ul {\n  border-radius: var(--f7-popover-border-radius);\n}\n.popover .list + .list {\n  margin-top: var(--f7-list-margin-vertical);\n}\n.popover.modal-in {\n  opacity: 1;\n}\n.popover.not-animated {\n  transition-duration: 0ms;\n}\n.popover-inner {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.popover-from-actions .item-link i.icon {\n  width: var(--f7-popover-actions-icon-size);\n  height: var(--f7-popover-actions-icon-size);\n  font-size: var(--f7-popover-actions-icon-size);\n}\n.popover-from-actions-bold {\n  font-weight: 600;\n}\n.popover-from-actions-label {\n  line-height: 1.3;\n  position: relative;\n  display: flex;\n  align-items: center;\n  padding: var(--f7-actions-label-padding);\n  color: var(--f7-popover-actions-label-text-color);\n  font-size: var(--f7-actions-label-font-size);\n  justify-content: var(--f7-actions-label-justify-content);\n}\n.popover-from-actions-label:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-list-item-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.popover-from-actions-label:last-child:after {\n  display: none !important;\n}\n.ios .popover {\n  transform: none;\n  transition-property: opacity;\n}\n.ios .popover-angle {\n  width: 26px;\n  height: 26px;\n  position: absolute;\n  left: -26px;\n  top: 0;\n  z-index: 100;\n  overflow: hidden;\n}\n.ios .popover-angle:after {\n  content: '';\n  background: var(--f7-popover-bg-color);\n  width: 26px;\n  height: 26px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  border-radius: 3px;\n  transform: rotate(45deg);\n}\n.ios .popover-angle.on-left {\n  left: -26px;\n}\n.ios .popover-angle.on-left:after {\n  left: 19px;\n  top: 0;\n}\n.ios .popover-angle.on-right {\n  left: 100%;\n}\n.ios .popover-angle.on-right:after {\n  left: -19px;\n  top: 0;\n}\n.ios .popover-angle.on-top {\n  left: 0;\n  top: -26px;\n}\n.ios .popover-angle.on-top:after {\n  left: 0;\n  top: 19px;\n}\n.ios .popover-angle.on-bottom {\n  left: 0;\n  top: 100%;\n}\n.ios .popover-angle.on-bottom:after {\n  left: 0;\n  top: -19px;\n}\n.md .popover {\n  transform: scale(0.85, 0.6);\n  transition-property: opacity, transform;\n}\n.md .popover.modal-in {\n  opacity: 1;\n  transform: scale(1);\n}\n.md .popover.modal-out {\n  opacity: 0;\n  transform: scale(1);\n}\n.md .popover-on-top {\n  transform-origin: center bottom;\n}\n.md .popover-on-top.popover-on-right {\n  transform-origin: left bottom;\n}\n.md .popover-on-top.popover-on-left {\n  transform-origin: right bottom;\n}\n.md .popover-on-middle {\n  transform-origin: center center;\n}\n.md .popover-on-middle.popover-on-right {\n  transform-origin: left center;\n}\n.md .popover-on-middle.popover-on-left {\n  transform-origin: right center;\n}\n.md .popover-on-bottom {\n  transform-origin: center top;\n}\n.md .popover-on-bottom.popover-on-right {\n  transform-origin: left top;\n}\n.md .popover-on-bottom.popover-on-left {\n  transform-origin: right top;\n}\n.aurora .popover {\n  transform: none;\n  transition-property: opacity;\n}\n.aurora .popover-angle {\n  width: 18px;\n  height: 18px;\n  position: absolute;\n  left: -18px;\n  top: 0;\n  z-index: 100;\n  overflow: hidden;\n}\n.aurora .popover-angle:after {\n  content: '';\n  background: var(--f7-popover-bg-color);\n  width: 18px;\n  height: 18px;\n  position: absolute;\n  left: 0;\n  top: 0;\n  border-radius: 2px;\n  transform: rotate(45deg);\n}\n.aurora .popover-angle.on-left {\n  left: -18px;\n}\n.aurora .popover-angle.on-left:after {\n  left: 13px;\n  top: 0;\n}\n.aurora .popover-angle.on-right {\n  left: 100%;\n}\n.aurora .popover-angle.on-right:after {\n  left: -13px;\n  top: 0;\n}\n.aurora .popover-angle.on-top {\n  left: 0;\n  top: -18px;\n}\n.aurora .popover-angle.on-top:after {\n  left: 0;\n  top: 13px;\n}\n.aurora .popover-angle.on-bottom {\n  left: 0;\n  top: 100%;\n}\n.aurora .popover-angle.on-bottom:after {\n  left: 0;\n  top: -13px;\n}\n/* === Actions === */\n:root {\n  --f7-actions-grid-button-font-size: 12px;\n  --f7-actions-grid-button-text-color: #757575;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-actions-label-text-color: rgba(255, 255, 255, 0.55);\n}\n.ios {\n  --f7-actions-border-radius: 13px;\n  /*\n  --f7-actions-button-text-color: var(--f7-theme-color);\n  */\n  --f7-actions-button-padding: 0px;\n  --f7-actions-button-text-align: center;\n  --f7-actions-button-height: 57px;\n  --f7-actions-button-height-landscape: 44px;\n  --f7-actions-button-font-size: 20px;\n  --f7-actions-button-icon-size: 28px;\n  --f7-actions-button-justify-content: center;\n  --f7-actions-label-padding: 8px 10px;\n  --f7-actions-label-font-size: 13px;\n  --f7-actions-label-justify-content: center;\n  --f7-actions-group-border-color: transparent;\n  --f7-actions-group-margin: 8px;\n  --f7-actions-grid-button-icon-size: 48px;\n  --f7-actions-bg-color: rgba(255, 255, 255, 0.95);\n  --f7-actions-bg-color-rgb: 255, 255, 255;\n  --f7-actions-button-border-color: rgba(0, 0, 0, 0.2);\n  --f7-actions-button-pressed-bg-color: rgba(230, 230, 230, 0.9);\n  --f7-actions-button-pressed-bg-color-rgb: 230, 230, 230;\n  --f7-actions-label-text-color: #8a8a8a;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-actions-bg-color: rgba(45, 45, 45, 0.95);\n  --f7-actions-bg-color-rgb: 45, 45, 45;\n  --f7-actions-button-border-color: rgba(255, 255, 255, 0.15);\n  --f7-actions-button-pressed-bg-color: rgba(50, 50, 50, 0.9);\n  --f7-actions-button-pressed-bg-color-rgb: 50, 50, 50;\n}\n.md {\n  --f7-actions-border-radius: 0px;\n  --f7-actions-button-border-color: transparent;\n  --f7-actions-button-padding: 0 16px;\n  --f7-actions-button-text-align: left;\n  --f7-actions-button-height: 48px;\n  --f7-actions-button-height-landscape: 48px;\n  --f7-actions-button-font-size: 16px;\n  --f7-actions-button-icon-size: 24px;\n  --f7-actions-button-justify-content: space-between;\n  --f7-actions-label-padding: 12px 16px;\n  --f7-actions-label-font-size: 16px;\n  --f7-actions-label-justify-content: flex-start;\n  --f7-actions-group-margin: 0px;\n  --f7-actions-grid-button-icon-size: 48px;\n  --f7-actions-bg-color: #fff;\n  --f7-actions-button-text-color: rgba(0, 0, 0, 0.87);\n  --f7-actions-button-pressed-bg-color: #e5e5e5;\n  --f7-actions-label-text-color: rgba(0, 0, 0, 0.54);\n  --f7-actions-group-border-color: rgba(0, 0, 0, 0.12);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-actions-bg-color: #202020;\n  --f7-actions-button-text-color: #fff;\n  --f7-actions-button-pressed-bg-color: #2e2e2e;\n  --f7-actions-group-border-color: rgba(255, 255, 255, 0.15);\n}\n.aurora {\n  --f7-actions-border-radius: 4px;\n  --f7-actions-button-padding: 0 16px;\n  --f7-actions-button-text-align: center;\n  --f7-actions-button-height: 32px;\n  --f7-actions-button-height-landscape: 32px;\n  --f7-actions-button-font-size: 14px;\n  --f7-actions-button-icon-size: 18px;\n  --f7-actions-button-justify-content: space-between;\n  --f7-actions-label-padding: 10px 16px;\n  --f7-actions-label-font-size: 12px;\n  --f7-actions-label-justify-content: center;\n  --f7-actions-group-margin: 16px;\n  --f7-actions-grid-button-icon-size: 32px;\n  --f7-actions-bg-color: #fff;\n  --f7-actions-button-border-color: rgba(0, 0, 0, 0.12);\n  /*\n    --f7-actions-button-text-color: var(--f7-theme-color);\n    */\n  --f7-actions-button-pressed-bg-color: #e5e5e5;\n  --f7-actions-label-text-color: rgba(0, 0, 0, 0.5);\n  --f7-actions-group-border-color: rgba(0, 0, 0, 0.1);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-actions-bg-color: #202020;\n  --f7-actions-button-text-color: #fff;\n  --f7-actions-button-border-color: rgba(255, 255, 255, 0.15);\n  --f7-actions-button-pressed-bg-color: #2e2e2e;\n  --f7-actions-group-border-color: rgba(255, 255, 255, 0.15);\n}\n.actions-modal {\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  z-index: 13500;\n  width: 100%;\n  transform: translate3d(0, 100%, 0);\n  display: none;\n  max-height: 100%;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  transition-property: transform;\n  will-change: transform;\n}\n.actions-modal.modal-in,\n.actions-modal.modal-out {\n  transition-duration: 300ms;\n}\n.actions-modal.not-animated {\n  transition-duration: 0ms;\n}\n.actions-modal.modal-in {\n  transform: translate3d(0, calc(-1 * var(--f7-safe-area-bottom)), 0);\n}\n.actions-modal.modal-out {\n  z-index: 13499;\n  transform: translate3d(0, 100%, 0);\n}\n@media (min-width: 496px) {\n  .actions-modal {\n    width: 480px;\n    left: 50%;\n    margin-left: -240px;\n  }\n}\n@media (orientation: landscape) {\n  .actions-modal {\n    --f7-actions-button-height: var(--f7-actions-button-height-landscape);\n  }\n}\n.actions-group {\n  overflow: hidden;\n  position: relative;\n  margin: var(--f7-actions-group-margin);\n  border-radius: var(--f7-actions-border-radius);\n  transform: translate3d(0, 0, 0);\n}\n.actions-group:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-actions-group-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.actions-group:last-child:after {\n  display: none !important;\n}\n.actions-button,\n.actions-label {\n  width: 100%;\n  font-weight: normal;\n  margin: 0;\n  box-sizing: border-box;\n  display: block;\n  position: relative;\n  overflow: hidden;\n  text-align: var(--f7-actions-button-text-align);\n  background: var(--f7-actions-bg-color);\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-modals .actions-button,\n  .ios-translucent-modals .actions-label {\n    background-color: rgba(var(--f7-actions-bg-color-rgb), 0.8);\n    -webkit-backdrop-filter: saturate(180%) blur(20px);\n            backdrop-filter: saturate(180%) blur(20px);\n  }\n}\n.actions-button:after,\n.actions-label:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-actions-button-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.actions-button:first-child,\n.actions-label:first-child {\n  border-radius: var(--f7-actions-border-radius) var(--f7-actions-border-radius) 0 0;\n}\n.actions-button:last-child,\n.actions-label:last-child {\n  border-radius: 0 0 var(--f7-actions-border-radius) var(--f7-actions-border-radius);\n}\n.actions-button:last-child:after,\n.actions-label:last-child:after {\n  display: none !important;\n}\n.actions-button:first-child:last-child,\n.actions-label:first-child:last-child {\n  border-radius: var(--f7-actions-border-radius);\n}\n.actions-button a,\n.actions-label a {\n  text-decoration: none;\n  color: inherit;\n  display: block;\n}\n.actions-button b,\n.actions-label b,\n.actions-button.actions-button-bold,\n.actions-label.actions-button-bold {\n  font-weight: 600;\n}\n.actions-button {\n  cursor: pointer;\n  display: flex;\n  color: var(--f7-actions-button-text-color, var(--f7-theme-color));\n  font-size: var(--f7-actions-button-font-size);\n  height: var(--f7-actions-button-height);\n  line-height: var(--f7-actions-button-height);\n  padding: var(--f7-actions-button-padding);\n  justify-content: var(--f7-actions-button-justify-content);\n  z-index: 10;\n}\n.actions-button.active-state {\n  background-color: var(--f7-actions-button-pressed-bg-color) !important;\n}\n.actions-button[class*=\"color-\"] {\n  color: var(--f7-theme-color);\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-modals .actions-button.active-state {\n    background-color: rgba(var(--f7-actions-button-pressed-bg-color-rgb), 0.8);\n    -webkit-backdrop-filter: saturate(180%) blur(20px);\n            backdrop-filter: saturate(180%) blur(20px);\n  }\n}\n.actions-button-media {\n  flex-shrink: 0;\n  display: flex;\n  align-items: center;\n}\n.actions-button-media i.icon {\n  width: var(--f7-actions-button-icon-size);\n  height: var(--f7-actions-button-icon-size);\n  font-size: var(--f7-actions-button-icon-size);\n}\n.actions-button a,\n.actions-button-text {\n  position: relative;\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n}\n.actions-button-text {\n  width: 100%;\n  flex-shrink: 1;\n  text-align: var(--f7-actions-button-text-align);\n}\n.actions-label {\n  line-height: 1.3;\n  display: flex;\n  align-items: center;\n  font-size: var(--f7-actions-label-font-size);\n  color: var(--f7-actions-label-text-color);\n  padding: var(--f7-actions-label-padding);\n  justify-content: var(--f7-actions-label-justify-content);\n  min-height: var(--f7-actions-label-min-height, var(--f7-actions-button-height));\n}\n.actions-label[class*=\" color-\"] {\n  --f7-actions-label-text-color: var(--f7-theme-color);\n}\n.actions-grid .actions-group {\n  display: flex;\n  flex-wrap: wrap;\n  justify-content: flex-start;\n  border-radius: 0;\n  background: var(--f7-actions-bg-color);\n  margin-top: 0;\n}\n.actions-grid .actions-group:first-child {\n  border-radius: var(--f7-actions-border-radius) var(--f7-actions-border-radius) 0 0;\n}\n.actions-grid .actions-group:last-child {\n  border-radius: 0 0 var(--f7-actions-border-radius) var(--f7-actions-border-radius);\n}\n.actions-grid .actions-group:first-child:last-child {\n  border-radius: var(--f7-actions-border-radius);\n}\n.actions-grid .actions-group:not(:last-child) {\n  margin-bottom: 0;\n}\n.actions-grid .actions-button,\n.actions-grid .actions-label {\n  border-radius: 0 !important;\n  background: none;\n}\n.actions-grid .actions-button {\n  width: 33.33333333%;\n  display: block;\n  color: var(--f7-actions-grid-button-text-color);\n  height: auto;\n  line-height: 1;\n  padding: 16px;\n}\n.actions-grid .actions-button:after {\n  display: none !important;\n}\n.actions-grid .actions-button-media {\n  margin-left: auto !important;\n  margin-right: auto !important;\n  width: var(--f7-actions-grid-button-icon-size);\n  height: var(--f7-actions-grid-button-icon-size);\n}\n.actions-grid .actions-button-media i.icon {\n  width: var(--f7-actions-grid-button-icon-size);\n  height: var(--f7-actions-grid-button-icon-size);\n  font-size: var(--f7-actions-grid-button-icon-size);\n}\n.actions-grid .actions-button-text {\n  margin-left: 0 !important;\n  text-align: center !important;\n  margin-top: 8px;\n  line-height: 1.33em;\n  height: 1.33em;\n  font-size: var(--f7-actions-grid-button-font-size);\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-modals .actions-grid .actions-group {\n    background-color: rgba(var(--f7-actions-bg-color-rgb), 0.8);\n    -webkit-backdrop-filter: saturate(180%) blur(20px);\n            backdrop-filter: saturate(180%) blur(20px);\n  }\n}\n.ios .actions-button-media {\n  margin-left: 16px;\n}\n.ios .actions-button-media + .actions-button-text {\n  text-align: left;\n  margin-left: 16px;\n}\n.md .actions-button {\n  transition-duration: 300ms;\n}\n.md .actions-button-media {\n  min-width: 40px;\n}\n.md .actions-button-media + .actions-button-text {\n  margin-left: 16px;\n}\n.aurora .actions-button-media {\n  margin-left: 16px;\n}\n.aurora .actions-button-media + .actions-button-text {\n  text-align: left;\n  margin-left: 16px;\n}\n/* === Sheet Modal === */\n:root {\n  --f7-sheet-height: 260px;\n  --f7-sheet-border-color: transparent;\n  --f7-sheet-transition-duration: 300ms;\n  --f7-sheet-push-border-radius: 10px;\n  --f7-sheet-push-offset: var(--f7-safe-area-top);\n  --f7-sheet-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-sheet-bg-color: #202020;\n}\n.ios {\n  --f7-sheet-border-color: var(--f7-bars-border-color);\n}\n.sheet-backdrop {\n  z-index: 11000;\n}\n.sheet-modal {\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  width: 100%;\n  height: var(--f7-sheet-height);\n  display: none;\n  box-sizing: border-box;\n  transition-property: transform;\n  transform: translate3d(0, 100%, 0);\n  background: var(--f7-sheet-bg-color);\n  z-index: 12500;\n  will-change: transform, opacity;\n}\n.sheet-modal.modal-in,\n.sheet-modal.modal-out {\n  transition-duration: var(--f7-sheet-transition-duration);\n}\n.sheet-modal.not-animated {\n  transition-duration: 0ms;\n}\n.sheet-modal.modal-in {\n  display: block;\n  transform: translate3d(0, 0, 0);\n}\n.sheet-modal.modal-in-swipe-step {\n  display: block;\n  transform: translate3d(0, var(--f7-sheet-swipe-step, 0), 0);\n}\n.sheet-modal.modal-out {\n  transform: translate3d(0, 100%, 0);\n}\n.sheet-modal .sheet-modal-inner {\n  height: 100%;\n  position: relative;\n  overflow: hidden;\n}\n.sheet-modal .toolbar {\n  --f7-safe-area-bottom: 0px;\n  position: relative;\n  width: 100%;\n}\n.sheet-modal .toolbar:after,\n.sheet-modal .toolbar:before {\n  display: none;\n}\n.sheet-modal .toolbar + .sheet-modal-inner {\n  height: calc(100% - var(--f7-toolbar-height));\n}\n.sheet-modal .toolbar + .sheet-modal-inner .page-content {\n  --f7-page-toolbar-top-offset: 0px;\n  --f7-page-toolbar-bottom-offset: 0px;\n}\n.sheet-modal-top:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-sheet-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.sheet-modal-top:after {\n  z-index: 700;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  transform-style: preserve-3d;\n}\n.sheet-modal-bottom,\n.sheet-modal:not(.sheet-modal-top) {\n  --f7-safe-area-top: 0px;\n}\n.sheet-modal-bottom:before,\n.sheet-modal:not(.sheet-modal-top):before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-sheet-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.sheet-modal-bottom:before,\n.sheet-modal:not(.sheet-modal-top):before {\n  z-index: 700;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  transform-style: preserve-3d;\n}\n.sheet-modal-top {\n  --f7-safe-area-bottom: 0px;\n  bottom: auto;\n  top: 0;\n  transform: translate3d(0, -100%, 0);\n}\n.sheet-modal-top.modal-out {\n  transform: translate3d(0, -100%, 0);\n}\n.sheet-modal-top .toolbar-bottom {\n  position: absolute;\n}\n.sheet-modal-top .page-content {\n  padding-top: var(--f7-safe-area-top);\n}\nhtml.with-modal-sheet-push .sheet-modal-push,\nhtml.with-modal-sheet-push-closing .sheet-modal-push {\n  --f7-sheet-border-color: transparent;\n  border-radius: var(--f7-sheet-push-border-radius) var(--f7-sheet-push-border-radius) 0 0;\n  overflow: hidden;\n}\nhtml.with-modal-sheet-push .sheet-modal-push .view,\nhtml.with-modal-sheet-push-closing .sheet-modal-push .view,\nhtml.with-modal-sheet-push .sheet-modal-push .page,\nhtml.with-modal-sheet-push-closing .sheet-modal-push .page {\n  --f7-safe-area-top: 0px;\n}\nhtml.with-modal-sheet-push .sheet-modal-push.sheet-modal-top,\nhtml.with-modal-sheet-push-closing .sheet-modal-push.sheet-modal-top {\n  border-radius: 0 0 var(--f7-sheet-push-border-radius) var(--f7-sheet-push-border-radius);\n}\nhtml.with-modal-sheet-push .framework7-root,\nhtml.with-modal-sheet-push-closing .framework7-root {\n  background: #000;\n}\nhtml.with-modal-sheet-push .framework7-root > .views,\nhtml.with-modal-sheet-push-closing .framework7-root > .views,\nhtml.with-modal-sheet-push .framework7-root > .view,\nhtml.with-modal-sheet-push-closing .framework7-root > .view {\n  transition-duration: var(--f7-sheet-transition-duration);\n}\nhtml.with-modal-sheet-push.theme-dark .framework7-root > .views:after,\nhtml.with-modal-sheet-push-closing.theme-dark .framework7-root > .views:after,\nhtml.with-modal-sheet-push.theme-dark .framework7-root > .view:after,\nhtml.with-modal-sheet-push-closing.theme-dark .framework7-root > .view:after,\nhtml.with-modal-sheet-push .theme-dark .framework7-root > .views:after,\nhtml.with-modal-sheet-push-closing .theme-dark .framework7-root > .views:after,\nhtml.with-modal-sheet-push .theme-dark .framework7-root > .view:after,\nhtml.with-modal-sheet-push-closing .theme-dark .framework7-root > .view:after,\nhtml.with-modal-sheet-push .theme-dark.framework7-root > .views:after,\nhtml.with-modal-sheet-push-closing .theme-dark.framework7-root > .views:after,\nhtml.with-modal-sheet-push .theme-dark.framework7-root > .view:after,\nhtml.with-modal-sheet-push-closing .theme-dark.framework7-root > .view:after,\nhtml.with-modal-sheet-push .framework7-root > .views.theme-dark:after,\nhtml.with-modal-sheet-push-closing .framework7-root > .views.theme-dark:after,\nhtml.with-modal-sheet-push .framework7-root > .view.theme-dark:after,\nhtml.with-modal-sheet-push-closing .framework7-root > .view.theme-dark:after {\n  content: '';\n  position: absolute;\n  pointer-events: none;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(255, 255, 255, 0.1);\n  z-index: 13000;\n  border-radius: var(--f7-sheet-push-border-radius) var(--f7-sheet-push-border-radius) 0 0;\n  opacity: 1;\n  animation: sheet-dark-push-overlay-fade-in var(--f7-sheet-transition-duration) forwards;\n}\nhtml.with-modal-sheet-push .framework7-root > .views,\nhtml.with-modal-sheet-push .framework7-root > .view {\n  border-radius: var(--f7-sheet-push-border-radius);\n  transform: translate3d(0, 0, 0px) scale(var(--f7-sheet-push-scale, 1));\n}\nhtml.with-modal-sheet-push-closing.theme-dark .framework7-root > .views:after,\nhtml.with-modal-sheet-push-closing.theme-dark .framework7-root > .view:after,\nhtml.with-modal-sheet-push-closing .theme-dark .framework7-root > .views:after,\nhtml.with-modal-sheet-push-closing .theme-dark .framework7-root > .view:after,\nhtml.with-modal-sheet-push-closing .theme-dark.framework7-root > .views:after,\nhtml.with-modal-sheet-push-closing .theme-dark.framework7-root > .view:after,\nhtml.with-modal-sheet-push-closing .framework7-root > .views.theme-dark:after,\nhtml.with-modal-sheet-push-closing .framework7-root > .view.theme-dark:after {\n  animation: sheet-dark-push-overlay-fade-out var(--f7-sheet-transition-duration) forwards;\n}\n@keyframes sheet-dark-push-overlay-fade-in {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes sheet-dark-push-overlay-fade-out {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n.md .sheet-modal .toolbar a.link:not(.tab-link) {\n  flex-shrink: 0;\n}\n/* === Toast === */\n:root {\n  --f7-toast-text-color: #fff;\n  --f7-toast-font-size: 14px;\n  --f7-toast-icon-size: 48px;\n}\n.ios {\n  --f7-toast-bg-color: rgba(0, 0, 0, 0.75);\n  --f7-toast-bg-color-rgb: 0, 0, 0;\n  --f7-toast-padding-horizontal: 16px;\n  --f7-toast-padding-vertical: 12px;\n  --f7-toast-border-radius: 8px;\n  --f7-toast-button-min-width: 64px;\n}\n.md {\n  --f7-toast-bg-color: #323232;\n  --f7-toast-padding-horizontal: 24px;\n  --f7-toast-padding-vertical: 14px;\n  --f7-toast-border-radius: 4px;\n  --f7-toast-button-min-width: 64px;\n}\n.aurora {\n  --f7-toast-bg-color: rgba(0, 0, 0, 0.85);\n  --f7-toast-padding-horizontal: 10px;\n  --f7-toast-padding-vertical: 10px;\n  --f7-toast-border-radius: 4px;\n  --f7-toast-button-min-width: 32px;\n}\n.toast {\n  --f7-touch-ripple-color: var(--f7-touch-ripple-white);\n  transition-property: transform, opacity;\n  position: absolute;\n  max-width: 568px;\n  z-index: 20000;\n  color: var(--f7-toast-text-color);\n  font-size: var(--f7-toast-font-size);\n  box-sizing: border-box;\n  background-color: var(--f7-toast-bg-color);\n  opacity: 0;\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-modals .toast {\n    background-color: rgba(var(--f7-toast-bg-color-rgb), 0.8);\n    -webkit-backdrop-filter: saturate(180%) blur(20px);\n            backdrop-filter: saturate(180%) blur(20px);\n  }\n}\n.toast.modal-in {\n  opacity: 1;\n}\n.toast .toast-content {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  box-sizing: border-box;\n  padding: var(--f7-toast-padding-vertical) var(--f7-toast-padding-horizontal);\n}\n.toast .toast-text {\n  line-height: 20px;\n  flex-shrink: 1;\n  min-width: 0;\n}\n.toast .toast-button {\n  flex-shrink: 0;\n  min-width: var(--f7-toast-button-min-width);\n  margin-top: -8px;\n  margin-bottom: -8px;\n}\n.toast.toast-with-icon .toast-content {\n  display: block;\n  text-align: center;\n}\n.toast.toast-with-icon .toast-text {\n  text-align: center;\n}\n.toast.toast-with-icon .toast-icon .f7-icons,\n.toast.toast-with-icon .toast-icon .material-icons {\n  font-size: var(--f7-toast-icon-size);\n}\n.toast.toast-center {\n  top: 50%;\n}\n.toast.toast-top {\n  margin-top: var(--f7-safe-area-top);\n}\n.ios .toast {\n  transition-duration: 300ms;\n  width: 100%;\n  left: 0;\n}\n.ios .toast.toast-top {\n  top: 0;\n  transform: translate3d(0, -100%, 0);\n}\n.ios .toast.toast-top.modal-in {\n  transform: translate3d(0, 0%, 0);\n}\n.ios .toast.toast-center {\n  width: auto;\n  left: 50%;\n  border-radius: var(--f7-toast-border-radius);\n  transform: translate3d(-50%, -50%, 0);\n}\n.ios .toast.toast-center.modal-in {\n  transform: translate3d(-50%, -50%, 0);\n}\n.ios .toast.toast-bottom {\n  bottom: 0;\n  transform: translate3d(0, 100%, 0);\n}\n.ios .toast.toast-bottom.modal-in {\n  transform: translate3d(0, 0%, 0);\n}\n@media (max-width: 568px) {\n  .ios .toast.toast-top {\n    margin-top: 0;\n  }\n  .ios .toast.toast-top .toast-content {\n    padding-top: calc(var(--f7-toast-padding-vertical) + var(--f7-safe-area-top));\n  }\n  .ios .toast.toast-bottom .toast-content {\n    padding-bottom: calc(var(--f7-toast-padding-vertical) + var(--f7-safe-area-bottom));\n  }\n}\n@media (min-width: 569px) {\n  .ios .toast {\n    left: 50%;\n    margin-left: -284px;\n    border-radius: var(--f7-toast-border-radius);\n  }\n  .ios .toast.toast-top {\n    top: 16px;\n  }\n  .ios .toast.toast-center {\n    margin-left: 0;\n  }\n  .ios .toast.toast-bottom {\n    margin-bottom: calc(16px + var(--f7-safe-area-bottom));\n  }\n}\n@media (min-width: 1024px) {\n  .ios .toast {\n    margin-left: 0;\n    width: auto;\n  }\n  .ios .toast.toast-bottom,\n  .ios .toast.toast-top {\n    left: 16px;\n  }\n}\n.ios .toast-button {\n  margin-left: 16px;\n  margin-right: calc(-1 * var(--f7-button-padding-horizontal));\n}\n.md .toast {\n  transition-duration: 200ms;\n  border-radius: var(--f7-toast-border-radius);\n  left: 8px;\n  width: calc(100% - 16px);\n  transform: scale(0.9);\n}\n.md .toast.modal-in {\n  transform: scale(1);\n}\n.md .toast.modal-out {\n  transform: scale(1);\n}\n.md .toast.toast-top {\n  top: 8px;\n}\n.md .toast.toast-center {\n  left: 50%;\n  width: auto;\n  transform: scale(0.9) translate3d(-55%, -55%, 0);\n}\n.md .toast.toast-center.modal-in {\n  transform: scale(1) translate3d(-50%, -50%, 0);\n}\n.md .toast.toast-center.modal-out {\n  transform: scale(1) translate3d(-50%, -50%, 0);\n}\n.md .toast.toast-bottom {\n  bottom: calc(8px + var(--f7-safe-area-bottom));\n}\n@media (min-width: 584px) {\n  .md .toast {\n    left: 50%;\n    margin-left: -284px;\n  }\n  .md .toast.toast-center {\n    margin-left: 0;\n  }\n}\n@media (min-width: 1024px) {\n  .md .toast {\n    margin-left: 0;\n    width: auto;\n  }\n  .md .toast.toast-bottom,\n  .md .toast.toast-top {\n    left: 24px;\n  }\n  .md .toast.toast-bottom {\n    bottom: calc(24px + var(--f7-safe-area-bottom));\n  }\n  .md .toast.toast-top {\n    top: 24px;\n  }\n}\n.md .toast-button {\n  margin-left: 16px;\n  margin-right: -8px;\n}\n.aurora .toast {\n  transition-duration: 200ms;\n  border-radius: var(--f7-toast-border-radius);\n  left: 10px;\n  width: calc(100% - 20px);\n  transform: scale(0.9);\n}\n.aurora .toast.modal-in {\n  transform: scale(1);\n}\n.aurora .toast.modal-out {\n  transform: scale(1);\n}\n.aurora .toast.toast-top {\n  top: 10px;\n}\n.aurora .toast.toast-center {\n  left: 50%;\n  width: auto;\n  transform: scale(0.9) translate3d(-55%, -55%, 0);\n}\n.aurora .toast.toast-center.modal-in {\n  transform: scale(1) translate3d(-50%, -50%, 0);\n}\n.aurora .toast.toast-center.modal-out {\n  transform: scale(1) translate3d(-50%, -50%, 0);\n}\n.aurora .toast.toast-bottom {\n  bottom: calc(10px + var(--f7-safe-area-bottom));\n}\n@media (min-width: 584px) {\n  .aurora .toast {\n    left: 50%;\n    margin-left: -284px;\n  }\n  .aurora .toast.toast-center {\n    margin-left: 0;\n  }\n}\n@media (min-width: 1024px) {\n  .aurora .toast {\n    margin-left: 0;\n    width: auto;\n  }\n  .aurora .toast.toast-bottom,\n  .aurora .toast.toast-top {\n    left: 10px;\n  }\n}\n.aurora .toast-button {\n  margin-left: 10px;\n}\n/* === Preloader === */\n:root {\n  --f7-preloader-modal-padding: 8px;\n  --f7-preloader-modal-bg-color: rgba(0, 0, 0, 0.8);\n}\n.ios {\n  --f7-preloader-color: #6c6c6c;\n  --f7-preloader-size: 20px;\n  --f7-preloader-modal-preloader-size: 34px;\n  --f7-preloader-modal-border-radius: 5px;\n}\n.md {\n  --f7-preloader-color: #757575;\n  --f7-preloader-size: 32px;\n  --f7-preloader-modal-preloader-size: 32px;\n  --f7-preloader-modal-border-radius: 4px;\n}\n.aurora {\n  --f7-preloader-color: #757575;\n  --f7-preloader-size: 24px;\n  --f7-preloader-modal-preloader-size: 24px;\n  --f7-preloader-modal-border-radius: 4px;\n}\n.preloader {\n  display: inline-block;\n  vertical-align: middle;\n  width: var(--f7-preloader-size);\n  height: var(--f7-preloader-size);\n  font-size: 0;\n  position: relative;\n}\n/* === Preloader Modal === */\n.preloader-backdrop {\n  visibility: visible;\n  opacity: 0;\n  background: none;\n  z-index: 14000;\n}\n.preloader-modal {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  padding: var(--f7-preloader-modal-padding);\n  background: var(--f7-preloader-modal-bg-color);\n  z-index: 14500;\n  transform: translateX(-50%) translateY(-50%);\n  border-radius: var(--f7-preloader-modal-border-radius);\n}\n.preloader-modal .preloader {\n  --f7-preloader-size: var(--f7-preloader-modal-preloader-size);\n  display: block !important;\n}\nhtml.with-modal-preloader .page-content,\n.with-modal-preloader .page-content,\n.with-modal-preloader.page-content {\n  overflow: hidden;\n  -webkit-overflow-scrolling: auto;\n}\n.preloader[class*=\"color-\"] {\n  --f7-preloader-color: var(--f7-theme-color);\n}\n.ios .preloader {\n  animation: ios-preloader-spin 1s steps(12, end) infinite;\n}\n.ios .preloader .preloader-inner-line {\n  display: block;\n  width: 7.15%;\n  height: 28.5%;\n  border-radius: 100px;\n  background: var(--f7-preloader-color);\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform-origin: center 175%;\n}\n.ios .preloader .preloader-inner-line:nth-child(1) {\n  transform: translate(-50%, -175%) rotate(0deg);\n  opacity: 0.27;\n}\n.ios .preloader .preloader-inner-line:nth-child(2) {\n  transform: translate(-50%, -175%) rotate(30deg);\n  opacity: 0.32272727;\n}\n.ios .preloader .preloader-inner-line:nth-child(3) {\n  transform: translate(-50%, -175%) rotate(60deg);\n  opacity: 0.37545455;\n}\n.ios .preloader .preloader-inner-line:nth-child(4) {\n  transform: translate(-50%, -175%) rotate(90deg);\n  opacity: 0.42818182;\n}\n.ios .preloader .preloader-inner-line:nth-child(5) {\n  transform: translate(-50%, -175%) rotate(120deg);\n  opacity: 0.48090909;\n}\n.ios .preloader .preloader-inner-line:nth-child(6) {\n  transform: translate(-50%, -175%) rotate(150deg);\n  opacity: 0.53363636;\n}\n.ios .preloader .preloader-inner-line:nth-child(7) {\n  transform: translate(-50%, -175%) rotate(180deg);\n  opacity: 0.58636364;\n}\n.ios .preloader .preloader-inner-line:nth-child(8) {\n  transform: translate(-50%, -175%) rotate(210deg);\n  opacity: 0.63909091;\n}\n.ios .preloader .preloader-inner-line:nth-child(9) {\n  transform: translate(-50%, -175%) rotate(240deg);\n  opacity: 0.69181818;\n}\n.ios .preloader .preloader-inner-line:nth-child(10) {\n  transform: translate(-50%, -175%) rotate(270deg);\n  opacity: 0.74454545;\n}\n.ios .preloader .preloader-inner-line:nth-child(11) {\n  transform: translate(-50%, -175%) rotate(300deg);\n  opacity: 0.79727273;\n}\n.ios .preloader .preloader-inner-line:nth-child(12) {\n  transform: translate(-50%, -175%) rotate(330deg);\n  opacity: 0.85;\n}\n@keyframes ios-preloader-spin {\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.md .preloader {\n  animation: md-preloader-outer 3300ms linear infinite;\n}\n@keyframes md-preloader-outer {\n  0% {\n    transform: rotate(0);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n.md .preloader-inner {\n  position: relative;\n  display: block;\n  width: 100%;\n  height: 100%;\n  animation: md-preloader-inner-rotate 5.25s cubic-bezier(0.35, 0, 0.25, 1) infinite;\n}\n.md .preloader-inner .preloader-inner-gap {\n  position: absolute;\n  width: 2px;\n  left: 50%;\n  margin-left: -1px;\n  top: 0;\n  bottom: 0;\n  box-sizing: border-box;\n  border-top: 4px solid var(--f7-preloader-color);\n}\n.md .preloader-inner .preloader-inner-left,\n.md .preloader-inner .preloader-inner-right {\n  position: absolute;\n  top: 0;\n  height: 100%;\n  width: 50%;\n  overflow: hidden;\n}\n.md .preloader-inner .preloader-inner-half-circle {\n  position: absolute;\n  top: 0;\n  height: 100%;\n  width: 200%;\n  box-sizing: border-box;\n  border: 4px solid var(--f7-preloader-color);\n  border-bottom-color: transparent !important;\n  border-radius: 50%;\n  animation-iteration-count: infinite;\n  animation-duration: 1.3125s;\n  animation-timing-function: cubic-bezier(0.35, 0, 0.25, 1);\n}\n.md .preloader-inner .preloader-inner-left {\n  left: 0;\n}\n.md .preloader-inner .preloader-inner-left .preloader-inner-half-circle {\n  left: 0;\n  border-right-color: transparent !important;\n  animation-name: md-preloader-left-rotate;\n}\n.md .preloader-inner .preloader-inner-right {\n  right: 0;\n}\n.md .preloader-inner .preloader-inner-right .preloader-inner-half-circle {\n  right: 0;\n  border-left-color: transparent !important;\n  animation-name: md-preloader-right-rotate;\n}\n.md .preloader.color-multi .preloader-inner-left .preloader-inner-half-circle {\n  animation-name: md-preloader-left-rotate-multicolor;\n}\n.md .preloader.color-multi .preloader-inner-right .preloader-inner-half-circle {\n  animation-name: md-preloader-right-rotate-multicolor;\n}\n@keyframes md-preloader-left-rotate {\n  0%,\n  100% {\n    transform: rotate(130deg);\n  }\n  50% {\n    transform: rotate(-5deg);\n  }\n}\n@keyframes md-preloader-right-rotate {\n  0%,\n  100% {\n    transform: rotate(-130deg);\n  }\n  50% {\n    transform: rotate(5deg);\n  }\n}\n@keyframes md-preloader-inner-rotate {\n  12.5% {\n    transform: rotate(135deg);\n  }\n  25% {\n    transform: rotate(270deg);\n  }\n  37.5% {\n    transform: rotate(405deg);\n  }\n  50% {\n    transform: rotate(540deg);\n  }\n  62.5% {\n    transform: rotate(675deg);\n  }\n  75% {\n    transform: rotate(810deg);\n  }\n  87.5% {\n    transform: rotate(945deg);\n  }\n  100% {\n    transform: rotate(1080deg);\n  }\n}\n@keyframes md-preloader-left-rotate-multicolor {\n  0%,\n  100% {\n    border-left-color: #4285F4;\n    transform: rotate(130deg);\n  }\n  75% {\n    border-left-color: #1B9A59;\n    border-top-color: #1B9A59;\n  }\n  50% {\n    border-left-color: #F7C223;\n    border-top-color: #F7C223;\n    transform: rotate(-5deg);\n  }\n  25% {\n    border-left-color: #DE3E35;\n    border-top-color: #DE3E35;\n  }\n}\n@keyframes md-preloader-right-rotate-multicolor {\n  0%,\n  100% {\n    border-right-color: #4285F4;\n    transform: rotate(-130deg);\n  }\n  75% {\n    border-right-color: #1B9A59;\n    border-top-color: #1B9A59;\n  }\n  50% {\n    border-right-color: #F7C223;\n    border-top-color: #F7C223;\n    transform: rotate(5deg);\n  }\n  25% {\n    border-top-color: #DE3E35;\n    border-right-color: #DE3E35;\n  }\n}\n.aurora .preloader-inner {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n}\n.aurora .preloader-inner-circle {\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  border-radius: 50%;\n  border: calc(var(--f7-preloader-size) / 8) solid var(--f7-preloader-color);\n  border-top-color: transparent;\n  box-sizing: border-box;\n  animation: aurora-preloader-rotate 1s linear infinite;\n}\n.aurora .preloader.color-multi .preloader-inner-circle {\n  animation: aurora-preloader-rotate 1s linear infinite, aurora-preloader-multicolor 2s linear infinite;\n}\n@keyframes aurora-preloader-rotate {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n@keyframes aurora-preloader-multicolor {\n  0%,\n  100% {\n    border-color: #2196f3;\n    border-top-color: transparent;\n  }\n  25% {\n    border-color: #ff3b30;\n    border-top-color: transparent;\n  }\n  50% {\n    border-color: #4cd964;\n    border-top-color: transparent;\n  }\n  75% {\n    border-color: #ff9500;\n    border-top-color: transparent;\n  }\n}\n/* === Progressbar === */\n:root {\n  /*\n  --f7-progressbar-progress-color: var(--f7-theme-color);\n  */\n}\n.ios {\n  --f7-progressbar-height: 2px;\n  --f7-progressbar-border-radius: 2px;\n  --f7-progressbar-bg-color: rgba(0, 0, 0, 0.3);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-progressbar-bg-color: rgba(255, 255, 255, 0.3);\n}\n.md {\n  /*\n  --f7-progressbar-bg-color: rgba(var(--f7-theme-color-rgb), 0.5);\n  */\n  --f7-progressbar-height: 4px;\n  --f7-progressbar-border-radius: 0px;\n}\n.aurora {\n  --f7-progressbar-height: 6px;\n  --f7-progressbar-border-radius: 3px;\n  --f7-progressbar-bg-color: #dbdbdb;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-progressbar-bg-color: #444;\n}\n.progressbar,\n.progressbar-infinite {\n  width: 100%;\n  overflow: hidden;\n  position: relative;\n  display: block;\n  transform-style: preserve-3d;\n  background: var(--f7-progressbar-bg-color, rgba(var(--f7-theme-color-rgb), 0.5));\n  transform-origin: center top;\n  height: var(--f7-progressbar-height);\n  border-radius: var(--f7-progressbar-border-radius);\n}\n.progressbar {\n  vertical-align: middle;\n}\n.progressbar span {\n  background-color: var(--f7-progressbar-progress-color, var(--f7-theme-color));\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  transform: translate3d(-100%, 0, 0);\n  transition-duration: 150ms;\n}\n.progressbar-infinite {\n  z-index: 15000;\n}\n.progressbar-infinite:before,\n.progressbar-infinite:after {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  transform-origin: left center;\n  transform: translate3d(0, 0, 0);\n  display: block;\n  background-color: var(--f7-progressbar-progress-color, var(--f7-theme-color));\n}\n.progressbar-infinite.color-multi {\n  background: none !important;\n}\n.progressbar-in {\n  animation: progressbar-in 150ms forwards;\n}\n.progressbar-out {\n  animation: progressbar-out 150ms forwards;\n}\nbody > .progressbar,\n.view > .progressbar,\n.views > .progressbar,\n.page > .progressbar,\n.panel > .progressbar,\n.popup > .progressbar,\n.framework7-root > .progressbar,\nbody > .progressbar-infinite,\n.view > .progressbar-infinite,\n.views > .progressbar-infinite,\n.page > .progressbar-infinite,\n.panel > .progressbar-infinite,\n.popup > .progressbar-infinite,\n.framework7-root > .progressbar-infinite {\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: 15000;\n  border-radius: 0 !important;\n  transform-origin: center top !important;\n}\n@keyframes progressbar-in {\n  from {\n    opacity: 0;\n    transform: scaleY(0);\n  }\n  to {\n    opacity: 1;\n    transform: scaleY(1);\n  }\n}\n@keyframes progressbar-out {\n  from {\n    opacity: 1;\n    transform: scaleY(1);\n  }\n  to {\n    opacity: 0;\n    transform: scaleY(0);\n  }\n}\n.ios .progressbar-infinite:before {\n  animation: ios-progressbar-infinite 1s linear infinite;\n}\n.ios .progressbar-infinite:after {\n  display: none;\n}\n.ios .progressbar-infinite.color-multi:before {\n  width: 400%;\n  background-image: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55, #5856d6, #34aadc, #007aff, #5ac8fa, #4cd964);\n  background-size: 25% 100%;\n  background-repeat: repeat-x;\n  animation: ios-progressbar-infinite-multicolor 3s linear infinite;\n}\n@keyframes ios-progressbar-infinite {\n  0% {\n    transform: translate3d(-100%, 0, 0);\n  }\n  100% {\n    transform: translate3d(100%, 0, 0);\n  }\n}\n@keyframes ios-progressbar-infinite-multicolor {\n  0% {\n    transform: translate3d(0%, 0, 0);\n  }\n  100% {\n    transform: translate3d(-50%, 0, 0);\n  }\n}\n.md .progressbar-infinite:before {\n  animation: md-progressbar-infinite-1 2s linear infinite;\n}\n.md .progressbar-infinite:after {\n  animation: md-progressbar-infinite-2 2s linear infinite;\n}\n.md .progressbar-infinite.color-multi:before {\n  background: none;\n  animation: md-progressbar-infinite-multicolor-bg 3s step-end infinite;\n}\n.md .progressbar-infinite.color-multi:after {\n  background: none;\n  animation: md-progressbar-infinite-multicolor-fill 3s linear infinite;\n  transform-origin: center center;\n}\n@keyframes md-progressbar-infinite-1 {\n  0% {\n    transform: translateX(-10%) scaleX(0.1);\n  }\n  25% {\n    transform: translateX(30%) scaleX(0.6);\n  }\n  50% {\n    transform: translateX(100%) scaleX(1);\n  }\n  100% {\n    transform: translateX(100%) scaleX(1);\n  }\n}\n@keyframes md-progressbar-infinite-2 {\n  0% {\n    transform: translateX(-100%) scaleX(1);\n  }\n  40% {\n    transform: translateX(-100%) scaleX(1);\n  }\n  75% {\n    transform: translateX(60%) scaleX(0.35);\n  }\n  90% {\n    transform: translateX(100%) scaleX(0.1);\n  }\n  100% {\n    transform: translateX(100%) scaleX(0.1);\n  }\n}\n@keyframes md-progressbar-infinite-multicolor-bg {\n  0% {\n    background-color: #4caf50;\n  }\n  25% {\n    background-color: #f44336;\n  }\n  50% {\n    background-color: #2196f3;\n  }\n  75% {\n    background-color: #ffeb3b;\n  }\n}\n@keyframes md-progressbar-infinite-multicolor-fill {\n  0% {\n    transform: scaleX(0);\n    background-color: #f44336;\n  }\n  24.9% {\n    transform: scaleX(1);\n    background-color: #f44336;\n  }\n  25% {\n    transform: scaleX(0);\n    background-color: #2196f3;\n  }\n  49.9% {\n    transform: scaleX(1);\n    background-color: #2196f3;\n  }\n  50% {\n    transform: scaleX(0);\n    background-color: #ffeb3b;\n  }\n  74.9% {\n    transform: scaleX(1);\n    background-color: #ffeb3b;\n  }\n  75% {\n    transform: scaleX(0);\n    background-color: #4caf50;\n  }\n  100% {\n    transform: scaleX(1);\n    background-color: #4caf50;\n  }\n}\n.aurora .progressbar,\n.aurora .progressbar-infinite,\n.aurora .progressbar span,\n.aurora .progressbar-infinite:before {\n  box-shadow: 0px 0px 0px 1px rgba(0, 0, 0, 0.05) inset;\n}\n.aurora .progressbar-infinite:before {\n  animation: aurora-progressbar-infinite 1s linear infinite;\n}\n.aurora .progressbar-infinite:after {\n  display: none;\n}\n.aurora .progressbar-infinite.color-multi:before {\n  width: 400%;\n  background-image: linear-gradient(to right, #4cd964, #5ac8fa, #007aff, #34aadc, #5856d6, #ff2d55, #5856d6, #34aadc, #007aff, #5ac8fa, #4cd964);\n  background-size: 25% 100%;\n  background-repeat: repeat-x;\n  animation: aurora-progressbar-infinite-multicolor 3s linear infinite;\n}\n@keyframes aurora-progressbar-infinite {\n  0% {\n    transform: translate3d(-100%, 0, 0);\n  }\n  100% {\n    transform: translate3d(100%, 0, 0);\n  }\n}\n@keyframes aurora-progressbar-infinite-multicolor {\n  0% {\n    transform: translate3d(0%, 0, 0);\n  }\n  100% {\n    transform: translate3d(-50%, 0, 0);\n  }\n}\n/* === Sortable === */\n:root {\n  --f7-sortable-handler-color: rgba(0, 0, 0, 0.22);\n  --f7-sortable-sorting-item-bg-color: rgba(255, 255, 255, 0.8);\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-sortable-sorting-item-bg-color: rgba(50, 50, 50, 0.8);\n  --f7-sortable-handler-color: rgba(255, 255, 255, 0.55);\n}\n.ios {\n  --f7-sortable-handler-width: 36px;\n  --f7-sortable-sorting-item-box-shadow: 0px 2px 8px rgba(0, 0, 0, 0.6);\n}\n.md {\n  --f7-sortable-handler-width: 42px;\n  --f7-sortable-sorting-item-box-shadow: var(--f7-elevation-2);\n}\n.aurora {\n  --f7-sortable-handler-width: 32px;\n  --f7-sortable-sorting-item-box-shadow: var(--f7-elevation-2);\n}\n.sortable .sortable-handler {\n  width: var(--f7-sortable-handler-width);\n  height: 100%;\n  position: absolute;\n  top: 0;\n  z-index: 10;\n  opacity: 0;\n  pointer-events: none;\n  cursor: move;\n  transition-duration: 300ms;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  overflow: hidden;\n  right: var(--f7-safe-area-right);\n}\n.sortable .sortable-handler:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  transition-duration: 300ms;\n  transform: translateX(10px);\n  color: var(--f7-sortable-handler-color);\n  overflow: hidden;\n  height: 20px;\n  width: 18px;\n}\n.sortable li.sorting {\n  z-index: 50;\n  background: var(--f7-sortable-sorting-item-bg-color);\n  transition-duration: 0ms;\n  box-shadow: var(--f7-sortable-sorting-item-box-shadow);\n}\n.sortable li.sorting .item-inner:after {\n  display: none !important;\n}\n.sortable-opposite .sortable-handler {\n  left: var(--f7-safe-area-right);\n  right: auto;\n}\n.sortable-opposite .sortable-handler:after {\n  transform: translateX(-10px);\n}\n.sortable:not(.sortable-opposite) .item-inner,\n.sortable-opposite .item-content,\n.sortable.simple-list li,\n.sortable-opposite.links-list li a {\n  transition-duration: 300ms;\n  transition-property: all;\n}\n.sortable-sorting li {\n  transition-duration: 300ms;\n}\n.sortable-enabled li:not(.no-sorting):not(.disallow-sorting) .sortable-handler {\n  pointer-events: auto;\n  opacity: 1;\n}\n.sortable-enabled li:not(.no-sorting):not(.disallow-sorting) .sortable-handler:after {\n  transform: translateX(0px);\n}\n.sortable-enabled:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting) .item-link .item-inner:before,\n.sortable-enabled:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting) .item-link .item-title-row:before,\n.sortable-enabled:not(.sortable-opposite).links-list li:not(.no-sorting):not(.disallow-sorting) > a:before {\n  display: none;\n}\n.sortable-enabled:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting) .item-inner,\n.sortable-enabled:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting) .item-link .item-inner,\n.sortable-enabled:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting) .item-link.no-chevron .item-inner,\n.sortable-enabled.no-chevron:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting) .item-link .item-inner,\n.sortable-enabled :not(.sortable-opposite).no-chevron .item-link .item-inner,\n.no-chevron .sortable-enabled:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting) .item-link .item-inner,\n.simple-list.sortable-enabled:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting),\n.links-list.sortable-enabled:not(.sortable-opposite) li:not(.no-sorting):not(.disallow-sorting) a {\n  padding-right: calc(var(--f7-sortable-handler-width) + var(--f7-safe-area-right));\n}\n.sortable-opposite.sortable-enabled li:not(.no-sorting):not(.disallow-sorting) .item-content,\n.simple-list.sortable-opposite.sortable-enabled li:not(.no-sorting):not(.disallow-sorting),\n.links-list.sortable-opposite.sortable-enabled li:not(.no-sorting):not(.disallow-sorting) a {\n  padding-left: calc(var(--f7-sortable-handler-width) + var(--f7-safe-area-right));\n}\n.ios .sortable-handler:after {\n  content: 'sort_ios';\n}\n.md .sortable-handler:after {\n  content: 'sort_md';\n}\n.aurora .sortable-handler:after {\n  content: 'sort_md';\n  font-size: 16px;\n  height: 16px;\n}\n/* === Swipeout === */\n:root {\n  --f7-swipeout-button-text-color: #fff;\n  --f7-swipeout-delete-button-bg-color: #ff3b30;\n  --f7-swipeout-button-font-size: inherit;\n  --f7-swipeout-button-font-weight: inherit;\n  --f7-swipeout-button-bg-color: rgba(0, 0, 0, 0.22);\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-swipeout-button-bg-color: rgba(255, 255, 255, 0.55);\n}\n.ios {\n  --f7-swipeout-button-padding: 0 30px;\n}\n.md {\n  --f7-swipeout-button-padding: 0 24px;\n}\n.aurora {\n  --f7-swipeout-button-padding: 0 12px;\n  --f7-swipeout-button-font-weight: 500;\n}\n.swipeout {\n  overflow: hidden;\n  transform-style: preserve-3d;\n}\n.swipeout-deleting {\n  transition-duration: 300ms;\n}\n.swipeout-deleting .swipeout-content {\n  transform: translateX(-100%);\n}\n.swipeout-transitioning .swipeout-content,\n.swipeout-transitioning .swipeout-actions-right a,\n.swipeout-transitioning .swipeout-actions-left a,\n.swipeout-transitioning .swipeout-overswipe {\n  transition-duration: 300ms;\n  transition-property: transform, left;\n}\n.swipeout-content {\n  position: relative;\n  z-index: 10;\n}\n.swipeout-overswipe {\n  transition-duration: 200ms;\n  transition-property: left;\n}\n.swipeout-actions-left,\n.swipeout-actions-right {\n  position: absolute;\n  top: 0;\n  height: 100%;\n  display: flex;\n  direction: ltr;\n}\n.swipeout-actions-left > a,\n.swipeout-actions-right > a,\n.swipeout-actions-left > button,\n.swipeout-actions-right > button,\n.swipeout-actions-left > span,\n.swipeout-actions-right > span,\n.swipeout-actions-left > div,\n.swipeout-actions-right > div {\n  color: var(--f7-swipeout-button-text-color);\n  background: var(--f7-swipeout-button-bg-color);\n  padding: var(--f7-swipeout-button-padding);\n  display: flex;\n  align-items: center;\n  position: relative;\n  left: 0;\n  font-size: var(--f7-swipeout-button-font-size);\n  font-weight: var(--f7-swipeout-button-font-weight);\n}\n.swipeout-actions-left > a:after,\n.swipeout-actions-right > a:after,\n.swipeout-actions-left > button:after,\n.swipeout-actions-right > button:after,\n.swipeout-actions-left > span:after,\n.swipeout-actions-right > span:after,\n.swipeout-actions-left > div:after,\n.swipeout-actions-right > div:after {\n  content: '';\n  position: absolute;\n  top: 0;\n  width: 600%;\n  height: 100%;\n  background: inherit;\n  z-index: -1;\n  transform: translate3d(0, 0, 0);\n  pointer-events: none;\n}\n.swipeout-actions-left .swipeout-delete,\n.swipeout-actions-right .swipeout-delete {\n  background: var(--f7-swipeout-delete-button-bg-color);\n}\n.swipeout-actions-right {\n  right: 0%;\n  transform: translateX(100%);\n}\n.swipeout-actions-right > a:after,\n.swipeout-actions-right > button:after,\n.swipeout-actions-right > span:after,\n.swipeout-actions-right > div:after {\n  left: 100%;\n  margin-left: -1px;\n}\n.swipeout-actions-left {\n  left: 0%;\n  transform: translateX(-100%);\n}\n.swipeout-actions-left > a:after,\n.swipeout-actions-left > button:after,\n.swipeout-actions-left > span:after,\n.swipeout-actions-left > div:after {\n  right: 100%;\n  margin-right: -1px;\n}\n.swipeout-actions-left [class*=\"color-\"],\n.swipeout-actions-right [class*=\"color-\"] {\n  --f7-swipeout-button-bg-color: var(--f7-theme-color);\n}\n/* === Accordion === */\n:root {\n  --f7-accordion-chevron-icon-down: 'chevron_down';\n  --f7-accordion-chevron-icon-up: 'chevron_up';\n}\n.aurora {\n  --f7-accordion-chevron-icon-down: 'chevron_down_aurora';\n  --f7-accordion-chevron-icon-up: 'chevron_up_aurora';\n}\n.accordion-item-toggle {\n  cursor: pointer;\n}\n.list.accordion-list .accordion-item-toggle {\n  transition-duration: 300ms;\n  position: relative;\n  overflow: hidden;\n}\n.list.accordion-list .accordion-item-toggle.active-state {\n  transition-duration: 300ms;\n  background-color: var(--f7-list-link-pressed-bg-color);\n}\n.list.accordion-list .accordion-item-toggle.active-state > .item-inner:after {\n  background-color: transparent;\n}\n.list.accordion-list .accordion-item-toggle .item-inner {\n  transition-duration: 300ms;\n  transition-property: background-color;\n}\n.list.accordion-list .accordion-item-toggle .item-inner:after {\n  transition-duration: 300ms;\n}\n.list.accordion-list .accordion-item-toggle .ripple-wave {\n  z-index: 0;\n}\n.accordion-item .item-link .item-inner:after {\n  transition-duration: 300ms;\n}\n.accordion-item .list,\n.accordion-item .block {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.accordion-item .block > h1:first-child,\n.accordion-item .block > h2:first-child,\n.accordion-item .block > h3:first-child,\n.accordion-item .block > h4:first-child,\n.accordion-item .block > p:first-child {\n  margin-top: 10px;\n}\n.accordion-item .block > h1:last-child,\n.accordion-item .block > h2:last-child,\n.accordion-item .block > h3:last-child,\n.accordion-item .block > h4:last-child,\n.accordion-item .block > p:last-child {\n  margin-bottom: 10px;\n}\n.accordion-item-opened .accordion-item-toggle .item-inner:after,\n.accordion-item-opened > .item-link .item-inner:after {\n  background-color: transparent;\n}\n.list li.accordion-item ul {\n  padding-left: 0;\n}\n.accordion-item-content {\n  position: relative;\n  overflow: hidden;\n  height: 0;\n  font-size: 14px;\n  transition-duration: 300ms;\n}\n.accordion-item-opened > .accordion-item-content {\n  height: auto;\n}\nhtml.device-android-4 .accordion-item-content {\n  transform: none;\n}\n.list .accordion-item-toggle .item-inner:before {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  position: absolute;\n  top: 50%;\n  font-size: var(--f7-list-chevron-icon-font-size);\n  color: var(--f7-list-chevron-icon-color);\n  pointer-events: none;\n  right: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.list:not(.accordion-opposite) .accordion-item-toggle .item-inner {\n  padding-right: calc(var(--f7-list-chevron-icon-area) + var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.accordion-opposite .accordion-item-toggle.item-link .item-inner,\n.accordion-opposite .accordion-item-toggle .item-inner,\n.accordion-opposite .accordion-item > .item-link > .item-inner,\n.accordion-opposite .accordion-item > .item-link > .item-content > .item-inner {\n  padding-right: calc(var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-right));\n}\n.accordion-opposite .accordion-item > .item-link > .item-title-row {\n  padding-right: 0;\n}\n.accordion-opposite .accordion-item-toggle.item-link .item-inner:before,\n.accordion-opposite .accordion-item-toggle .item-inner:before,\n.accordion-opposite .accordion-item > .item-link > .item-inner:before,\n.accordion-opposite .accordion-item > .item-link > .item-content > .item-inner:before,\n.accordion-opposite .accordion-item > .item-link .item-title-row:before {\n  display: none;\n}\n.accordion-opposite .accordion-item-toggle > .item-content,\n.accordion-opposite .accordion-item-toggle.item-content,\n.accordion-opposite .accordion-item > .item-content,\n.accordion-opposite .accordion-item > .item-link > .item-content,\n.accordion-opposite.links-list .accordion-item > a {\n  position: relative;\n  padding-left: calc(var(--f7-list-chevron-icon-area) + var(--f7-list-item-padding-horizontal) + var(--f7-safe-area-left));\n}\n.accordion-opposite .accordion-item-toggle > .item-content:before,\n.accordion-opposite .accordion-item-toggle.item-content:before,\n.accordion-opposite .accordion-item > .item-content:before,\n.accordion-opposite .accordion-item > .item-link > .item-content:before,\n.accordion-opposite.links-list .accordion-item > a:before {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  position: absolute;\n  top: 50%;\n  font-size: var(--f7-list-chevron-icon-font-size);\n  color: var(--f7-list-chevron-icon-color);\n  pointer-events: none;\n  content: var(--f7-accordion-chevron-icon-down);\n  width: 14px;\n  height: 8px;\n  margin-top: -4px;\n  line-height: 8px;\n  transform: translateX(-50%);\n  left: calc((var(--f7-list-chevron-icon-area) + var(--f7-list-item-padding-horizontal)) / 2 + var(--f7-safe-area-left));\n}\n.list .accordion-item-toggle.active-state {\n  background-color: var(--f7-list-link-pressed-bg-color);\n}\n.list .accordion-item-toggle .item-inner:before,\n.list:not(.media-list) .accordion-item:not(.media-item) .accordion-item-toggle .item-inner:before,\n.list:not(.media-list) .accordion-item:not(.media-item) > .item-link .item-inner:before,\n.media-list .accordion-item .accordion-item-toggle .item-title-row:before,\n.media-list .accordion-item > .item-link .item-title-row:before,\n.accordion-item.media-item .accordion-item-toggle .item-title-row:before,\n.accordion-item.media-item > .item-link .item-title-row:before,\n.links-list .accordion-item > a:before {\n  content: var(--f7-accordion-chevron-icon-down);\n  width: 14px;\n  height: 8px;\n  margin-top: -4px;\n  line-height: 8px;\n}\n.list .accordion-item-toggle.accordion-item-opened .item-inner:before,\n.list:not(.media-list) .accordion-item-opened:not(.media-item) .accordion-item-toggle .item-inner:before,\n.list:not(.media-list) .accordion-item-opened:not(.media-item) > .item-link .item-inner:before,\n.media-list .accordion-item-opened .accordion-item-toggle .item-title-row:before,\n.media-list .accordion-item-opened > .item-link .item-title-row:before,\n.accordion-item-opened.media-item .accordion-item-toggle .item-title-row:before,\n.accordion-item-opened.media-item > .item-link .item-title-row:before,\n.links-list .accordion-item-opened > a:before,\n.accordion-opposite .accordion-item-opened .accordion-item-toggle > .item-content:before,\n.accordion-opposite .accordion-item-opened .accordion-item-toggle.item-content:before,\n.accordion-opposite .accordion-item-opened > .item-content:before,\n.accordion-opposite .accordion-item-opened > .item-link > .item-content:before,\n.accordion-opposite .links-list .accordion-item-opened > a:before {\n  content: var(--f7-accordion-chevron-icon-up);\n  width: 14px;\n  height: 8px;\n  margin-top: -4px;\n  line-height: 8px;\n}\n/* === Contacts === */\n:root .theme-dark,\n:root.theme-dark {\n  --f7-contacts-list-title-text-color: #fff;\n}\n.ios {\n  --f7-contacts-list-title-font-size: inherit;\n  --f7-contacts-list-title-font-weight: 600;\n  --f7-contacts-list-title-height: 22px;\n  --f7-contacts-list-title-text-color: #000;\n  --f7-contacts-list-title-bg-color: #f7f7f7;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-contacts-list-title-bg-color: #323234;\n}\n.md {\n  --f7-contacts-list-title-font-size: 20px;\n  --f7-contacts-list-title-font-weight: 500;\n  /*\n  --f7-contacts-list-title-text-color: var(--f7-theme-color);\n  */\n  --f7-contacts-list-title-height: 48px;\n  --f7-contacts-list-title-bg-color: transparent;\n}\n.aurora {\n  --f7-contacts-list-title-font-weight: 600;\n  --f7-contacts-list-title-text-color: #000;\n  /*\n  --f7-contacts-list-title-bg-color: var(--f7-list-group-title-bg-color);\n  --f7-contacts-list-title-font-size: var(--f7-list-group-title-font-size);\n  --f7-contacts-list-title-line-height: var(--f7-list-group-title-height);\n  --f7-contacts-list-title-height: var(--f7-list-group-title-height);\n  */\n}\n.contacts-list {\n  --f7-list-margin-vertical: 0px;\n}\n.contacts-list .list-group-title,\n.contacts-list li.list-group-title {\n  background-color: var(--f7-contacts-list-title-bg-color, var(--f7-list-group-title-bg-color));\n  font-weight: var(--f7-contacts-list-title-font-weight, var(--f7-list-group-title-font-weight));\n  font-size: var(--f7-contacts-list-title-font-size, var(--f7-list-group-title-font-size));\n  color: var(--f7-contacts-list-title-text-color, var(--f7-theme-color));\n  line-height: var(--f7-contacts-list-title-height, var(--f7-list-group-title-height));\n  height: var(--f7-contacts-list-title-height, var(--f7-list-group-title-height));\n}\n.contacts-list .list-group:first-child ul:before {\n  display: none !important;\n}\n.contacts-list .list-group:last-child ul:after {\n  display: none !important;\n}\n.md .contacts-list .list-group-title {\n  pointer-events: none;\n  overflow: visible;\n  width: 56px;\n}\n.md .contacts-list .list-group-title + li {\n  margin-top: calc(var(--f7-contacts-list-title-height) * -1);\n}\n.md .contacts-list li:not(.list-group-title) {\n  padding-left: 56px;\n}\n/* === Virtual List === */\n/* === Indexed List === */\n:root {\n  --f7-list-index-width: 16px;\n  --f7-list-index-font-size: 11px;\n  --f7-list-index-font-weight: 600;\n  /* --f7-list-index-text-color: var(--f7-theme-color); */\n  --f7-list-index-item-height: 14px;\n  --f7-list-index-label-text-color: #fff;\n  /* --f7-list-index-label-bg-color: var(--f7-theme-color); */\n  --f7-list-index-label-font-weight: 500;\n}\n.ios {\n  --f7-list-index-label-size: 44px;\n  --f7-list-index-label-font-size: 17px;\n  --f7-list-index-skip-dot-size: 6px;\n}\n.md {\n  --f7-list-index-label-size: 56px;\n  --f7-list-index-label-font-size: 20px;\n  --f7-list-index-skip-dot-size: 4px;\n}\n.aurora {\n  --f7-list-index-font-size: 12px;\n  --f7-list-index-label-size: 32px;\n  --f7-list-index-label-font-size: 12px;\n  --f7-list-index-label-font-weight: 600;\n  --f7-list-index-skip-dot-size: 4px;\n}\n.list-index {\n  position: absolute;\n  top: 0;\n  bottom: 0;\n  text-align: center;\n  z-index: 10;\n  width: var(--f7-list-index-width);\n  cursor: pointer;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  right: var(--f7-safe-area-right);\n}\n.list-index:before {\n  content: '';\n  position: absolute;\n  width: 20px;\n  top: 0;\n  right: 100%;\n  height: 100%;\n}\n.list-index ul {\n  color: var(--f7-list-index-text-color, var(--f7-theme-color));\n  font-size: var(--f7-list-index-font-size);\n  font-weight: var(--f7-list-index-font-weight);\n  list-style: none;\n  margin: 0;\n  padding: 0;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n  align-items: center;\n  flex-shrink: 0;\n  height: 100%;\n  width: 100%;\n  position: relative;\n}\n.list-index li {\n  margin: 0;\n  padding: 0;\n  list-style: none;\n  position: relative;\n  height: var(--f7-list-index-item-height);\n  line-height: var(--f7-list-index-item-height);\n  flex-shrink: 0;\n  display: block;\n  width: 100%;\n}\n.list-index .list-index-skip-placeholder:after {\n  content: '';\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  border-radius: 50%;\n  width: var(--f7-list-index-skip-dot-size);\n  height: var(--f7-list-index-skip-dot-size);\n  margin-left: calc(-1 * var(--f7-list-index-skip-dot-size) / 2);\n  margin-top: calc(-1 * var(--f7-list-index-skip-dot-size) / 2);\n  background: var(--f7-list-index-text-color, var(--f7-theme-color));\n}\n.list-index .list-index-label {\n  position: absolute;\n  bottom: 0;\n  right: 100%;\n  text-align: center;\n  background-color: var(--f7-list-index-label-bg-color, var(--f7-theme-color));\n  color: var(--f7-list-index-label-text-color);\n  width: var(--f7-list-index-label-size);\n  height: var(--f7-list-index-label-size);\n  line-height: var(--f7-list-index-label-size);\n  font-size: var(--f7-list-index-label-font-size);\n  font-weight: var(--f7-list-index-label-font-weight);\n}\n.navbar ~ .page > .list-index,\n.navbars ~ .page > .list-index,\n.navbar ~ .list-index {\n  top: var(--f7-navbar-height);\n}\n.navbar ~ .toolbar-top ~ .list-index,\n.navbars ~ .toolbar-top ~ .list-index,\n.ios .navbar ~ .toolbar-top-ios ~ .list-index,\n.ios .navbars ~ .toolbar-top-ios .md .navbar ~ .toolbar-top-md ~ .list-index {\n  top: calc(var(--f7-navbar-height) + var(--f7-toolbar-height));\n}\n.navbar ~ .toolbar-top.tabbar-labels ~ .list-index,\n.navbars ~ .toolbar-top.tabbar-labels ~ .list-index,\n.ios .navbar ~ .toolbar-top-ios.tabbar-labels ~ .list-index,\n.ios .navbars ~ .toolbar-top-ios .md .navbar ~ .toolbar-top-md.tabbar-labels ~ .list-index {\n  top: calc(var(--f7-navbar-height) + var(--f7-tabbar-labels-height));\n}\n.navbar ~ .subnavbar ~ .list-index,\n.navbars ~ .subnavbar ~ .list-index,\n.page-with-subnavbar .navbar ~ .list-index {\n  top: calc(var(--f7-navbar-height) + var(--f7-subnavbar-height));\n}\n.toolbar-bottom ~ .page > .list-index,\n.ios .toolbar-bottom-ios ~ .page > .list-index,\n.md .toolbar-bottom-md ~ .page > .list-index,\n.toolbar-bottom ~ * .page > .list-index,\n.ios .toolbar-bottom-ios ~ * .page > .list-index,\n.md .toolbar-bottom-md ~ * .page > .list-index,\n.toolbar-bottom ~ .list-index,\n.ios .toolbar-bottom-ios ~ .list-index,\n.md .toolbar-bottom-md ~ .list-index {\n  bottom: calc(var(--f7-toolbar-height) + var(--f7-safe-area-bottom));\n}\n.toolbar-bottom.tabbar-labels ~ .page > .list-index,\n.ios .toolbar-bottom-ios.tabbar-labels ~ .page > .list-index,\n.md .toolbar-bottom-md.tabbar-labels ~ .page > .list-index,\n.toolbar-bottom.tabbar-labels ~ * .page > .list-index,\n.ios .toolbar-bottom-ios.tabbar-labels ~ * .page > .list-index,\n.md .toolbar-bottom-md.tabbar-labels ~ * .page > .list-index,\n.toolbar-bottom.tabbar-labels ~ .list-index,\n.ios .toolbar-bottom-ios.tabbar-labels ~ .list-index,\n.md .toolbar-bottom-md.tabbar-labels ~ .list-index {\n  bottom: calc(var(--f7-tabbar-labels-height) + var(--f7-safe-area-bottom));\n}\n.ios .list-index .list-index-label {\n  margin-bottom: calc(-1 * var(--f7-list-index-label-size) / 2);\n  margin-right: calc(var(--f7-list-index-width) - 1px);\n  border-radius: 50%;\n}\n.ios .list-index .list-index-label:before {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  border-radius: 50% 0% 50% 50%;\n  content: '';\n  background-color: inherit;\n  left: 0;\n  top: 0;\n  transform: rotate(45deg);\n  z-index: -1;\n}\n.md .list-index .list-index-label {\n  border-radius: 50% 50% 0 50%;\n}\n.aurora .list-index .list-index-label {\n  margin-bottom: calc(-1 * var(--f7-list-index-label-size) / 2);\n  margin-right: calc(var(--f7-list-index-width) - 1px);\n  border-radius: 50%;\n}\n.aurora .list-index .list-index-label:before {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  border-radius: 50% 1px 50% 50%;\n  content: '';\n  background-color: inherit;\n  left: 0;\n  top: 0;\n  transform: rotate(45deg);\n  z-index: -1;\n}\n/* === Timeline === */\n:root {\n  --f7-timeline-inner-block-margin-vertical: 16px;\n  --f7-timeline-divider-margin-horizontal: 16px;\n  --f7-timeline-horizontal-date-height: 34px;\n  --f7-timeline-year-height: 24px;\n  --f7-timeline-year-font-weight: inherit;\n  --f7-timeline-month-height: 24px;\n  --f7-timeline-month-font-size: inherit;\n  --f7-timeline-month-font-weight: inherit;\n  --f7-timeline-item-text-font-weight: inherit;\n  --f7-timeline-item-subtitle-font-weight: inherit;\n  --f7-timeline-item-inner-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-timeline-item-inner-bg-color: #1c1c1d;\n  --f7-timeline-horizontal-item-border-color: rgba(255, 255, 255, 0.15);\n  --f7-timeline-horizontal-item-date-border-color: rgba(255, 255, 255, 0.15);\n}\n.ios {\n  --f7-timeline-padding-horizontal: 16px;\n  --f7-timeline-margin-vertical: 35px;\n  --f7-timeline-item-inner-border-radius: 7px;\n  --f7-timeline-item-inner-box-shadow: none;\n  --f7-timeline-item-time-font-size: 13px;\n  --f7-timeline-item-title-font-size: 17px;\n  --f7-timeline-item-title-line-height: inherit;\n  --f7-timeline-item-title-font-weight: 600;\n  --f7-timeline-item-subtitle-font-size: 15px;\n  --f7-timeline-item-subtitle-line-height: inherit;\n  --f7-timeline-item-text-font-size: inherit;\n  --f7-timeline-item-text-color: inherit;\n  --f7-timeline-item-text-line-height: inherit;\n  --f7-timeline-year-font-size: 16px;\n  --f7-timeline-horizontal-item-padding: 10px;\n  --f7-timeline-horizontal-item-date-shadow-image: none;\n  --f7-timeline-item-time-text-color: rgba(0, 0, 0, 0.45);\n  --f7-timeline-horizontal-item-border-color: rgba(0, 0, 0, 0.22);\n  --f7-timeline-horizontal-item-date-border-color: rgba(0, 0, 0, 0.22);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-timeline-item-time-text-color: rgba(255, 255, 255, 0.55);\n}\n.md {\n  --f7-timeline-padding-horizontal: 16px;\n  --f7-timeline-margin-vertical: 32px;\n  --f7-timeline-item-inner-border-radius: 4px;\n  --f7-timeline-item-inner-box-shadow: var(--f7-elevation-1);\n  --f7-timeline-item-time-font-size: 13px;\n  --f7-timeline-item-title-font-size: 16px;\n  --f7-timeline-item-title-line-height: inherit;\n  --f7-timeline-item-title-font-weight: 400;\n  --f7-timeline-item-subtitle-font-size: inherit;\n  --f7-timeline-item-subtitle-line-height: inherit;\n  --f7-timeline-item-text-font-size: inherit;\n  --f7-timeline-item-text-line-height: inherit;\n  --f7-timeline-item-text-color: inherit;\n  --f7-timeline-year-font-size: 16px;\n  --f7-timeline-horizontal-item-padding: 12px;\n  --f7-timeline-horizontal-item-date-shadow-image: var(--f7-bars-shadow-bottom-image);\n  --f7-timeline-item-time-text-color: rgba(0, 0, 0, 0.54);\n  --f7-timeline-horizontal-item-border-color: rgba(0, 0, 0, 0.12);\n  --f7-timeline-horizontal-item-date-border-color: transparent;\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-timeline-item-time-text-color: rgba(255, 255, 255, 0.54);\n}\n.aurora {\n  --f7-timeline-padding-horizontal: 10px;\n  --f7-timeline-margin-vertical: 15px;\n  --f7-timeline-item-inner-border-radius: 4px;\n  --f7-timeline-item-inner-box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.15);\n  --f7-timeline-item-time-font-size: 12px;\n  --f7-timeline-item-title-font-size: 14px;\n  --f7-timeline-item-title-line-height: 1.3;\n  --f7-timeline-item-title-font-weight: 600;\n  --f7-timeline-item-subtitle-font-size: 14px;\n  --f7-timeline-item-subtitle-line-height: 1.3;\n  --f7-timeline-item-text-font-size: 12px;\n  --f7-timeline-item-text-line-height: 1.33;\n  --f7-timeline-year-font-size: 14px;\n  --f7-timeline-year-font-weight: 500;\n  --f7-timeline-horizontal-item-padding: 10px;\n  --f7-timeline-horizontal-item-date-shadow-image: none;\n  --f7-timeline-item-time-text-color: rgba(0, 0, 0, 0.5);\n  --f7-timeline-item-text-color: rgba(0, 0, 0, 0.6);\n  --f7-timeline-horizontal-item-border-color: rgba(0, 0, 0, 0.2);\n  --f7-timeline-horizontal-item-date-border-color: rgba(0, 0, 0, 0.2);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-timeline-item-time-text-color: rgba(255, 255, 255, 0.54);\n  --f7-timeline-item-text-color: rgba(255, 255, 255, 0.54);\n}\n.timeline {\n  box-sizing: border-box;\n  margin: var(--f7-timeline-margin-vertical) 0;\n  padding: 0 var(--f7-timeline-padding-horizontal);\n  padding-top: 0;\n  padding-bottom: 0;\n  padding-left: calc(var(--f7-timeline-padding-horizontal) + var(--f7-safe-area-left));\n  padding-right: calc(var(--f7-timeline-padding-horizontal) + var(--f7-safe-area-right));\n}\n.block-strong .timeline {\n  padding: 0;\n  margin: 0;\n}\n.timeline-item {\n  display: flex;\n  justify-content: flex-start;\n  overflow: hidden;\n  box-sizing: border-box;\n  position: relative;\n  padding: 2px 0px var(--f7-timeline-padding-horizontal);\n}\n.timeline-item:last-child {\n  padding-bottom: 2px;\n}\n.timeline-item-date {\n  flex-shrink: 0;\n  width: 50px;\n  text-align: right;\n  box-sizing: border-box;\n}\n.timeline-item-date small {\n  font-size: 10px;\n}\n.timeline-item-content {\n  margin: 2px;\n  min-width: 0;\n  position: relative;\n  flex-shrink: 10;\n}\n.timeline-item-content .card,\n.timeline-item-content.card,\n.timeline-item-content .list,\n.timeline-item-content.list,\n.timeline-item-content .block,\n.timeline-item-content.block {\n  margin: 0;\n  width: 100%;\n}\n.timeline-item-content .card + .card,\n.timeline-item-content .list + .card,\n.timeline-item-content .block + .card,\n.timeline-item-content .card + .list,\n.timeline-item-content .list + .list,\n.timeline-item-content .block + .list,\n.timeline-item-content .card + .block,\n.timeline-item-content .list + .block,\n.timeline-item-content .block + .block {\n  margin: var(--f7-timeline-inner-block-margin-vertical) 0 0;\n}\n.timeline-item-content p:first-child,\n.timeline-item-content ul:first-child,\n.timeline-item-content ol:first-child,\n.timeline-item-content h1:first-child,\n.timeline-item-content h2:first-child,\n.timeline-item-content h3:first-child,\n.timeline-item-content h4:first-child {\n  margin-top: 0;\n}\n.timeline-item-content p:last-child,\n.timeline-item-content ul:last-child,\n.timeline-item-content ol:last-child,\n.timeline-item-content h1:last-child,\n.timeline-item-content h2:last-child,\n.timeline-item-content h3:last-child,\n.timeline-item-content h4:last-child {\n  margin-bottom: 0;\n}\n.timeline-item-inner {\n  background: var(--f7-timeline-item-inner-bg-color);\n  box-sizing: border-box;\n  border-radius: var(--f7-timeline-item-inner-border-radius);\n  padding: 8px var(--f7-timeline-padding-horizontal);\n  box-shadow: var(--f7-timeline-item-inner-box-shadow);\n}\n.timeline-item-inner + .timeline-item-inner {\n  margin-top: var(--f7-timeline-inner-block-margin-vertical);\n}\n.timeline-item-inner .block {\n  padding: 0;\n  color: inherit;\n}\n.timeline-item-inner .block-strong {\n  padding-left: 0;\n  padding-right: 0;\n  margin: 0;\n}\n.timeline-item-inner .block-strong:before,\n.timeline-item-inner .block-strong:after {\n  display: none !important;\n}\n.timeline-item-inner .list ul:before,\n.timeline-item-inner .list ul:after {\n  display: none !important;\n}\n.timeline-item-divider {\n  width: 1px;\n  position: relative;\n  width: 10px;\n  height: 10px;\n  background: #bbb;\n  border-radius: 50%;\n  flex-shrink: 0;\n  margin: 3px var(--f7-timeline-divider-margin-horizontal) 0;\n}\n.timeline-item-divider:after,\n.timeline-item-divider:before {\n  content: ' ';\n  width: 1px;\n  height: 100vh;\n  position: absolute;\n  left: 50%;\n  background: inherit;\n  transform: translate3d(-50%, 0, 0);\n}\n.timeline-item-divider:after {\n  top: 100%;\n}\n.timeline-item-divider:before {\n  bottom: 100%;\n}\n.timeline-item:last-child .timeline-item-divider:after {\n  display: none;\n}\n.timeline-item:first-child .timeline-item-divider:before {\n  display: none;\n}\n.timeline-item-time {\n  font-size: var(--f7-timeline-item-time-font-size);\n  margin-top: var(--f7-timeline-inner-block-margin-vertical);\n  color: var(--f7-timeline-item-time-text-color);\n}\n.timeline-item-time:first-child,\n.timeline-item-time:last-child {\n  margin-top: 0;\n}\n.timeline-item-title + .timeline-item-time {\n  margin-top: 0;\n}\n.timeline-item-title {\n  font-size: var(--f7-timeline-item-title-font-size);\n  font-weight: var(--f7-timeline-item-title-font-weight);\n  line-height: var(--f7-timeline-item-title-line-height);\n}\n.timeline-item-subtitle {\n  font-size: var(--f7-timeline-item-subtitle-font-size);\n  font-weight: var(--f7-timeline-item-subtitle-font-weight);\n  line-height: var(--f7-timeline-item-subtitle-line-height);\n}\n.timeline-item-text {\n  color: var(--f7-timeline-item-text-color);\n  font-size: var(--f7-timeline-item-text-font-size);\n  font-weight: var(--f7-timeline-item-text-font-weight);\n  line-height: var(--f7-timeline-item-text-line-height);\n}\n.timeline-sides .timeline-item-right,\n.timeline-sides .timeline-item {\n  margin-left: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n  margin-right: 0;\n}\n.timeline-sides .timeline-item-right .timeline-item-date,\n.timeline-sides .timeline-item .timeline-item-date {\n  text-align: right;\n}\n.timeline-sides .timeline-item-left,\n.timeline-sides .timeline-item:not(.timeline-item-right):nth-child(2n) {\n  flex-direction: row-reverse;\n  margin-right: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n  margin-left: 0;\n}\n.timeline-sides .timeline-item-left .timeline-item-date,\n.timeline-sides .timeline-item:not(.timeline-item-right):nth-child(2n) .timeline-item-date {\n  text-align: left;\n}\n@media (min-width: 480px) {\n  .xsmall-sides .timeline-item-right,\n  .xsmall-sides .timeline-item {\n    margin-left: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-right: 0;\n  }\n  .xsmall-sides .timeline-item-right .timeline-item-date,\n  .xsmall-sides .timeline-item .timeline-item-date {\n    text-align: right;\n  }\n  .xsmall-sides .timeline-item-left,\n  .xsmall-sides .timeline-item:not(.timeline-item-right):nth-child(2n) {\n    flex-direction: row-reverse;\n    margin-right: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-left: 0;\n  }\n  .xsmall-sides .timeline-item-left .timeline-item-date,\n  .xsmall-sides .timeline-item:not(.timeline-item-right):nth-child(2n) .timeline-item-date {\n    text-align: left;\n  }\n}\n@media (min-width: 568px) {\n  .small-sides .timeline-item-right,\n  .small-sides .timeline-item {\n    margin-left: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-right: 0;\n  }\n  .small-sides .timeline-item-right .timeline-item-date,\n  .small-sides .timeline-item .timeline-item-date {\n    text-align: right;\n  }\n  .small-sides .timeline-item-left,\n  .small-sides .timeline-item:not(.timeline-item-right):nth-child(2n) {\n    flex-direction: row-reverse;\n    margin-right: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-left: 0;\n  }\n  .small-sides .timeline-item-left .timeline-item-date,\n  .small-sides .timeline-item:not(.timeline-item-right):nth-child(2n) .timeline-item-date {\n    text-align: left;\n  }\n}\n@media (min-width: 768px) {\n  .medium-sides .timeline-item-right,\n  .medium-sides .timeline-item {\n    margin-left: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-right: 0;\n  }\n  .medium-sides .timeline-item-right .timeline-item-date,\n  .medium-sides .timeline-item .timeline-item-date {\n    text-align: right;\n  }\n  .medium-sides .timeline-item-left,\n  .medium-sides .timeline-item:not(.timeline-item-right):nth-child(2n) {\n    flex-direction: row-reverse;\n    margin-right: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-left: 0;\n  }\n  .medium-sides .timeline-item-left .timeline-item-date,\n  .medium-sides .timeline-item:not(.timeline-item-right):nth-child(2n) .timeline-item-date {\n    text-align: left;\n  }\n}\n@media (min-width: 1024px) {\n  .large-sides .timeline-item-right,\n  .large-sides .timeline-item {\n    margin-left: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-right: 0;\n  }\n  .large-sides .timeline-item-right .timeline-item-date,\n  .large-sides .timeline-item .timeline-item-date {\n    text-align: right;\n  }\n  .large-sides .timeline-item-left,\n  .large-sides .timeline-item:not(.timeline-item-right):nth-child(2n) {\n    flex-direction: row-reverse;\n    margin-right: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-left: 0;\n  }\n  .large-sides .timeline-item-left .timeline-item-date,\n  .large-sides .timeline-item:not(.timeline-item-right):nth-child(2n) .timeline-item-date {\n    text-align: left;\n  }\n}\n@media (min-width: 1200px) {\n  .xlarge-sides .timeline-item-right,\n  .xlarge-sides .timeline-item {\n    margin-left: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-right: 0;\n  }\n  .xlarge-sides .timeline-item-right .timeline-item-date,\n  .xlarge-sides .timeline-item .timeline-item-date {\n    text-align: right;\n  }\n  .xlarge-sides .timeline-item-left,\n  .xlarge-sides .timeline-item:not(.timeline-item-right):nth-child(2n) {\n    flex-direction: row-reverse;\n    margin-right: calc(50% - (var(--f7-timeline-divider-margin-horizontal) * 2 + 10px) / 2 - 50px);\n    margin-left: 0;\n  }\n  .xlarge-sides .timeline-item-left .timeline-item-date,\n  .xlarge-sides .timeline-item:not(.timeline-item-right):nth-child(2n) .timeline-item-date {\n    text-align: left;\n  }\n}\n.timeline-horizontal {\n  height: 100%;\n  display: flex;\n  padding: 0;\n  margin: 0;\n  position: relative;\n  padding-left: var(--f7-safe-area-left);\n  padding-right: 0;\n}\n.timeline-horizontal .timeline-item {\n  display: block;\n  width: 33.33333333vw;\n  margin: 0;\n  padding: 0;\n  flex-shrink: 0;\n  position: relative;\n  height: 100%;\n  padding-top: var(--f7-timeline-horizontal-date-height) !important;\n  padding-bottom: var(--f7-timeline-horizontal-item-padding);\n}\n.timeline-horizontal .timeline-item:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-timeline-horizontal-item-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: 0;\n  bottom: auto;\n  left: auto;\n  width: 1px;\n  height: 100%;\n  transform-origin: 100% 50%;\n  transform: scaleX(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.timeline-horizontal .timeline-item-date {\n  padding: 0px var(--f7-timeline-horizontal-item-padding);\n  width: auto;\n  line-height: var(--f7-timeline-horizontal-date-height);\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: var(--f7-timeline-horizontal-date-height);\n  background-color: var(--f7-bars-bg-color);\n  color: var(--f7-bars-text-color);\n  text-align: left;\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-bars .timeline-horizontal .timeline-item-date {\n    background-color: rgba(var(--f7-bars-bg-color-rgb), var(--f7-bars-translucent-opacity));\n    -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n            backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n  }\n}\n.timeline-horizontal .timeline-item-date:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-timeline-horizontal-item-date-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.timeline-horizontal .timeline-item-date:before {\n  content: '';\n  position: absolute;\n  right: 0;\n  width: 100%;\n  top: 100%;\n  bottom: auto;\n  height: 8px;\n  pointer-events: none;\n  background: var(--f7-timeline-horizontal-item-date-shadow-image);\n}\n.timeline-horizontal.no-shadow .timeline-item-date:before {\n  display: none;\n}\n.timeline-horizontal .timeline-item-content {\n  padding: var(--f7-timeline-horizontal-item-padding);\n  height: calc(100% - var(--f7-timeline-horizontal-item-padding));\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  margin: 0;\n}\n.timeline-horizontal .timeline-item-divider {\n  display: none;\n}\n.timeline-horizontal > .timeline-item:last-child:after,\n.timeline-horizontal .timeline-month:last-child .timeline-item:last-child:after {\n  display: none !important;\n}\n.timeline-horizontal.col-5 .timeline-item {\n  width: 5vw;\n}\n.timeline-horizontal.col-10 .timeline-item {\n  width: 10vw;\n}\n.timeline-horizontal.col-15 .timeline-item {\n  width: 15vw;\n}\n.timeline-horizontal.col-20 .timeline-item {\n  width: 20vw;\n}\n.timeline-horizontal.col-25 .timeline-item {\n  width: 25vw;\n}\n.timeline-horizontal.col-30 .timeline-item {\n  width: 30vw;\n}\n.timeline-horizontal.col-33 .timeline-item {\n  width: 33.333333333333336vw;\n}\n.timeline-horizontal.col-35 .timeline-item {\n  width: 35vw;\n}\n.timeline-horizontal.col-40 .timeline-item {\n  width: 40vw;\n}\n.timeline-horizontal.col-45 .timeline-item {\n  width: 45vw;\n}\n.timeline-horizontal.col-50 .timeline-item {\n  width: 50vw;\n}\n.timeline-horizontal.col-55 .timeline-item {\n  width: 55vw;\n}\n.timeline-horizontal.col-60 .timeline-item {\n  width: 60vw;\n}\n.timeline-horizontal.col-65 .timeline-item {\n  width: 65vw;\n}\n.timeline-horizontal.col-66 .timeline-item {\n  width: 66.66666666666666vw;\n}\n.timeline-horizontal.col-70 .timeline-item {\n  width: 70vw;\n}\n.timeline-horizontal.col-75 .timeline-item {\n  width: 75vw;\n}\n.timeline-horizontal.col-80 .timeline-item {\n  width: 80vw;\n}\n.timeline-horizontal.col-85 .timeline-item {\n  width: 85vw;\n}\n.timeline-horizontal.col-90 .timeline-item {\n  width: 90vw;\n}\n.timeline-horizontal.col-95 .timeline-item {\n  width: 95vw;\n}\n.timeline-horizontal.col-100 .timeline-item {\n  width: 100vw;\n}\n@media (min-width: 768px) {\n  .timeline-horizontal.tablet-5 .timeline-item {\n    width: 5vw;\n  }\n  .timeline-horizontal.tablet-10 .timeline-item {\n    width: 10vw;\n  }\n  .timeline-horizontal.tablet-15 .timeline-item {\n    width: 15vw;\n  }\n  .timeline-horizontal.tablet-20 .timeline-item {\n    width: 20vw;\n  }\n  .timeline-horizontal.tablet-25 .timeline-item {\n    width: 25vw;\n  }\n  .timeline-horizontal.tablet-30 .timeline-item {\n    width: 30vw;\n  }\n  .timeline-horizontal.tablet-33 .timeline-item {\n    width: 33.333333333333336vw;\n  }\n  .timeline-horizontal.tablet-35 .timeline-item {\n    width: 35vw;\n  }\n  .timeline-horizontal.tablet-40 .timeline-item {\n    width: 40vw;\n  }\n  .timeline-horizontal.tablet-45 .timeline-item {\n    width: 45vw;\n  }\n  .timeline-horizontal.tablet-50 .timeline-item {\n    width: 50vw;\n  }\n  .timeline-horizontal.tablet-55 .timeline-item {\n    width: 55vw;\n  }\n  .timeline-horizontal.tablet-60 .timeline-item {\n    width: 60vw;\n  }\n  .timeline-horizontal.tablet-65 .timeline-item {\n    width: 65vw;\n  }\n  .timeline-horizontal.tablet-66 .timeline-item {\n    width: 66.66666666666666vw;\n  }\n  .timeline-horizontal.tablet-70 .timeline-item {\n    width: 70vw;\n  }\n  .timeline-horizontal.tablet-75 .timeline-item {\n    width: 75vw;\n  }\n  .timeline-horizontal.tablet-80 .timeline-item {\n    width: 80vw;\n  }\n  .timeline-horizontal.tablet-85 .timeline-item {\n    width: 85vw;\n  }\n  .timeline-horizontal.tablet-90 .timeline-item {\n    width: 90vw;\n  }\n  .timeline-horizontal.tablet-95 .timeline-item {\n    width: 95vw;\n  }\n  .timeline-horizontal.tablet-100 .timeline-item {\n    width: 100vw;\n  }\n}\n.timeline-year {\n  padding-top: var(--f7-timeline-year-height);\n}\n.timeline-year:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-timeline-horizontal-item-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: 0;\n  bottom: auto;\n  left: auto;\n  width: 1px;\n  height: 100%;\n  transform-origin: 100% 50%;\n  transform: scaleX(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.timeline-year:last-child:after {\n  display: none !important;\n}\n.timeline-month {\n  padding-top: var(--f7-timeline-month-height);\n}\n.timeline-month .timeline-item:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-timeline-horizontal-item-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.timeline-year,\n.timeline-month {\n  display: flex;\n  flex-shrink: 0;\n  position: relative;\n  box-sizing: border-box;\n  height: 100%;\n}\n.timeline-year-title {\n  line-height: var(--f7-timeline-year-height);\n  height: var(--f7-timeline-year-height);\n  font-size: var(--f7-timeline-year-font-size);\n  font-weight: var(--f7-timeline-year-font-weight);\n}\n.timeline-month-title {\n  line-height: var(--f7-timeline-month-height);\n  height: var(--f7-timeline-month-height);\n  font-size: var(--f7-timeline-month-font-size);\n  font-weight: var(--f7-timeline-month-font-weight);\n}\n.timeline-year-title,\n.timeline-month-title {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  box-sizing: border-box;\n  padding: 0 var(--f7-timeline-horizontal-item-padding);\n  background-color: var(--f7-bars-bg-color);\n  color: var(--f7-bars-text-color);\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-bars .timeline-year-title,\n  .ios-translucent-bars .timeline-month-title {\n    background-color: rgba(var(--f7-bars-bg-color-rgb), var(--f7-bars-translucent-opacity));\n    -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n            backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n  }\n}\n.timeline-year-title span,\n.timeline-month-title span {\n  display: inline-block;\n  position: -webkit-sticky;\n  position: sticky;\n  left: calc(var(--f7-timeline-horizontal-item-padding) + var(--f7-safe-area-left));\n}\n.timeline-month-title span {\n  margin-top: -2px;\n}\n.timeline-year:first-child .timeline-year-title,\n.timeline-year:first-child .timeline-month:first-child .timeline-month-title,\n.timeline-year:first-child .timeline-year-title + .timeline-month .timeline-month-title {\n  left: calc(var(--f7-safe-area-left) * -1);\n  right: 0;\n  width: auto;\n}\n.timeline-horizontal .timeline-item:first-child,\n.timeline-year:first-child .timeline-month:first-child .timeline-item:first-child,\n.timeline-year:first-child .timeline-year-title + .timeline-month .timeline-item:first-child,\n.timeline-year:first-child .timeline-year-title + .timeline-month .timeline-month-title + .timeline-item {\n  overflow: visible;\n}\n.timeline-horizontal .timeline-item:first-child .timeline-item-date,\n.timeline-year:first-child .timeline-month:first-child .timeline-item:first-child .timeline-item-date,\n.timeline-year:first-child .timeline-year-title + .timeline-month .timeline-item:first-child .timeline-item-date,\n.timeline-year:first-child .timeline-year-title + .timeline-month .timeline-month-title + .timeline-item .timeline-item-date {\n  width: auto;\n  padding-left: calc(var(--f7-timeline-horizontal-item-padding) + var(--f7-safe-area-left));\n  left: calc(0px - var(--f7-safe-area-left));\n  right: 0;\n}\n.timeline-year:last-child .timeline-year-title,\n.timeline-year:last-child .timeline-month:last-child .timeline-month-title {\n  width: auto;\n  right: calc(0px - var(--f7-safe-area-right));\n}\n.timeline-horizontal .timeline-item:last-child,\n.timeline-year:last-child .timeline-month:last-child .timeline-item:last-child {\n  overflow: visible;\n}\n.timeline-horizontal .timeline-item:last-child .timeline-item-date,\n.timeline-year:last-child .timeline-month:last-child .timeline-item:last-child .timeline-item-date {\n  width: auto;\n  right: calc(0px - var(--f7-safe-area-right));\n  left: 0;\n}\n.ios .block-strong .timeline-item-inner {\n  border-radius: 3px;\n  border: 1px solid rgba(0, 0, 0, 0.1);\n}\n.ios .timeline-year-title span {\n  margin-top: 3px;\n}\n.md .timeline-year-title span {\n  margin-top: 2px;\n}\n.aurora .timeline-year-title span {\n  margin-top: 2px;\n}\n/* === Tabs === */\n.tabs .tab {\n  display: none;\n}\n.tabs .tab-active {\n  display: block;\n}\n.tabs-animated-wrap {\n  position: relative;\n  width: 100%;\n  overflow: hidden;\n  height: 100%;\n}\n.tabs-animated-wrap > .tabs {\n  display: flex;\n  height: 100%;\n  transition-duration: 300ms;\n}\n.tabs-animated-wrap > .tabs > .tab {\n  width: 100%;\n  display: block;\n  flex-shrink: 0;\n}\n.tabs-animated-wrap.not-animated > .tabs {\n  transition-duration: 0ms;\n}\n.tabs-swipeable-wrap {\n  height: 100%;\n}\n.tabs-swipeable-wrap > .tabs {\n  height: 100%;\n}\n.tabs-swipeable-wrap > .tabs > .tab {\n  display: block;\n}\n.page > .tabs {\n  height: 100%;\n}\n/* === Panels === */\n:root {\n  --f7-panel-width: 260px;\n  /*\n  --f7-panel-left-width: var(--f7-panel-width);\n  --f7-panel-right-width: var(--f7-panel-width);\n  --f7-panel-left-collapsed-width: var(--f7-panel-collapsed-width);\n  --f7-panel-right-collapsed-width: var(--f7-panel-collapsed-width);\n  */\n  --f7-panel-bg-color: #fff;\n}\n.ios {\n  --f7-panel-collapsed-width: 58px;\n  --f7-panel-backdrop-bg-color: rgba(0, 0, 0, 0);\n  --f7-panel-transition-duration: 400ms;\n  --f7-panel-shadow: transparent;\n}\n.md {\n  --f7-panel-collapsed-width: 60px;\n  --f7-panel-backdrop-bg-color: rgba(0, 0, 0, 0.3);\n  --f7-panel-transition-duration: 300ms;\n  --f7-panel-shadow: rgba(0, 0, 0, 0.2) 0%,\n    rgba(0, 0, 0, 0.07) 30%,\n    rgba(0, 0, 0, 0.03) 40%,\n    rgba(0, 0, 0, 0) 60%,\n    rgba(0, 0, 0, 0) 100%;\n}\n.aurora {\n  --f7-panel-collapsed-width: 44px;\n  --f7-panel-backdrop-bg-color: rgba(0, 0, 0, 0.2);\n  --f7-panel-transition-duration: 400ms;\n  --f7-panel-shadow: transparent;\n}\n.panel-backdrop {\n  position: absolute;\n  left: 0;\n  top: var(--f7-appbar-app-offset, 0px);\n  width: 100%;\n  height: calc(100% - var(--f7-appbar-app-offset, 0px));\n  opacity: 0;\n  z-index: 5999;\n  visibility: hidden;\n  pointer-events: none;\n  transform: translate3d(0, 0, 0);\n  background-color: var(--f7-panel-backdrop-bg-color);\n  transition-property: transform, opacity;\n  transition-duration: var(--f7-panel-transition-duration);\n}\n.panel-backdrop .with-panel,\n.panel-backdrop .with-panel-closing {\n  visibility: visible;\n}\n.panel-backdrop.not-animated {\n  transition-duration: 0ms !important;\n}\n.panel {\n  z-index: 1000;\n  box-sizing: border-box;\n  position: absolute;\n  top: var(--f7-appbar-app-offset, 0px);\n  height: calc(100% - var(--f7-appbar-app-offset, 0px));\n  transform: translate3d(0, 0, 0);\n  width: var(--f7-panel-width);\n  background-color: var(--f7-panel-bg-color);\n  overflow: visible;\n  transition-property: transform;\n  transition-duration: var(--f7-panel-transition-duration);\n}\n.panel:not(.panel-in):not(.panel-out):not(.panel-in-breakpoint):not(.panel-in-collapsed):not(.panel-in-swipe) {\n  display: none;\n}\n.panel:after {\n  pointer-events: none;\n  opacity: 0;\n  z-index: 5999;\n  position: absolute;\n  content: '';\n  top: 0;\n  width: 20px;\n  height: 100%;\n  transition-property: transform, opacity;\n  transition-duration: var(--f7-panel-transition-duration);\n}\n.panel.not-animated,\n.panel.not-animated:after {\n  transition-duration: 0ms !important;\n}\n.panel.panel-reveal.not-animated ~ .views,\n.panel.panel-reveal.not-animated ~ .view {\n  transition-duration: 0ms !important;\n}\n.panel.panel-resizing {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.panel.panel-resizing,\n.panel.panel-resizing:after,\n.panel.panel-resizing ~ .views,\n.panel.panel-resizing ~ .view {\n  transition-duration: 0ms !important;\n}\n.panel-cover {\n  z-index: 6000;\n}\n.panel-left {\n  left: 0;\n  width: var(--f7-panel-left-width, var(--f7-panel-width));\n}\n.panel-left.panel-cover {\n  transform: translate3d(-100%, 0, 0);\n}\n.panel-left.panel-cover:after {\n  left: 100%;\n  background: linear-gradient(to right, var(--f7-panel-shadow));\n}\nhtml.with-panel-left-cover .panel-left.panel-cover:after {\n  opacity: 1;\n}\n.panel-left.panel-reveal:after {\n  right: 0;\n  transform: translate3d(calc(-1 * var(--f7-panel-left-width, var(--f7-panel-width))), 0, 0);\n  background: linear-gradient(to left, var(--f7-panel-shadow));\n}\nhtml.with-panel-left-reveal .panel-left.panel-reveal:after {\n  opacity: 1;\n  transform: translate3d(0, 0, 0);\n}\n.panel-right {\n  right: 0;\n  width: var(--f7-panel-right-width, var(--f7-panel-width));\n}\n.panel-right.panel-cover {\n  transform: translate3d(100%, 0, 0);\n}\n.panel-right.panel-cover:after {\n  right: 100%;\n  background: linear-gradient(to left, var(--f7-panel-shadow));\n}\nhtml.with-panel-right-cover .panel-right.panel-cover:after {\n  opacity: 1;\n}\n.panel-right.panel-reveal:after {\n  left: 0;\n  background: linear-gradient(to right, var(--f7-panel-shadow));\n  transform: translate3d(var(--f7-panel-right-width, var(--f7-panel-width)), 0, 0);\n}\nhtml.with-panel-right-reveal .panel-right.panel-reveal:after {\n  opacity: 1;\n  transform: translate3d(0, 0, 0);\n}\n.panel-in-breakpoint {\n  transform: translate3d(0, 0, 0) !important;\n  transition-duration: 0ms;\n}\n.panel-in-breakpoint:after {\n  display: none;\n}\n.panel-in-breakpoint.panel-cover {\n  z-index: 5900;\n}\nhtml.with-panel-left-reveal .views,\nhtml.with-panel-right-reveal .views,\nhtml.with-panel-closing .views,\nhtml.with-panel-left-reveal .framework7-root > .view,\nhtml.with-panel-right-reveal .framework7-root > .view,\nhtml.with-panel-closing .framework7-root > .view {\n  transition-duration: var(--f7-panel-transition-duration);\n  transition-property: transform;\n}\nhtml.with-panel-left-reveal .panel-backdrop,\nhtml.with-panel-right-reveal .panel-backdrop,\nhtml.with-panel-closing .panel-backdrop {\n  visibility: visible;\n  pointer-events: auto;\n  opacity: 0;\n}\nhtml.with-panel .framework7-root > .views .page-content,\nhtml.with-panel .framework7-root > .view .page-content {\n  overflow: hidden;\n  -webkit-overflow-scrolling: auto;\n}\nhtml.with-panel-left-cover .panel-backdrop,\nhtml.with-panel-right-cover .panel-backdrop {\n  visibility: visible;\n  pointer-events: auto;\n  opacity: 1;\n}\nhtml.with-panel-left-reveal .views,\nhtml.with-panel-left-reveal .framework7-root > .view,\nhtml.with-panel-left-reveal .panel-backdrop {\n  transform: translate3d(var(--f7-panel-left-width, var(--f7-panel-width)), 0, 0);\n}\nhtml.with-panel-right-reveal .views,\nhtml.with-panel-right-reveal .framework7-root > .view,\nhtml.with-panel-right-reveal .panel-backdrop {\n  transform: translate3d(calc(-1 * var(--f7-panel-right-width, var(--f7-panel-width))), 0, 0);\n}\nhtml.with-panel-left-cover .panel-left {\n  transform: translate3d(0px, 0, 0);\n}\nhtml.with-panel-right-cover .panel-right {\n  transform: translate3d(0px, 0, 0);\n}\n.panel-resize-handler {\n  position: absolute;\n  top: 0;\n  height: 100%;\n  width: 6px;\n  cursor: col-resize;\n  z-index: 6000;\n  display: none;\n}\n.panel-resizable .panel-resize-handler {\n  display: block;\n}\n.panel-left.panel-cover .panel-resize-handler {\n  right: -3px;\n}\n.panel-left.panel-reveal .panel-resize-handler {\n  right: 0;\n}\n.panel-right.panel-cover .panel-resize-handler {\n  left: -3px;\n}\n.panel-right.panel-reveal .panel-resize-handler {\n  left: 0;\n}\n.panel-left.panel-in-collapsed ~ .views,\n.panel-left.panel-in-collapsed ~ .view {\n  margin-left: var(--f7-panel-left-collapsed-width, var(--f7-panel-collapsed-width));\n}\nhtml.with-panel-left-reveal .panel-left.panel-in-collapsed ~ .views,\nhtml.with-panel-left-reveal .panel-left.panel-in-collapsed ~ .view {\n  transform: translate3d(calc(var(--f7-panel-left-width, var(--f7-panel-width)) - var(--f7-panel-left-collapsed-width, var(--f7-panel-collapsed-width))), 0, 0);\n}\n.panel-right.panel-in-collapsed ~ .views,\n.panel-right.panel-in-collapsed ~ .view {\n  margin-right: var(--f7-panel-right-collapsed-width, var(--f7-panel-collapsed-width));\n}\nhtml.with-panel-right-reveal .panel-right.panel-in-collapsed ~ .views,\nhtml.with-panel-right-reveal .panel-right.panel-in-collapsed ~ .view {\n  transform: translate3d(calc(var(--f7-panel-right-collapsed-width, var(--f7-panel-collapsed-width)) - var(--f7-panel-right-width, var(--f7-panel-width))), 0, 0);\n}\n/* === Card === */\n:root {\n  --f7-card-content-padding-horizontal: 16px;\n  --f7-card-content-padding-vertical: 16px;\n  --f7-card-border-radius: 4px;\n  --f7-card-font-size: inherit;\n  --f7-card-header-text-color: inherit;\n  --f7-card-header-font-weight: 400;\n  --f7-card-header-padding-horizontal: 16px;\n  --f7-card-footer-font-weight: 400;\n  --f7-card-footer-font-size: inherit;\n  --f7-card-footer-padding-horizontal: 16px;\n  --f7-card-expandable-font-size: 16px;\n  --f7-card-expandable-tablet-width: 670px;\n  --f7-card-expandable-tablet-height: 670px;\n  --f7-card-bg-color: #fff;\n  --f7-card-outline-border-color: rgba(0, 0, 0, 0.12);\n  --f7-card-header-border-color: rgba(0, 0, 0, 0.1);\n  --f7-card-footer-border-color: rgba(0, 0, 0, 0.1);\n  --f7-card-expandable-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-card-bg-color: #1c1c1d;\n  --f7-card-expandable-bg-color: #1c1c1d;\n  --f7-card-outline-border-color: rgba(255, 255, 255, 0.15);\n  --f7-card-header-border-color: rgba(255, 255, 255, 0.15);\n  --f7-card-footer-border-color: rgba(255, 255, 255, 0.15);\n  --f7-card-footer-text-color: rgba(255, 255, 255, 0.55);\n}\n.ios {\n  --f7-card-margin-horizontal: 10px;\n  --f7-card-margin-vertical: 10px;\n  --f7-card-box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.2);\n  --f7-card-header-font-size: 17px;\n  --f7-card-header-padding-vertical: 10px;\n  --f7-card-header-min-height: 44px;\n  --f7-card-footer-text-color: rgba(0, 0, 0, 0.45);\n  --f7-card-footer-padding-vertical: 10px;\n  --f7-card-footer-min-height: 44px;\n  --f7-card-expandable-margin-horizontal: 20px;\n  --f7-card-expandable-margin-vertical: 30px;\n  --f7-card-expandable-box-shadow: 0px 20px 40px rgba(0, 0, 0, 0.3);\n  --f7-card-expandable-border-radius: 15px;\n  --f7-card-expandable-tablet-border-radius: 5px;\n  --f7-card-expandable-header-font-size: 27px;\n  --f7-card-expandable-header-font-weight: bold;\n}\n.md {\n  --f7-card-margin-horizontal: 8px;\n  --f7-card-margin-vertical: 8px;\n  --f7-card-box-shadow: var(--f7-elevation-1);\n  --f7-card-header-font-size: 16px;\n  --f7-card-header-padding-vertical: 4px;\n  --f7-card-header-min-height: 48px;\n  --f7-card-footer-text-color: rgba(0, 0, 0, 0.54);\n  --f7-card-footer-padding-vertical: 4px;\n  --f7-card-footer-min-height: 48px;\n  --f7-card-expandable-margin-horizontal: 12px;\n  --f7-card-expandable-margin-vertical: 24px;\n  --f7-card-expandable-box-shadow: var(--f7-elevation-10);\n  --f7-card-expandable-border-radius: 8px;\n  --f7-card-expandable-tablet-border-radius: 4px;\n  --f7-card-expandable-header-font-size: 24px;\n  --f7-card-expandable-header-font-weight: 500;\n}\n.aurora {\n  --f7-card-margin-horizontal: 10px;\n  --f7-card-margin-vertical: 10px;\n  --f7-card-box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.15);\n  --f7-card-header-font-size: 14px;\n  --f7-card-header-font-weight: bold;\n  --f7-card-header-padding-vertical: 10px;\n  --f7-card-header-min-height: 38px;\n  --f7-card-footer-text-color: rgba(0, 0, 0, 0.6);\n  --f7-card-footer-padding-vertical: 10px;\n  --f7-card-footer-min-height: 38px;\n  --f7-card-expandable-margin-horizontal: 10px;\n  --f7-card-expandable-margin-vertical: 20px;\n  --f7-card-expandable-box-shadow: 0px 5px 10px rgba(0, 0, 0, 0.15);\n  --f7-card-expandable-border-radius: 15px;\n  --f7-card-expandable-tablet-border-radius: 5px;\n  --f7-card-expandable-header-font-size: 27px;\n  --f7-card-expandable-header-font-weight: bold;\n}\n.cards-list > ul:before,\n.card .list > ul:before,\n.cards-list > ul:after,\n.card .list > ul:after {\n  display: none !important;\n}\n.cards-list ul,\n.card .list ul {\n  background: none;\n}\n.card {\n  background: var(--f7-card-bg-color);\n  position: relative;\n  border-radius: var(--f7-card-border-radius);\n  font-size: var(--f7-card-font-size);\n  margin-top: var(--f7-card-margin-vertical);\n  margin-bottom: var(--f7-card-margin-vertical);\n  margin-left: calc(var(--f7-card-margin-horizontal) + var(--f7-safe-area-left));\n  margin-right: calc(var(--f7-card-margin-horizontal) + var(--f7-safe-area-right));\n  box-shadow: var(--f7-card-box-shadow);\n}\n.card .list,\n.card .block {\n  margin: 0;\n}\n.row:not(.no-gap) .col > .card {\n  margin-left: 0;\n  margin-right: 0;\n}\n.card.no-shadow {\n  box-shadow: none;\n}\n.card-outline,\n.ios .card-outline-ios,\n.md .card-outline-md,\n.aurora .card-outline-aurora {\n  box-shadow: none;\n  border: 1px solid var(--f7-card-outline-border-color);\n}\n.card-outline.no-border,\n.ios .card-outline-ios.no-border,\n.md .card-outline-md.no-border,\n.aurora .card-outline-aurora.no-border,\n.card-outline.no-hairlines,\n.ios .card-outline-ios.no-hairlines,\n.md .card-outline-md.no-hairlines,\n.aurora .card-outline-aurora.no-hairlines {\n  border: none;\n}\n.card-content {\n  position: relative;\n}\n.card-content-padding {\n  position: relative;\n  padding: var(--f7-card-content-padding-vertical) var(--f7-card-content-padding-horizontal);\n}\n.card-content-padding > .list,\n.card-content-padding > .block {\n  margin: calc(-1 * var(--f7-card-content-padding-vertical)) calc(-1 * var(--f7-card-content-padding-horizontal));\n}\n.card-content-padding > p:first-child {\n  margin-top: 0;\n}\n.card-content-padding > p:last-child {\n  margin-bottom: 0;\n}\n.card-header {\n  min-height: var(--f7-card-header-min-height);\n  color: var(--f7-card-header-text-color);\n  font-size: var(--f7-card-header-font-size);\n  font-weight: var(--f7-card-header-font-weight);\n  padding: var(--f7-card-header-padding-vertical) var(--f7-card-header-padding-horizontal);\n}\n.card-footer {\n  min-height: var(--f7-card-footer-min-height);\n  color: var(--f7-card-footer-text-color);\n  font-size: var(--f7-card-footer-font-size);\n  font-weight: var(--f7-card-footer-font-weight);\n  padding: var(--f7-card-footer-padding-vertical) var(--f7-card-footer-padding-horizontal);\n}\n.card-footer a.link {\n  overflow: hidden;\n}\n.card-header,\n.card-footer {\n  position: relative;\n  box-sizing: border-box;\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.card-header[valign=\"top\"],\n.card-footer[valign=\"top\"] {\n  align-items: flex-start;\n}\n.card-header[valign=\"bottom\"],\n.card-footer[valign=\"bottom\"] {\n  align-items: flex-end;\n}\n.card-header a.link,\n.card-footer a.link {\n  position: relative;\n}\n.card-header a.link i.icon,\n.card-footer a.link i.icon {\n  display: block;\n}\n.card-header a.icon-only,\n.card-footer a.icon-only {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  margin: 0;\n}\n.card-header {\n  border-radius: var(--f7-card-border-radius) var(--f7-card-border-radius) 0 0;\n}\n.card-header:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-card-header-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.card-header.no-hairline:after {\n  display: none !important;\n}\n.card-footer {\n  border-radius: 0 0 var(--f7-card-border-radius) var(--f7-card-border-radius);\n}\n.card-footer:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-card-footer-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.card-footer.no-hairline:before {\n  display: none !important;\n}\n.card-expandable {\n  overflow: hidden;\n  height: 300px;\n  background: var(--f7-card-expandable-bg-color);\n  position: relative;\n  transform-origin: center center;\n  transition-property: transform, border-radius;\n  border-radius: var(--f7-card-expandable-border-radius);\n  z-index: 2;\n  transition-duration: 200ms;\n  margin-left: calc(var(--f7-card-expandable-margin-horizontal) + var(--f7-safe-area-left));\n  margin-right: calc(var(--f7-card-expandable-margin-horizontal) + var(--f7-safe-area-right));\n  margin-top: var(--f7-card-expandable-margin-vertical);\n  margin-bottom: var(--f7-card-expandable-margin-vertical);\n  box-shadow: var(--f7-card-expandable-box-shadow);\n  font-size: var(--f7-card-expandable-font-size);\n}\n.card-expandable.card-no-transition {\n  transition-duration: 0ms;\n}\n.card-expandable.card-expandable-animate-width .card-content {\n  transition-property: width, transform;\n  width: 100%;\n}\n.card-expandable.active-state {\n  transform: scale(0.97) translate3d(0, 0, 0);\n}\n.card-expandable .card-opened-fade-in,\n.card-expandable .card-opened-fade-out {\n  transition-duration: 400ms;\n}\n.card-expandable .card-opened-fade-in {\n  opacity: 0;\n  pointer-events: none;\n}\n.card-expandable .card-content {\n  position: absolute;\n  top: 0;\n  width: 100vw;\n  height: 100vh;\n  transform-origin: center top;\n  overflow: hidden;\n  transition-property: transform;\n  box-sizing: border-box;\n  pointer-events: none;\n  left: 0;\n}\n.card-expandable .card-content .card-content-padding {\n  padding-left: calc(var(--f7-safe-area-left) + var(--f7-card-content-padding-horizontal));\n  padding-right: calc(var(--f7-safe-area-right) + var(--f7-card-content-padding-horizontal));\n}\n.card-expandable.card-opened {\n  transition-duration: 0ms;\n}\n.card-expandable.card-opening,\n.card-expandable.card-closing,\n.card-expandable.card-transitioning {\n  transition-duration: 400ms;\n}\n.card-expandable.card-opening .card-content {\n  transition-duration: 300ms;\n}\n.card-expandable.card-closing .card-content {\n  transition-duration: 500ms;\n}\n.card-expandable.card-opening,\n.card-expandable.card-opened,\n.card-expandable.card-closing {\n  z-index: 300;\n}\n.card-expandable.card-opening,\n.card-expandable.card-opened {\n  border-radius: 0;\n}\n.card-expandable.card-opening .card-opened-fade-in,\n.card-expandable.card-opened .card-opened-fade-in {\n  opacity: 1;\n  pointer-events: auto;\n}\n.card-expandable.card-opening .card-opened-fade-out,\n.card-expandable.card-opened .card-opened-fade-out {\n  opacity: 0;\n  pointer-events: none;\n}\n.card-expandable.card-opened .card-content {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  pointer-events: auto;\n}\n.card-expandable .card-header {\n  font-size: var(--f7-card-expandable-header-font-size);\n  font-weight: var(--f7-card-expandable-header-font-weight);\n}\n.card-expandable .card-header:after {\n  display: none !important;\n}\n.card-prevent-open {\n  pointer-events: auto;\n}\n.card-expandable-size {\n  width: 0;\n  height: 0;\n  position: absolute;\n  left: 0;\n  top: 0;\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n}\n@media (min-width: 768px) and (min-height: 670px) {\n  .card-expandable:not(.card-tablet-fullscreen) {\n    max-width: var(--f7-card-expandable-tablet-width);\n  }\n  .card-expandable:not(.card-tablet-fullscreen).card-opened,\n  .card-expandable:not(.card-tablet-fullscreen).card-opening {\n    border-radius: var(--f7-card-expandable-tablet-border-radius);\n  }\n  .card-expandable:not(.card-tablet-fullscreen):not(.card-expandable-animate-width) .card-content {\n    width: var(--f7-card-expandable-tablet-width);\n  }\n  .card-expandable:not(.card-tablet-fullscreen) .card-expandable-size {\n    width: var(--f7-card-expandable-tablet-width);\n    height: var(--f7-card-expandable-tablet-height);\n  }\n}\n.page.page-with-card-opened .page-content {\n  overflow: hidden;\n}\n.card-backdrop {\n  position: fixed;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 299;\n  pointer-events: none;\n  background: rgba(0, 0, 0, 0.2);\n  opacity: 0;\n}\n.card-backdrop-in {\n  animation: card-backdrop-fade-in 400ms forwards;\n  pointer-events: auto;\n}\n.card-backdrop-out {\n  animation: card-backdrop-fade-out 400ms forwards;\n}\n@supports ((-webkit-backdrop-filter: blur(15px)) or (backdrop-filter: blur(15px))) {\n  .card-backdrop {\n    background: transparent;\n    -webkit-backdrop-filter: blur(15px);\n            backdrop-filter: blur(15px);\n  }\n}\n@keyframes card-backdrop-fade-in {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n@keyframes card-backdrop-fade-out {\n  from {\n    opacity: 1;\n  }\n  to {\n    opacity: 0;\n  }\n}\n/* === Chips === */\n:root {\n  --f7-chip-font-size: 13px;\n  --f7-chip-font-weight: normal;\n  --f7-chip-media-font-size: 16px;\n  --f7-chip-bg-color: rgba(0, 0, 0, 0.12);\n  --f7-chip-outline-border-color: rgba(0, 0, 0, 0.12);\n  --f7-chip-delete-button-color: #000;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-chip-delete-button-color: #fff;\n  --f7-chip-bg-color: #333;\n  --f7-chip-outline-border-color: rgba(255, 255, 255, 0.12);\n}\n.ios {\n  --f7-chip-height: 24px;\n  --f7-chip-padding-horizontal: 10px;\n  --f7-chip-text-color: #000;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-chip-text-color: #fff;\n}\n.md {\n  --f7-chip-height: 32px;\n  --f7-chip-padding-horizontal: 12px;\n  --f7-chip-text-color: rgba(0, 0, 0, 0.87);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-chip-text-color: rgba(255, 255, 255, 0.87);\n}\n.aurora {\n  --f7-chip-height: 20px;\n  --f7-chip-padding-horizontal: 10px;\n  --f7-chip-font-size: 12px;\n  --f7-chip-media-font-size: 14px;\n  --f7-chip-text-color: #000;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-chip-text-color: #fff;\n}\n.chip {\n  padding-left: var(--f7-chip-padding-horizontal);\n  padding-right: var(--f7-chip-padding-horizontal);\n  font-weight: var(--f7-chip-font-weight);\n  display: inline-flex;\n  box-sizing: border-box;\n  vertical-align: middle;\n  align-items: center;\n  margin: 2px 0;\n  background-color: var(--f7-chip-bg-color);\n  font-size: var(--f7-chip-font-size);\n  color: var(--f7-chip-text-color);\n  height: var(--f7-chip-height);\n  line-height: var(--f7-chip-height);\n  border-radius: var(--f7-chip-height);\n  position: relative;\n}\n.chip-media {\n  border-radius: 50%;\n  flex-shrink: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  height: var(--f7-chip-height);\n  width: var(--f7-chip-height);\n  border-radius: var(--f7-chip-height);\n  text-align: center;\n  line-height: var(--f7-chip-height);\n  box-sizing: border-box;\n  color: #fff;\n  font-size: var(--f7-chip-media-font-size);\n  vertical-align: middle;\n  margin-left: calc(-1 * var(--f7-chip-padding-horizontal));\n}\n.chip-media i.icon {\n  font-size: calc(var(--f7-chip-height) - 8px);\n  height: calc(var(--f7-chip-height) - 8px);\n}\n.chip-media img {\n  max-width: 100%;\n  max-height: 100%;\n  width: auto;\n  height: auto;\n  border-radius: 50%;\n  display: block;\n}\n.chip-media + .chip-label {\n  margin-left: 4px;\n}\n.chip-label {\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  position: relative;\n  flex-shrink: 1;\n  min-width: 0;\n}\n.chip-delete {\n  text-align: center;\n  cursor: pointer;\n  flex-shrink: 0;\n  background-repeat: no-repeat;\n  width: 24px;\n  height: 24px;\n  color: var(--f7-chip-delete-button-color);\n  opacity: 0.54;\n  position: relative;\n}\n.chip-delete:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  content: 'delete_round_ios';\n  line-height: 24px;\n}\n.chip .chip-delete.active-state {\n  opacity: 1;\n}\n.chip-outline,\n.ios .chip-outline-ios,\n.md .chip-outline-md,\n.aurora .chip-outline-aurora {\n  border: 1px solid var(--f7-chip-outline-border-color);\n  background: none;\n}\n.chip[class*=\"color-\"] {\n  --f7-chip-bg-color: var(--f7-theme-color);\n  --f7-chip-text-color: #fff;\n}\n.chip-outline[class*=\"color-\"],\n.ios .chip-outline-ios[class*=\"color-\"],\n.md .chip-outline-md[class*=\"color-\"],\n.aurora .chip-outline-aurora[class*=\"color-\"] {\n  --f7-chip-outline-border-color: var(--f7-theme-color);\n  --f7-chip-text-color: var(--f7-theme-color);\n}\n.ios .chip-delete {\n  margin-right: calc(-1 * var(--f7-chip-padding-horizontal));\n}\n.ios .chip-delete:after {\n  font-size: 10px;\n}\n.md .chip-label + .chip-delete {\n  margin-left: 4px;\n}\n.md .chip-delete {\n  margin-right: calc(-1 * var(--f7-chip-padding-horizontal) + 4px);\n}\n.md .chip-delete:after {\n  font-size: 12px;\n}\n.aurora .chip-delete {\n  margin-right: calc(-1 * var(--f7-chip-padding-horizontal));\n}\n.aurora .chip-delete:after {\n  font-size: 10px;\n}\n/* === Form === */\n/* === Input === */\n:root {\n  --f7-input-bg-color: transparent;\n  --f7-label-font-weight: 400;\n  --f7-label-line-height: 1.3;\n  --f7-input-padding-left: 0px;\n  --f7-input-padding-right: 0px;\n  --f7-input-error-text-color: #ff3b30;\n  --f7-input-error-font-size: 12px;\n  --f7-input-error-line-height: 1.4;\n  --f7-input-error-font-weight: 400;\n  --f7-input-info-font-size: 12px;\n  --f7-input-info-line-height: 1.4;\n  --f7-input-outline-height: 40px;\n  --f7-input-outline-border-radius: 4px;\n  --f7-input-outline-padding-horizontal: 12px;\n  --f7-textarea-height: 100px;\n  /*\n  --f7-input-outline-focused-border-color: var(--f7-theme-color);\n  --f7-input-outline-invalid-border-color: var(--f7-input-error-text-color);\n  */\n  --f7-input-outline-border-color: #999;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-input-outline-border-color: #444;\n}\n.ios {\n  --f7-input-height: 44px;\n  --f7-input-font-size: 17px;\n  --f7-input-placeholder-color: #a9a9a9;\n  --f7-textarea-padding-vertical: 11px;\n  /*\n  --f7-input-focused-border-color: var(--f7-list-item-border-color);\n  --f7-input-invalid-border-color: var(--f7-list-item-border-color);\n  --f7-input-invalid-text-color: var(--f7-input-error-text-color);\n  */\n  --f7-label-font-size: 12px;\n  --f7-label-text-color: inherit;\n  /*\n  --f7-label-focused-text-color: var(--f7-label-text-color);\n  --f7-label-invalid-text-color: var(--f7-label-text-color);\n  */\n  --f7-floating-label-scale: calc(17 / 12);\n  --f7-inline-label-font-size: 17px;\n  --f7-inline-label-line-height: 1.4;\n  --f7-inline-label-padding-top: 3px;\n  --f7-input-clear-button-size: 14px;\n  --f7-input-text-color: #000000;\n  --f7-input-info-text-color: rgba(0, 0, 0, 0.45);\n  --f7-input-clear-button-color: rgba(0, 0, 0, 0.45);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-input-text-color: #fff;\n  --f7-input-info-text-color: rgba(255, 255, 255, 0.55);\n  --f7-input-clear-button-color: rgba(255, 255, 255, 0.5);\n}\n.md {\n  --f7-input-height: 36px;\n  --f7-input-font-size: 16px;\n  --f7-textarea-padding-vertical: 7px;\n  /*\n  --f7-input-focused-border-color: var(--f7-theme-color);\n  --f7-input-invalid-border-color: var(--f7-input-error-text-color);\n  --f7-input-invalid-text-color: var(--f7-input-text-color);\n  */\n  --f7-label-font-size: 12px;\n  /*\n  --f7-label-focused-text-color: var(--f7-theme-color);\n  --f7-label-invalid-text-color: var(--f7-input-error-text-color );\n  */\n  --f7-floating-label-scale: calc(16 / 12);\n  --f7-inline-label-font-size: 16px;\n  --f7-inline-label-line-height: 1.5;\n  --f7-inline-label-padding-top: 7px;\n  --f7-input-clear-button-size: 18px;\n  --f7-input-clear-button-color: #aaa;\n  --f7-input-text-color: #212121;\n  --f7-input-placeholder-color: rgba(0, 0, 0, 0.35);\n  --f7-label-text-color: rgba(0, 0, 0, 0.65);\n  --f7-input-info-text-color: rgba(0, 0, 0, 0.45);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-input-text-color: rgba(255, 255, 255, 0.87);\n  --f7-input-placeholder-color: rgba(255, 255, 255, 0.35);\n  --f7-label-text-color: rgba(255, 255, 255, 0.54);\n  --f7-input-info-text-color: rgba(255, 255, 255, 0.45);\n}\n.aurora {\n  --f7-input-height: 24px;\n  --f7-input-font-size: 13px;\n  --f7-textarea-padding-vertical: 2px;\n  /*\n  --f7-input-focused-border-color: var(--f7-list-item-border-color);\n  --f7-input-invalid-border-color: var(--f7-list-item-border-color);\n  --f7-input-invalid-text-color: var(--f7-input-error-text-color);\n  */\n  --f7-label-font-size: 11px;\n  --f7-label-text-color: inherit;\n  /*\n  --f7-label-focused-text-color: var(--f7-label-text-color);\n  --f7-label-invalid-text-color: var(--f7-label-text-color);\n  */\n  --f7-floating-label-scale: calc(13 / 11);\n  --f7-inline-label-font-size: 14px;\n  --f7-inline-label-line-height: 1.4;\n  --f7-inline-label-padding-top: 1px;\n  --f7-input-clear-button-size: 14px;\n  --f7-input-outline-height: 32px;\n  --f7-input-outline-padding-horizontal: 8px;\n  --f7-input-text-color: #000000;\n  --f7-input-placeholder-color: rgba(0, 0, 0, 0.32);\n  --f7-input-clear-button-color: #666;\n  --f7-input-info-text-color: rgba(0, 0, 0, 0.5);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-input-text-color: #fff;\n  --f7-input-clear-button-color: #aaa;\n  --f7-input-placeholder-color: rgba(255, 255, 255, 0.35);\n  --f7-input-info-text-color: rgba(255, 255, 255, 0.45);\n}\ninput[type=\"text\"],\ninput[type=\"password\"],\ninput[type=\"search\"],\ninput[type=\"email\"],\ninput[type=\"tel\"],\ninput[type=\"url\"],\ninput[type=\"date\"],\ninput[type='month'],\ninput[type=\"datetime-local\"],\ninput[type=\"time\"],\ninput[type=\"number\"],\nselect,\ntextarea {\n  box-sizing: border-box;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border: none;\n  box-shadow: none;\n  border-radius: 0;\n  outline: 0;\n  display: block;\n  padding: 0;\n  margin: 0;\n  font-family: inherit;\n  background: none;\n  resize: none;\n  font-size: inherit;\n  color: inherit;\n}\n.textarea-resizable-shadow {\n  opacity: 0;\n  position: absolute;\n  z-index: -1000;\n  pointer-events: none;\n  left: -1000px;\n  top: -1000px;\n  visibility: hidden;\n}\n.list input[type=\"text\"],\n.list input[type=\"password\"],\n.list input[type=\"search\"],\n.list input[type=\"email\"],\n.list input[type=\"tel\"],\n.list input[type=\"url\"],\n.list input[type=\"date\"],\n.list input[type='month'],\n.list input[type=\"datetime-local\"],\n.list input[type=\"time\"],\n.list input[type=\"number\"],\n.list select {\n  width: 100%;\n  height: var(--f7-input-height);\n  color: var(--f7-input-text-color);\n  font-size: var(--f7-input-font-size);\n  background-color: var(--f7-input-bg-color, transparent);\n  padding-left: var(--f7-input-padding-left);\n  padding-right: var(--f7-input-padding-right);\n}\n.list input[type=\"text\"]::-webkit-input-placeholder, .list input[type=\"password\"]::-webkit-input-placeholder, .list input[type=\"search\"]::-webkit-input-placeholder, .list input[type=\"email\"]::-webkit-input-placeholder, .list input[type=\"tel\"]::-webkit-input-placeholder, .list input[type=\"url\"]::-webkit-input-placeholder, .list input[type=\"date\"]::-webkit-input-placeholder, .list input[type='month']::-webkit-input-placeholder, .list input[type=\"datetime-local\"]::-webkit-input-placeholder, .list input[type=\"time\"]::-webkit-input-placeholder, .list input[type=\"number\"]::-webkit-input-placeholder, .list select::-webkit-input-placeholder {\n  color: var(--f7-input-placeholder-color);\n}\n.list input[type=\"text\"]::placeholder,\n.list input[type=\"password\"]::placeholder,\n.list input[type=\"search\"]::placeholder,\n.list input[type=\"email\"]::placeholder,\n.list input[type=\"tel\"]::placeholder,\n.list input[type=\"url\"]::placeholder,\n.list input[type=\"date\"]::placeholder,\n.list input[type='month']::placeholder,\n.list input[type=\"datetime-local\"]::placeholder,\n.list input[type=\"time\"]::placeholder,\n.list input[type=\"number\"]::placeholder,\n.list select::placeholder {\n  color: var(--f7-input-placeholder-color);\n}\n.list textarea {\n  width: 100%;\n  color: var(--f7-input-text-color);\n  font-size: var(--f7-input-font-size);\n  resize: none;\n  line-height: 1.4;\n  height: var(--f7-textarea-height);\n  background-color: var(--f7-input-bg-color, transparent);\n  padding-top: var(--f7-textarea-padding-vertical);\n  padding-bottom: var(--f7-textarea-padding-vertical);\n  padding-left: var(--f7-input-padding-left);\n  padding-right: var(--f7-input-padding-right);\n}\n.list textarea::-webkit-input-placeholder {\n  color: var(--f7-input-placeholder-color);\n}\n.list textarea::placeholder {\n  color: var(--f7-input-placeholder-color);\n}\n.list textarea.resizable {\n  height: var(--f7-input-height);\n}\n.list input[type=\"datetime-local\"] {\n  max-width: 50vw;\n}\n.list input[type=\"time\"],\n.list input[type=\"date\"],\n.list input[type='month'],\n.list input[type=\"datetime-local\"] {\n  line-height: var(--f7-input-height);\n}\n.list .item-label,\n.list .item-floating-label {\n  width: 100%;\n  vertical-align: top;\n  flex-shrink: 0;\n  font-size: var(--f7-label-font-size);\n  font-weight: var(--f7-label-font-weight);\n  line-height: var(--f7-label-line-height);\n  color: var(--f7-label-text-color);\n  transition-duration: 200ms;\n  transition-property: transform, color;\n}\n.list .item-floating-label {\n  --label-height: calc(var(--f7-label-font-size) * var(--f7-label-line-height));\n  transform: scale(var(--f7-floating-label-scale)) translateY(calc((var(--f7-input-height) / 2 + 50%) / var(--f7-floating-label-scale)));\n  color: var(--f7-input-placeholder-color);\n  width: auto;\n  max-width: calc(100% / var(--f7-floating-label-scale));\n  pointer-events: none;\n  left: var(--f7-input-padding-left);\n  transform-origin: left center;\n}\n.list .item-floating-label ~ .item-input-wrap input::-webkit-input-placeholder, .list .item-floating-label ~ .item-input-wrap textarea::-webkit-input-placeholder {\n  opacity: 0;\n  transition-duration: 100ms;\n}\n.list .item-floating-label ~ .item-input-wrap input::placeholder,\n.list .item-floating-label ~ .item-input-wrap textarea::placeholder {\n  opacity: 0;\n  transition-duration: 100ms;\n}\n.list .item-floating-label ~ .item-input-wrap input.input-focused::-webkit-input-placeholder, .list .item-floating-label ~ .item-input-wrap textarea.input-focused::-webkit-input-placeholder {\n  opacity: 1;\n  transition-duration: 300ms;\n}\n.list .item-floating-label ~ .item-input-wrap input.input-focused::placeholder,\n.list .item-floating-label ~ .item-input-wrap textarea.input-focused::placeholder {\n  opacity: 1;\n  transition-duration: 300ms;\n}\n.list .item-input-with-value .item-floating-label {\n  color: var(--f7-label-text-color);\n}\n.list .item-input-with-value .item-floating-label,\n.list .item-input-focused .item-floating-label {\n  transform: scale(1) translateY(0);\n}\n.list .item-input-wrap {\n  width: 100%;\n  flex-shrink: 1;\n  position: relative;\n}\n.item-input .item-inner {\n  display: flex;\n  flex-direction: column;\n  align-items: flex-start;\n}\n.item-input-error-message,\n.input-error-message {\n  font-size: var(--f7-input-error-font-size);\n  line-height: var(--f7-input-error-line-height);\n  color: var(--f7-input-error-text-color);\n  font-weight: var(--f7-input-error-font-weight);\n  display: none;\n  box-sizing: border-box;\n}\n.item-input-info,\n.input-info {\n  font-size: var(--f7-input-info-font-size);\n  line-height: var(--f7-input-info-line-height);\n  color: var(--f7-input-info-text-color);\n}\n.item-input-invalid .item-input-error-message,\n.input-invalid .item-input-error-message,\n.item-input-invalid .input-error-message,\n.input-invalid .input-error-message {\n  display: block;\n}\n.item-input-invalid .item-input-info,\n.input-invalid .item-input-info,\n.item-input-invalid .input-info,\n.input-invalid .input-info {\n  display: none;\n}\n.inline-labels .item-inner,\n.inline-label .item-inner {\n  display: flex;\n  align-items: center;\n  flex-direction: row;\n}\n.inline-labels .item-label,\n.inline-label .item-label,\n.inline-labels .item-floating-label,\n.inline-label .item-floating-label {\n  padding-top: var(--f7-inline-label-padding-top);\n  align-self: flex-start;\n  width: 35%;\n  font-size: var(--f7-inline-label-font-size);\n  line-height: var(--f7-inline-label-line-height);\n}\n.inline-labels .item-label + .item-input-wrap,\n.inline-label .item-label + .item-input-wrap,\n.inline-labels .item-floating-label + .item-input-wrap,\n.inline-label .item-floating-label + .item-input-wrap {\n  margin-left: 8px;\n}\n.input {\n  position: relative;\n}\n.input input,\n.input select,\n.input textarea {\n  width: 100%;\n}\n.input-clear-button {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n  transition-duration: 100ms;\n  position: absolute;\n  top: 50%;\n  border: none;\n  padding: 0;\n  margin: 0;\n  outline: 0;\n  z-index: 1;\n  cursor: pointer;\n  background: none;\n  width: var(--f7-input-clear-button-size);\n  height: var(--f7-input-clear-button-size);\n  margin-top: calc(-1 * var(--f7-input-clear-button-size) / 2);\n  color: var(--f7-input-clear-button-color);\n  right: 0;\n}\n.input-clear-button:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n}\n.input-clear-button:before {\n  position: absolute;\n  content: '';\n  left: 50%;\n  top: 50%;\n}\n.item-input-wrap .input-clear-button {\n  top: calc(var(--f7-input-height) / 2);\n}\n.input-clear-button.active-state {\n  opacity: 0.75 !important;\n}\n.input-with-value ~ .input-clear-button,\n.item-input-with-value .input-clear-button,\n.input-with-value .input-clear-button {\n  opacity: 1;\n  pointer-events: auto;\n  visibility: visible;\n}\n.input-dropdown-wrap,\n.input-dropdown {\n  position: relative;\n}\n.input-dropdown-wrap:before,\n.input-dropdown:before {\n  content: '';\n  pointer-events: none;\n  position: absolute;\n  top: 50%;\n  margin-top: -2px;\n  width: 0;\n  height: 0;\n  border-left: 4px solid transparent;\n  border-right: 4px solid transparent;\n  border-top: 5px solid #727272;\n  right: 6px;\n}\n.input-dropdown-wrap select,\n.input-dropdown select,\n.input-dropdown-wrap input,\n.input-dropdown input,\n.input-dropdown-wrap textarea,\n.input-dropdown textarea {\n  padding-right: calc(20px + var(--f7-input-padding-right));\n}\n.input-outline:after,\n.item-input-outline .item-input-wrap:after {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  box-sizing: border-box;\n  border: 1px solid var(--f7-input-outline-border-color);\n  border-radius: var(--f7-input-outline-border-radius);\n  transition-duration: 200ms;\n  pointer-events: none;\n}\n.input-outline.input-focused:after,\n.item-input-outline.item-input-focused .item-input-wrap:after {\n  border-width: 2px;\n  border-color: var(--f7-input-outline-focused-border-color, var(--f7-theme-color));\n}\n.input-outline.input-invalid:after,\n.item-input-outline.item-input-invalid .item-input-wrap:after {\n  border-width: 2px;\n  border-color: var(--f7-input-outline-invalid-border-color, var(--f7-input-error-text-color));\n}\n.input-outline input,\n.item-input-outline input,\n.list .item-input-outline input,\n.input-outline textarea,\n.item-input-outline textarea,\n.list .item-input-outline textarea,\n.input-outline select,\n.item-input-outline select,\n.list .item-input-outline select {\n  border-radius: var(--f7-input-outline-border-radius);\n  padding-left: var(--f7-input-outline-padding-horizontal);\n  padding-right: var(--f7-input-outline-padding-horizontal);\n}\n.input-outline.input-dropdown:before,\n.item-input-outline .input-dropdown-wrap:before {\n  right: 8px;\n}\n.input-outline.input-dropdown input,\n.item-input-outline .input-dropdown-wrap input,\n.input-outline.input-dropdown textarea,\n.item-input-outline .input-dropdown-wrap textarea,\n.input-outline.input-dropdown select,\n.item-input-outline .input-dropdown-wrap select {\n  padding-right: 20px;\n}\n.input-outline .input-clear-button,\n.item-input-outline .input-clear-button {\n  right: 8px;\n}\n.item-input-outline {\n  --f7-input-height: var(--f7-input-outline-height);\n}\n.item-input-outline .item-inner:after {\n  display: none !important;\n}\n.item-input-outline .item-label {\n  left: var(--f7-input-outline-padding-horizontal);\n}\n.inline-labels .item-input-outline .item-label,\n.inline-label .item-input-outline .item-label,\n.item-input-outline .inline-label .item-label,\n.item-input-outline .inline-label.item-label {\n  left: 0;\n}\n.item-input-outline .item-floating-label {\n  left: calc(var(--f7-input-outline-padding-horizontal) - 4px);\n  padding-left: 4px;\n  padding-right: 4px;\n  background: var(--f7-page-bg-color);\n  z-index: 10;\n  margin-top: calc(-0.5 * (var(--f7-label-font-size) * var(--f7-label-line-height)));\n}\n.item-input-outline.item-input-with-value .item-floating-label,\n.item-input-outline.item-input-focused .item-floating-label {\n  transform: scale(1) translateY(50%);\n}\n.item-input-outline .item-input-info,\n.item-input-outline .item-input-error-message {\n  padding-left: var(--f7-input-outline-padding-horizontal);\n}\n.block-strong .item-input-outline .item-floating-label {\n  background: var(--f7-block-strong-bg-color);\n}\n.list .item-input-outline .item-floating-label {\n  background: var(--f7-list-bg-color);\n}\n.theme-dark option {\n  background-color: var(--f7-page-bg-color);\n}\n.ios .item-label + .item-input-wrap,\n.ios .item-floating-label + .item-input-wrap {\n  margin-top: 0;\n}\n.ios .item-input-focused .item-floating-label {\n  color: var(--f7-label-text-color);\n}\n.ios .item-input .item-media {\n  align-self: flex-start;\n}\n.ios .item-input-wrap {\n  margin-top: calc(-1 * var(--f7-list-item-padding-vertical));\n  margin-bottom: calc(-1 * var(--f7-list-item-padding-vertical));\n}\n.ios .inline-labels .item-label + .item-input-wrap,\n.ios .inline-label .item-label + .item-input-wrap,\n.ios .inline-labels .item-floating-label + .item-input-wrap,\n.ios .inline-label .item-floating-label + .item-input-wrap {\n  margin-top: calc(-1 * var(--f7-list-item-padding-vertical));\n}\n.ios .inline-labels .item-input-wrap,\n.ios .inline-label .item-input-wrap {\n  margin-top: calc(-1 * var(--f7-list-item-padding-vertical));\n}\n.ios .item-input-error-message,\n.ios .item-input-info,\n.ios .input-error-message,\n.ios .input-info {\n  position: relative;\n  margin-bottom: 6px;\n  margin-top: -8px;\n}\n.ios .item-input-focused .item-label,\n.ios .item-input-focused .item-floating-label {\n  color: var(--f7-label-focused-text-color, var(--f7-label-text-color));\n}\n.ios .item-input-focused .item-inner:after {\n  background: var(--f7-input-focused-border-color, var(--f7-list-item-border-color));\n}\n.ios .item-input-invalid .item-label,\n.ios .item-input-invalid .item-floating-label {\n  color: var(--f7-label-invalid-text-color, var(--f7-label-text-color));\n}\n.ios .item-input-invalid .item-inner:after {\n  background: var(--f7-input-invalid-border-color, var(--f7-list-item-border-color));\n}\n.ios .item-input-invalid input,\n.ios .input-invalid input,\n.ios .item-input-invalid select,\n.ios .input-invalid select,\n.ios .item-input-invalid textarea,\n.ios .input-invalid textarea {\n  color: var(--f7-input-invalid-text-color, var(--f7-input-error-text-color));\n}\n.ios .input-clear-button:after {\n  content: 'delete_round_ios';\n  font-size: calc(var(--f7-input-clear-button-size) / (14 / 10));\n  line-height: 1.4;\n}\n.ios .input-clear-button:before {\n  width: 44px;\n  height: 44px;\n  margin-left: -22px;\n  margin-top: -22px;\n}\n.ios .item-input-outline .item-input-wrap,\n.ios .input-outline .item-input-wrap {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.ios .item-input-outline .item-input-error-message,\n.ios .input-outline .item-input-error-message,\n.ios .item-input-outline .item-input-info,\n.ios .input-outline .item-input-info,\n.ios .item-input-outline .input-error-message,\n.ios .input-outline .input-error-message,\n.ios .item-input-outline .input-info,\n.ios .input-outline .input-info {\n  margin-top: 0;\n  white-space: normal;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.ios .item-input-outline .item-input-info,\n.ios .input-outline .item-input-info,\n.ios .item-input-outline .input-info,\n.ios .input-outline .input-info {\n  margin-bottom: calc(-1 * var(--f7-input-info-font-size) * var(--f7-input-info-line-height));\n}\n.ios .item-input-outline .item-input-error-message,\n.ios .input-outline .item-input-error-message,\n.ios .item-input-outline .input-error-message,\n.ios .input-outline .input-error-message {\n  margin-bottom: calc(-1 * var(--f7-input-error-font-size) * var(--f7-input-error-line-height));\n}\n.ios .item-input-outline.item-input-with-info .item-input-wrap,\n.ios .input-outline.item-input-with-info .item-input-wrap,\n.ios .item-input-outline.input-with-info .item-input-wrap,\n.ios .input-outline.input-with-info .item-input-wrap {\n  margin-bottom: calc(var(--f7-input-info-font-size) * var(--f7-input-info-line-height));\n}\n.ios .item-input-outline.item-input-with-error-message .item-input-wrap,\n.ios .input-outline.item-input-with-error-message .item-input-wrap,\n.ios .item-input-outline.input-with-error-message .item-input-wrap,\n.ios .input-outline.input-with-error-message .item-input-wrap {\n  margin-bottom: calc(var(--f7-input-error-font-size) * var(--f7-input-error-line-height));\n}\n.md .item-input:not(.item-input-outline) .item-input-wrap:after,\n.md .input:not(.input-outline):after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-list-item-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.md .item-input:not(.item-input-outline) .item-input-wrap:after,\n.md .input:not(.input-outline):after {\n  transition-duration: 200ms;\n}\n.md .item-input-wrap {\n  min-height: var(--f7-input-height);\n}\n.md .item-input .item-media {\n  align-self: flex-end;\n}\n.md .item-input .item-inner:after {\n  display: none !important;\n}\n.md .inline-labels .item-media,\n.md .inline-label .item-media {\n  align-self: flex-start;\n  padding-top: 14px;\n}\n.md .item-input-with-error-message,\n.md .item-input-with-info,\n.md .input-with-error-message,\n.md .input-with-info {\n  padding-bottom: 20px;\n}\n.md .item-input-error-message,\n.md .item-input-info,\n.md .input-error-message,\n.md .input-info {\n  position: absolute;\n  top: 100%;\n  margin-top: 4px;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  width: 100%;\n  left: 0;\n}\n.md .item-input-focused .item-label,\n.md .item-input-focused .item-floating-label {\n  color: var(--f7-label-focused-text-color, var(--f7-theme-color));\n}\n.md .item-input-focused:not(.item-input-outline) .item-input-wrap:after,\n.md .input-focused:not(.input-outline):after {\n  background: var(--f7-input-focused-border-color, var(--f7-theme-color));\n}\n.md .item-input-invalid:not(.item-input-outline) .item-input-wrap:after,\n.md .item-input-focused:not(.item-input-outline) .item-input-wrap:after,\n.md .input-invalid:not(.input-outline):after,\n.md .input-focused:not(.input-outline):after {\n  transform: scaleY(2) !important;\n}\n.md .item-input-invalid:not(.item-input-outline) .item-input-wrap:after,\n.md .input-invalid:not(.input-outline):after {\n  background: var(--f7-input-invalid-border-color, var(--f7-input-error-text-color));\n}\n.md .item-input-invalid .item-label,\n.md .item-input-invalid .item-floating-label {\n  color: var(--f7-label-invalid-text-color, var(--f7-input-error-text-color));\n}\n.md .item-input-invalid input,\n.md .input-invalid input,\n.md .item-input-invalid select,\n.md .input-invalid select,\n.md .item-input-invalid textarea,\n.md .input-invalid textarea {\n  color: var(--f7-input-invalid-text-color, var(--f7-input-text-color));\n}\n.md .input-clear-button:after {\n  font-size: calc(var(--f7-input-clear-button-size) / (24 / 20));\n  content: 'delete_round_md';\n  line-height: 1.2;\n}\n.md .input-clear-button:before {\n  width: 48px;\n  height: 48px;\n  margin-left: -24px;\n  margin-top: -24px;\n}\n.aurora .item-label + .item-input-wrap,\n.aurora .item-floating-label + .item-input-wrap {\n  margin-top: 0;\n}\n.aurora .item-input-focused .item-floating-label {\n  color: var(--f7-label-text-color);\n}\n.aurora .item-input .item-media {\n  align-self: flex-start;\n}\n.aurora .item-input-error-message,\n.aurora .item-input-info,\n.aurora .input-error-message,\n.aurora .input-info {\n  position: relative;\n}\n.aurora .item-input-focused .item-label,\n.aurora .item-input-focused .item-floating-label {\n  color: var(--f7-label-focused-text-color, var(--f7-label-text-color));\n}\n.aurora .item-input-focused .item-inner:after {\n  background: var(--f7-input-focused-border-color, var(--f7-list-item-border-color));\n}\n.aurora .item-input-invalid .item-label,\n.aurora .item-input-invalid .item-floating-label {\n  color: var(--f7-label-invalid-text-color, var(--f7-label-text-color));\n}\n.aurora .item-input-invalid .item-inner:after {\n  background: var(--f7-input-invalid-border-color, var(--f7-list-item-border-color));\n}\n.aurora .item-input-invalid input,\n.aurora .input-invalid input,\n.aurora .item-input-invalid select,\n.aurora .input-invalid select,\n.aurora .item-input-invalid textarea,\n.aurora .input-invalid textarea {\n  color: var(--f7-input-invalid-text-color, var(--f7-input-error-text-color));\n}\n.aurora .input-clear-button:after {\n  content: 'delete_round_ios';\n  font-size: calc(var(--f7-input-clear-button-size) / (14 / 10));\n  line-height: 1.4;\n}\n.aurora .input-clear-button:before {\n  width: 28px;\n  height: 28px;\n  margin-left: -14px;\n  margin-top: -14px;\n}\n.aurora .item-input-outline .item-input-wrap,\n.aurora .input-outline .item-input-wrap {\n  margin-top: 0;\n  margin-bottom: 0;\n}\n.aurora .item-input-outline .item-input-error-message,\n.aurora .input-outline .item-input-error-message,\n.aurora .item-input-outline .item-input-info,\n.aurora .input-outline .item-input-info,\n.aurora .item-input-outline .input-error-message,\n.aurora .input-outline .input-error-message,\n.aurora .item-input-outline .input-info,\n.aurora .input-outline .input-info {\n  margin-top: 0;\n  white-space: normal;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.aurora .item-input-outline .item-input-info,\n.aurora .input-outline .item-input-info,\n.aurora .item-input-outline .input-info,\n.aurora .input-outline .input-info {\n  margin-bottom: calc(-1 * var(--f7-input-info-font-size) * var(--f7-input-info-line-height));\n}\n.aurora .item-input-outline .item-input-error-message,\n.aurora .input-outline .item-input-error-message,\n.aurora .item-input-outline .input-error-message,\n.aurora .input-outline .input-error-message {\n  margin-bottom: calc(-1 * var(--f7-input-error-font-size) * var(--f7-input-error-line-height));\n}\n.aurora .item-input-outline.item-input-with-info .item-input-wrap,\n.aurora .input-outline.item-input-with-info .item-input-wrap,\n.aurora .item-input-outline.input-with-info .item-input-wrap,\n.aurora .input-outline.input-with-info .item-input-wrap {\n  margin-bottom: calc(var(--f7-input-info-font-size) * var(--f7-input-info-line-height));\n}\n.aurora .item-input-outline.item-input-with-error-message .item-input-wrap,\n.aurora .input-outline.item-input-with-error-message .item-input-wrap,\n.aurora .item-input-outline.input-with-error-message .item-input-wrap,\n.aurora .input-outline.input-with-error-message .item-input-wrap {\n  margin-bottom: calc(var(--f7-input-error-font-size) * var(--f7-input-error-line-height));\n}\n/* === Checkbox === */\n:root {\n  /* --f7-checkbox-active-color: var(--f7-theme-color); */\n  --f7-checkbox-icon-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-checkbox-inactive-color: rgba(255, 255, 255, 0.3);\n}\n.ios {\n  --f7-checkbox-size: 22px;\n  --f7-checkbox-border-radius: 50%;\n  --f7-checkbox-border-width: 1px;\n  --f7-checkbox-extra-margin: 0px;\n  --f7-checkbox-inactive-color: #c7c7cc;\n}\n.md {\n  --f7-checkbox-size: 18px;\n  --f7-checkbox-border-radius: 2px;\n  --f7-checkbox-border-width: 2px;\n  --f7-checkbox-extra-margin: 22px;\n  --f7-checkbox-inactive-color: #6d6d6d;\n}\n.aurora {\n  --f7-checkbox-size: 14px;\n  --f7-checkbox-border-radius: 2px;\n  --f7-checkbox-border-width: 1px;\n  --f7-checkbox-extra-margin: 0px;\n  --f7-checkbox-inactive-color: #888;\n}\n.checkbox {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  z-index: 1;\n  background-color: transparent;\n  --f7-touch-ripple-color: rgba(var(--f7-theme-color-rgb), 0.5);\n}\n.icon-checkbox,\n.checkbox i {\n  flex-shrink: 0;\n  border: var(--f7-checkbox-border-width) solid var(--f7-checkbox-inactive-color);\n  width: var(--f7-checkbox-size);\n  height: var(--f7-checkbox-size);\n  border-radius: var(--f7-checkbox-border-radius);\n  box-sizing: border-box;\n  position: relative;\n  display: block;\n}\n.icon-checkbox:after,\n.checkbox i:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  width: var(--f7-checkbox-size);\n  height: var(--f7-checkbox-size);\n  line-height: var(--f7-checkbox-size);\n  top: calc(0px - var(--f7-checkbox-border-width));\n  opacity: 0;\n  color: var(--f7-checkbox-icon-color);\n  position: relative;\n  transition-property: opacity;\n  left: calc(0px - var(--f7-checkbox-border-width));\n}\nlabel.item-checkbox input[type=\"checkbox\"]:not(:checked) ~ .icon-checkbox:after,\nlabel.item-checkbox input[type=\"checkbox\"]:not(:checked) ~ * .icon-checkbox:after,\n.checkbox input[type=\"checkbox\"]:not(:checked) ~ i:after {\n  font-size: 0;\n}\nlabel.item-checkbox input[type=\"checkbox\"]:checked ~ .icon-checkbox,\nlabel.item-checkbox input[type=\"checkbox\"]:checked ~ * .icon-checkbox,\n.checkbox input[type=\"checkbox\"]:checked ~ i,\nlabel.item-checkbox input[type=\"checkbox\"]:indeterminate ~ .icon-checkbox,\nlabel.item-checkbox input[type=\"checkbox\"]:indeterminate ~ * .icon-checkbox,\n.checkbox input[type=\"checkbox\"]:indeterminate ~ i {\n  border-color: var(--f7-checkbox-active-color, var(--f7-theme-color));\n  background-color: var(--f7-checkbox-active-color, var(--f7-theme-color));\n}\nlabel.item-checkbox input[type=\"checkbox\"]:checked ~ .icon-checkbox:after,\nlabel.item-checkbox input[type=\"checkbox\"]:checked ~ * .icon-checkbox:after,\n.checkbox input[type=\"checkbox\"]:checked ~ i:after,\nlabel.item-checkbox input[type=\"checkbox\"]:indeterminate ~ .icon-checkbox:after,\nlabel.item-checkbox input[type=\"checkbox\"]:indeterminate ~ * .icon-checkbox:after,\n.checkbox input[type=\"checkbox\"]:indeterminate ~ i:after {\n  opacity: 1;\n}\nlabel.item-checkbox input[type=\"checkbox\"]:indeterminate ~ .icon-checkbox:after,\nlabel.item-checkbox input[type=\"checkbox\"]:indeterminate ~ * .icon-checkbox:after,\n.checkbox input[type=\"checkbox\"]:indeterminate ~ i:after {\n  font-size: 0;\n  content: '';\n  position: absolute;\n  top: 50%;\n  width: 70%;\n  background: #fff;\n  height: 2px;\n  border-radius: 2px;\n  margin-top: -1px;\n  transition: 0ms;\n  left: 15%;\n}\nlabel.item-checkbox,\n.checkbox {\n  cursor: pointer;\n}\nlabel.item-checkbox input[type=\"checkbox\"],\n.checkbox input[type=\"checkbox\"],\nlabel.item-checkbox input[type=\"radio\"],\n.checkbox input[type=\"radio\"] {\n  display: none;\n}\nlabel.item-checkbox {\n  transition-duration: 300ms;\n}\nlabel.item-checkbox .item-content .item-media,\nlabel.item-checkbox.item-content .item-media {\n  align-self: center;\n}\nlabel.item-checkbox > .icon-checkbox {\n  margin-right: calc(var(--f7-list-item-media-margin) + var(--f7-checkbox-extra-margin));\n}\nlabel.item-checkbox.active-state {\n  background-color: var(--f7-list-link-pressed-bg-color);\n}\nlabel.item-checkbox.active-state:after {\n  background-color: transparent;\n}\nlabel.item-checkbox.disabled,\n.disabled label.item-checkbox {\n  opacity: 0.55;\n  pointer-events: none;\n  opacity: 0.55 !important;\n  pointer-events: none !important;\n}\n.ios .icon-checkbox:after,\n.ios .checkbox i:after {\n  content: 'checkbox_ios';\n  font-size: 21px;\n}\n.ios label.item-checkbox.active-state {\n  transition-duration: 0ms;\n}\n.ios label.item-checkbox input[type=\"checkbox\"]:indeterminate ~ .icon-checkbox:after,\n.ios label.item-checkbox input[type=\"checkbox\"]:indeterminate ~ * .icon-checkbox:after,\n.ios .checkbox input[type=\"checkbox\"]:indeterminate ~ i:after {\n  height: 1px;\n  margin-top: 0px;\n}\n.md .icon-checkbox,\n.md .checkbox i {\n  transition-duration: 200ms;\n}\n.md .icon-checkbox:after,\n.md .checkbox i:after {\n  content: 'checkbox_md';\n  transition-duration: 200ms;\n  font-size: 15px;\n}\n.md label.item-checkbox {\n  position: relative;\n  overflow: hidden;\n  z-index: 0;\n}\n.aurora .icon-checkbox,\n.aurora .checkbox i {\n  transition-duration: 150ms;\n}\n.aurora .icon-checkbox:after,\n.aurora .checkbox i:after {\n  content: 'checkbox_aurora';\n  transition-duration: 150ms;\n  font-size: 19px;\n}\n.aurora .icon-checkbox:before,\n.aurora .checkbox i:before {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(0, 0, 0, 0.1);\n  opacity: 0;\n  transition-duration: 150ms;\n}\n.aurora .checkbox.active-state i:before {\n  opacity: 1;\n}\n.aurora label.item-checkbox {\n  position: relative;\n  overflow: hidden;\n  z-index: 0;\n}\n/* === Radio === */\n:root {\n  /*\n  --f7-radio-active-color: var(--f7-theme-color);\n  */\n  --f7-radio-border-radius: 50%;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-radio-inactive-color: rgba(255, 255, 255, 0.3);\n}\n.ios {\n  --f7-radio-size: 22px;\n  --f7-radio-border-width: 1px;\n  --f7-radio-extra-margin: 0px;\n  --f7-radio-inactive-color: #c7c7cc;\n}\n.md {\n  --f7-radio-size: 20px;\n  --f7-radio-border-width: 2px;\n  --f7-radio-extra-margin: 22px;\n  --f7-radio-inactive-color: #6d6d6d;\n}\n.aurora {\n  --f7-radio-size: 16px;\n  --f7-radio-border-width: 1px;\n  --f7-radio-extra-margin: 0px;\n  --f7-radio-inactive-color: #888;\n}\n.radio {\n  position: relative;\n  display: inline-block;\n  vertical-align: middle;\n  z-index: 1;\n  --f7-touch-ripple-color: rgba(var(--f7-theme-color-rgb), 0.5);\n}\n.icon-radio {\n  width: var(--f7-radio-size);\n  height: var(--f7-radio-size);\n  border-radius: var(--f7-radio-border-radius);\n  position: relative;\n  box-sizing: border-box;\n  display: block;\n  flex-shrink: 0;\n}\n.radio .icon-radio,\n.md .icon-radio,\n.aurora .icon-radio {\n  border: var(--f7-radio-border-width) solid var(--f7-radio-inactive-color);\n}\nlabel.item-radio,\n.radio {\n  cursor: pointer;\n}\nlabel.item-radio input[type=\"checkbox\"],\n.radio input[type=\"checkbox\"],\nlabel.item-radio input[type=\"radio\"],\n.radio input[type=\"radio\"] {\n  display: none;\n}\nlabel.item-radio {\n  transition-duration: 300ms;\n}\nlabel.item-radio .item-content .item-media,\nlabel.item-radio.item-content .item-media {\n  align-self: center;\n}\nlabel.item-radio.active-state {\n  background-color: var(--f7-list-link-pressed-bg-color);\n}\nlabel.item-radio.active-state:after {\n  background-color: transparent;\n}\nlabel.item-radio.disabled,\n.disabled label.item-radio {\n  opacity: 0.55;\n  pointer-events: none;\n  opacity: 0.55 !important;\n  pointer-events: none !important;\n}\n.ios .icon-radio:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  width: calc(var(--f7-radio-size) - var(--f7-radio-border-width) * 2);\n  height: calc(var(--f7-radio-size) - var(--f7-radio-border-width) * 2);\n  line-height: calc(var(--f7-radio-size) - var(--f7-radio-border-width) * 2 + 1px);\n  font-size: 20px;\n  content: 'radio_ios';\n  color: var(--f7-radio-active-color, var(--f7-theme-color));\n  opacity: 0;\n}\n.ios label.item-radio input[type=\"radio\"]:checked ~ .icon-radio:after,\n.ios label.item-radio input[type=\"radio\"]:checked ~ * .icon-radio:after,\n.ios .radio input[type=\"radio\"]:checked ~ .icon-radio:after {\n  opacity: 1;\n}\n.ios .radio input[type=\"radio\"]:checked ~ .icon-radio {\n  border-color: var(--f7-radio-active-color, var(--f7-theme-color));\n}\n.ios label.item-radio:not(.item-radio-icon-start) input[type=\"radio\"] ~ .icon-radio {\n  position: absolute;\n  top: 50%;\n  margin-top: -11px;\n  right: calc(var(--f7-safe-area-right) + 10px);\n}\n.ios label.item-radio:not(.item-radio-icon-start) .item-inner {\n  padding-right: calc(var(--f7-safe-area-right) + 36px);\n}\n.ios label.item-radio-icon-start > .icon-radio {\n  margin-right: calc(var(--f7-list-item-media-margin) + var(--f7-checkbox-extra-margin));\n}\n.ios label.item-radio.active-state {\n  transition-duration: 0ms;\n}\n.md .icon-radio {\n  transition-duration: 200ms;\n}\n.md .icon-radio:after {\n  content: '';\n  position: absolute;\n  width: 10px;\n  height: 10px;\n  left: 50%;\n  top: 50%;\n  margin-left: -5px;\n  margin-top: -5px;\n  background-color: var(--f7-radio-active-color, var(--f7-theme-color));\n  border-radius: 50%;\n  transform: scale(0);\n  transition-duration: 200ms;\n}\n.md label.item-radio input[type=\"radio\"]:checked ~ .icon-radio,\n.md label.item-radio input[type=\"radio\"]:checked ~ * .icon-radio,\n.md .radio input[type=\"radio\"]:checked ~ .icon-radio {\n  border-color: var(--f7-radio-active-color, var(--f7-theme-color));\n}\n.md label.item-radio input[type=\"radio\"]:checked ~ .icon-radio:after,\n.md label.item-radio input[type=\"radio\"]:checked ~ * .icon-radio:after,\n.md .radio input[type=\"radio\"]:checked ~ .icon-radio:after {\n  background-color: var(--f7-radio-active-color, var(--f7-theme-color));\n  transform: scale(1);\n}\n.md label.item-radio {\n  position: relative;\n  overflow: hidden;\n  z-index: 0;\n}\n.md label.item-radio:not(.item-radio-icon-end) > .icon-radio {\n  margin-right: calc(var(--f7-list-item-media-margin) + var(--f7-radio-extra-margin));\n}\n.md label.item-radio-icon-end input[type=\"radio\"] ~ .icon-radio {\n  position: absolute;\n  top: 50%;\n  margin-top: -10px;\n  right: calc(var(--f7-safe-area-right) + 16px);\n}\n.md label.item-radio-icon-end .item-inner {\n  padding-right: calc(var(--f7-safe-area-right) + 52px);\n}\n.aurora .icon-radio {\n  transition-duration: 150ms;\n  overflow: hidden;\n}\n.aurora .icon-radio:after {\n  content: '';\n  position: absolute;\n  width: 6px;\n  height: 6px;\n  left: 50%;\n  top: 50%;\n  margin-left: -3px;\n  margin-top: -3px;\n  background-color: #fff;\n  border-radius: 50%;\n  transform: scale(0);\n  transition-duration: 150ms;\n}\n.aurora .icon-radio:before {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background: rgba(0, 0, 0, 0.1);\n  opacity: 0;\n  transition-duration: 150ms;\n}\n.aurora .radio.active-state i:before {\n  opacity: 1;\n}\n.aurora label.item-radio input[type=\"radio\"]:checked ~ .icon-radio,\n.aurora label.item-radio input[type=\"radio\"]:checked ~ * .icon-radio,\n.aurora .radio input[type=\"radio\"]:checked ~ .icon-radio {\n  border-color: var(--f7-radio-active-color, var(--f7-theme-color));\n  background-color: var(--f7-radio-active-color, var(--f7-theme-color));\n}\n.aurora label.item-radio input[type=\"radio\"]:checked ~ .icon-radio:after,\n.aurora label.item-radio input[type=\"radio\"]:checked ~ * .icon-radio:after,\n.aurora .radio input[type=\"radio\"]:checked ~ .icon-radio:after {\n  transform: scale(1);\n}\n.aurora label.item-radio {\n  position: relative;\n  overflow: hidden;\n  z-index: 0;\n}\n.aurora label.item-radio:not(.item-radio-icon-end) > .icon-radio {\n  margin-right: calc(var(--f7-list-item-media-margin) + var(--f7-radio-extra-margin));\n}\n.aurora label.item-radio-icon-end input[type=\"radio\"] ~ .icon-radio {\n  position: absolute;\n  top: 50%;\n  margin-top: -8px;\n  right: calc(var(--f7-safe-area-right) + 16px);\n}\n.aurora label.item-radio-icon-end .item-inner {\n  padding-right: calc(var(--f7-safe-area-right) + 48px);\n}\n/* === Toggle === */\n:root {\n  --f7-toggle-handle-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-toggle-inactive-color: #555;\n}\n.ios {\n  --f7-toggle-width: 52px;\n  --f7-toggle-height: 32px;\n  --f7-toggle-border-color: #e5e5e5;\n  --f7-toggle-inactive-color: #fff;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-toggle-border-color: #555;\n}\n.md {\n  --f7-toggle-width: 36px;\n  --f7-toggle-height: 14px;\n  --f7-toggle-inactive-color: #b0afaf;\n}\n.aurora {\n  --f7-toggle-width: 40px;\n  --f7-toggle-height: 20px;\n  --f7-toggle-inactive-color: #aaa;\n}\n.toggle,\n.toggle-icon {\n  width: var(--f7-toggle-width);\n  height: var(--f7-toggle-height);\n  border-radius: var(--f7-toggle-height);\n}\n.toggle {\n  display: inline-block;\n  vertical-align: middle;\n  position: relative;\n  box-sizing: border-box;\n  align-self: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.toggle input[type=\"checkbox\"] {\n  display: none;\n}\n.toggle input[disabled] ~ .toggle-icon {\n  pointer-events: none;\n}\n.toggle-icon {\n  z-index: 0;\n  margin: 0;\n  padding: 0;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border: none;\n  position: relative;\n  transition: 300ms;\n  box-sizing: border-box;\n  display: block;\n  cursor: pointer;\n}\n.toggle-icon:before,\n.toggle-icon:after {\n  content: '';\n}\n.toggle-icon:after {\n  background: var(--f7-toggle-handle-color);\n  position: absolute;\n  z-index: 2;\n  transform: translateX(0px);\n  transition-duration: 300ms;\n}\n.ios .toggle input[type=\"checkbox\"]:checked + .toggle-icon {\n  background: var(--f7-toggle-active-color, var(--f7-theme-color));\n}\n.ios .toggle input[type=\"checkbox\"]:checked + .toggle-icon:before {\n  transform: scale(0);\n}\n.ios .toggle input[type=\"checkbox\"]:checked + .toggle-icon:after {\n  transform: translateX(calc(var(--f7-toggle-width) - var(--f7-toggle-height)));\n}\n.ios .toggle-icon {\n  background: var(--f7-toggle-border-color);\n}\n.ios .toggle-icon:before {\n  position: absolute;\n  left: 2px;\n  top: 2px;\n  width: calc(var(--f7-toggle-width) - 4px);\n  height: calc(var(--f7-toggle-height) - 4px);\n  border-radius: var(--f7-toggle-height);\n  box-sizing: border-box;\n  background: var(--f7-toggle-inactive-color);\n  z-index: 1;\n  transition-duration: 300ms;\n  transform: scale(1);\n}\n.ios .toggle-icon:after {\n  height: calc(var(--f7-toggle-height) - 4px);\n  width: calc(var(--f7-toggle-height) - 4px);\n  top: 2px;\n  left: 2px;\n  box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n  border-radius: calc(var(--f7-toggle-height) - 4px);\n}\n.ios .toggle-active-state input[type=\"checkbox\"]:not(:checked) + .toggle-icon:before {\n  transform: scale(0);\n}\n.ios .toggle-active-state input[type=\"checkbox\"] + .toggle-icon:after {\n  width: calc(var(--f7-toggle-height) + 4px);\n}\n.ios .toggle-active-state input[type=\"checkbox\"]:checked + .toggle-icon:after {\n  transform: translateX(calc(var(--f7-toggle-width) - var(--f7-toggle-height) - 8px));\n}\n.md .toggle input[type=\"checkbox\"]:checked + .toggle-icon {\n  background: var(--f7-toggle-active-color, rgba(var(--f7-theme-color-rgb), 0.5));\n}\n.md .toggle input[type=\"checkbox\"]:checked + .toggle-icon:after {\n  transform: translateX(calc(var(--f7-toggle-width) - var(--f7-toggle-height) - 6px));\n  background: var(--f7-toggle-active-color, var(--f7-theme-color));\n}\n.md .toggle-icon {\n  background: var(--f7-toggle-inactive-color);\n}\n.md .toggle-icon:after {\n  height: calc(var(--f7-toggle-height) + 6px);\n  width: calc(var(--f7-toggle-height) + 6px);\n  top: -3px;\n  box-shadow: 0 2px 5px rgba(0, 0, 0, 0.4);\n  border-radius: var(--f7-toggle-height);\n  left: 0;\n}\n.aurora .toggle input[type=\"checkbox\"]:checked + .toggle-icon {\n  background: var(--f7-toggle-active-color, var(--f7-theme-color));\n}\n.aurora .toggle input[type=\"checkbox\"]:checked + .toggle-icon:after {\n  transform: translateX(calc(var(--f7-toggle-width) - var(--f7-toggle-height)));\n}\n.aurora .toggle-icon {\n  background: var(--f7-toggle-inactive-color);\n}\n.aurora .toggle-icon:after {\n  height: calc(var(--f7-toggle-height) - 4px);\n  width: calc(var(--f7-toggle-height) - 4px);\n  top: 2px;\n  left: 2px;\n  border-radius: calc(var(--f7-toggle-height) - 4px);\n}\n/* === Range Slider === */\n:root {\n  /*\n  --f7-range-bar-active-bg-color: var(--f7-theme-color);\n  --f7-range-scale-bg-color: var(--f7-range-bar-bg-color);\n  --f7-range-scale-substep-bg-color: var(--f7-range-bar-bg-color);\n  */\n  --f7-range-scale-step-height: 5px;\n  --f7-range-scale-text-color: #666;\n  --f7-range-scale-substep-width: 1px;\n  --f7-range-scale-substep-height: 4px;\n}\n.ios {\n  --f7-range-size: 28px;\n  --f7-range-bar-bg-color: #b7b8b7;\n  --f7-range-bar-size: 1px;\n  --f7-range-bar-border-radius: 2px;\n  --f7-range-knob-size: 28px;\n  --f7-range-knob-color: #fff;\n  --f7-range-knob-box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);\n  --f7-range-label-size: 20px;\n  --f7-range-label-text-color: #000;\n  --f7-range-label-bg-color: #fff;\n  --f7-range-label-font-size: 12px;\n  --f7-range-label-font-weight: normal;\n  --f7-range-label-border-radius: 5px;\n  --f7-range-label-padding: 0px;\n  --f7-range-scale-step-width: 1px;\n  --f7-range-scale-font-size: 12px;\n  --f7-range-scale-font-weight: 400;\n  --f7-range-scale-label-offset: 4px;\n}\n.md {\n  --f7-range-size: 20px;\n  --f7-range-bar-bg-color: #b9b9b9;\n  --f7-range-bar-size: 2px;\n  --f7-range-bar-border-radius: 0px;\n  --f7-range-knob-size: 12px;\n  /*\n  --f7-range-knob-color: var(--f7-theme-color);\n  */\n  --f7-range-knob-box-shadow: none;\n  --f7-range-label-size: 26px;\n  --f7-range-label-font-weight: normal;\n  --f7-range-label-text-color: #fff;\n  /*\n  --f7-range-label-bg-color: var(--f7-theme-color);\n  */\n  --f7-range-label-font-size: 10px;\n  --f7-range-label-border-radius: 50%;\n  --f7-range-label-padding: 0px;\n  --f7-range-scale-step-width: 2px;\n  --f7-range-scale-font-size: 12px;\n  --f7-range-scale-font-weight: 400;\n  --f7-range-scale-label-offset: 4px;\n}\n.aurora {\n  --f7-range-size: 20px;\n  --f7-range-bar-bg-color: #c7c7c7;\n  --f7-range-bar-size: 2px;\n  --f7-range-bar-border-radius: 2px;\n  --f7-range-knob-size: 16px;\n  /*\n  --f7-range-knob-color: var(--f7-theme-color);\n  */\n  --f7-range-knob-box-shadow: none;\n  --f7-range-label-size: 20px;\n  --f7-range-label-text-color: #fff;\n  /*\n  --f7-range-label-bg-color: var(--f7-theme-color);\n  */\n  --f7-range-label-font-size: 10px;\n  --f7-range-label-font-weight: 600;\n  --f7-range-label-border-radius: 4px;\n  --f7-range-label-padding: 0px 4px;\n  --f7-range-scale-step-width: 2px;\n  --f7-range-scale-font-size: 11px;\n  --f7-range-scale-font-weight: 500;\n  --f7-range-scale-label-offset: 2px;\n}\n.range-slider {\n  display: block;\n  position: relative;\n  align-self: center;\n  cursor: pointer;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.range-slider input[type=\"range\"] {\n  display: none;\n}\n.range-slider.range-slider-horizontal {\n  width: 100%;\n  height: var(--f7-range-size);\n}\n.range-slider.range-slider-vertical {\n  height: 100%;\n  width: var(--f7-range-size);\n}\n.range-bar {\n  position: absolute;\n  overflow: hidden;\n  background: var(--f7-range-bar-bg-color);\n  border-radius: var(--f7-range-bar-border-radius);\n}\n.range-slider-vertical .range-bar {\n  left: 50%;\n  top: 0;\n  height: 100%;\n  width: var(--f7-range-bar-size);\n  margin-left: calc(-1 * var(--f7-range-bar-size) / 2);\n}\n.range-slider-horizontal .range-bar {\n  left: 0;\n  top: 50%;\n  width: 100%;\n  height: var(--f7-range-bar-size);\n  margin-top: calc(-1 * var(--f7-range-bar-size) / 2);\n}\n.range-bar-active {\n  position: absolute;\n  background: var(--f7-range-bar-active-bg-color, var(--f7-theme-color));\n}\n.range-slider-horizontal .range-bar-active {\n  left: 0;\n  top: 0;\n  height: 100%;\n}\n.range-slider-vertical .range-bar-active {\n  left: 0;\n  bottom: 0;\n  width: 100%;\n}\n.range-slider-vertical-reversed .range-bar-active {\n  top: 0;\n  bottom: auto;\n}\n.range-knob-wrap {\n  z-index: 20;\n  position: absolute;\n  height: var(--f7-range-knob-size);\n  width: var(--f7-range-knob-size);\n}\n.range-slider-horizontal .range-knob-wrap {\n  top: 50%;\n  margin-top: calc(-1 * var(--f7-range-knob-size) / 2);\n  margin-left: calc(-1 * var(--f7-range-knob-size) / 2);\n  left: 0;\n}\n.range-slider-vertical .range-knob-wrap {\n  left: 50%;\n  margin-left: calc(-1 * var(--f7-range-knob-size) / 2);\n  bottom: 0;\n  margin-bottom: calc(-1 * var(--f7-range-knob-size) / 2);\n}\n.range-slider-vertical-reversed .range-knob-wrap {\n  bottom: auto;\n  top: 0;\n  margin-bottom: 0;\n  margin-top: calc(-1 * var(--f7-range-knob-size) / 2);\n}\n.range-knob {\n  box-sizing: border-box;\n  border-radius: 50%;\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  background: var(--f7-range-knob-color, var(--f7-range-knob-bg-color, var(--f7-theme-color)));\n  box-shadow: var(--f7-range-knob-box-shadow);\n}\n.range-knob:after {\n  content: '';\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  width: 44px;\n  height: 44px;\n  margin-left: -22px;\n  margin-top: -22px;\n}\n.range-knob-label {\n  position: absolute;\n  left: 50%;\n  bottom: 100%;\n  text-align: center;\n  transition-duration: 120ms;\n  transition-property: transform;\n  box-sizing: border-box;\n  transform: translateY(100%) scale(0);\n  height: var(--f7-range-label-size);\n  line-height: var(--f7-range-label-size);\n  min-width: var(--f7-range-label-size);\n  color: var(--f7-range-label-text-color);\n  background-color: var(--f7-range-label-bg-color, var(--f7-theme-color));\n  font-size: var(--f7-range-label-font-size);\n  font-weight: var(--f7-range-label-font-weight);\n  border-radius: var(--f7-range-label-border-radius);\n  padding: var(--f7-range-label-padding);\n}\n.range-knob-active-state .range-knob-label {\n  transform: translateY(0%) scale(1);\n}\n.range-scale {\n  position: absolute;\n}\n.range-slider-horizontal .range-scale {\n  top: 50%;\n  left: 0;\n  width: 100%;\n  margin-top: calc(var(--f7-range-bar-size) / 2);\n}\n.range-slider-vertical .range-scale {\n  right: 50%;\n  top: 0;\n  height: 100%;\n  margin-right: calc(var(--f7-range-bar-size) / 2);\n}\n.range-scale-step {\n  position: absolute;\n  box-sizing: border-box;\n  display: flex;\n  font-size: var(--f7-range-scale-font-size);\n  font-weight: var(--f7-range-scale-font-weight);\n  color: var(--f7-range-scale-text-color, var(--f7-range-bar-bg-color));\n  line-height: 1;\n}\n.range-scale-step:before {\n  content: '';\n  position: absolute;\n  background: var(--f7-range-scale-step-bg-color, var(--f7-range-bar-bg-color));\n}\n.range-slider-horizontal .range-scale-step {\n  justify-content: center;\n  align-items: flex-start;\n  width: var(--f7-range-scale-step-width);\n  height: var(--f7-range-scale-step-height);\n  padding-top: calc(var(--f7-range-scale-step-height) + var(--f7-range-scale-label-offset));\n  top: 0;\n  margin-left: calc(-1 * var(--f7-range-scale-step-width) / 2);\n}\n.range-slider-horizontal .range-scale-step:before {\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: var(--f7-range-scale-step-height);\n}\n.range-slider-horizontal .range-scale-step:first-child {\n  margin-left: 0;\n}\n.range-slider-horizontal .range-scale-step:last-child {\n  margin-left: calc(-1 * var(--f7-range-scale-step-width));\n}\n.range-slider-vertical .range-scale-step {\n  line-height: 1;\n  justify-content: flex-end;\n  align-items: center;\n  height: var(--f7-range-scale-step-width);\n  width: var(--f7-range-scale-step-height);\n  padding-right: calc(var(--f7-range-scale-step-height) + var(--f7-range-scale-label-offset));\n  right: 0;\n  margin-bottom: calc(-1 * var(--f7-range-scale-step-width) / 2);\n}\n.range-slider-vertical .range-scale-step:first-child {\n  margin-bottom: 0;\n}\n.range-slider-vertical .range-scale-step:last-child {\n  margin-bottom: calc(-1 * var(--f7-range-scale-step-width));\n}\n.range-slider-vertical .range-scale-step:before {\n  right: 0;\n  top: 0;\n  height: 100%;\n  width: var(--f7-range-scale-step-height);\n}\n.range-scale-substep {\n  --f7-range-scale-step-bg-color: var(--f7-range-scale-substep-bg-color, var(--f7-range-bar-bg-color));\n  --f7-range-scale-step-width: var(--f7-range-scale-substep-width);\n  --f7-range-scale-step-height: var(--f7-range-scale-substep-height);\n}\n.ios .range-knob-label {\n  margin-bottom: 6px;\n  transform: translateX(-50%) translateY(100%) scale(0);\n}\n.ios .range-knob-active-state .range-knob-label {\n  transform: translateX(-50%) translateY(0%) scale(1);\n}\n.md .range-knob {\n  transition-duration: 200ms;\n  transition-property: transform, background-color;\n}\n.md .range-knob-active-state .range-knob {\n  transform: scale(1.5);\n}\n.md .range-slider-min:not(.range-slider-dual) .range-knob {\n  background: #fff !important;\n  border: 2px solid var(--f7-range-bar-bg-color);\n}\n.md .range-knob-label {\n  width: var(--f7-range-label-size);\n  margin-left: calc(-1 * var(--f7-range-label-size) / 2);\n  margin-bottom: 8px;\n}\n.md .range-knob-label:before {\n  content: '';\n  left: 50%;\n  top: 0px;\n  margin-left: calc(-1 * var(--f7-range-label-size) / 2);\n  position: absolute;\n  z-index: -1;\n  width: var(--f7-range-label-size);\n  height: var(--f7-range-label-size);\n  background: var(--f7-range-label-bg-color, var(--f7-theme-color));\n  transform: rotate(-45deg);\n  border-radius: 50% 50% 50% 0;\n}\n.md .range-knob-active-state .range-knob-label {\n  transform: translateY(0%) scale(1);\n}\n.md .range-slider-label .range-knob-active-state .range-knob {\n  transform: scale(0);\n}\n.aurora .range-knob-label {\n  margin-bottom: 6px;\n  transform: translateX(-50%) translateY(100%) scale(0);\n}\n.aurora .range-knob-active-state .range-knob-label {\n  transform: translateX(-50%) translateY(0%) scale(1);\n}\n/* === Stepper === */\n:root {\n  /*\n  --f7-stepper-button-text-color: var(--f7-theme-color);\n  --f7-stepper-button-pressed-text-color: var(--f7-button-text-color, var(--f7-theme-color));\n  --f7-stepper-value-text-color: var(--f7-theme-color);\n  */\n  --f7-stepper-fill-button-text-color: #fff;\n  /*\n  --f7-stepper-fill-button-bg-color: var(--f7-theme-color);\n  */\n  --f7-stepper-raised-box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0,0,0,0.24);\n  --f7-stepper-value-font-weight: 500;\n  --f7-stepper-border-width: 2px;\n}\n.ios {\n  --f7-stepper-height: 28px;\n  --f7-stepper-border-radius: 5px;\n  /*\n  --f7-stepper-button-pressed-bg-color: rgba(var(--f7-theme-color-rgb), .15);\n  --f7-stepper-fill-button-pressed-bg-color: var(--f7-theme-color-tint);\n  */\n  --f7-stepper-large-height: 44px;\n  --f7-stepper-small-height: 26px;\n  --f7-stepper-small-border-width: 2px;\n  --f7-stepper-value-font-size: 17px;\n}\n.md {\n  --f7-stepper-height: 36px;\n  --f7-stepper-border-radius: 4px;\n  /*\n  --f7-stepper-fill-button-pressed-bg-color: var(--f7-theme-color-shade);\n  */\n  --f7-stepper-large-height: 48px;\n  --f7-stepper-small-border-width: 2px;\n  --f7-stepper-small-height: 28px;\n  --f7-stepper-value-font-size: 14px;\n  --f7-stepper-button-pressed-bg-color: rgba(0, 0, 0, 0.1);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-stepper-button-pressed-bg-color: rgba(255, 255, 255, 0.1);\n}\n.aurora {\n  /*\n  --f7-stepper-button-hover-bg-color: rgba(var(--f7-theme-color-rgb), .07);\n  --f7-stepper-button-fill-hover-bg-color: var(--f7-theme-color-tint);\n  */\n  --f7-stepper-height: 28px;\n  --f7-stepper-border-radius: 4px;\n  /*\n  --f7-stepper-button-pressed-bg-color: rgba(var(--f7-theme-color-rgb), .15);\n  --f7-stepper-fill-button-pressed-bg-color: var(--f7-theme-color-shade);\n  */\n  --f7-stepper-large-height: 34px;\n  --f7-stepper-small-border-width: 1px;\n  --f7-stepper-small-height: 22px;\n  --f7-stepper-value-font-size: 14px;\n}\n.stepper {\n  display: inline-flex;\n  align-items: stretch;\n  height: var(--f7-stepper-height);\n  border-radius: var(--f7-stepper-border-radius);\n}\n.stepper-button,\n.stepper-button-minus,\n.stepper-button-plus {\n  background-color: var(--f7-stepper-button-bg-color);\n  width: 40px;\n  border-radius: var(--f7-stepper-border-radius);\n  border: var(--f7-stepper-border-width) solid var(--f7-theme-color);\n  color: var(--f7-stepper-button-text-color, var(--f7-theme-color));\n  line-height: calc(var(--f7-stepper-height) - var(--f7-stepper-border-width, 0px));\n  text-align: center;\n  display: flex;\n  justify-content: center;\n  align-content: center;\n  align-items: center;\n  flex-shrink: 0;\n  box-sizing: border-box;\n  position: relative;\n  cursor: pointer;\n}\n.stepper-button.active-state,\n.stepper-button-minus.active-state,\n.stepper-button-plus.active-state {\n  background-color: var(--f7-stepper-button-pressed-bg-color, rgba(var(--f7-theme-color-rgb), 0.15));\n  color: var(--f7-stepper-button-pressed-text-color, var(--f7-stepper-button-text-color, var(--f7-theme-color)));\n}\n.stepper-button:first-child,\n.stepper-button-minus:first-child,\n.stepper-button-plus:first-child {\n  border-radius: var(--f7-stepper-border-radius) 0 0 var(--f7-stepper-border-radius);\n}\n.stepper-button:last-child,\n.stepper-button-minus:last-child,\n.stepper-button-plus:last-child {\n  border-radius: 0 var(--f7-stepper-border-radius) var(--f7-stepper-border-radius) 0;\n}\n.stepper-button .icon,\n.stepper-button-minus .icon,\n.stepper-button-plus .icon {\n  pointer-events: none;\n}\n.stepper-button + .stepper-button,\n.stepper-button-minus + .stepper-button,\n.stepper-button-plus + .stepper-button,\n.stepper-button + .stepper-button-minus,\n.stepper-button-minus + .stepper-button-minus,\n.stepper-button-plus + .stepper-button-minus,\n.stepper-button + .stepper-button-plus,\n.stepper-button-minus + .stepper-button-plus,\n.stepper-button-plus + .stepper-button-plus {\n  border-left: none;\n}\n.stepper-button-plus,\n.stepper-button-minus {\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.stepper-button-plus:after,\n.stepper-button-minus:after,\n.stepper-button-plus:before,\n.stepper-button-minus:before {\n  content: '';\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: var(--f7-stepper-button-text-color, var(--f7-theme-color));\n  border-radius: 2px;\n}\n.stepper-button-plus:after,\n.stepper-button-minus:after {\n  width: 15px;\n  height: 2px;\n}\n.stepper-button-plus:before {\n  height: 15px;\n  width: 2px;\n}\n.stepper-value {\n  display: flex;\n  align-content: center;\n  align-items: center;\n  justify-content: center;\n}\n.stepper-input-wrap,\n.stepper-value {\n  flex-shrink: 1;\n  text-align: center;\n  border-top: var(--f7-stepper-border-width) solid var(--f7-theme-color);\n  border-bottom: var(--f7-stepper-border-width) solid var(--f7-theme-color);\n}\n.stepper .stepper-input-wrap input,\n.stepper-value {\n  width: 45px;\n  color: var(--f7-stepper-value-text-color, var(--f7-theme-color));\n  font-size: var(--f7-stepper-value-font-size);\n  font-weight: var(--f7-stepper-value-font-weight);\n  text-align: center;\n}\n.stepper .stepper-input-wrap input {\n  height: 100%;\n}\n.stepper-round,\n.ios .stepper-round-ios,\n.md .stepper-round-md,\n.aurora .stepper-round-aurora {\n  --f7-stepper-border-radius: var(--f7-stepper-height);\n}\n.stepper-fill,\n.ios .stepper-fill-ios,\n.md .stepper-fill-md,\n.aurora .stepper-fill-aurora {\n  --f7-stepper-button-bg-color: var(--f7-stepper-fill-button-bg-color, var(--f7-theme-color));\n  --f7-stepper-button-text-color: var(--f7-stepper-fill-button-text-color);\n  --f7-touch-ripple-color: var(--f7-touch-ripple-white);\n}\n.stepper-fill .stepper-button + .stepper-button,\n.ios .stepper-fill-ios .stepper-button + .stepper-button,\n.md .stepper-fill-md .stepper-button + .stepper-button,\n.aurora .stepper-fill-aurora .stepper-button + .stepper-button,\n.stepper-raised .stepper-button + .stepper-button,\n.ios .stepper-raised-ios .stepper-button + .stepper-button,\n.md .stepper-raised-md .stepper-button + .stepper-button,\n.aurora .stepper-raised-aurora .stepper-button + .stepper-button,\n.stepper-fill .stepper-button-minus + .stepper-button-plus,\n.ios .stepper-fill-ios .stepper-button-minus + .stepper-button-plus,\n.md .stepper-fill-md .stepper-button-minus + .stepper-button-plus,\n.aurora .stepper-fill-aurora .stepper-button-minus + .stepper-button-plus,\n.stepper-raised .stepper-button-minus + .stepper-button-plus,\n.ios .stepper-raised-ios .stepper-button-minus + .stepper-button-plus,\n.md .stepper-raised-md .stepper-button-minus + .stepper-button-plus,\n.aurora .stepper-raised-aurora .stepper-button-minus + .stepper-button-plus {\n  border-left: 1px solid rgba(0, 0, 0, 0.1);\n}\n.stepper-fill .stepper-button + .stepper-button.active-state,\n.ios .stepper-fill-ios .stepper-button + .stepper-button.active-state,\n.md .stepper-fill-md .stepper-button + .stepper-button.active-state,\n.aurora .stepper-fill-aurora .stepper-button + .stepper-button.active-state,\n.stepper-fill .stepper-button-minus + .stepper-button-plus.active-state,\n.ios .stepper-fill-ios .stepper-button-minus + .stepper-button-plus.active-state,\n.md .stepper-fill-md .stepper-button-minus + .stepper-button-plus.active-state,\n.aurora .stepper-fill-aurora .stepper-button-minus + .stepper-button-plus.active-state {\n  border-left-color: var(--f7-stepper-button-pressed-bg-color);\n}\n.stepper-raised:not(.stepper-fill) .stepper-input-wrap,\n.ios .stepper-raised-ios:not(.stepper-fill-ios):not(.stepper-fill) .stepper-input-wrap,\n.md .stepper-raised-md:not(.stepper-fill-md):not(.stepper-fill) .stepper-input-wrap,\n.aurora .stepper-raised-aurora:not(.stepper-fill-aurora):not(.stepper-fill) .stepper-input-wrap,\n.stepper-raised:not(.stepper-fill) .stepper-value,\n.ios .stepper-raised-ios:not(.stepper-fill-ios):not(.stepper-fill) .stepper-value,\n.md .stepper-raised-md:not(.stepper-fill-md):not(.stepper-fill) .stepper-value,\n.aurora .stepper-raised-aurora:not(.stepper-fill-aurora):not(.stepper-fill) .stepper-value {\n  border-left: 1px solid rgba(0, 0, 0, 0.1);\n  border-right: 1px solid rgba(0, 0, 0, 0.1);\n}\n.stepper-large,\n.ios .stepper-large-ios,\n.md .stepper-large-md,\n.aurora .stepper-large-aurora {\n  --f7-stepper-height: var(--f7-stepper-large-height);\n}\n.stepper-small,\n.ios .stepper-small-ios,\n.md .stepper-small-md,\n.aurora .stepper-small-aurora {\n  --f7-stepper-border-width: var(--f7-stepper-small-border-width);\n  --f7-stepper-height: var(--f7-stepper-small-height);\n}\n.ios .stepper-fill.stepper-small-ios,\n.ios .stepper-fill.stepper-small {\n  --f7-stepper-button-pressed-bg-color: transparent;\n  --f7-stepper-button-pressed-text-color: var(--f7-theme-color);\n}\n.stepper-raised,\n.ios .stepper-raised-ios,\n.md .stepper-raised-md,\n.aurora .stepper-raised-aurora {\n  --f7-stepper-border-width: 0;\n  box-shadow: var(--f7-stepper-raised-box-shadow);\n}\n.ios .stepper-button .f7-icons,\n.ios .stepper-button-minus .f7-icons,\n.ios .stepper-button-plus .f7-icons {\n  font-size: 22px;\n}\n.ios .stepper-fill,\n.ios .stepper-fill-ios {\n  --f7-stepper-button-pressed-bg-color: var(--f7-stepper-fill-button-pressed-bg-color, var(--f7-theme-color-tint));\n}\n.ios .stepper-small.stepper-raised,\n.ios .stepper-small-ios.stepper-raised,\n.ios .stepper-small.stepper-raised-ios,\n.ios .stepper-small-ios.stepper-raised-ios {\n  --f7-stepper-border-width: 0px;\n}\n.ios .stepper-small .stepper-button,\n.ios .stepper-small-ios .stepper-button,\n.ios .stepper-small .stepper-button-minus,\n.ios .stepper-small-ios .stepper-button-minus,\n.ios .stepper-small .stepper-button-plus,\n.ios .stepper-small-ios .stepper-button-plus {\n  transition-duration: 200ms;\n}\n.ios .stepper-small .stepper-button.active-state:after,\n.ios .stepper-small-ios .stepper-button.active-state:after,\n.ios .stepper-small .stepper-button-minus.active-state:after,\n.ios .stepper-small-ios .stepper-button-minus.active-state:after,\n.ios .stepper-small .stepper-button-plus.active-state:after,\n.ios .stepper-small-ios .stepper-button-plus.active-state:after,\n.ios .stepper-small .stepper-button.active-state:before,\n.ios .stepper-small-ios .stepper-button.active-state:before,\n.ios .stepper-small .stepper-button-minus.active-state:before,\n.ios .stepper-small-ios .stepper-button-minus.active-state:before,\n.ios .stepper-small .stepper-button-plus.active-state:before,\n.ios .stepper-small-ios .stepper-button-plus.active-state:before {\n  transition-duration: 200ms;\n  background-color: var(--f7-theme-color);\n}\n.md .stepper-button,\n.md .stepper-button-minus,\n.md .stepper-button-plus {\n  transition-duration: 300ms;\n  transform: translate3d(0, 0, 0);\n  overflow: hidden;\n}\n.md .stepper-fill,\n.md .stepper-fill-md {\n  --f7-stepper-button-pressed-bg-color: var(--f7-stepper-fill-button-pressed-bg-color, var(--f7-theme-color-shade));\n}\n.aurora .stepper-button,\n.aurora .stepper-button-minus,\n.aurora .stepper-button-plus {\n  transition-duration: 100ms;\n  transform: translate3d(0, 0, 0);\n  overflow: hidden;\n}\n.aurora.device-desktop .stepper-button:not(.active-state):not(.no-hover):hover,\n.aurora.device-desktop .stepper-button-minus:not(.active-state):not(.no-hover):hover,\n.aurora.device-desktop .stepper-button-plus:not(.active-state):not(.no-hover):hover {\n  background-color: var(--f7-stepper-button-hover-bg-color, rgba(var(--f7-theme-color-rgb), 0.07));\n}\n.aurora .stepper-fill,\n.aurora .stepper-fill-aurora {\n  --f7-stepper-button-hover-bg-color: var(--f7-stepper-button-fill-hover-bg-color, var(--f7-theme-color-tint));\n  --f7-stepper-button-pressed-bg-color: var(--f7-stepper-fill-button-pressed-bg-color, var(--f7-theme-color-shade));\n}\n/* === Smart Select === */\n.smart-select :root {\n  /*\n  --f7-smart-select-sheet-bg: var(--f7-list-bg-color);\n  --f7-smart-select-sheet-toolbar-border-color: var(--f7-bars-border-color);\n  */\n}\n.smart-select select {\n  display: none;\n}\n.smart-select .item-after {\n  max-width: 70%;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  position: relative;\n  display: block;\n}\n.smart-select-sheet .page,\n.smart-select-sheet .sheet-modal-inner,\n.smart-select-sheet .list ul {\n  background: var(--f7-smart-select-sheet-bg, var(--f7-list-bg-color));\n}\n.smart-select-sheet .toolbar:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-smart-select-sheet-toolbar-border-color, var(--f7-bars-border-color));\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.smart-select-sheet .toolbar:after {\n  display: block;\n}\n.smart-select-sheet .list {\n  margin: 0;\n}\n.smart-select-sheet .list ul:before,\n.smart-select-sheet .list ul:after {\n  display: none !important;\n}\n.smart-select-popover .popover-inner {\n  max-height: 40vh;\n}\n/* === Grid === */\n:root {\n  --f7-grid-gap: 16px;\n  --f7-grid-row-gap: 0px;\n  --f7-grid-resize-handler-bg-color: rgba(0, 0, 0, 0.35);\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-grid-resize-handler-bg-color: rgba(255, 255, 255, 0.35);\n}\n.row {\n  display: flex;\n  justify-content: space-between;\n  flex-wrap: wrap;\n  align-items: flex-start;\n  --f7-cols-per-row: 1;\n}\n.row + .row {\n  margin-top: var(--f7-grid-row-gap);\n}\n.row > [class*=\"col-\"],\n.row > .col {\n  box-sizing: border-box;\n  width: calc((100% - var(--f7-grid-gap) * (var(--f7-cols-per-row) - 1)) / var(--f7-cols-per-row));\n}\n.row > [class*=\"col-\"].resizable,\n.row > .col.resizable {\n  position: relative;\n}\n.row.resizable {\n  position: relative;\n}\n.row.no-gap {\n  --f7-grid-gap: 0px;\n  --f7-grid-row-gap: 0px;\n}\n.row .col-5 {\n  --f7-cols-per-row: 20;\n}\n.row .col-10 {\n  --f7-cols-per-row: 10;\n}\n.row .col-15 {\n  --f7-cols-per-row: 6.66666667;\n}\n.row .col-20 {\n  --f7-cols-per-row: 5;\n}\n.row .col-25 {\n  --f7-cols-per-row: 4;\n}\n.row .col-30 {\n  --f7-cols-per-row: 3.33333333;\n}\n.row .col-33 {\n  --f7-cols-per-row: 3;\n}\n.row .col-35 {\n  --f7-cols-per-row: 2.85714286;\n}\n.row .col-40 {\n  --f7-cols-per-row: 2.5;\n}\n.row .col-45 {\n  --f7-cols-per-row: 2.22222222;\n}\n.row .col-50 {\n  --f7-cols-per-row: 2;\n}\n.row .col-55 {\n  --f7-cols-per-row: 1.81818182;\n}\n.row .col-60 {\n  --f7-cols-per-row: 1.66666667;\n}\n.row .col-65 {\n  --f7-cols-per-row: 1.53846154;\n}\n.row .col-66 {\n  --f7-cols-per-row: 1.5;\n}\n.row .col-70 {\n  --f7-cols-per-row: 1.42857143;\n}\n.row .col-75 {\n  --f7-cols-per-row: 1.33333333;\n}\n.row .col-80 {\n  --f7-cols-per-row: 1.25;\n}\n.row .col-85 {\n  --f7-cols-per-row: 1.17647059;\n}\n.row .col-90 {\n  --f7-cols-per-row: 1.11111111;\n}\n.row .col-95 {\n  --f7-cols-per-row: 1.05263158;\n}\n.row .col-100 {\n  --f7-cols-per-row: 1;\n}\n.row .col:nth-last-of-type(1),\n.row .col:nth-last-of-type(1) ~ .col {\n  --f7-cols-per-row: 1;\n}\n.row .col:nth-last-of-type(2),\n.row .col:nth-last-of-type(2) ~ .col {\n  --f7-cols-per-row: 2;\n}\n.row .col:nth-last-of-type(3),\n.row .col:nth-last-of-type(3) ~ .col {\n  --f7-cols-per-row: 3;\n}\n.row .col:nth-last-of-type(4),\n.row .col:nth-last-of-type(4) ~ .col {\n  --f7-cols-per-row: 4;\n}\n.row .col:nth-last-of-type(5),\n.row .col:nth-last-of-type(5) ~ .col {\n  --f7-cols-per-row: 5;\n}\n.row .col:nth-last-of-type(6),\n.row .col:nth-last-of-type(6) ~ .col {\n  --f7-cols-per-row: 6;\n}\n.row .col:nth-last-of-type(7),\n.row .col:nth-last-of-type(7) ~ .col {\n  --f7-cols-per-row: 7;\n}\n.row .col:nth-last-of-type(8),\n.row .col:nth-last-of-type(8) ~ .col {\n  --f7-cols-per-row: 8;\n}\n.row .col:nth-last-of-type(9),\n.row .col:nth-last-of-type(9) ~ .col {\n  --f7-cols-per-row: 9;\n}\n.row .col:nth-last-of-type(10),\n.row .col:nth-last-of-type(10) ~ .col {\n  --f7-cols-per-row: 10;\n}\n.row .col:nth-last-of-type(11),\n.row .col:nth-last-of-type(11) ~ .col {\n  --f7-cols-per-row: 11;\n}\n.row .col:nth-last-of-type(12),\n.row .col:nth-last-of-type(12) ~ .col {\n  --f7-cols-per-row: 12;\n}\n.row .col:nth-last-of-type(13),\n.row .col:nth-last-of-type(13) ~ .col {\n  --f7-cols-per-row: 13;\n}\n.row .col:nth-last-of-type(14),\n.row .col:nth-last-of-type(14) ~ .col {\n  --f7-cols-per-row: 14;\n}\n.row .col:nth-last-of-type(15),\n.row .col:nth-last-of-type(15) ~ .col {\n  --f7-cols-per-row: 15;\n}\n.row .col:nth-last-of-type(16),\n.row .col:nth-last-of-type(16) ~ .col {\n  --f7-cols-per-row: 16;\n}\n.row .col:nth-last-of-type(17),\n.row .col:nth-last-of-type(17) ~ .col {\n  --f7-cols-per-row: 17;\n}\n.row .col:nth-last-of-type(18),\n.row .col:nth-last-of-type(18) ~ .col {\n  --f7-cols-per-row: 18;\n}\n.row .col:nth-last-of-type(19),\n.row .col:nth-last-of-type(19) ~ .col {\n  --f7-cols-per-row: 19;\n}\n.row .col:nth-last-of-type(20),\n.row .col:nth-last-of-type(20) ~ .col {\n  --f7-cols-per-row: 20;\n}\n.row .col:nth-last-of-type(21),\n.row .col:nth-last-of-type(21) ~ .col {\n  --f7-cols-per-row: 21;\n}\n.row .col:nth-last-of-type(22),\n.row .col:nth-last-of-type(22) ~ .col {\n  --f7-cols-per-row: 22;\n}\n@media (min-width: 480px) {\n  .row .xsmall-5 {\n    --f7-cols-per-row: 20;\n  }\n  .row .xsmall-10 {\n    --f7-cols-per-row: 10;\n  }\n  .row .xsmall-15 {\n    --f7-cols-per-row: 6.66666667;\n  }\n  .row .xsmall-20 {\n    --f7-cols-per-row: 5;\n  }\n  .row .xsmall-25 {\n    --f7-cols-per-row: 4;\n  }\n  .row .xsmall-30 {\n    --f7-cols-per-row: 3.33333333;\n  }\n  .row .xsmall-33 {\n    --f7-cols-per-row: 3;\n  }\n  .row .xsmall-35 {\n    --f7-cols-per-row: 2.85714286;\n  }\n  .row .xsmall-40 {\n    --f7-cols-per-row: 2.5;\n  }\n  .row .xsmall-45 {\n    --f7-cols-per-row: 2.22222222;\n  }\n  .row .xsmall-50 {\n    --f7-cols-per-row: 2;\n  }\n  .row .xsmall-55 {\n    --f7-cols-per-row: 1.81818182;\n  }\n  .row .xsmall-60 {\n    --f7-cols-per-row: 1.66666667;\n  }\n  .row .xsmall-65 {\n    --f7-cols-per-row: 1.53846154;\n  }\n  .row .xsmall-66 {\n    --f7-cols-per-row: 1.5;\n  }\n  .row .xsmall-70 {\n    --f7-cols-per-row: 1.42857143;\n  }\n  .row .xsmall-75 {\n    --f7-cols-per-row: 1.33333333;\n  }\n  .row .xsmall-80 {\n    --f7-cols-per-row: 1.25;\n  }\n  .row .xsmall-85 {\n    --f7-cols-per-row: 1.17647059;\n  }\n  .row .xsmall-90 {\n    --f7-cols-per-row: 1.11111111;\n  }\n  .row .xsmall-95 {\n    --f7-cols-per-row: 1.05263158;\n  }\n  .row .xsmall-100 {\n    --f7-cols-per-row: 1;\n  }\n  .row .xsmall-auto:nth-last-of-type(1),\n  .row .xsmall-auto:nth-last-of-type(1) ~ .xsmall-auto {\n    --f7-cols-per-row: 1;\n  }\n  .row .xsmall-auto:nth-last-of-type(2),\n  .row .xsmall-auto:nth-last-of-type(2) ~ .xsmall-auto {\n    --f7-cols-per-row: 2;\n  }\n  .row .xsmall-auto:nth-last-of-type(3),\n  .row .xsmall-auto:nth-last-of-type(3) ~ .xsmall-auto {\n    --f7-cols-per-row: 3;\n  }\n  .row .xsmall-auto:nth-last-of-type(4),\n  .row .xsmall-auto:nth-last-of-type(4) ~ .xsmall-auto {\n    --f7-cols-per-row: 4;\n  }\n  .row .xsmall-auto:nth-last-of-type(5),\n  .row .xsmall-auto:nth-last-of-type(5) ~ .xsmall-auto {\n    --f7-cols-per-row: 5;\n  }\n  .row .xsmall-auto:nth-last-of-type(6),\n  .row .xsmall-auto:nth-last-of-type(6) ~ .xsmall-auto {\n    --f7-cols-per-row: 6;\n  }\n  .row .xsmall-auto:nth-last-of-type(7),\n  .row .xsmall-auto:nth-last-of-type(7) ~ .xsmall-auto {\n    --f7-cols-per-row: 7;\n  }\n  .row .xsmall-auto:nth-last-of-type(8),\n  .row .xsmall-auto:nth-last-of-type(8) ~ .xsmall-auto {\n    --f7-cols-per-row: 8;\n  }\n  .row .xsmall-auto:nth-last-of-type(9),\n  .row .xsmall-auto:nth-last-of-type(9) ~ .xsmall-auto {\n    --f7-cols-per-row: 9;\n  }\n  .row .xsmall-auto:nth-last-of-type(10),\n  .row .xsmall-auto:nth-last-of-type(10) ~ .xsmall-auto {\n    --f7-cols-per-row: 10;\n  }\n  .row .xsmall-auto:nth-last-of-type(11),\n  .row .xsmall-auto:nth-last-of-type(11) ~ .xsmall-auto {\n    --f7-cols-per-row: 11;\n  }\n  .row .xsmall-auto:nth-last-of-type(12),\n  .row .xsmall-auto:nth-last-of-type(12) ~ .xsmall-auto {\n    --f7-cols-per-row: 12;\n  }\n  .row .xsmall-auto:nth-last-of-type(13),\n  .row .xsmall-auto:nth-last-of-type(13) ~ .xsmall-auto {\n    --f7-cols-per-row: 13;\n  }\n  .row .xsmall-auto:nth-last-of-type(14),\n  .row .xsmall-auto:nth-last-of-type(14) ~ .xsmall-auto {\n    --f7-cols-per-row: 14;\n  }\n  .row .xsmall-auto:nth-last-of-type(15),\n  .row .xsmall-auto:nth-last-of-type(15) ~ .xsmall-auto {\n    --f7-cols-per-row: 15;\n  }\n  .row .xsmall-auto:nth-last-of-type(16),\n  .row .xsmall-auto:nth-last-of-type(16) ~ .xsmall-auto {\n    --f7-cols-per-row: 16;\n  }\n  .row .xsmall-auto:nth-last-of-type(17),\n  .row .xsmall-auto:nth-last-of-type(17) ~ .xsmall-auto {\n    --f7-cols-per-row: 17;\n  }\n  .row .xsmall-auto:nth-last-of-type(18),\n  .row .xsmall-auto:nth-last-of-type(18) ~ .xsmall-auto {\n    --f7-cols-per-row: 18;\n  }\n  .row .xsmall-auto:nth-last-of-type(19),\n  .row .xsmall-auto:nth-last-of-type(19) ~ .xsmall-auto {\n    --f7-cols-per-row: 19;\n  }\n  .row .xsmall-auto:nth-last-of-type(20),\n  .row .xsmall-auto:nth-last-of-type(20) ~ .xsmall-auto {\n    --f7-cols-per-row: 20;\n  }\n  .row .xsmall-auto:nth-last-of-type(21),\n  .row .xsmall-auto:nth-last-of-type(21) ~ .xsmall-auto {\n    --f7-cols-per-row: 21;\n  }\n  .row .xsmall-auto:nth-last-of-type(22),\n  .row .xsmall-auto:nth-last-of-type(22) ~ .xsmall-auto {\n    --f7-cols-per-row: 22;\n  }\n}\n@media (min-width: 568px) {\n  .row .small-5 {\n    --f7-cols-per-row: 20;\n  }\n  .row .small-10 {\n    --f7-cols-per-row: 10;\n  }\n  .row .small-15 {\n    --f7-cols-per-row: 6.66666667;\n  }\n  .row .small-20 {\n    --f7-cols-per-row: 5;\n  }\n  .row .small-25 {\n    --f7-cols-per-row: 4;\n  }\n  .row .small-30 {\n    --f7-cols-per-row: 3.33333333;\n  }\n  .row .small-33 {\n    --f7-cols-per-row: 3;\n  }\n  .row .small-35 {\n    --f7-cols-per-row: 2.85714286;\n  }\n  .row .small-40 {\n    --f7-cols-per-row: 2.5;\n  }\n  .row .small-45 {\n    --f7-cols-per-row: 2.22222222;\n  }\n  .row .small-50 {\n    --f7-cols-per-row: 2;\n  }\n  .row .small-55 {\n    --f7-cols-per-row: 1.81818182;\n  }\n  .row .small-60 {\n    --f7-cols-per-row: 1.66666667;\n  }\n  .row .small-65 {\n    --f7-cols-per-row: 1.53846154;\n  }\n  .row .small-66 {\n    --f7-cols-per-row: 1.5;\n  }\n  .row .small-70 {\n    --f7-cols-per-row: 1.42857143;\n  }\n  .row .small-75 {\n    --f7-cols-per-row: 1.33333333;\n  }\n  .row .small-80 {\n    --f7-cols-per-row: 1.25;\n  }\n  .row .small-85 {\n    --f7-cols-per-row: 1.17647059;\n  }\n  .row .small-90 {\n    --f7-cols-per-row: 1.11111111;\n  }\n  .row .small-95 {\n    --f7-cols-per-row: 1.05263158;\n  }\n  .row .small-100 {\n    --f7-cols-per-row: 1;\n  }\n  .row .small-auto:nth-last-of-type(1),\n  .row .small-auto:nth-last-of-type(1) ~ .small-auto {\n    --f7-cols-per-row: 1;\n  }\n  .row .small-auto:nth-last-of-type(2),\n  .row .small-auto:nth-last-of-type(2) ~ .small-auto {\n    --f7-cols-per-row: 2;\n  }\n  .row .small-auto:nth-last-of-type(3),\n  .row .small-auto:nth-last-of-type(3) ~ .small-auto {\n    --f7-cols-per-row: 3;\n  }\n  .row .small-auto:nth-last-of-type(4),\n  .row .small-auto:nth-last-of-type(4) ~ .small-auto {\n    --f7-cols-per-row: 4;\n  }\n  .row .small-auto:nth-last-of-type(5),\n  .row .small-auto:nth-last-of-type(5) ~ .small-auto {\n    --f7-cols-per-row: 5;\n  }\n  .row .small-auto:nth-last-of-type(6),\n  .row .small-auto:nth-last-of-type(6) ~ .small-auto {\n    --f7-cols-per-row: 6;\n  }\n  .row .small-auto:nth-last-of-type(7),\n  .row .small-auto:nth-last-of-type(7) ~ .small-auto {\n    --f7-cols-per-row: 7;\n  }\n  .row .small-auto:nth-last-of-type(8),\n  .row .small-auto:nth-last-of-type(8) ~ .small-auto {\n    --f7-cols-per-row: 8;\n  }\n  .row .small-auto:nth-last-of-type(9),\n  .row .small-auto:nth-last-of-type(9) ~ .small-auto {\n    --f7-cols-per-row: 9;\n  }\n  .row .small-auto:nth-last-of-type(10),\n  .row .small-auto:nth-last-of-type(10) ~ .small-auto {\n    --f7-cols-per-row: 10;\n  }\n  .row .small-auto:nth-last-of-type(11),\n  .row .small-auto:nth-last-of-type(11) ~ .small-auto {\n    --f7-cols-per-row: 11;\n  }\n  .row .small-auto:nth-last-of-type(12),\n  .row .small-auto:nth-last-of-type(12) ~ .small-auto {\n    --f7-cols-per-row: 12;\n  }\n  .row .small-auto:nth-last-of-type(13),\n  .row .small-auto:nth-last-of-type(13) ~ .small-auto {\n    --f7-cols-per-row: 13;\n  }\n  .row .small-auto:nth-last-of-type(14),\n  .row .small-auto:nth-last-of-type(14) ~ .small-auto {\n    --f7-cols-per-row: 14;\n  }\n  .row .small-auto:nth-last-of-type(15),\n  .row .small-auto:nth-last-of-type(15) ~ .small-auto {\n    --f7-cols-per-row: 15;\n  }\n  .row .small-auto:nth-last-of-type(16),\n  .row .small-auto:nth-last-of-type(16) ~ .small-auto {\n    --f7-cols-per-row: 16;\n  }\n  .row .small-auto:nth-last-of-type(17),\n  .row .small-auto:nth-last-of-type(17) ~ .small-auto {\n    --f7-cols-per-row: 17;\n  }\n  .row .small-auto:nth-last-of-type(18),\n  .row .small-auto:nth-last-of-type(18) ~ .small-auto {\n    --f7-cols-per-row: 18;\n  }\n  .row .small-auto:nth-last-of-type(19),\n  .row .small-auto:nth-last-of-type(19) ~ .small-auto {\n    --f7-cols-per-row: 19;\n  }\n  .row .small-auto:nth-last-of-type(20),\n  .row .small-auto:nth-last-of-type(20) ~ .small-auto {\n    --f7-cols-per-row: 20;\n  }\n  .row .small-auto:nth-last-of-type(21),\n  .row .small-auto:nth-last-of-type(21) ~ .small-auto {\n    --f7-cols-per-row: 21;\n  }\n  .row .small-auto:nth-last-of-type(22),\n  .row .small-auto:nth-last-of-type(22) ~ .small-auto {\n    --f7-cols-per-row: 22;\n  }\n}\n@media (min-width: 768px) {\n  .row .medium-5 {\n    --f7-cols-per-row: 20;\n  }\n  .row .medium-10 {\n    --f7-cols-per-row: 10;\n  }\n  .row .medium-15 {\n    --f7-cols-per-row: 6.66666667;\n  }\n  .row .medium-20 {\n    --f7-cols-per-row: 5;\n  }\n  .row .medium-25 {\n    --f7-cols-per-row: 4;\n  }\n  .row .medium-30 {\n    --f7-cols-per-row: 3.33333333;\n  }\n  .row .medium-33 {\n    --f7-cols-per-row: 3;\n  }\n  .row .medium-35 {\n    --f7-cols-per-row: 2.85714286;\n  }\n  .row .medium-40 {\n    --f7-cols-per-row: 2.5;\n  }\n  .row .medium-45 {\n    --f7-cols-per-row: 2.22222222;\n  }\n  .row .medium-50 {\n    --f7-cols-per-row: 2;\n  }\n  .row .medium-55 {\n    --f7-cols-per-row: 1.81818182;\n  }\n  .row .medium-60 {\n    --f7-cols-per-row: 1.66666667;\n  }\n  .row .medium-65 {\n    --f7-cols-per-row: 1.53846154;\n  }\n  .row .medium-66 {\n    --f7-cols-per-row: 1.5;\n  }\n  .row .medium-70 {\n    --f7-cols-per-row: 1.42857143;\n  }\n  .row .medium-75 {\n    --f7-cols-per-row: 1.33333333;\n  }\n  .row .medium-80 {\n    --f7-cols-per-row: 1.25;\n  }\n  .row .medium-85 {\n    --f7-cols-per-row: 1.17647059;\n  }\n  .row .medium-90 {\n    --f7-cols-per-row: 1.11111111;\n  }\n  .row .medium-95 {\n    --f7-cols-per-row: 1.05263158;\n  }\n  .row .medium-100 {\n    --f7-cols-per-row: 1;\n  }\n  .row .medium-auto:nth-last-of-type(1),\n  .row .medium-auto:nth-last-of-type(1) ~ .medium-auto {\n    --f7-cols-per-row: 1;\n  }\n  .row .medium-auto:nth-last-of-type(2),\n  .row .medium-auto:nth-last-of-type(2) ~ .medium-auto {\n    --f7-cols-per-row: 2;\n  }\n  .row .medium-auto:nth-last-of-type(3),\n  .row .medium-auto:nth-last-of-type(3) ~ .medium-auto {\n    --f7-cols-per-row: 3;\n  }\n  .row .medium-auto:nth-last-of-type(4),\n  .row .medium-auto:nth-last-of-type(4) ~ .medium-auto {\n    --f7-cols-per-row: 4;\n  }\n  .row .medium-auto:nth-last-of-type(5),\n  .row .medium-auto:nth-last-of-type(5) ~ .medium-auto {\n    --f7-cols-per-row: 5;\n  }\n  .row .medium-auto:nth-last-of-type(6),\n  .row .medium-auto:nth-last-of-type(6) ~ .medium-auto {\n    --f7-cols-per-row: 6;\n  }\n  .row .medium-auto:nth-last-of-type(7),\n  .row .medium-auto:nth-last-of-type(7) ~ .medium-auto {\n    --f7-cols-per-row: 7;\n  }\n  .row .medium-auto:nth-last-of-type(8),\n  .row .medium-auto:nth-last-of-type(8) ~ .medium-auto {\n    --f7-cols-per-row: 8;\n  }\n  .row .medium-auto:nth-last-of-type(9),\n  .row .medium-auto:nth-last-of-type(9) ~ .medium-auto {\n    --f7-cols-per-row: 9;\n  }\n  .row .medium-auto:nth-last-of-type(10),\n  .row .medium-auto:nth-last-of-type(10) ~ .medium-auto {\n    --f7-cols-per-row: 10;\n  }\n  .row .medium-auto:nth-last-of-type(11),\n  .row .medium-auto:nth-last-of-type(11) ~ .medium-auto {\n    --f7-cols-per-row: 11;\n  }\n  .row .medium-auto:nth-last-of-type(12),\n  .row .medium-auto:nth-last-of-type(12) ~ .medium-auto {\n    --f7-cols-per-row: 12;\n  }\n  .row .medium-auto:nth-last-of-type(13),\n  .row .medium-auto:nth-last-of-type(13) ~ .medium-auto {\n    --f7-cols-per-row: 13;\n  }\n  .row .medium-auto:nth-last-of-type(14),\n  .row .medium-auto:nth-last-of-type(14) ~ .medium-auto {\n    --f7-cols-per-row: 14;\n  }\n  .row .medium-auto:nth-last-of-type(15),\n  .row .medium-auto:nth-last-of-type(15) ~ .medium-auto {\n    --f7-cols-per-row: 15;\n  }\n  .row .medium-auto:nth-last-of-type(16),\n  .row .medium-auto:nth-last-of-type(16) ~ .medium-auto {\n    --f7-cols-per-row: 16;\n  }\n  .row .medium-auto:nth-last-of-type(17),\n  .row .medium-auto:nth-last-of-type(17) ~ .medium-auto {\n    --f7-cols-per-row: 17;\n  }\n  .row .medium-auto:nth-last-of-type(18),\n  .row .medium-auto:nth-last-of-type(18) ~ .medium-auto {\n    --f7-cols-per-row: 18;\n  }\n  .row .medium-auto:nth-last-of-type(19),\n  .row .medium-auto:nth-last-of-type(19) ~ .medium-auto {\n    --f7-cols-per-row: 19;\n  }\n  .row .medium-auto:nth-last-of-type(20),\n  .row .medium-auto:nth-last-of-type(20) ~ .medium-auto {\n    --f7-cols-per-row: 20;\n  }\n  .row .medium-auto:nth-last-of-type(21),\n  .row .medium-auto:nth-last-of-type(21) ~ .medium-auto {\n    --f7-cols-per-row: 21;\n  }\n  .row .medium-auto:nth-last-of-type(22),\n  .row .medium-auto:nth-last-of-type(22) ~ .medium-auto {\n    --f7-cols-per-row: 22;\n  }\n}\n@media (min-width: 1024px) {\n  .row .large-5 {\n    --f7-cols-per-row: 20;\n  }\n  .row .large-10 {\n    --f7-cols-per-row: 10;\n  }\n  .row .large-15 {\n    --f7-cols-per-row: 6.66666667;\n  }\n  .row .large-20 {\n    --f7-cols-per-row: 5;\n  }\n  .row .large-25 {\n    --f7-cols-per-row: 4;\n  }\n  .row .large-30 {\n    --f7-cols-per-row: 3.33333333;\n  }\n  .row .large-33 {\n    --f7-cols-per-row: 3;\n  }\n  .row .large-35 {\n    --f7-cols-per-row: 2.85714286;\n  }\n  .row .large-40 {\n    --f7-cols-per-row: 2.5;\n  }\n  .row .large-45 {\n    --f7-cols-per-row: 2.22222222;\n  }\n  .row .large-50 {\n    --f7-cols-per-row: 2;\n  }\n  .row .large-55 {\n    --f7-cols-per-row: 1.81818182;\n  }\n  .row .large-60 {\n    --f7-cols-per-row: 1.66666667;\n  }\n  .row .large-65 {\n    --f7-cols-per-row: 1.53846154;\n  }\n  .row .large-66 {\n    --f7-cols-per-row: 1.5;\n  }\n  .row .large-70 {\n    --f7-cols-per-row: 1.42857143;\n  }\n  .row .large-75 {\n    --f7-cols-per-row: 1.33333333;\n  }\n  .row .large-80 {\n    --f7-cols-per-row: 1.25;\n  }\n  .row .large-85 {\n    --f7-cols-per-row: 1.17647059;\n  }\n  .row .large-90 {\n    --f7-cols-per-row: 1.11111111;\n  }\n  .row .large-95 {\n    --f7-cols-per-row: 1.05263158;\n  }\n  .row .large-100 {\n    --f7-cols-per-row: 1;\n  }\n  .row .large-auto:nth-last-of-type(1),\n  .row .large-auto:nth-last-of-type(1) ~ .large-auto {\n    --f7-cols-per-row: 1;\n  }\n  .row .large-auto:nth-last-of-type(2),\n  .row .large-auto:nth-last-of-type(2) ~ .large-auto {\n    --f7-cols-per-row: 2;\n  }\n  .row .large-auto:nth-last-of-type(3),\n  .row .large-auto:nth-last-of-type(3) ~ .large-auto {\n    --f7-cols-per-row: 3;\n  }\n  .row .large-auto:nth-last-of-type(4),\n  .row .large-auto:nth-last-of-type(4) ~ .large-auto {\n    --f7-cols-per-row: 4;\n  }\n  .row .large-auto:nth-last-of-type(5),\n  .row .large-auto:nth-last-of-type(5) ~ .large-auto {\n    --f7-cols-per-row: 5;\n  }\n  .row .large-auto:nth-last-of-type(6),\n  .row .large-auto:nth-last-of-type(6) ~ .large-auto {\n    --f7-cols-per-row: 6;\n  }\n  .row .large-auto:nth-last-of-type(7),\n  .row .large-auto:nth-last-of-type(7) ~ .large-auto {\n    --f7-cols-per-row: 7;\n  }\n  .row .large-auto:nth-last-of-type(8),\n  .row .large-auto:nth-last-of-type(8) ~ .large-auto {\n    --f7-cols-per-row: 8;\n  }\n  .row .large-auto:nth-last-of-type(9),\n  .row .large-auto:nth-last-of-type(9) ~ .large-auto {\n    --f7-cols-per-row: 9;\n  }\n  .row .large-auto:nth-last-of-type(10),\n  .row .large-auto:nth-last-of-type(10) ~ .large-auto {\n    --f7-cols-per-row: 10;\n  }\n  .row .large-auto:nth-last-of-type(11),\n  .row .large-auto:nth-last-of-type(11) ~ .large-auto {\n    --f7-cols-per-row: 11;\n  }\n  .row .large-auto:nth-last-of-type(12),\n  .row .large-auto:nth-last-of-type(12) ~ .large-auto {\n    --f7-cols-per-row: 12;\n  }\n  .row .large-auto:nth-last-of-type(13),\n  .row .large-auto:nth-last-of-type(13) ~ .large-auto {\n    --f7-cols-per-row: 13;\n  }\n  .row .large-auto:nth-last-of-type(14),\n  .row .large-auto:nth-last-of-type(14) ~ .large-auto {\n    --f7-cols-per-row: 14;\n  }\n  .row .large-auto:nth-last-of-type(15),\n  .row .large-auto:nth-last-of-type(15) ~ .large-auto {\n    --f7-cols-per-row: 15;\n  }\n  .row .large-auto:nth-last-of-type(16),\n  .row .large-auto:nth-last-of-type(16) ~ .large-auto {\n    --f7-cols-per-row: 16;\n  }\n  .row .large-auto:nth-last-of-type(17),\n  .row .large-auto:nth-last-of-type(17) ~ .large-auto {\n    --f7-cols-per-row: 17;\n  }\n  .row .large-auto:nth-last-of-type(18),\n  .row .large-auto:nth-last-of-type(18) ~ .large-auto {\n    --f7-cols-per-row: 18;\n  }\n  .row .large-auto:nth-last-of-type(19),\n  .row .large-auto:nth-last-of-type(19) ~ .large-auto {\n    --f7-cols-per-row: 19;\n  }\n  .row .large-auto:nth-last-of-type(20),\n  .row .large-auto:nth-last-of-type(20) ~ .large-auto {\n    --f7-cols-per-row: 20;\n  }\n  .row .large-auto:nth-last-of-type(21),\n  .row .large-auto:nth-last-of-type(21) ~ .large-auto {\n    --f7-cols-per-row: 21;\n  }\n  .row .large-auto:nth-last-of-type(22),\n  .row .large-auto:nth-last-of-type(22) ~ .large-auto {\n    --f7-cols-per-row: 22;\n  }\n}\n@media (min-width: 1200px) {\n  .row .xlarge-5 {\n    --f7-cols-per-row: 20;\n  }\n  .row .xlarge-10 {\n    --f7-cols-per-row: 10;\n  }\n  .row .xlarge-15 {\n    --f7-cols-per-row: 6.66666667;\n  }\n  .row .xlarge-20 {\n    --f7-cols-per-row: 5;\n  }\n  .row .xlarge-25 {\n    --f7-cols-per-row: 4;\n  }\n  .row .xlarge-30 {\n    --f7-cols-per-row: 3.33333333;\n  }\n  .row .xlarge-33 {\n    --f7-cols-per-row: 3;\n  }\n  .row .xlarge-35 {\n    --f7-cols-per-row: 2.85714286;\n  }\n  .row .xlarge-40 {\n    --f7-cols-per-row: 2.5;\n  }\n  .row .xlarge-45 {\n    --f7-cols-per-row: 2.22222222;\n  }\n  .row .xlarge-50 {\n    --f7-cols-per-row: 2;\n  }\n  .row .xlarge-55 {\n    --f7-cols-per-row: 1.81818182;\n  }\n  .row .xlarge-60 {\n    --f7-cols-per-row: 1.66666667;\n  }\n  .row .xlarge-65 {\n    --f7-cols-per-row: 1.53846154;\n  }\n  .row .xlarge-66 {\n    --f7-cols-per-row: 1.5;\n  }\n  .row .xlarge-70 {\n    --f7-cols-per-row: 1.42857143;\n  }\n  .row .xlarge-75 {\n    --f7-cols-per-row: 1.33333333;\n  }\n  .row .xlarge-80 {\n    --f7-cols-per-row: 1.25;\n  }\n  .row .xlarge-85 {\n    --f7-cols-per-row: 1.17647059;\n  }\n  .row .xlarge-90 {\n    --f7-cols-per-row: 1.11111111;\n  }\n  .row .xlarge-95 {\n    --f7-cols-per-row: 1.05263158;\n  }\n  .row .xlarge-100 {\n    --f7-cols-per-row: 1;\n  }\n  .row .xlarge-auto:nth-last-of-type(1),\n  .row .xlarge-auto:nth-last-of-type(1) ~ .xlarge-auto {\n    --f7-cols-per-row: 1;\n  }\n  .row .xlarge-auto:nth-last-of-type(2),\n  .row .xlarge-auto:nth-last-of-type(2) ~ .xlarge-auto {\n    --f7-cols-per-row: 2;\n  }\n  .row .xlarge-auto:nth-last-of-type(3),\n  .row .xlarge-auto:nth-last-of-type(3) ~ .xlarge-auto {\n    --f7-cols-per-row: 3;\n  }\n  .row .xlarge-auto:nth-last-of-type(4),\n  .row .xlarge-auto:nth-last-of-type(4) ~ .xlarge-auto {\n    --f7-cols-per-row: 4;\n  }\n  .row .xlarge-auto:nth-last-of-type(5),\n  .row .xlarge-auto:nth-last-of-type(5) ~ .xlarge-auto {\n    --f7-cols-per-row: 5;\n  }\n  .row .xlarge-auto:nth-last-of-type(6),\n  .row .xlarge-auto:nth-last-of-type(6) ~ .xlarge-auto {\n    --f7-cols-per-row: 6;\n  }\n  .row .xlarge-auto:nth-last-of-type(7),\n  .row .xlarge-auto:nth-last-of-type(7) ~ .xlarge-auto {\n    --f7-cols-per-row: 7;\n  }\n  .row .xlarge-auto:nth-last-of-type(8),\n  .row .xlarge-auto:nth-last-of-type(8) ~ .xlarge-auto {\n    --f7-cols-per-row: 8;\n  }\n  .row .xlarge-auto:nth-last-of-type(9),\n  .row .xlarge-auto:nth-last-of-type(9) ~ .xlarge-auto {\n    --f7-cols-per-row: 9;\n  }\n  .row .xlarge-auto:nth-last-of-type(10),\n  .row .xlarge-auto:nth-last-of-type(10) ~ .xlarge-auto {\n    --f7-cols-per-row: 10;\n  }\n  .row .xlarge-auto:nth-last-of-type(11),\n  .row .xlarge-auto:nth-last-of-type(11) ~ .xlarge-auto {\n    --f7-cols-per-row: 11;\n  }\n  .row .xlarge-auto:nth-last-of-type(12),\n  .row .xlarge-auto:nth-last-of-type(12) ~ .xlarge-auto {\n    --f7-cols-per-row: 12;\n  }\n  .row .xlarge-auto:nth-last-of-type(13),\n  .row .xlarge-auto:nth-last-of-type(13) ~ .xlarge-auto {\n    --f7-cols-per-row: 13;\n  }\n  .row .xlarge-auto:nth-last-of-type(14),\n  .row .xlarge-auto:nth-last-of-type(14) ~ .xlarge-auto {\n    --f7-cols-per-row: 14;\n  }\n  .row .xlarge-auto:nth-last-of-type(15),\n  .row .xlarge-auto:nth-last-of-type(15) ~ .xlarge-auto {\n    --f7-cols-per-row: 15;\n  }\n  .row .xlarge-auto:nth-last-of-type(16),\n  .row .xlarge-auto:nth-last-of-type(16) ~ .xlarge-auto {\n    --f7-cols-per-row: 16;\n  }\n  .row .xlarge-auto:nth-last-of-type(17),\n  .row .xlarge-auto:nth-last-of-type(17) ~ .xlarge-auto {\n    --f7-cols-per-row: 17;\n  }\n  .row .xlarge-auto:nth-last-of-type(18),\n  .row .xlarge-auto:nth-last-of-type(18) ~ .xlarge-auto {\n    --f7-cols-per-row: 18;\n  }\n  .row .xlarge-auto:nth-last-of-type(19),\n  .row .xlarge-auto:nth-last-of-type(19) ~ .xlarge-auto {\n    --f7-cols-per-row: 19;\n  }\n  .row .xlarge-auto:nth-last-of-type(20),\n  .row .xlarge-auto:nth-last-of-type(20) ~ .xlarge-auto {\n    --f7-cols-per-row: 20;\n  }\n  .row .xlarge-auto:nth-last-of-type(21),\n  .row .xlarge-auto:nth-last-of-type(21) ~ .xlarge-auto {\n    --f7-cols-per-row: 21;\n  }\n  .row .xlarge-auto:nth-last-of-type(22),\n  .row .xlarge-auto:nth-last-of-type(22) ~ .xlarge-auto {\n    --f7-cols-per-row: 22;\n  }\n}\n.row .resize-handler {\n  position: absolute;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n  z-index: 100;\n}\n.row .resize-handler:before {\n  content: '';\n  position: absolute;\n}\n.row .resize-handler:after {\n  content: '';\n  position: absolute;\n  border-radius: 4px;\n  background: var(--f7-grid-resize-handler-bg-color);\n}\n.row > .resize-handler {\n  width: 100%;\n  height: var(--f7-grid-row-gap);\n  left: 0;\n  top: 100%;\n  cursor: row-resize;\n}\n.row > .resize-handler:before {\n  left: 0%;\n  top: 50%;\n  height: 12px;\n  width: 100%;\n  min-height: var(--f7-grid-row-gap);\n  transform: translateY(-50%);\n}\n.row > .resize-handler:after {\n  height: 4px;\n  margin-top: -2px;\n  width: 80%;\n  max-width: 20px;\n  left: 50%;\n  top: 50%;\n  transform: translateX(-50%);\n}\n[class*=\"col-\"] > .resize-handler,\n.col > .resize-handler {\n  width: var(--f7-grid-gap);\n  left: 100%;\n  top: 0;\n  height: 100%;\n  cursor: col-resize;\n}\n[class*=\"col-\"] > .resize-handler:before,\n.col > .resize-handler:before {\n  left: 50%;\n  top: 0;\n  height: 100%;\n  width: 12px;\n  min-width: var(--f7-grid-gap);\n  transform: translateX(-50%);\n}\n[class*=\"col-\"] > .resize-handler:after,\n.col > .resize-handler:after {\n  width: 4px;\n  margin-left: -2px;\n  height: 80%;\n  max-height: 20px;\n  border-radius: 4px;\n  left: 50%;\n  top: 50%;\n  transform: translateY(-50%);\n}\n.row:last-child > .resize-handler,\n.row:last-of-type > .resize-handler,\n.row [class*=\"col-\"]:last-child > .resize-handler,\n.row [class*=\"col-\"]:last-of-type > .resize-handler,\n.row .col:last-child > .resize-handler,\n.row .col:last-of-type > .resize-handler {\n  display: none;\n}\n/* === Calendar/Datepicker === */\n:root {\n  --f7-calendar-height: 340px;\n  --f7-calendar-sheet-landscape-height: 220px;\n  --f7-calendar-popover-width: 320px;\n  --f7-calendar-popover-height: 320px;\n  --f7-calendar-modal-height: 420px;\n  --f7-calendar-modal-max-width: 380px;\n  --f7-calendar-modal-border-radius: 4px;\n  /*\n  --f7-calendar-header-bg-color: var(--f7-bars-bg-color);\n  --f7-calendar-header-link-color: var(--f7-bars-link-color);\n  --f7-calendar-header-text-color: var(--f7-bars-text-color);\n  --f7-calendar-footer-bg-color: var(--f7-bars-bg-color);\n  --f7-calendar-footer-border-color: var(--f7-bars-border-color);\n  --f7-calendar-footer-link-color: var(--f7-bars-link-color);\n  --f7-calendar-footer-text-color: var(--f7-bars-text-color);\n  --f7-calendar-week-header-bg-color: var(--f7-bars-bg-color);\n  --f7-calendar-week-header-text-color: var(--f7-bars-text-color);\n  */\n  --f7-calendar-footer-padding: 0 8px;\n  --f7-calendar-week-header-font-size: 11px;\n  --f7-calendar-selected-text-color: #fff;\n  /*\n  --f7-calendar-selected-bg-color:  var(--f7-theme-color);\n  */\n  --f7-calendar-prev-next-text-color: #b8b8b8;\n  --f7-calendar-disabled-text-color: #d4d4d4;\n  --f7-calendar-event-dot-size: 4px;\n  /*\n  --f7-calendar-event-bg-color: var(--f7-theme-color);\n  */\n  /*\n  --f7-calendar-picker-selected-text-color: var(--f7-theme-color);\n  */\n  --f7-calendar-day-text-color: #000;\n  --f7-calendar-sheet-bg-color: #fff;\n  --f7-calendar-modal-bg-color: #fff;\n  --f7-calendar-picker-bg-color: #fff;\n  --f7-calendar-picker-pressed-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-calendar-picker-hover-bg-color: rgba(0, 0, 0, 0.03);\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-calendar-sheet-border-color: var(--f7-bars-border-color);\n  --f7-calendar-modal-bg-color: #121212;\n  --f7-calendar-sheet-bg-color: #121212;\n  --f7-calendar-picker-bg-color: #1c1c1d;\n  --f7-calendar-picker-pressed-bg-color: rgba(255, 255, 255, 0.08);\n  --f7-calendar-picker-hover-bg-color: rgba(255, 255, 255, 0.03);\n}\n.ios {\n  --f7-calendar-sheet-border-color: #929499;\n  --f7-calendar-header-height: 44px;\n  --f7-calendar-header-font-size: 17px;\n  --f7-calendar-header-font-weight: 600;\n  --f7-calendar-header-padding: 0 8px;\n  --f7-calendar-footer-height: 44px;\n  --f7-calendar-footer-font-size: 17px;\n  --f7-calendar-week-header-height: 18px;\n  --f7-calendar-day-font-size: 15px;\n  --f7-calendar-day-size: 30px;\n  --f7-calendar-picker-font-size: 17px;\n  --f7-calendar-time-selector-font-size: 17px;\n  --f7-calendar-row-border-color: rgba(0, 0, 0, 0.25);\n  --f7-calendar-today-text-color: #000;\n  --f7-calendar-today-bg-color: #e3e3e3;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-calendar-row-border-color: var(--f7-bars-border-color);\n  --f7-calendar-day-text-color: #fff;\n  --f7-calendar-today-text-color: #fff;\n  --f7-calendar-today-bg-color: #333;\n}\n.md {\n  --f7-calendar-sheet-border-color: #ccc;\n  --f7-calendar-header-height: 56px;\n  --f7-calendar-header-font-size: 20px;\n  --f7-calendar-header-font-weight: 400;\n  --f7-calendar-header-padding: 0 24px;\n  --f7-calendar-footer-height: 48px;\n  --f7-calendar-footer-font-size: 14px;\n  --f7-calendar-week-header-height: 24px;\n  --f7-calendar-row-border-color: transparent;\n  --f7-calendar-day-font-size: 14px;\n  /*\n  --f7-calendar-today-text-color: var(--f7-theme-color);\n  */\n  --f7-calendar-today-bg-color: none;\n  --f7-calendar-day-size: 32px;\n  --f7-calendar-picker-font-size: 14px;\n  --f7-calendar-time-selector-font-size: 14px;\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-calendar-day-text-color: rgba(255, 255, 255, 0.87);\n}\n.aurora {\n  --f7-calendar-sheet-border-color: #ccc;\n  --f7-calendar-header-height: 38px;\n  --f7-calendar-header-font-size: 14px;\n  --f7-calendar-header-font-weight: 600;\n  --f7-calendar-header-padding: 0 8px;\n  --f7-calendar-footer-height: 38px;\n  --f7-calendar-footer-font-size: 14px;\n  --f7-calendar-week-header-height: 18px;\n  --f7-calendar-day-font-size: 13px;\n  --f7-calendar-day-size: 30px;\n  --f7-calendar-picker-font-size: 14px;\n  --f7-calendar-time-selector-font-size: 14px;\n  --f7-calendar-row-border-color: #e3e3e3;\n  --f7-calendar-today-text-color: #000;\n  --f7-calendar-today-bg-color: #e3e3e3;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-calendar-row-border-color: var(--f7-bars-border-color);\n  --f7-calendar-day-text-color: #fff;\n  --f7-calendar-today-text-color: #fff;\n  --f7-calendar-today-bg-color: #333;\n}\n.calendar {\n  overflow: hidden;\n  height: var(--f7-calendar-height);\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n}\n.calendar.modal-in {\n  display: flex;\n}\n@media (orientation: landscape) and (max-height: 415px) {\n  .calendar.calendar-sheet {\n    height: var(--f7-calendar-sheet-landscape-height);\n  }\n  .calendar.calendar-modal {\n    height: calc(100vh - var(--f7-navbar-height));\n  }\n}\n.calendar.calendar-inline,\n.calendar.calendar-popover .calendar {\n  position: relative;\n}\n.calendar-sheet {\n  --f7-sheet-border-color: var(--f7-calendar-sheet-border-color);\n  background: var(--f7-calendar-sheet-bg-color);\n  padding-bottom: var(--f7-safe-area-bottom);\n  height: calc(var(--f7-calendar-height) + var(--f7-safe-area-bottom));\n}\n.calendar-sheet:before {\n  z-index: 600;\n}\n.calendar-sheet .toolbar:before,\n.calendar-modal .toolbar:before,\n.calendar-popover .toolbar:before {\n  display: none;\n}\n.calendar-popover {\n  width: var(--f7-calendar-popover-width);\n}\n.calendar-popover .calendar {\n  height: var(--f7-calendar-popover-height);\n  border-radius: var(--f7-popover-border-radius);\n  position: relative;\n}\n.calendar-header {\n  width: 100%;\n  position: relative;\n  overflow: hidden;\n  flex-shrink: 0;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  box-sizing: border-box;\n  padding: var(--f7-calendar-header-padding);\n  background-color: var(--f7-calendar-header-bg-color, var(--f7-bars-bg-color));\n  color: var(--f7-calendar-header-text-color, var(--f7-bars-text-color));\n  height: var(--f7-calendar-header-height);\n  line-height: var(--f7-calendar-header-height);\n  font-size: var(--f7-calendar-header-font-size);\n  font-weight: var(--f7-calendar-header-font-weight);\n}\n.calendar-header a {\n  color: var(--f7-calendar-header-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n}\n.calendar-footer {\n  width: 100%;\n  flex-shrink: 0;\n  padding: var(--f7-calendar-footer-padding);\n  background-color: var(--f7-calendar-footer-bg-color, var(--f7-bars-bg-color));\n  color: var(--f7-calendar-footer-text-color, var(--f7-bars-text-color));\n  height: var(--f7-calendar-footer-height);\n  font-size: var(--f7-calendar-header-font-size);\n  display: flex;\n  justify-content: flex-end;\n  box-sizing: border-box;\n  align-items: center;\n  position: relative;\n}\n.calendar-footer a {\n  color: var(--f7-calendar-footer-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n}\n.calendar-footer:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-calendar-footer-border-color, var(--f7-bars-border-color));\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.calendar-modal {\n  position: absolute;\n  height: var(--f7-calendar-modal-height);\n  overflow: hidden;\n  top: 50%;\n  left: 50%;\n  min-width: 300px;\n  max-width: var(--f7-calendar-modal-max-width);\n  transform: translate3d(-50%, 100vh, 0);\n  transition-property: transform;\n  display: flex;\n  z-index: 13500;\n  background: var(--f7-calendar-modal-bg-color);\n  width: 90%;\n  border-radius: var(--f7-calendar-modal-border-radius);\n  box-shadow: var(--f7-elevation-24);\n}\n.calendar-modal.modal-in,\n.calendar-modal.modal-out {\n  transition-duration: 400ms;\n}\n.calendar-modal.modal-in {\n  transform: translate3d(-50%, -50%, 0);\n}\n.calendar-modal.modal-out {\n  transform: translate3d(-50%, 100vh, 0);\n}\n.calendar-week-header {\n  display: flex;\n  box-sizing: border-box;\n  position: relative;\n  font-size: var(--f7-calendar-week-header-font-size);\n  background-color: var(--f7-calendar-week-header-bg-color, var(--f7-bars-bg-color));\n  color: var(--f7-calendar-week-header-text-color, var(--f7-bars-text-color));\n  height: var(--f7-calendar-week-header-height);\n  padding-left: var(--f7-safe-area-left);\n  padding-right: var(--f7-safe-area-right);\n}\n.calendar-week-header .calendar-week-day {\n  flex-shrink: 1;\n  width: calc(100% / 7);\n  text-align: center;\n  line-height: var(--f7-calendar-week-header-height);\n}\n.calendar-months {\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  position: relative;\n  flex-shrink: 10;\n}\n.calendar-months-wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  transition: 300ms;\n}\n.calendar-month {\n  display: flex;\n  flex-direction: column;\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.calendar-row {\n  height: 16.66666667%;\n  height: calc(100% / 6);\n  display: flex;\n  flex-shrink: 1;\n  width: 100%;\n  position: relative;\n  box-sizing: border-box;\n  padding-left: var(--f7-safe-area-left);\n  padding-right: var(--f7-safe-area-right);\n}\n.calendar-row:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-calendar-row-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.calendar-modal .calendar-months:first-child .calendar-row:first-child:before,\n.calendar-popover .calendar-months:first-child .calendar-row:first-child:before {\n  display: none !important;\n}\n.calendar-day {\n  flex-shrink: 1;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  box-sizing: border-box;\n  width: 14.28571429%;\n  width: calc(100% / 7);\n  text-align: center;\n  cursor: pointer;\n  z-index: 20;\n  color: var(--f7-calendar-day-text-color);\n  height: 100%;\n  font-size: var(--f7-calendar-day-font-size);\n}\n.calendar-day.calendar-day-today .calendar-day-number {\n  color: var(--f7-calendar-today-text-color, var(--f7-theme-color));\n  background-color: var(--f7-calendar-today-bg-color);\n}\n.calendar-day.calendar-day-prev,\n.calendar-day.calendar-day-next {\n  color: var(--f7-calendar-prev-next-text-color);\n}\n.calendar-day.calendar-day-disabled {\n  color: var(--f7-calendar-disabled-text-color);\n  cursor: auto;\n}\n.calendar-day.calendar-day-selected .calendar-day-number {\n  color: var(--f7-calendar-selected-text-color);\n  background-color: var(--f7-calendar-selected-bg-color, var(--f7-theme-color));\n}\n.calendar-day .calendar-day-number {\n  display: inline-block;\n  border-radius: 50%;\n  position: relative;\n  width: var(--f7-calendar-day-size);\n  height: var(--f7-calendar-day-size);\n  line-height: var(--f7-calendar-day-size);\n}\n.calendar-day .calendar-day-events {\n  position: absolute;\n  display: flex;\n  left: 0;\n  width: 100%;\n  top: 100%;\n  align-items: center;\n  justify-content: center;\n  margin-top: 1px;\n}\n.calendar-day .calendar-day-event {\n  width: var(--f7-calendar-event-dot-size);\n  height: var(--f7-calendar-event-dot-size);\n  border-radius: calc(var(--f7-calendar-event-dot-size) / 2);\n  background-color: var(--f7-calendar-event-bg-color);\n}\n.calendar-day .calendar-day-event + .calendar-day-event {\n  margin-left: 2px;\n}\n.calendar-range .calendar-day.calendar-day-selected {\n  align-items: stretch;\n  align-content: stretch;\n}\n.calendar-range .calendar-day.calendar-day-selected .calendar-day-number {\n  width: 100%;\n  border-radius: 0;\n  height: auto;\n  text-align: center;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n.calendar-month-selector,\n.calendar-year-selector {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  width: 50%;\n  max-width: 200px;\n  flex-shrink: 10;\n  margin-left: auto;\n  margin-right: auto;\n}\n.calendar-month-selector .calendar-day-number,\n.calendar-year-selector .calendar-day-number {\n  flex-shrink: 1;\n  position: relative;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.calendar-month-selector a.icon-only,\n.calendar-year-selector a.icon-only {\n  min-width: 36px;\n}\n.calendar-month-picker,\n.calendar-year-picker,\n.calendar-time-picker {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  left: 0px;\n  top: 0px;\n  background: var(--f7-calendar-picker-bg-color);\n  z-index: 1000;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n.calendar-month-picker,\n.calendar-year-picker {\n  flex-wrap: wrap;\n  font-size: var(--f7-calendar-picker-font-size);\n  display: flex;\n}\n.calendar-month-picker-item,\n.calendar-year-picker-item {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  position: relative;\n  overflow: hidden;\n  cursor: pointer;\n  transition-duration: 100ms;\n  box-sizing: border-box;\n}\n.calendar-month-picker-item span,\n.calendar-year-picker-item span {\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  box-sizing: border-box;\n  position: relative;\n  overflow: hidden;\n  pointer-events: none;\n}\n.device-desktop.aurora .calendar-month-picker-item:hover,\n.device-desktop.aurora .calendar-year-picker-item:hover {\n  background-color: var(--f7-calendar-picker-hover-bg-color);\n}\n.calendar-month-picker-item.active-state,\n.calendar-year-picker-item.active-state,\n.device-desktop.aurora .calendar-month-picker-item.active-state,\n.device-desktop.aurora .calendar-year-picker-item.active-state {\n  background: var(--f7-calendar-picker-pressed-bg-color);\n}\n.calendar-month-picker-item {\n  padding: 5px;\n}\n.calendar-month-picker-item:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-calendar-row-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.calendar-month-picker-item:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-calendar-row-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  width: 1px;\n  height: 100%;\n  transform-origin: 0% 50%;\n  transform: scaleX(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.sheet-modal .calendar-month-picker-item {\n  width: 25%;\n  height: calc(100% / 3);\n}\n.sheet-modal .calendar-month-picker-item:nth-child(4n + 1):before {\n  display: none !important;\n}\n.sheet-modal .calendar-month-picker-item:nth-child(n + 9):after {\n  display: none !important;\n}\n.popover .calendar-month-picker-item,\n.calendar-modal .calendar-month-picker-item {\n  width: calc(100% / 3);\n  height: 25%;\n}\n.popover .calendar-month-picker-item:nth-child(3n + 1):before,\n.calendar-modal .calendar-month-picker-item:nth-child(3n + 1):before {\n  display: none !important;\n}\n.popover .calendar-month-picker-item:nth-child(n + 10):after,\n.calendar-modal .calendar-month-picker-item:nth-child(n + 10):after {\n  display: none !important;\n}\n.calendar-month-picker-item-current,\n.calendar-year-picker-item-current {\n  color: var(--f7-calendar-picker-selected-text-color, var(--f7-theme-color));\n}\n.calendar-year-picker {\n  overflow: auto;\n  --webkit-overflow-scrolling: touch;\n}\n.calendar-year-picker-item {\n  height: 34px;\n  line-height: 34px;\n  width: 100%;\n}\n.calendar-year-picker-item:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-calendar-row-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.calendar-time-selector {\n  flex-shrink: 0;\n  font-size: var(--f7-calendar-time-selector-font-size);\n  position: relative;\n}\n.calendar-time-selector:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-calendar-row-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.calendar-time-selector a {\n  overflow: hidden;\n  position: relative;\n  justify-content: center;\n  align-items: center;\n  display: flex;\n  width: 100%;\n  height: 44px;\n}\n.calendar-time-picker {\n  --f7-picker-popover-height: 100%;\n  --f7-picker-inline-height: 100%;\n  --f7-picker-item-selected-text-color: var(--f7-theme-color);\n}\n.calendar-time-picker .toolbar {\n  flex-shrink: 0;\n  top: 0 !important;\n}\n.calendar-time-picker .picker {\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n}\n/* === Picker === */\n:root {\n  --f7-picker-height: 260px;\n  --f7-picker-inline-height: 200px;\n  --f7-picker-popover-height: 200px;\n  --f7-picker-popover-width: 280px;\n  --f7-picker-landscape-height: 200px;\n  --f7-picker-item-height: 36px;\n  --f7-picker-item-selected-text-color: #000;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-picker-item-selected-text-color: #fff;\n}\n.ios {\n  --f7-picker-column-font-size: 20px;\n  --f7-picker-sheet-bg-color: #cfd5da;\n  --f7-picker-divider-text-color: #000;\n  --f7-picker-item-text-color: rgba(0, 0, 0, 0.45);\n  --f7-picker-item-selected-border-color: rgba(0, 0, 0, 0.22);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-picker-sheet-bg-color: #1c1c1d;\n  --f7-picker-divider-text-color: #fff;\n  --f7-picker-item-text-color: rgba(255, 255, 255, 0.55);\n  --f7-picker-item-selected-border-color: rgba(255, 255, 255, 0.06);\n}\n.md {\n  /*\n  --f7-picker-sheet-bg-color: var(--f7-sheet-bg-color);\n  */\n  --f7-picker-column-font-size: 20px;\n  --f7-picker-divider-text-color: rgba(0, 0, 0, 0.87);\n  --f7-picker-item-text-color: rgba(0, 0, 0, 0.54);\n  --f7-picker-item-selected-border-color: rgba(0, 0, 0, 0.15);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-picker-item-text-color: rgba(255, 255, 255, 0.54);\n  --f7-picker-divider-text-color: rgba(255, 255, 255, 0.87);\n  --f7-picker-item-selected-border-color: rgba(255, 255, 255, 0.15);\n}\n.aurora {\n  /*\n  --f7-picker-sheet-bg-color: var(--f7-sheet-bg-color);\n  */\n  --f7-picker-column-font-size: 16px;\n  --f7-picker-item-height: 28px;\n  --f7-picker-item-text-color: #888;\n  --f7-picker-divider-text-color: #000;\n  --f7-picker-item-selected-border-color: rgba(0, 0, 0, 0.12);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-picker-divider-text-color: #fff;\n  --f7-picker-item-selected-border-color: rgba(255, 255, 255, 0.06);\n}\n.picker {\n  width: 100%;\n  height: var(--f7-picker-height);\n}\n.picker.picker-inline {\n  height: var(--f7-picker-inline-height);\n}\n.popover .picker {\n  height: var(--f7-picker-popover-height);\n}\n@media (orientation: landscape) and (max-height: 415px) {\n  .picker:not(.picker-inline) {\n    height: var(--f7-picker-landscape-height);\n  }\n}\n.picker.sheet-modal {\n  background: var(--f7-picker-sheet-bg-color, var(--f7-sheet-bg-color));\n}\n.picker-popover {\n  width: var(--f7-picker-popover-width);\n}\n.picker-popover .toolbar {\n  background: none;\n  border-radius: var(--f7-popover-border-radius) var(--f7-popover-border-radius) 0 0;\n}\n.picker-popover .toolbar:before {\n  display: none !important;\n}\n.picker-popover .toolbar + .picker-columns {\n  height: calc(100% - var(--f7-toolbar-height));\n}\n.picker-columns {\n  display: flex;\n  overflow: hidden;\n  justify-content: center;\n  padding: 0;\n  text-align: right;\n  height: 100%;\n  position: relative;\n  -webkit-mask-box-image: linear-gradient(to top, transparent, transparent 5%, white 20%, white 80%, transparent 95%, transparent);\n  font-size: var(--f7-picker-column-font-size);\n}\n.picker-column {\n  position: relative;\n  max-height: 100%;\n}\n.picker-column.picker-column-first:before,\n.picker-column.picker-column-last:after {\n  height: 100%;\n  width: 100vw;\n  position: absolute;\n  content: '';\n  top: 0;\n}\n.picker-column.picker-column-first:before {\n  right: 100%;\n}\n.picker-column.picker-column-last:after {\n  left: 100%;\n}\n.picker-column.picker-column-left {\n  text-align: left;\n}\n.picker-column.picker-column-center {\n  text-align: center;\n}\n.picker-column.picker-column-right {\n  text-align: right;\n}\n.picker-column.picker-column-divider {\n  display: flex;\n  align-items: center;\n  color: var(--f7-picker-divider-text-color);\n}\n.picker-items {\n  transition: 300ms;\n  transition-timing-function: ease-out;\n}\n.picker-item {\n  height: var(--f7-picker-item-height);\n  line-height: var(--f7-picker-item-height);\n  white-space: nowrap;\n  position: relative;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  left: 0;\n  top: 0;\n  width: 100%;\n  box-sizing: border-box;\n  transition: 300ms;\n  color: var(--f7-picker-item-text-color);\n  cursor: pointer;\n}\n.picker-item span {\n  padding: 0 10px;\n}\n.picker-column-absolute .picker-item {\n  position: absolute;\n}\n.picker-item.picker-item-far {\n  pointer-events: none;\n}\n.picker-item.picker-item-selected {\n  color: var(--f7-picker-item-selected-text-color);\n  transform: translate3d(0, 0, 0) rotateX(0deg);\n}\n.picker-center-highlight {\n  height: var(--f7-picker-item-height);\n  box-sizing: border-box;\n  position: absolute;\n  left: 0;\n  width: 100%;\n  top: 50%;\n  margin-top: calc(-1 * var(--f7-picker-item-height) / 2);\n  pointer-events: none;\n}\n.picker-center-highlight:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-picker-item-selected-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.picker-center-highlight:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-picker-item-selected-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.picker-3d .picker-columns {\n  overflow: hidden;\n  perspective: 1200px;\n}\n.picker-3d .picker-column,\n.picker-3d .picker-items,\n.picker-3d .picker-item {\n  transform-style: preserve-3d;\n}\n.picker-3d .picker-column {\n  overflow: visible;\n}\n.picker-3d .picker-item {\n  transform-origin: center center -110px;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  transition-timing-function: ease-out;\n}\n/* === Infinite === */\n.infinite-scroll-preloader {\n  margin-left: auto;\n  margin-right: auto;\n  text-align: center;\n}\n.infinite-scroll-preloader.preloader {\n  display: block;\n}\n.ios .infinite-scroll-preloader {\n  margin-top: 35px;\n  margin-bottom: 35px;\n}\n.ios .infinite-scroll-preloader .preloader,\n.ios .infinite-scroll-preloader.preloader {\n  width: 27px;\n  height: 27px;\n}\n.md .infinite-scroll-preloader {\n  margin-top: 32px;\n  margin-bottom: 32px;\n}\n.aurora .infinite-scroll-preloader {\n  margin-top: 15px;\n  margin-bottom: 15px;\n}\n/* === PTR === */\n.ios {\n  --f7-ptr-preloader-size: 28px;\n  --f7-ptr-size: 44px;\n}\n.md {\n  --f7-ptr-preloader-size: 22px;\n  --f7-ptr-size: 40px;\n}\n.aurora {\n  --f7-ptr-preloader-size: 20px;\n  --f7-ptr-size: 38px;\n}\n.ptr-preloader {\n  position: relative;\n  top: var(--f7-ptr-top, 0);\n  height: var(--f7-ptr-size);\n}\n.ptr-preloader .preloader {\n  position: absolute;\n  left: 50%;\n  width: var(--f7-ptr-preloader-size);\n  height: var(--f7-ptr-preloader-size);\n  margin-left: calc(-1 * var(--f7-ptr-preloader-size) / 2);\n  margin-top: calc(-1 * var(--f7-ptr-preloader-size) / 2);\n  top: 50%;\n  visibility: hidden;\n}\n.ptr-bottom .ptr-preloader {\n  top: auto;\n  bottom: 0;\n  position: fixed;\n}\n.ptr-with-navbar-large-transparent .ptr-preloader,\n.ptr-with-navbar-transparent .ptr-preloader {\n  top: calc(-1 * var(--f7-page-navbar-offset, 0px) + var(--f7-safe-area-top));\n}\n.ios .ptr-preloader {\n  margin-top: calc(-1 * var(--f7-ptr-size));\n  width: 100%;\n  left: 0;\n}\n.ios .ptr-arrow {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  background: no-repeat center;\n  z-index: 10;\n  transform: rotate(0deg) translate3d(0, 0, 0);\n  transition-duration: 300ms;\n  transition-property: transform, opacity;\n  width: 12px;\n  height: 20px;\n  margin-left: -6px;\n  margin-top: -10px;\n  visibility: visible;\n  color: var(--f7-preloader-color);\n}\n.ios .ptr-arrow:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  width: 12px;\n  height: 20px;\n  line-height: 20px;\n  font-size: 10px;\n  content: 'ptr_arrow_ios';\n}\n.ios .ptr-content:not(.ptr-refreshing) .ptr-preloader .preloader {\n  animation: none;\n}\n.ios .ptr-transitioning,\n.ios .ptr-refreshing {\n  transition-duration: 300ms;\n  transition-property: transform;\n}\n.ios .ptr-refreshing {\n  transform: translate3d(0, var(--f7-ptr-size), 0);\n}\n.ios .ptr-refreshing .ptr-arrow {\n  visibility: hidden;\n}\n.ios .ptr-refreshing .ptr-preloader .preloader {\n  visibility: visible;\n}\n.ios .ptr-pull-up .ptr-arrow {\n  transform: rotate(180deg) translate3d(0, 0, 0);\n}\n.ios .ptr-no-navbar,\n.ios .ptr-with-navbar-large-transparent,\n.ios .ptr-with-navbar-transparent {\n  margin-top: calc(-1 * var(--f7-ptr-size));\n  height: calc(100% + var(--f7-ptr-size));\n}\n.ios .ptr-no-navbar .ptr-preloader,\n.ios .ptr-with-navbar-large-transparent .ptr-preloader,\n.ios .ptr-with-navbar-transparent .ptr-preloader {\n  margin-top: 0;\n}\n.ios .ptr-bottom .ptr-preloader {\n  margin-top: 0;\n  margin-bottom: calc(-1 * var(--f7-ptr-size));\n}\n.ios .ptr-bottom.ptr-transitioning > *,\n.ios .ptr-bottom.ptr-refreshing > * {\n  transition-duration: 300ms;\n  transition-property: transform;\n}\n.ios .ptr-bottom.ptr-refreshing {\n  transform: none;\n}\n.ios .ptr-bottom.ptr-refreshing > * {\n  transform: translate3d(0, calc(-1 * var(--f7-ptr-size)), 0);\n}\n.ios .ptr-bottom .ptr-arrow {\n  transform: rotate(180deg) translate3d(0, 0, 0);\n}\n.ios .ptr-bottom.ptr-pull-up .ptr-arrow {\n  transform: rotate(0deg) translate3d(0, 0, 0);\n}\n.ios .ptr-with-navbar-large-transparent .ptr-preloader .preloader,\n.ios .ptr-with-navbar-transparent .ptr-preloader .preloader,\n.ios .ptr-with-navbar-large-transparent .ptr-preloader .ptr-arrow,\n.ios .ptr-with-navbar-transparent .ptr-preloader .ptr-arrow {\n  opacity: 0;\n  transition-duration: 300ms;\n  transition-property: transform, opacity;\n}\n.ios .ptr-with-navbar-large-transparent.ptr-pull-down .ptr-preloader .preloader,\n.ios .ptr-with-navbar-transparent.ptr-pull-down .ptr-preloader .preloader,\n.ios .ptr-with-navbar-large-transparent.ptr-pull-up .ptr-preloader .preloader,\n.ios .ptr-with-navbar-transparent.ptr-pull-up .ptr-preloader .preloader,\n.ios .ptr-with-navbar-large-transparent.ptr-refreshing .ptr-preloader .preloader,\n.ios .ptr-with-navbar-transparent.ptr-refreshing .ptr-preloader .preloader,\n.ios .ptr-with-navbar-large-transparent.ptr-pull-down .ptr-preloader .ptr-arrow,\n.ios .ptr-with-navbar-transparent.ptr-pull-down .ptr-preloader .ptr-arrow,\n.ios .ptr-with-navbar-large-transparent.ptr-pull-up .ptr-preloader .ptr-arrow,\n.ios .ptr-with-navbar-transparent.ptr-pull-up .ptr-preloader .ptr-arrow,\n.ios .ptr-with-navbar-large-transparent.ptr-refreshing .ptr-preloader .ptr-arrow,\n.ios .ptr-with-navbar-transparent.ptr-refreshing .ptr-preloader .ptr-arrow {\n  opacity: 1;\n}\n.ios .ptr-with-navbar-large-transparent.ptr-closing .ptr-preloader .preloader,\n.ios .ptr-with-navbar-transparent.ptr-closing .ptr-preloader .preloader,\n.ios .ptr-with-navbar-large-transparent.ptr-closing .ptr-preloader .ptr-arrow,\n.ios .ptr-with-navbar-transparent.ptr-closing .ptr-preloader .ptr-arrow {\n  opacity: 0;\n  transition-duration: 300ms;\n}\n.md {\n  --f7-ptr-top: -4px;\n}\n.md .ptr-preloader {\n  width: var(--f7-ptr-size);\n  border-radius: 50%;\n  background: #fff;\n  margin-top: calc(-1 * var(--f7-ptr-size));\n  z-index: 100;\n  box-shadow: var(--f7-elevation-1);\n  left: 50%;\n  margin-left: calc(-1 * var(--f7-ptr-size) / 2);\n}\n.md .ptr-preloader .preloader .preloader-inner-gap,\n.md .ptr-preloader .preloader .preloader-inner-half-circle {\n  border-width: 3px;\n}\n.md .ptr-arrow {\n  width: 22px;\n  height: 22px;\n  box-sizing: border-box;\n  border: 3px solid var(--f7-preloader-color);\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -11px;\n  margin-top: -11px;\n  border-left-color: transparent;\n  border-radius: 50%;\n  opacity: 1;\n  transform: rotate(150deg);\n}\n.md .ptr-arrow:after {\n  content: '';\n  width: 0px;\n  height: 0px;\n  position: absolute;\n  left: -5px;\n  bottom: 0px;\n  border-bottom-width: 6px;\n  border-bottom-style: solid;\n  border-bottom-color: inherit;\n  border-left: 5px solid transparent;\n  border-right: 5px solid transparent;\n  transform: rotate(-40deg);\n}\n.md .ptr-content:not(.ptr-refreshing):not(.ptr-pull-up) .ptr-preloader .preloader,\n.md .ptr-content:not(.ptr-refreshing):not(.ptr-pull-up) .ptr-preloader .preloader * {\n  animation: none;\n}\n.md .ptr-refreshing .ptr-preloader .preloader,\n.md .ptr-pull-up .ptr-preloader .preloader {\n  visibility: visible;\n}\n.md .ptr-refreshing .ptr-arrow,\n.md .ptr-pull-up .ptr-arrow {\n  visibility: hidden;\n}\n.md .ptr-refreshing .ptr-preloader {\n  transform: translate3d(0, 66px, 0);\n}\n.md .ptr-transitioning .ptr-arrow {\n  transition: 300ms;\n}\n.md .ptr-pull-up .ptr-arrow {\n  transition: 400ms;\n  transform: rotate(620deg) !important;\n  opacity: 0;\n}\n.md .ptr-transitioning .ptr-preloader,\n.md .ptr-refreshing .ptr-preloader {\n  transition-duration: 300ms;\n  transition-property: transform, opacity;\n}\n.md .ptr-bottom .ptr-preloader {\n  margin-top: 0;\n  margin-bottom: calc(-1 * var(--f7-ptr-size) - 4px);\n}\n.md .ptr-bottom.ptr-refreshing .ptr-preloader {\n  transform: translate3d(0, -66px, 0);\n}\n.md .ptr-with-navbar-large-transparent .ptr-preloader,\n.md .ptr-with-navbar-transparent .ptr-preloader {\n  opacity: 0;\n}\n.md .ptr-with-navbar-large-transparent.ptr-pull-down .ptr-preloader,\n.md .ptr-with-navbar-transparent.ptr-pull-down .ptr-preloader,\n.md .ptr-with-navbar-large-transparent.ptr-pull-up .ptr-preloader,\n.md .ptr-with-navbar-transparent.ptr-pull-up .ptr-preloader,\n.md .ptr-with-navbar-large-transparent.ptr-refreshing .ptr-preloader,\n.md .ptr-with-navbar-transparent.ptr-refreshing .ptr-preloader {\n  opacity: 1;\n}\n.md .ptr-with-navbar-large-transparent.ptr-closing .ptr-preloader,\n.md .ptr-with-navbar-transparent.ptr-closing .ptr-preloader {\n  opacity: 0;\n  transition-duration: 300ms;\n}\n.aurora .ptr-preloader {\n  margin-top: calc(-1 * var(--f7-ptr-size));\n  width: 100%;\n  left: 0;\n}\n.aurora .ptr-arrow {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  background: no-repeat center;\n  z-index: 10;\n  transform: rotate(0deg) translate3d(0, 0, 0);\n  transition-duration: 300ms;\n  transition-property: transform, opacity;\n  width: 12px;\n  height: 20px;\n  margin-left: -6px;\n  margin-top: -10px;\n  visibility: visible;\n  color: var(--f7-preloader-color);\n}\n.aurora .ptr-arrow:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  width: 12px;\n  height: 20px;\n  line-height: 20px;\n  font-size: 8px;\n  content: 'ptr_arrow_ios';\n}\n.aurora .ptr-content:not(.ptr-refreshing) .ptr-preloader .preloader {\n  animation: none;\n}\n.aurora .ptr-transitioning,\n.aurora .ptr-refreshing {\n  transition-duration: 300ms;\n  transition-property: transform;\n}\n.aurora .ptr-refreshing {\n  transform: translate3d(0, var(--f7-ptr-size), 0);\n}\n.aurora .ptr-refreshing .ptr-arrow {\n  visibility: hidden;\n}\n.aurora .ptr-refreshing .ptr-preloader .preloader {\n  visibility: visible;\n}\n.aurora .ptr-pull-up .ptr-arrow {\n  transform: rotate(180deg) translate3d(0, 0, 0);\n}\n.aurora .ptr-no-navbar,\n.aurora .ptr-with-navbar-large-transparent,\n.aurora .ptr-with-navbar-transparent {\n  margin-top: calc(-1 * var(--f7-ptr-size));\n  height: calc(100% + var(--f7-ptr-size));\n}\n.aurora .ptr-no-navbar .ptr-preloader,\n.aurora .ptr-with-navbar-large-transparent .ptr-preloader,\n.aurora .ptr-with-navbar-transparent .ptr-preloader {\n  margin-top: 0;\n}\n.aurora .ptr-bottom .ptr-preloader {\n  margin-top: 0;\n  margin-bottom: calc(-1 * var(--f7-ptr-size));\n}\n.aurora .ptr-bottom.ptr-transitioning > *,\n.aurora .ptr-bottom.ptr-refreshing > * {\n  transition-duration: 300ms;\n  transition-property: transform;\n}\n.aurora .ptr-bottom.ptr-refreshing {\n  transform: none;\n}\n.aurora .ptr-bottom.ptr-refreshing > * {\n  transform: translate3d(0, calc(-1 * var(--f7-ptr-size)), 0);\n}\n.aurora .ptr-bottom .ptr-arrow {\n  transform: rotate(180deg) translate3d(0, 0, 0);\n}\n.aurora .ptr-bottom.ptr-pull-up .ptr-arrow {\n  transform: rotate(0deg) translate3d(0, 0, 0);\n}\n.aurora .ptr-with-navbar-large-transparent .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-transparent .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-large-transparent .ptr-preloader .ptr-arrow,\n.aurora .ptr-with-navbar-transparent .ptr-preloader .ptr-arrow {\n  opacity: 0;\n  transition-duration: 300ms;\n  transition-property: transform, opacity;\n}\n.aurora .ptr-with-navbar-large-transparent.ptr-pull-down .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-transparent.ptr-pull-down .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-large-transparent.ptr-pull-up .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-transparent.ptr-pull-up .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-large-transparent.ptr-refreshing .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-transparent.ptr-refreshing .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-large-transparent.ptr-pull-down .ptr-preloader .ptr-arrow,\n.aurora .ptr-with-navbar-transparent.ptr-pull-down .ptr-preloader .ptr-arrow,\n.aurora .ptr-with-navbar-large-transparent.ptr-pull-up .ptr-preloader .ptr-arrow,\n.aurora .ptr-with-navbar-transparent.ptr-pull-up .ptr-preloader .ptr-arrow,\n.aurora .ptr-with-navbar-large-transparent.ptr-refreshing .ptr-preloader .ptr-arrow,\n.aurora .ptr-with-navbar-transparent.ptr-refreshing .ptr-preloader .ptr-arrow {\n  opacity: 1;\n}\n.aurora .ptr-with-navbar-large-transparent.ptr-closing .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-transparent.ptr-closing .ptr-preloader .preloader,\n.aurora .ptr-with-navbar-large-transparent.ptr-closing .ptr-preloader .ptr-arrow,\n.aurora .ptr-with-navbar-transparent.ptr-closing .ptr-preloader .ptr-arrow {\n  opacity: 0;\n  transition-duration: 300ms;\n}\n/* === Images Lazy Loading === */\n.lazy-loaded.lazy-fade-in {\n  animation: lazyFadeIn 600ms;\n}\n@keyframes lazyFadeIn {\n  from {\n    opacity: 0;\n  }\n  to {\n    opacity: 1;\n  }\n}\n/* === Data Table === */\n:root {\n  --f7-table-head-font-size: 12px;\n  --f7-table-body-font-size: 14px;\n  --f7-table-footer-font-size: 12px;\n  --f7-table-input-height: 24px;\n  --f7-table-input-font-size: 14px;\n  --f7-table-collapsible-cell-padding: 16px;\n  --f7-table-link-icon-only-icon-size: 20px;\n  --f7-table-sortable-icon-color: #000;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-table-cell-border-color: rgba(255, 255, 255, 0.15);\n  --f7-table-sortable-icon-color: #fff;\n  --f7-table-input-text-color: #fff;\n}\n.ios {\n  --f7-table-head-font-weight: 600;\n  --f7-table-head-cell-height: 44px;\n  --f7-table-head-icon-size: 18px;\n  --f7-table-body-cell-height: 44px;\n  --f7-table-cell-padding-vertical: 0px;\n  --f7-table-cell-padding-horizontal: 16px;\n  --f7-table-edge-cell-padding-horizontal: 16px;\n  --f7-table-label-cell-padding-horizontal: 16px;\n  --f7-table-checkbox-cell-width: 22px;\n  /* --f7-table-actions-cell-link-color: var(--f7-theme-color); */\n  /* --f7-table-actions-link-color: var(--f7-theme-color); */\n  --f7-table-title-font-size: 17px;\n  --f7-table-title-font-weight: 600;\n  --f7-table-card-header-height: 64px;\n  --f7-table-footer-height: 44px;\n  --f7-table-head-text-color: rgba(0, 0, 0, 0.45);\n  --f7-table-cell-border-color: rgba(0, 0, 0, 0.22);\n  --f7-table-selected-row-bg-color: rgba(0, 0, 0, 0.03);\n  --f7-table-footer-text-color: rgba(0, 0, 0, 0.45);\n  --f7-table-input-text-color: #000;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-table-head-text-color: rgba(255, 255, 255, 0.55);\n  --f7-table-footer-text-color: rgba(255, 255, 255, 0.55);\n  --f7-table-selected-row-bg-color: rgba(255, 255, 255, 0.08);\n}\n.md {\n  --f7-table-head-font-weight: 500;\n  --f7-table-head-cell-height: 56px;\n  --f7-table-head-icon-size: 16px;\n  --f7-table-body-cell-height: 48px;\n  --f7-table-cell-padding-vertical: 0px;\n  --f7-table-cell-padding-horizontal: 28px;\n  --f7-table-edge-cell-padding-horizontal: 24px;\n  --f7-table-label-cell-padding-horizontal: 24px;\n  --f7-table-checkbox-cell-width: 18px;\n  --f7-table-title-font-size: 20px;\n  --f7-table-title-font-weight: 400;\n  --f7-table-card-header-height: 64px;\n  --f7-table-footer-height: 56px;\n  --f7-table-head-text-color: rgba(0, 0, 0, 0.54);\n  --f7-table-cell-border-color: rgba(0, 0, 0, 0.12);\n  --f7-table-actions-cell-link-color: rgba(0, 0, 0, 0.54);\n  --f7-table-selected-row-bg-color: #f5f5f5;\n  --f7-table-actions-link-color: rgba(0, 0, 0, 0.54);\n  --f7-table-footer-text-color: rgba(0, 0, 0, 0.54);\n  --f7-table-input-text-color: #212121;\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-table-head-text-color: rgba(255, 255, 255, 0.54);\n  --f7-table-footer-text-color: rgba(255, 255, 255, 0.54);\n  --f7-table-selected-row-bg-color: rgba(255, 255, 255, 0.05);\n  --f7-table-actions-cell-link-color: rgba(255, 255, 255, 0.54);\n  --f7-table-actions-link-color: rgba(255, 255, 255, 0.54);\n}\n.aurora {\n  --f7-table-link-icon-only-icon-size: 18px;\n  --f7-table-head-font-weight: 400;\n  --f7-table-head-cell-height: 32px;\n  --f7-table-head-icon-size: 18px;\n  --f7-table-body-cell-height: 32px;\n  --f7-table-cell-padding-vertical: 5px;\n  --f7-table-cell-padding-horizontal: 10px;\n  --f7-table-edge-cell-padding-horizontal: 16px;\n  --f7-table-label-cell-padding-horizontal: 16px;\n  --f7-table-checkbox-cell-width: 22px;\n  /* --f7-table-actions-cell-link-color: var(--f7-theme-color); */\n  /* --f7-table-actions-link-color: var(--f7-theme-color); */\n  --f7-table-title-font-size: 14px;\n  --f7-table-title-font-weight: 600;\n  --f7-table-card-header-height: 42px;\n  --f7-table-footer-height: 32px;\n  --f7-table-head-text-color: rgba(0, 0, 0, 0.6);\n  --f7-table-cell-border-color: rgba(0, 0, 0, 0.12);\n  --f7-table-selected-row-bg-color: rgba(0, 0, 0, 0.03);\n  --f7-table-footer-text-color: rgba(0, 0, 0, 0.5);\n  --f7-table-input-text-color: #000;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-table-selected-row-bg-color: rgba(255, 255, 255, 0.03);\n  --f7-table-head-text-color: rgba(255, 255, 255, 0.54);\n  --f7-table-footer-text-color: rgba(255, 255, 255, 0.54);\n}\n.data-table {\n  overflow-x: auto;\n}\n.data-table table,\ntable.data-table {\n  width: 100%;\n  border: none;\n  padding: 0;\n  margin: 0;\n  border-collapse: collapse;\n  text-align: left;\n}\n.data-table thead th,\n.data-table thead td {\n  font-size: var(--f7-table-head-font-size);\n  font-weight: var(--f7-table-head-font-weight);\n  overflow: hidden;\n  white-space: nowrap;\n  text-overflow: ellipsis;\n  line-height: 16px;\n  height: var(--f7-table-head-cell-height);\n}\n.data-table thead th:not(.sortable-cell-active),\n.data-table thead td:not(.sortable-cell-active) {\n  color: var(--f7-table-head-text-color);\n}\n.data-table thead i.icon,\n.data-table thead i.f7-icons,\n.data-table thead i.material-icons {\n  vertical-align: top;\n  font-size: var(--f7-table-head-icon-size);\n}\n.data-table tbody {\n  font-size: var(--f7-table-body-font-size);\n}\n.data-table tbody th,\n.data-table tbody td {\n  height: var(--f7-table-body-cell-height);\n}\n.data-table tbody tr.data-table-row-selected,\n.device-desktop .data-table tbody tr:hover {\n  background: var(--f7-table-selected-row-bg-color);\n}\n.data-table tbody td:before,\n.data-table tbody th:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-table-cell-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.data-table th,\n.data-table td {\n  --f7-table-cell-padding-left: var(--f7-table-cell-padding-horizontal);\n  --f7-table-cell-padding-right: var(--f7-table-cell-padding-horizontal);\n  padding-top: var(--f7-table-cell-padding-vertical);\n  padding-bottom: var(--f7-table-cell-padding-vertical);\n  padding-left: var(--f7-table-cell-padding-left);\n  padding-right: var(--f7-table-cell-padding-right);\n  position: relative;\n  box-sizing: border-box;\n}\n.data-table th:first-child,\n.data-table td:first-child {\n  --f7-table-cell-padding-left: var(--f7-table-edge-cell-padding-horizontal);\n}\n.data-table th:last-child,\n.data-table td:last-child {\n  --f7-table-cell-padding-right: var(--f7-table-edge-cell-padding-horizontal);\n}\n.data-table th.label-cell,\n.data-table td.label-cell {\n  --f7-table-cell-padding-left: var(--f7-table-label-cell-padding-horizontal);\n  --f7-table-cell-padding-right: var(--f7-table-label-cell-padding-horizontal);\n}\n.data-table th.numeric-cell,\n.data-table td.numeric-cell {\n  text-align: right;\n}\n.data-table th.checkbox-cell,\n.data-table td.checkbox-cell {\n  overflow: visible;\n  width: var(--f7-table-checkbox-cell-width);\n}\n.data-table th.checkbox-cell label + span,\n.data-table td.checkbox-cell label + span {\n  margin-left: 8px;\n}\n.data-table th.checkbox-cell:first-child,\n.data-table td.checkbox-cell:first-child {\n  padding-right: calc(var(--f7-table-cell-padding-right) / 2);\n}\n.data-table th.checkbox-cell:first-child + td,\n.data-table td.checkbox-cell:first-child + td,\n.data-table th.checkbox-cell:first-child + th,\n.data-table td.checkbox-cell:first-child + th {\n  padding-left: calc(var(--f7-table-cell-padding-left) / 2);\n}\n.data-table th.checkbox-cell:last-child,\n.data-table td.checkbox-cell:last-child {\n  padding-left: calc(var(--f7-table-cell-padding-left) / 2);\n}\n.data-table th.actions-cell,\n.data-table td.actions-cell {\n  text-align: right;\n  white-space: nowrap;\n}\n.data-table th.actions-cell a.link,\n.data-table td.actions-cell a.link {\n  color: var(--f7-table-actions-cell-link-color, var(--f7-theme-color));\n}\n.data-table th a.icon-only,\n.data-table td a.icon-only,\n.card .data-table th a.icon-only,\n.card .data-table td a.icon-only,\n.card.data-table th a.icon-only,\n.card.data-table td a.icon-only {\n  display: inline-block;\n  vertical-align: middle;\n  text-align: center;\n  font-size: 0;\n  min-width: 0;\n}\n.data-table th a.icon-only i,\n.data-table td a.icon-only i,\n.card .data-table th a.icon-only i,\n.card .data-table td a.icon-only i,\n.card.data-table th a.icon-only i,\n.card.data-table td a.icon-only i {\n  font-size: var(--f7-table-link-icon-only-icon-size);\n  vertical-align: middle;\n}\n.data-table .sortable-cell:not(.input-cell) {\n  cursor: pointer;\n  position: relative;\n}\n.data-table .sortable-cell.input-cell .table-head-label {\n  cursor: pointer;\n  position: relative;\n}\n.data-table .sortable-cell:not(.numeric-cell):not(.input-cell):after,\n.data-table .sortable-cell.numeric-cell:not(.input-cell):before,\n.data-table .sortable-cell:not(.numeric-cell).input-cell > .table-head-label:after,\n.data-table .sortable-cell.numeric-cell.input-cell > .table-head-label:before {\n  content: 'arrow_bottom_md';\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  display: inline-block;\n  vertical-align: top;\n  width: 16px;\n  height: 16px;\n  color: var(--f7-table-sortable-icon-color);\n  font-size: 13px;\n  line-height: 16px;\n  transition-duration: 300ms;\n  transform: rotate(0);\n  opacity: 0;\n}\n.device-desktop .data-table .sortable-cell:not(.sortable-cell-active):hover:after,\n.device-desktop .data-table .sortable-cell:not(.sortable-cell-active) .table-head-label:hover:after,\n.device-desktop .data-table .sortable-cell:not(.sortable-cell-active):hover:before,\n.device-desktop .data-table .sortable-cell:not(.sortable-cell-active) .table-head-label:hover:before {\n  opacity: 0.54;\n}\n.data-table .sortable-cell.sortable-cell-active:after,\n.data-table .sortable-cell.sortable-cell-active .table-head-label:after,\n.data-table .sortable-cell.sortable-cell-active:before,\n.data-table .sortable-cell.sortable-cell-active .table-head-label:before {\n  opacity: 0.87 !important;\n}\n.data-table .sortable-cell.sortable-desc:after,\n.data-table .sortable-cell.sortable-desc:after,\n.data-table .table-head-label:after,\n.data-table .sortable-cell.sortable-desc:before,\n.data-table .sortable-cell.sortable-desc:before,\n.data-table .table-head-label:before {\n  transform: rotate(180deg) !important;\n}\n.data-table.card .card-header,\n.card .data-table .card-header,\n.data-table.card .card-footer,\n.card .data-table .card-footer {\n  padding-left: var(--f7-table-edge-cell-padding-horizontal);\n  padding-right: var(--f7-table-edge-cell-padding-horizontal);\n}\n.data-table.card .card-header,\n.card .data-table .card-header {\n  min-height: var(--f7-table-card-header-height);\n}\n.data-table.card .card-content,\n.card .data-table .card-content {\n  overflow-x: auto;\n}\n.data-table.card .card-footer,\n.card .data-table .card-footer {\n  min-height: var(--f7-table-footer-height);\n}\n.data-table .data-table-title {\n  font-size: var(--f7-table-title-font-size);\n  font-weight: var(--f7-table-title-font-weight);\n}\n.data-table .data-table-links,\n.data-table .data-table-actions {\n  display: flex;\n}\n.data-table .data-table-links .button {\n  min-width: 64px;\n}\n.data-table .data-table-actions {\n  margin-left: auto;\n  align-items: center;\n}\n.data-table .data-table-actions a.link {\n  color: var(--f7-table-actions-link-color, var(--f7-theme-color));\n  min-width: 0;\n}\n.data-table .data-table-actions a.link.icon-only {\n  line-height: 1;\n  justify-content: center;\n  padding: 0;\n}\n.data-table .data-table-header,\n.data-table .data-table-header-selected {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  width: 100%;\n}\n.data-table .card-header > .data-table-header,\n.data-table .card-header > .data-table-header-selected {\n  padding-top: var(--f7-card-header-padding-vertical);\n  padding-bottom: var(--f7-card-header-padding-vertical);\n  height: 100%;\n  padding-left: var(--f7-table-edge-cell-padding-horizontal);\n  padding-right: var(--f7-table-edge-cell-padding-horizontal);\n  margin-left: calc(-1 * var(--f7-table-edge-cell-padding-horizontal));\n  margin-right: calc(-1 * var(--f7-table-edge-cell-padding-horizontal));\n}\n.data-table .data-table-header-selected {\n  background: rgba(var(--f7-theme-color-rgb), 0.1);\n  display: none;\n}\n.data-table.data-table-has-checked .data-table-header {\n  display: none;\n}\n.data-table.data-table-has-checked .data-table-header-selected {\n  display: flex;\n}\n.data-table .data-table-title-selected {\n  font-size: 14px;\n  color: var(--f7-theme-color);\n}\n.data-table .data-table-footer {\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  position: relative;\n  font-size: var(--f7-table-footer-font-size);\n  overflow: hidden;\n  min-height: var(--f7-table-footer-height);\n  color: var(--f7-table-footer-text-color);\n  justify-content: flex-end;\n}\n.data-table .data-table-footer:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-table-cell-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.data-table .data-table-rows-select,\n.data-table .data-table-pagination {\n  display: flex;\n  align-items: center;\n}\n.data-table .input-cell {\n  padding-top: 8px;\n  padding-bottom: 8px;\n  height: auto;\n  vertical-align: top;\n}\n.data-table .input-cell .table-head-label + .input {\n  margin-top: 4px;\n}\n.data-table .input-cell .input {\n  height: var(--f7-table-input-height);\n}\n.data-table .input-cell .input input,\n.data-table .input-cell .input textarea,\n.data-table .input-cell .input select {\n  height: var(--f7-table-input-height);\n  color: var(--f7-table-input-text-color);\n  font-size: var(--f7-table-input-font-size);\n}\n@media (max-width: 480px) and (orientation: portrait) {\n  .data-table.data-table-collapsible thead {\n    display: none;\n  }\n  .data-table.data-table-collapsible tbody,\n  .data-table.data-table-collapsible tr,\n  .data-table.data-table-collapsible td {\n    display: block;\n  }\n  .data-table.data-table-collapsible tr {\n    position: relative;\n  }\n  .data-table.data-table-collapsible tr:before {\n    content: '';\n    position: absolute;\n    background-color: var(--f7-table-cell-border-color);\n    display: block;\n    z-index: 15;\n    top: 0;\n    right: auto;\n    bottom: auto;\n    left: 0;\n    height: 1px;\n    width: 100%;\n    transform-origin: 50% 0%;\n    transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n  }\n  .data-table.data-table-collapsible tr:hover {\n    background-color: inherit;\n  }\n  .data-table.data-table-collapsible td {\n    --f7-table-cell-padding-left: var(--f7-table-collapsible-cell-padding);\n    --f7-table-cell-padding-right: var(--f7-table-collapsible-cell-padding);\n    height: auto;\n    min-height: var(--f7-table-body-cell-height);\n    display: flex;\n    align-content: center;\n    align-items: center;\n    justify-content: flex-start;\n    text-align: left;\n  }\n  .data-table.data-table-collapsible td:before {\n    display: none !important;\n  }\n  .data-table.data-table-collapsible td:not(.checkbox-cell):before {\n    width: 40%;\n    display: block !important;\n    content: attr(data-collapsible-title);\n    position: relative;\n    height: auto;\n    background: none !important;\n    transform: none !important;\n    font-size: var(--f7-table-head-font-size);\n    font-weight: var(--f7-table-head-font-weight);\n    color: var(--f7-table-head-text-color);\n    margin-right: 16px;\n    flex-shrink: 0;\n  }\n  .data-table.data-table-collapsible td.checkbox-cell {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n  .data-table.data-table-collapsible td.checkbox-cell + td {\n    padding-left: 16px;\n  }\n  .data-table.data-table-collapsible td.checkbox-cell ~ td {\n    margin-left: 32px;\n  }\n}\n.data-table .xsmall-only,\n.data-table .xsmall-landscape-only {\n  display: none;\n}\n@media (min-width: 480px) {\n  .data-table .xsmall-only {\n    display: table-cell;\n  }\n}\n@media (min-width: 480px) and (orientation: landscape) {\n  .data-table .xsmall-landscape-only {\n    display: table-cell;\n  }\n}\n.data-table .small-only,\n.data-table .small-landscape-only {\n  display: none;\n}\n@media (min-width: 568px) {\n  .data-table .small-only {\n    display: table-cell;\n  }\n}\n@media (min-width: 568px) and (orientation: landscape) {\n  .data-table .small-landscape-only {\n    display: table-cell;\n  }\n}\n.data-table .medium-only,\n.data-table .medium-landscape-only {\n  display: none;\n}\n@media (min-width: 768px) {\n  .data-table .medium-only {\n    display: table-cell;\n  }\n}\n@media (min-width: 768px) and (orientation: landscape) {\n  .data-table .medium-landscape-only {\n    display: table-cell;\n  }\n}\n.data-table .large-only,\n.data-table .large-landscape-only {\n  display: none;\n}\n@media (min-width: 1024px) {\n  .data-table .large-only {\n    display: table-cell;\n  }\n}\n@media (min-width: 1024px) and (orientation: landscape) {\n  .data-table .large-landscape-only {\n    display: table-cell;\n  }\n}\n.data-table .xlarge-only,\n.data-table .xlarge-landscape-only {\n  display: none;\n}\n@media (min-width: 1200px) {\n  .data-table .xlarge-only {\n    display: table-cell;\n  }\n}\n@media (min-width: 1200px) and (orientation: landscape) {\n  .data-table .xlarge-landscape-only {\n    display: table-cell;\n  }\n}\n.ios .data-table th.actions-cell a.link + a.link,\n.ios .data-table td.actions-cell a.link + a.link {\n  margin-left: 16px;\n}\n.ios .sortable-cell:not(.numeric-cell):after {\n  margin-left: 5px;\n}\n.ios .sortable-cell.numeric-cell:before {\n  margin-right: 5px;\n}\n.ios .data-table-links a.link + a.link,\n.ios .data-table-actions a.link + a.link,\n.ios .data-table-links .button + .button,\n.ios .data-table-actions .button + .button {\n  margin-left: 16px;\n}\n.ios .data-table-actions a.link.icon-only {\n  width: 44px;\n  height: 44px;\n}\n.ios .data-table-rows-select a.link,\n.ios .data-table-pagination a.link {\n  width: 44px;\n  height: 44px;\n}\n.ios .data-table-rows-select + .data-table-pagination {\n  margin-left: 30px;\n}\n.ios .data-table-rows-select .input {\n  margin-left: 20px;\n}\n.ios .data-table-pagination-label {\n  margin-right: 16px;\n}\n.md .data-table th.actions-cell a.link + a.link,\n.md .data-table td.actions-cell a.link + a.link {\n  margin-left: 24px;\n}\n.md .data-table th.actions-cell a.icon-only,\n.md .data-table td.actions-cell a.icon-only {\n  width: 24px;\n  height: 24px;\n  line-height: 24px;\n}\n.md .sortable-cell:not(.numeric-cell):after {\n  margin-left: 8px;\n}\n.md .sortable-cell.numeric-cell:before {\n  margin-right: 8px;\n}\n.md .data-table-links a.link + a.link,\n.md .data-table-actions a.link + a.link,\n.md .data-table-links .button + .button,\n.md .data-table-actions .button + .button {\n  margin-left: 24px;\n}\n.md .data-table-actions a.link.icon-only {\n  width: 24px;\n  height: 24px;\n  overflow: visible;\n}\n.md .data-table-actions a.link.icon-only.active-state {\n  background: none;\n}\n.md .data-table-rows-select a.link,\n.md .data-table-pagination a.link {\n  width: 48px;\n  height: 48px;\n}\n.md .data-table-rows-select a.link:before,\n.md .data-table-pagination a.link:before {\n  content: '';\n  width: 152%;\n  height: 152%;\n  position: absolute;\n  left: -26%;\n  top: -26%;\n  background-image: radial-gradient(circle at center, var(--f7-link-highlight-color) 66%, rgba(255, 255, 255, 0) 66%);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 100% 100%;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 600ms;\n}\n.md .data-table-rows-select a.link.active-state:before,\n.md .data-table-pagination a.link.active-state:before {\n  opacity: 1;\n  transition-duration: 150ms;\n}\n.md .data-table-rows-select + .data-table-pagination {\n  margin-left: 32px;\n}\n.md .data-table-rows-select .input {\n  margin-left: 24px;\n}\n.md .data-table-pagination-label {\n  margin-right: 20px;\n}\n.md .input-cell .input-clear-button {\n  transform: scale(0.8);\n}\n.aurora .data-table th.actions-cell a.link + a.link,\n.aurora .data-table td.actions-cell a.link + a.link {\n  margin-left: 10px;\n}\n.aurora .sortable-cell:not(.numeric-cell):after {\n  margin-left: 5px;\n}\n.aurora .sortable-cell.numeric-cell:before {\n  margin-right: 5px;\n}\n.aurora .data-table-links a.link + a.link,\n.aurora .data-table-actions a.link + a.link,\n.aurora .data-table-links .button + .button,\n.aurora .data-table-actions .button + .button {\n  margin-left: 10px;\n}\n.aurora .data-table-rows-select a.link,\n.aurora .data-table-pagination a.link {\n  width: 32px;\n  height: 32px;\n}\n.aurora .data-table-rows-select + .data-table-pagination {\n  margin-left: 16px;\n}\n.aurora .data-table-rows-select .input {\n  margin-left: 10px;\n}\n.aurora .data-table-pagination-label {\n  margin-right: 10px;\n}\n/* === FAB === */\n:root {\n  --f7-fab-margin: 16px;\n  --f7-fab-text-color: #fff;\n  --f7-fab-extended-text-font-size: 14px;\n  --f7-fab-extended-text-padding: 0 20px;\n  --f7-fab-label-bg-color: #fff;\n  --f7-fab-label-text-color: #333;\n  --f7-fab-label-border-radius: 4px;\n  --f7-fab-label-padding: 4px 12px;\n  --f7-fab-button-size: 40px;\n  /* --f7-fab-pressed-bg-color: var(--f7-theme-color-shade); */\n}\n.ios {\n  --f7-fab-size: 50px;\n  --f7-fab-box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);\n  --f7-fab-extended-size: 50px;\n  --f7-fab-extended-text-font-weight: 600;\n  --f7-fab-extended-text-letter-spacing: 0;\n  --f7-fab-label-box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.4);\n  --f7-fab-label-font-size: inherit;\n}\n.md {\n  --f7-fab-size: 56px;\n  --f7-fab-box-shadow: var(--f7-elevation-6);\n  --f7-fab-extended-size: 48px;\n  --f7-fab-extended-text-font-weight: 500;\n  --f7-fab-extended-text-letter-spacing: 0.03em;\n  --f7-fab-label-box-shadow: var(--f7-elevation-3);\n  --f7-fab-label-font-size: inherit;\n}\n.aurora {\n  --f7-fab-size: 40px;\n  --f7-fab-box-shadow: 0px 2px 4px rgba(0, 0, 0, 0.4);\n  --f7-fab-extended-size: 38px;\n  --f7-fab-extended-text-font-weight: 500;\n  --f7-fab-extended-text-letter-spacing: 0;\n  --f7-fab-label-box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.4);\n  --f7-fab-label-font-size: 12px;\n}\n.fab-backdrop {\n  z-index: 1400;\n}\n.fab {\n  position: absolute;\n  z-index: 1500;\n}\n.fab a {\n  --f7-touch-ripple-color: var(--f7-touch-ripple-white);\n}\n.fab[class*=\"fab-left\"] {\n  left: calc(var(--f7-fab-margin) + var(--f7-safe-area-left));\n}\n.fab[class*=\"fab-right\"] {\n  right: calc(var(--f7-fab-margin) + var(--f7-safe-area-right));\n}\n.fab[class*=\"-top\"] {\n  top: var(--f7-fab-margin);\n}\n.fab[class*=\"-bottom\"] {\n  bottom: calc(var(--f7-fab-margin) + var(--f7-safe-area-bottom));\n}\n.fab[class*=\"fab-center\"] {\n  left: 50%;\n  transform: translateX(-50%);\n}\n.fab[class*=\"left-center\"],\n.fab[class*=\"right-center\"] {\n  top: 50%;\n  transform: translateY(-50%);\n}\n.fab[class*=\"center-center\"] {\n  top: 50%;\n  left: 50%;\n  transform: translateX(-50%) translateY(-50%);\n}\n.fab > a,\n.fab-buttons a {\n  background-color: var(--f7-fab-bg-color, var(--f7-theme-color));\n  width: var(--f7-fab-size);\n  height: var(--f7-fab-size);\n  box-shadow: var(--f7-fab-box-shadow);\n  border-radius: calc(var(--f7-fab-size) / 2);\n  position: relative;\n  transition-duration: 300ms;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  overflow: hidden;\n  z-index: 1;\n  color: var(--f7-fab-text-color);\n}\n.fab > a.active-state,\n.fab-buttons a.active-state {\n  background-color: var(--f7-fab-pressed-bg-color, var(--f7-theme-color-shade));\n}\n.fab > a i {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate3d(-50%, -50%, 0) rotate(0deg) scale(1);\n  transition: 300ms;\n}\n.fab > a i + i {\n  transform: translate3d(-50%, -50%, 0) rotate(-90deg) scale(0.5);\n  opacity: 0;\n}\n.fab-buttons a {\n  border-radius: calc(var(--f7-fab-button-size) / 2);\n  width: var(--f7-fab-button-size);\n  height: var(--f7-fab-button-size);\n}\n.fab-buttons {\n  display: flex;\n  visibility: hidden;\n  pointer-events: none;\n  position: absolute;\n}\n.fab-buttons a {\n  opacity: 0;\n}\n.fab-opened:not(.fab-morph) > a i {\n  transform: translate3d(-50%, -50%, 0) rotate(90deg) scale(0.5);\n  opacity: 0;\n}\n.fab-opened:not(.fab-morph) > a i + i {\n  transform: translate3d(-50%, -50%, 0) rotate(0deg) scale(1);\n  opacity: 1;\n}\n.fab-opened .fab-buttons {\n  visibility: visible;\n  pointer-events: auto;\n}\n.fab-opened .fab-buttons a {\n  opacity: 1;\n  transform: translate3d(0, 0px, 0) scale(1) !important;\n}\n.fab-opened .fab-buttons a:nth-child(2) {\n  transition-delay: 50ms;\n}\n.fab-opened .fab-buttons a:nth-child(3) {\n  transition-delay: 100ms;\n}\n.fab-opened .fab-buttons a:nth-child(4) {\n  transition-delay: 150ms;\n}\n.fab-opened .fab-buttons a:nth-child(5) {\n  transition-delay: 200ms;\n}\n.fab-opened .fab-buttons a:nth-child(6) {\n  transition-delay: 250ms;\n}\n.fab-buttons-top,\n.fab-buttons-bottom {\n  left: 50%;\n  width: var(--f7-fab-button-size);\n  margin-left: calc(-1 * var(--f7-fab-button-size) / 2);\n}\n.fab-buttons-top {\n  bottom: 100%;\n  margin-bottom: 16px;\n  flex-direction: column-reverse;\n}\n.fab-buttons-top a {\n  transform: translate3d(0, 8px, 0) scale(0.3);\n  transform-origin: center bottom;\n}\n.fab-buttons-top a + a {\n  margin-bottom: 16px;\n}\n.fab-buttons-bottom {\n  top: 100%;\n  margin-top: 16px;\n  flex-direction: column;\n}\n.fab-buttons-bottom a {\n  transform: translate3d(0, -8px, 0) scale(0.3);\n  transform-origin: center top;\n}\n.fab-buttons-bottom a + a {\n  margin-top: 16px;\n}\n.fab-buttons-left,\n.fab-buttons-right {\n  top: 50%;\n  height: var(--f7-fab-button-size);\n  margin-top: calc(-1 * var(--f7-fab-button-size) / 2);\n}\n.fab-buttons-left {\n  right: 100%;\n  margin-right: 16px;\n  flex-direction: row-reverse;\n}\n.fab-buttons-left a {\n  transform: translate3d(8px, 0px, 0) scale(0.3);\n  transform-origin: right center;\n}\n.fab-buttons-left a + a {\n  margin-right: 16px;\n}\n.fab-buttons-right {\n  left: 100%;\n  margin-left: 16px;\n}\n.fab-buttons-right a {\n  transform: translate3d(-8px, 0, 0) scale(0.3);\n  transform-origin: left center;\n}\n.fab-buttons-right a + a {\n  margin-left: 16px;\n}\n.fab-buttons-center {\n  left: 0%;\n  top: 0%;\n  width: 100%;\n  height: 100%;\n}\n.fab-buttons-center a {\n  position: absolute;\n}\n.fab-buttons-center a:nth-child(1) {\n  left: 50%;\n  margin-left: calc(-1 * var(--f7-fab-button-size) / 2);\n  bottom: 100%;\n  margin-bottom: 16px;\n  transform: translateY(-8px) scale(0.3);\n  transform-origin: center bottom;\n}\n.fab-buttons-center a:nth-child(2) {\n  left: 100%;\n  margin-top: calc(-1 * var(--f7-fab-button-size) / 2);\n  top: 50%;\n  margin-left: 16px;\n  transform: translateX(-8px) scale(0.3);\n  transform-origin: left center;\n}\n.fab-buttons-center a:nth-child(3) {\n  left: 50%;\n  margin-left: calc(-1 * var(--f7-fab-button-size) / 2);\n  top: 100%;\n  margin-top: 16px;\n  transform: translateY(8px) scale(0.3);\n  transform-origin: center top;\n}\n.fab-buttons-center a:nth-child(4) {\n  right: 100%;\n  margin-top: calc(-1 * var(--f7-fab-button-size) / 2);\n  top: 50%;\n  margin-right: 16px;\n  transform: translateX(8px) scale(0.3);\n  transform-origin: right center;\n}\n.fab-morph {\n  border-radius: calc(var(--f7-fab-size) / 2);\n  background: var(--f7-fab-bg-color, var(--f7-theme-color));\n  box-shadow: var(--f7-fab-box-shadow);\n}\n.fab-morph > a {\n  box-shadow: none;\n  background: none !important;\n}\n.fab-opened.fab-morph > a i {\n  opacity: 0;\n}\n.fab-morph,\n.fab-morph > a,\n.fab-morph-target {\n  transition-duration: 250ms;\n}\n.fab-morph-target:not(.fab-morph-target-visible) {\n  display: none;\n}\n.fab-extended {\n  width: auto;\n  min-width: var(--f7-fab-extended-size);\n}\n.fab-extended > a {\n  width: 100%;\n  height: var(--f7-fab-extended-size);\n}\n.fab-extended > a i {\n  left: calc(var(--f7-fab-extended-size) / 2);\n}\n.fab-extended i ~ .fab-text {\n  padding-left: var(--f7-fab-extended-size);\n}\n.fab-extended > a {\n  width: 100% !important;\n}\n.fab-text {\n  box-sizing: border-box;\n  font-size: var(--f7-fab-extended-text-font-size);\n  padding: var(--f7-fab-extended-text-padding);\n  font-weight: var(--f7-fab-extended-text-font-weight);\n  letter-spacing: var(--f7-fab-extended-text-letter-spacing);\n  text-transform: uppercase;\n}\n.fab-label-button {\n  overflow: visible !important;\n}\n.fab-label {\n  position: absolute;\n  top: 50%;\n  padding: var(--f7-fab-label-padding);\n  border-radius: var(--f7-fab-label-border-radius);\n  background: var(--f7-fab-label-bg-color);\n  color: var(--f7-fab-label-text-color);\n  box-shadow: var(--f7-fab-label-box-shadow);\n  white-space: nowrap;\n  transform: translateY(-50%);\n  pointer-events: none;\n  font-size: var(--f7-fab-label-font-size);\n}\n.fab[class*=\"fab-right-\"] .fab-label {\n  right: 100%;\n  margin-right: 8px;\n}\n.fab[class*=\"fab-left-\"] .fab-label {\n  left: 100%;\n  margin-left: 8px;\n}\n.navbar ~ * .fab[class*=\"-top\"],\n.navbar ~ .fab[class*=\"-top\"],\n.navbars ~ * .fab[class*=\"-top\"],\n.navbars ~ .fab[class*=\"-top\"] {\n  margin-top: calc(var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.toolbar-top ~ * .fab[class*=\"-top\"],\n.toolbar-top ~ .fab[class*=\"-top\"],\n.ios .toolbar-top-ios ~ * .fab[class*=\"-top\"],\n.ios .toolbar-top-ios ~ .fab[class*=\"-top\"],\n.md .toolbar-top-md ~ * .fab[class*=\"-top\"],\n.md .toolbar-top-md ~ .fab[class*=\"-top\"] {\n  margin-top: var(--f7-toolbar-height);\n}\n.toolbar-bottom ~ * .fab[class*=\"-bottom\"],\n.toolbar-bottom ~ .fab[class*=\"-bottom\"],\n.ios .toolbar-bottom-ios ~ * .fab[class*=\"-bottom\"],\n.ios .toolbar-bottom-ios ~ .fab[class*=\"-bottom\"],\n.md .toolbar-bottom-md ~ * .fab[class*=\"-bottom\"],\n.md .toolbar-bottom-md ~ .fab[class*=\"-bottom\"] {\n  margin-bottom: var(--f7-toolbar-height);\n}\n.tabbar-labels.toolbar-bottom ~ * .fab[class*=\"-bottom\"],\n.tabbar-labels.toolbar-bottom ~ .fab[class*=\"-bottom\"],\n.ios .tabbar-labels.toolbar-bottom-ios ~ * .fab[class*=\"-bottom\"],\n.ios .tabbar-labels.toolbar-bottom-ios ~ .fab[class*=\"-bottom\"],\n.md .tabbar-labels.toolbar-bottom-md ~ * .fab[class*=\"-bottom\"],\n.md .tabbar-labels.toolbar-bottom-md ~ .fab[class*=\"-bottom\"] {\n  margin-bottom: var(--f7-tabbar-labels-height);\n}\n.tabbar-labels.toolbar-top ~ * .fab[class*=\"-bottom\"],\n.tabbar-labels.toolbar-top ~ .fab[class*=\"-bottom\"],\n.ios .tabbar-labels.toolbar-top-ios ~ * .fab[class*=\"-bottom\"],\n.ios .tabbar-labels.toolbar-top-ios ~ .fab[class*=\"-bottom\"],\n.md .tabbar-labels.toolbar-top-md ~ * .fab[class*=\"-bottom\"],\n.md .tabbar-labels.toolbar-top-md ~ .fab[class*=\"-bottom\"] {\n  margin-top: var(--f7-tabbar-labels-height);\n}\n.messagebar ~ * .fab[class*=\"-bottom\"],\n.messagebar ~ .fab[class*=\"-bottom\"] {\n  margin-bottom: var(--f7-messagebar-height);\n}\n.navbar + .toolbar-top ~ * .fab[class*=\"-top\"],\n.ios .navbar + .toolbar-top-ios ~ * .fab[class*=\"-top\"],\n.md .navbar + .toolbar-top-ios ~ * .fab[class*=\"-top\"],\n.navbar + .toolbar-top ~ .fab[class*=\"-top\"],\n.ios .navbar + .toolbar-top-ios ~ .fab[class*=\"-top\"],\n.md .navbar + .toolbar-top-ios ~ .fab[class*=\"-top\"] {\n  margin-top: calc(var(--f7-toolbar-height) + var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.navbar + .toolbar-top.tabbar-labels ~ * .fab[class*=\"-top\"],\n.ios .navbar + .toolbar-top-ios.tabbar-labels ~ * .fab[class*=\"-top\"],\n.md .navbar + .toolbar-top-ios.tabbar-labels ~ * .fab[class*=\"-top\"],\n.navbar + .toolbar-top.tabbar-labels ~ .fab[class*=\"-top\"],\n.ios .navbar + .toolbar-top-ios.tabbar-labels ~ .fab[class*=\"-top\"],\n.md .navbar + .toolbar-top-ios.tabbar-labels ~ .fab[class*=\"-top\"] {\n  margin-top: calc(var(--f7-tabbar-labels-height) + var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.navbars + .toolbar-top ~ * .fab[class*=\"-top\"],\n.ios .navbars + .toolbar-top-ios ~ * .fab[class*=\"-top\"],\n.navbars + .toolbar-top ~ .fab[class*=\"-top\"],\n.ios .navbars + .toolbar-top-ios ~ .fab[class*=\"-top\"] {\n  margin-top: calc(var(--f7-toolbar-height) + var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.navbars + .toolbar-top.tabbar-labels ~ * .fab[class*=\"-top\"],\n.ios .navbars + .toolbar-top-ios.tabbar-labels ~ * .fab[class*=\"-top\"],\n.navbars + .toolbar-top.tabbar-labels ~ .fab[class*=\"-top\"],\n.ios .navbars + .toolbar-top-ios.tabbar-labels ~ .fab[class*=\"-top\"] {\n  margin-top: calc(var(--f7-tabbar-labels-height) + var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.ios .fab > a.active-state,\n.ios .fab-buttons a.active-state {\n  transition-duration: 0ms;\n}\n/* === Searchbar === */\n:root {\n  /*\n  --f7-searchbar-link-color: var(--f7-bars-link-color);\n  --f7-searchbar-inline-input-font-size: var(--f7-searchbar-input-font-size);\n  --f7-searchbar-inline-input-height: var(--f7-searchbar-input-height);\n  */\n  --f7-searchbar-input-border-width: 0px;\n  --f7-searchbar-input-border-color: transparent;\n  --f7-searchbar-input-text-color: #000;\n  --f7-searchbar-placeholder-color: rgba(0, 0, 0, 0.4);\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-searchbar-input-text-color: #fff;\n  --f7-searchbar-placeholder-color: rgba(255, 255, 255, 0.4);\n}\n.ios {\n  /*\n  --f7-searchbar-bg-image: var(--f7-bars-bg-image);\n  --f7-searchbar-bg-color: var(--f7-bars-bg-color);\n  --f7-searchbar-bg-color-rgb: var(--f7-bars-bg-color-rgb);\n  --f7-searchbar-border-color: var(--f7-bars-border-color);\n  */\n  --f7-searchbar-height: 44px;\n  --f7-searchbar-inner-padding-left: 8px;\n  --f7-searchbar-inner-padding-right: 8px;\n  /*\n  --f7-searchbar-link-color: var(--f7-bars-link-color, var(--f7-theme-color));\n  */\n  --f7-searchbar-input-font-size: 17px;\n  --f7-searchbar-input-border-radius: 8px;\n  --f7-searchbar-input-height: 32px;\n  --f7-searchbar-input-padding-horizontal: 28px;\n  /*\n  --f7-searchbar-inline-input-padding-horizontal: var(--f7-searchbar-input-padding-horizontal);\n  --f7-searchbar-input-clear-button-color: var(--f7-input-clear-button-color);\n  */\n  --f7-searchbar-backdrop-bg-color: rgba(0, 0, 0, 0.4);\n  --f7-searchbar-shadow-image: none;\n  --f7-searchbar-in-page-content-margin: 0px;\n  --f7-searchbar-in-page-content-box-shadow: none;\n  --f7-searchbar-in-page-content-border-radius: 0;\n  --f7-searchbar-in-page-content-input-border-radius: 0;\n  --f7-searchbar-search-icon-color: rgba(0, 0, 0, 0.4);\n  --f7-searchbar-input-bg-color: #e4e4e4;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-searchbar-search-icon-color: rgba(255, 255, 255, 0.4);\n  --f7-searchbar-input-bg-color: #2a2a2a;\n}\n.md {\n  --f7-searchbar-border-color: transparent;\n  --f7-searchbar-height: 48px;\n  --f7-searchbar-inner-padding-left: 0px;\n  --f7-searchbar-inner-padding-right: 0px;\n  --f7-searchbar-link-color: #737373;\n  --f7-searchbar-search-icon-color: #737373;\n  --f7-searchbar-input-font-size: 20px;\n  --f7-searchbar-input-border-radius: 0px;\n  --f7-searchbar-input-height: 100%;\n  --f7-searchbar-input-padding-horizontal: 48px;\n  --f7-searchbar-inline-input-padding-horizontal: 24px;\n  --f7-searchbar-input-clear-button-color: #737373;\n  --f7-searchbar-backdrop-bg-color: rgba(0, 0, 0, 0.25);\n  --f7-searchbar-shadow-image: var(--f7-bars-shadow-bottom-image);\n  --f7-searchbar-in-page-content-margin: 8px;\n  --f7-searchbar-in-page-content-box-shadow: var(--f7-elevation-1);\n  --f7-searchbar-in-page-content-border-radius: 4px;\n  --f7-searchbar-in-page-content-input-border-radius: 4px;\n  --f7-searchbar-bg-color: #fff;\n  --f7-searchbar-input-bg-color: #fff;\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-searchbar-bg-color: #202020;\n  --f7-searchbar-input-bg-color: #202020;\n}\n.aurora {\n  /*\n  --f7-searchbar-bg-image: var(--f7-bars-bg-image);\n  --f7-searchbar-bg-color: var(--f7-bars-bg-color);\n  --f7-searchbar-border-color: var(--f7-bars-border-color);\n  */\n  --f7-searchbar-height: 38px;\n  --f7-searchbar-inner-padding-left: 8px;\n  --f7-searchbar-inner-padding-right: 8px;\n  /*\n  --f7-searchbar-link-color: var(--f7-bars-link-color, var(--f7-theme-color));\n  */\n  --f7-searchbar-input-font-size: 13px;\n  --f7-searchbar-input-border-radius: 4px;\n  --f7-searchbar-input-height: 24px;\n  --f7-searchbar-input-padding-horizontal: 24px;\n  /*\n  --f7-searchbar-inline-input-padding-horizontal: var(--f7-searchbar-input-padding-horizontal;\n  --f7-searchbar-input-clear-button-color: var(--f7-input-clear-button-color);\n  */\n  --f7-searchbar-backdrop-bg-color: rgba(0, 0, 0, 0.4);\n  --f7-searchbar-shadow-image: none;\n  --f7-searchbar-in-page-content-margin: 0px;\n  --f7-searchbar-in-page-content-box-shadow: none;\n  --f7-searchbar-in-page-content-border-radius: 0;\n  /*\n  --f7-searchbar-in-page-content-input-border-radius: var(--f7-searchbar-input-border-radius);\n  */\n  --f7-searchbar-search-icon-color: rgba(0, 0, 0, 0.4);\n  --f7-searchbar-input-bg-color: #fff;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-searchbar-input-bg-color: #333;\n  --f7-searchbar-search-icon-color: rgba(255, 255, 255, 0.4);\n}\n.searchbar {\n  width: 100%;\n  position: relative;\n  z-index: 200;\n  height: var(--f7-searchbar-height);\n  background-image: var(--f7-searchbar-bg-image, var(--f7-bars-bg-image));\n  background-color: var(--f7-searchbar-bg-color, var(--f7-bars-bg-color));\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-bars .searchbar {\n    background-color: rgba(var(--f7-searchbar-bg-color-rgb, var(--f7-bars-bg-color-rgb)), var(--f7-bars-translucent-opacity));\n    -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n            backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n  }\n}\n.ios .subnavbar .searchbar {\n  background-color: transparent;\n  -webkit-backdrop-filter: none;\n          backdrop-filter: none;\n}\n.ios .subnavbar .searchbar:after {\n  display: none !important;\n}\n.searchbar.no-hairline:after,\n.searchbar.no-border:after {\n  display: none !important;\n}\n.searchbar.no-shadow:before {\n  display: none !important;\n}\n.searchbar:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-searchbar-border-color, var(--f7-bars-border-color));\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.page > .searchbar:not(.searchbar-inline) {\n  z-index: 600;\n}\n.page > .searchbar:not(.searchbar-inline):before {\n  content: '';\n  position: absolute;\n  right: 0;\n  width: 100%;\n  top: 100%;\n  bottom: auto;\n  height: 8px;\n  pointer-events: none;\n  background: var(--f7-searchbar-shadow-image);\n}\n.searchbar input[type=\"text\"],\n.searchbar input[type=\"search\"] {\n  box-sizing: border-box;\n  width: 100%;\n  height: 100%;\n  display: block;\n  border: var(--f7-searchbar-input-border-width) solid var(--f7-searchbar-input-border-color);\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  font-family: inherit;\n  font-weight: normal;\n  color: var(--f7-searchbar-input-text-color);\n  font-size: var(--f7-searchbar-input-font-size);\n  background-color: var(--f7-searchbar-input-bg-color);\n  border-radius: var(--f7-searchbar-input-border-radius);\n  position: relative;\n  padding: 0;\n  padding-left: calc(var(--f7-searchbar-input-padding-horizontal) + var(--f7-searchbar-input-extra-padding-left, 0px));\n  padding-right: calc(var(--f7-searchbar-input-padding-horizontal) + var(--f7-searchbar-input-extra-padding-right, 0px));\n}\n.searchbar input[type=\"text\"]::-webkit-input-placeholder, .searchbar input[type=\"search\"]::-webkit-input-placeholder {\n  color: var(--f7-searchbar-placeholder-color);\n  opacity: 1;\n}\n.searchbar input[type=\"text\"]::placeholder,\n.searchbar input[type=\"search\"]::placeholder {\n  color: var(--f7-searchbar-placeholder-color);\n  opacity: 1;\n}\n.searchbar input::-webkit-search-cancel-button {\n  -webkit-appearance: none;\n          appearance: none;\n}\n.searchbar .searchbar-input-wrap {\n  flex-shrink: 1;\n  width: 100%;\n  height: var(--f7-searchbar-input-height);\n  position: relative;\n}\n.searchbar a {\n  color: var(--f7-searchbar-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n}\n.page > .searchbar:not(.searchbar-inline) {\n  position: absolute;\n  left: 0;\n  top: 0;\n}\n.page-content .searchbar:not(.searchbar-inline) {\n  border-radius: var(--f7-searchbar-in-page-content-border-radius);\n  margin: var(--f7-searchbar-in-page-content-margin);\n  width: auto;\n  box-shadow: var(--f7-searchbar-in-page-content-box-shadow);\n}\n.page-content .searchbar:not(.searchbar-inline) .searchbar-inner,\n.page-content .searchbar:not(.searchbar-inline) input[type=\"text\"],\n.page-content .searchbar:not(.searchbar-inline) input[type=\"search\"] {\n  border-radius: var(--f7-searchbar-in-page-content-input-border-radius, var(--f7-searchbar-input-border-radius));\n}\n.searchbar .input-clear-button {\n  color: var(--f7-searchbar-input-clear-button-color, var(--f7-input-clear-button-color));\n}\n.searchbar-expandable {\n  --f7-searchbar-expandable-size: var(--f7-searchbar-height);\n  position: absolute;\n  transition-duration: 300ms;\n  pointer-events: none;\n}\n.navbar .searchbar-expandable {\n  background: transparent;\n}\n.navbar .searchbar-expandable:after {\n  display: none !important;\n}\n.navbar .searchbar.searchbar-expandable {\n  --f7-searchbar-expandable-size: var(--f7-navbar-height);\n}\n.toolbar .searchbar.searchbar-expandable {\n  --f7-searchbar-expandable-size: var(--f7-toolbar-height);\n}\n.subnavbar .searchbar.searchbar-expandable {\n  --f7-searchbar-expandable-size: var(--f7-subnavbar-height);\n}\n.tabbar-labels .searchbar.searchbar-expandable {\n  --f7-searchbar-expandable-size: var(--f7-tabbar-labels-height);\n}\n.searchbar-inner {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  display: flex;\n  align-items: center;\n  box-sizing: border-box;\n  padding: 0 calc(var(--f7-searchbar-inner-padding-right) + var(--f7-safe-area-right)) 0 calc(var(--f7-searchbar-inner-padding-left) + var(--f7-safe-area-left));\n}\n.searchbar-disable-button {\n  cursor: pointer;\n  pointer-events: none;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  background: none;\n  border: none;\n  outline: 0;\n  padding: 0;\n  margin: 0;\n  width: auto;\n  opacity: 0;\n}\n.searchbar-icon {\n  pointer-events: none;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n.searchbar-icon:after {\n  color: var(--f7-searchbar-search-icon-color);\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n}\n.searchbar-backdrop {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 100;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 300ms;\n  transform: translate3d(0, 0, 0);\n  background: var(--f7-searchbar-backdrop-bg-color);\n}\n.searchbar-backdrop.searchbar-backdrop-in {\n  opacity: 1;\n  pointer-events: auto;\n}\n.page-content > .searchbar-backdrop {\n  position: fixed;\n}\n.searchbar-not-found {\n  display: none;\n}\n.hidden-by-searchbar,\n.list .hidden-by-searchbar,\n.list.li.hidden-by-searchbar,\n.list li.hidden-by-searchbar {\n  display: none !important;\n}\n.navbar.with-searchbar-expandable-enabled-no-transition,\n.navbar.with-searchbar-expandable-enabled-no-transition {\n  --f7-navbar-large-collapse-progress: 1;\n}\n.navbar.with-searchbar-expandable-enabled,\n.navbar.with-searchbar-expandable-enabled {\n  --f7-navbar-large-collapse-progress: 1;\n}\n.navbar.with-searchbar-expandable-enabled .navbar-bg,\n.navbar.with-searchbar-expandable-enabled .navbar-bg,\n.navbar.with-searchbar-expandable-enabled .title-large,\n.navbar.with-searchbar-expandable-enabled .title-large,\n.navbar.with-searchbar-expandable-enabled .title-large-text,\n.navbar.with-searchbar-expandable-enabled .title-large-text {\n  transition-duration: 300ms;\n}\n.navbar.with-searchbar-expandable-closing .navbar-bg,\n.navbar.with-searchbar-expandable-closing .navbar-bg,\n.navbar.with-searchbar-expandable-closing .title-large,\n.navbar.with-searchbar-expandable-closing .title-large,\n.navbar.with-searchbar-expandable-closing .title-large-text,\n.navbar.with-searchbar-expandable-closing .title-large-text {\n  transition-duration: 300ms;\n}\n.page-content.with-searchbar-expandable-enabled {\n  height: calc(100% + var(--f7-navbar-large-title-height));\n  transform: translateY(calc(-1 * var(--f7-navbar-large-title-height)));\n  transition-duration: 300ms;\n  transition-property: transform;\n}\n.page-content.with-searchbar-expandable-closing {\n  transition-duration: 300ms;\n}\n.navbar ~ .page:not(.no-navbar) > .searchbar,\n.navbars ~ .page:not(.no-navbar) > .searchbar,\n.page > .navbar ~ .searchbar {\n  top: calc(var(--f7-navbar-height) + var(--f7-safe-area-top));\n}\n.navbar ~ .page-with-navbar-large:not(.no-navbar) .searchbar,\n.navbars ~ .page-with-navbar-large:not(.no-navbar) .searchbar,\n.page-with-navbar-large .navbar ~ .searchbar,\n.page-with-navbar-large .navbar ~ * .searchbar {\n  top: calc(var(--f7-navbar-height) + var(--f7-navbar-large-title-height) + var(--f7-safe-area-top));\n  transform: translate3d(0, calc(-1 * var(--f7-navbar-large-collapse-progress) * var(--f7-navbar-large-title-height)), 0);\n}\n.navbars ~ .page-with-navbar-large:not(.no-navbar) .page-content .searchbar,\n.page-with-navbar-large .page-content .searchbar {\n  top: 0;\n  transform: none;\n}\n.searchbar ~ * {\n  --f7-page-searchbar-offset: var(--f7-searchbar-height);\n}\n.page > .toolbar-top ~ .searchbar,\n.ios .page > .toolbar-top-ios ~ .searchbar,\n.md .page > .toolbar-top-md ~ .searchbar,\n.aurora .page > .toolbar-top-aurora ~ .searchbar {\n  top: var(--f7-toolbar-height);\n}\n.page > .tabbar-labels.toolbar-top ~ .searchbar,\n.ios .page > .tabbar-labels.toolbar-top-ios ~ .searchbar,\n.md .page > .tabbar-labels.toolbar-top-md ~ .searchbar,\n.aurora .page > .tabbar-labels.toolbar-top-aurora ~ .searchbar {\n  top: var(--f7-tabbar-labels-height);\n}\n.page > .navbar ~ .toolbar-top ~ .searchbar,\n.ios .page > .navbar ~ .toolbar-top-ios ~ .searchbar,\n.md .page > .navbar ~ .toolbar-top-md ~ .searchbar,\n.aurora .page > .navbar ~ .toolbar-top-aurora ~ .searchbar {\n  top: calc(var(--f7-navbar-height) + var(--f7-toolbar-height) + var(--f7-safe-area-top));\n}\n.page > .navbar ~ .tabbar-labels.toolbar-top ~ .searchbar,\n.ios .page > .navbar ~ .tabbar-labels.toolbar-top-ios ~ .searchbar,\n.md .page > .navbar ~ .tabbar-labels.toolbar-top-md ~ .searchbar,\n.aurora .page > .navbar ~ .tabbar-labels.toolbar-top-aurora ~ .searchbar {\n  top: calc(var(--f7-navbar-height) + var(--f7-tabbar-labels-height) + var(--f7-safe-area-top));\n}\n.searchbar.searchbar-inline {\n  width: auto;\n  height: auto;\n  background-color: transparent;\n  background-image: none;\n}\n.searchbar.searchbar-inline:after,\n.searchbar.searchbar-inline:before {\n  display: none !important;\n}\n.searchbar.searchbar-inline .searchbar-input-wrap {\n  height: var(--f7-searchbar-inline-input-height, var(--f7-searchbar-input-height));\n}\n.searchbar.searchbar-inline .searchbar-inner {\n  padding: 0;\n  position: static;\n  width: auto;\n  height: auto;\n}\n.searchbar.searchbar-inline input[type=\"text\"],\n.searchbar.searchbar-inline input[type=\"search\"] {\n  font-size: var(--f7-searchbar-inline-input-font-size, var(--f7-searchbar-input-font-size));\n  padding-left: calc(var(--f7-searchbar-inline-input-padding-horizontal, var(--f7-searchbar-input-padding-horizontal)) + var(--f7-searchbar-input-extra-padding-left, 0px));\n  padding-right: calc(var(--f7-searchbar-inline-input-padding-horizontal, var(--f7-searchbar-input-padding-horizontal)) + var(--f7-searchbar-input-extra-padding-right, 0px));\n}\n.ios .searchbar input[type=\"search\"],\n.ios .searchbar input[type=\"text\"] {\n  z-index: 30;\n}\n.ios .searchbar .input-clear-button {\n  z-index: 40;\n  right: 7px;\n}\n.ios .searchbar-icon {\n  width: 13px;\n  height: 13px;\n  position: absolute;\n  top: 50%;\n  margin-top: -6px;\n  z-index: 40;\n  left: 8px;\n}\n.ios .searchbar-icon:after {\n  content: 'search_ios';\n  line-height: 13px;\n}\n.ios .searchbar-disable-button {\n  font-size: 17px;\n  flex-shrink: 0;\n  transform: translate3d(0, 0, 0);\n  transition-duration: 300ms;\n  color: var(--f7-searchbar-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n  display: none;\n}\n.ios .searchbar-disable-button.active-state {\n  transition-duration: 0ms;\n  opacity: 0.3 !important;\n}\n.ios .searchbar-enabled .searchbar-disable-button {\n  pointer-events: auto;\n  opacity: 1;\n  margin-left: 8px;\n}\n.ios .searchbar:not(.searchbar-enabled) .searchbar-disable-button {\n  transition-duration: 300ms !important;\n}\n.ios .searchbar-expandable {\n  left: 0;\n  bottom: 0;\n  opacity: 1;\n  width: 100%;\n  height: 0%;\n  transform: translate3d(0, 0, 0);\n  overflow: hidden;\n}\n.ios .searchbar-expandable .searchbar-disable-button {\n  margin-left: 8px;\n  opacity: 1;\n  display: block;\n}\n.ios .searchbar-expandable .searchbar-inner {\n  height: var(--f7-searchbar-expandable-size);\n}\n.ios .navbar.with-searchbar-expandable-enabled .navbar-bg,\n.ios .navbar.with-searchbar-expandable-closing .navbar-bg {\n  transition-property: transform, opacity;\n}\n.ios .navbar.with-searchbar-expandable-enabled .navbar-bg,\n.ios .navbar.with-searchbar-expandable-closing .navbar-bg,\n.ios .navbar.with-searchbar-expandable-enabled .left,\n.ios .navbar.with-searchbar-expandable-closing .left,\n.ios .navbar.with-searchbar-expandable-enabled .title,\n.ios .navbar.with-searchbar-expandable-closing .title,\n.ios .navbar.with-searchbar-expandable-enabled .right,\n.ios .navbar.with-searchbar-expandable-closing .right {\n  transition-duration: 300ms;\n}\n.ios .navbar.with-searchbar-expandable-enabled .left,\n.ios .navbar.with-searchbar-expandable-enabled-no-transition .left,\n.ios .navbar.with-searchbar-expandable-enabled .title,\n.ios .navbar.with-searchbar-expandable-enabled-no-transition .title,\n.ios .navbar.with-searchbar-expandable-enabled .right,\n.ios .navbar.with-searchbar-expandable-enabled-no-transition .right {\n  transform: translateY(calc(-1 * var(--f7-navbar-height)));\n  opacity: 0 !important;\n}\n.ios .searchbar-expandable.searchbar-enabled {\n  opacity: 1;\n  height: var(--f7-searchbar-expandable-size);\n  pointer-events: auto;\n}\n.md .searchbar-icon,\n.md .searchbar-disable-button {\n  position: absolute;\n  left: calc(-4px + var(--f7-safe-area-left));\n  top: 50%;\n  transition-duration: 300ms;\n}\n.md .searchbar-icon {\n  width: 24px;\n  height: 24px;\n  margin-left: 12px;\n  margin-top: -12px;\n}\n.md .searchbar-icon:after {\n  content: 'search_md';\n  line-height: 1.2;\n}\n.md .searchbar-disable-button {\n  width: 48px;\n  height: 48px;\n  transform: rotate(-90deg) scale(0.5);\n  font-size: 0 !important;\n  display: block;\n  margin-top: -24px;\n  color: var(--f7-searchbar-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n}\n.md .searchbar-disable-button:before {\n  content: '';\n  width: 152%;\n  height: 152%;\n  position: absolute;\n  left: -26%;\n  top: -26%;\n  background-image: radial-gradient(circle at center, var(--f7-link-highlight-color) 66%, rgba(255, 255, 255, 0) 66%);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 100% 100%;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 600ms;\n}\n.md .searchbar-disable-button.active-state:before {\n  opacity: 1;\n  transition-duration: 150ms;\n}\n.md .searchbar-disable-button:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  text-align: center;\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  line-height: 48px;\n  content: \"arrow_left_md\";\n}\n.md .searchbar-enabled:not(.searchbar-enabled-no-disable-button) .searchbar-disable-button {\n  transform: rotate(0deg) scale(1);\n  pointer-events: auto;\n  opacity: 1;\n}\n.md .searchbar-enabled:not(.searchbar-enabled-no-disable-button) .searchbar-icon {\n  opacity: 0;\n  transform: rotate(90deg) scale(0.5);\n}\n.md .searchbar {\n  --f7-searchbar-input-extra-padding-left: 17px;\n}\n.md .searchbar .input-clear-button {\n  width: 48px;\n  height: 48px;\n  margin-top: -24px;\n  right: 0;\n}\n.md .searchbar .input-clear-button:before {\n  content: '';\n  width: 152%;\n  height: 152%;\n  position: absolute;\n  left: -26%;\n  top: -26%;\n  background-image: radial-gradient(circle at center, var(--f7-link-highlight-color) 66%, rgba(255, 255, 255, 0) 66%);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 100% 100%;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 600ms;\n}\n.md .searchbar .input-clear-button.active-state:before {\n  opacity: 1;\n  transition-duration: 150ms;\n}\n.md .searchbar .input-clear-button:after {\n  line-height: 48px;\n  content: 'delete_md';\n  opacity: 1;\n}\n.md .searchbar .input-clear-button:before {\n  margin-left: 0;\n  margin-top: 0;\n}\n.md .page > .searchbar,\n.md .subnavbar .searchbar,\n.md .searchbar-expandable {\n  --f7-searchbar-input-extra-padding-left: calc(17px + 8px);\n}\n.md .page > .searchbar .searchbar-icon,\n.md .subnavbar .searchbar .searchbar-icon,\n.md .searchbar-expandable .searchbar-icon,\n.md .page > .searchbar .searchbar-disable-button,\n.md .subnavbar .searchbar .searchbar-disable-button,\n.md .searchbar-expandable .searchbar-disable-button {\n  left: calc(-4px + 8px + var(--f7-safe-area-left));\n}\n.md .searchbar-expandable {\n  height: var(--f7-searchbar-expandable-size);\n  opacity: 0;\n  bottom: 0;\n  border-radius: calc(var(--f7-searchbar-expandable-size));\n  width: calc(var(--f7-searchbar-expandable-size));\n  margin-top: calc(var(--f7-searchbar-expandable-size) * -1 / 2);\n  transform: translate3d(0px, 0px, 0px);\n  left: 100%;\n  margin-left: calc(var(--f7-searchbar-expandable-size) * -1);\n}\n.md .searchbar-expandable.searchbar-enabled {\n  width: 100%;\n  border-radius: 0;\n  opacity: 1;\n  pointer-events: auto;\n  margin-top: 0;\n  left: 0;\n  margin-left: 0;\n}\n.aurora .searchbar input[type=\"search\"],\n.aurora .searchbar input[type=\"text\"] {\n  z-index: 30;\n}\n.aurora .searchbar .input-clear-button {\n  z-index: 40;\n  right: 4px;\n}\n.aurora .searchbar-icon {\n  width: 13px;\n  height: 13px;\n  position: absolute;\n  top: 50%;\n  margin-top: -6px;\n  z-index: 40;\n  left: 6px;\n}\n.aurora .searchbar-icon:after {\n  content: 'search_aurora';\n  line-height: 13px;\n}\n.aurora .searchbar-disable-button {\n  font-size: 14px;\n  flex-shrink: 0;\n  transform: translate3d(0, 0, 0);\n  transition-duration: 300ms;\n  color: var(--f7-searchbar-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n  display: none;\n}\n.aurora .searchbar-disable-button.active-state {\n  transition-duration: 0ms;\n  opacity: 0.3 !important;\n}\n.aurora .searchbar-enabled .searchbar-disable-button {\n  pointer-events: auto;\n  opacity: 1;\n  margin-left: 8px;\n}\n.aurora .searchbar:not(.searchbar-enabled) .searchbar-disable-button {\n  transition-duration: 300ms !important;\n}\n.aurora .searchbar-expandable {\n  left: 0;\n  top: auto;\n  bottom: 0;\n  opacity: 0;\n  width: 100%;\n  transform: translate3d(0, 0%, 0);\n  overflow: hidden;\n}\n.aurora .searchbar-expandable .searchbar-disable-button {\n  margin-left: 8px;\n  opacity: 1;\n  display: block;\n}\n.aurora .searchbar-expandable .searchbar-inner {\n  height: var(--f7-searchbar-expandable-size);\n}\n.aurora .searchbar-expandable.searchbar-enabled {\n  opacity: 1;\n  pointer-events: auto;\n}\n/* === Messages === */\n:root {\n  --f7-message-text-header-text-color: inherit;\n  --f7-message-text-header-opacity: 0.65;\n  --f7-message-text-header-font-size: 12px;\n  --f7-message-text-footer-text-color: inherit;\n  --f7-message-text-footer-opacity: 0.65;\n  --f7-message-text-footer-font-size: 12px;\n  --f7-message-bubble-line-height: 1.2;\n  --f7-message-header-font-size: 12px;\n  --f7-message-footer-font-size: 11px;\n  --f7-message-name-font-size: 12px;\n  --f7-message-name-font-weight: inherit;\n  --f7-message-avatar-border-radius: 50%;\n  --f7-messages-title-font-weight: inherit;\n  /*\n  --f7-message-sent-bg-color: var(--f7-theme-color);\n  */\n  --f7-message-sent-text-color: #fff;\n  --f7-messages-content-bg-color: #fff;\n  --f7-message-typing-indicator-bg-color: #000;\n  --f7-message-received-bg-color: #e5e5ea;\n  --f7-message-received-text-color: #000;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-messages-title-text-color: rgba(255, 255, 255, 0.54);\n  --f7-message-header-text-color: rgba(255, 255, 255, 0.54);\n  --f7-message-name-text-color: rgba(255, 255, 255, 0.54);\n  --f7-message-footer-text-color: rgba(255, 255, 255, 0.54);\n  --f7-messages-content-bg-color: transparent;\n  --f7-message-received-bg-color: #252525;\n  --f7-message-received-text-color: #fff;\n  --f7-message-typing-indicator-bg-color: #fff;\n}\n.ios {\n  --f7-messages-title-text-color: rgba(0, 0, 0, 0.45);\n  --f7-messages-title-font-size: 11px;\n  --f7-message-header-text-color: rgba(0, 0, 0, 0.45);\n  --f7-message-footer-text-color: rgba(0, 0, 0, 0.45);\n  --f7-message-name-text-color: rgba(0, 0, 0, 0.45);\n  --f7-message-avatar-size: 29px;\n  --f7-message-margin: 10px;\n  --f7-message-bubble-min-height: 32px;\n  --f7-message-bubble-font-size: 17px;\n  --f7-message-bubble-border-radius: 16px;\n  --f7-message-bubble-padding-vertical: 6px;\n  --f7-message-bubble-padding-horizontal: 16px;\n  --f7-message-typing-indicator-opacity: 0.35;\n}\n.md {\n  --f7-messages-title-font-size: 12px;\n  --f7-message-avatar-size: 32px;\n  --f7-message-margin: 16px;\n  --f7-message-bubble-min-height: 32px;\n  --f7-message-bubble-font-size: 16px;\n  --f7-message-bubble-border-radius: 4px;\n  --f7-message-bubble-padding-vertical: 6px;\n  --f7-message-bubble-padding-horizontal: 8px;\n  --f7-message-typing-indicator-opacity: 0.6;\n  --f7-messages-title-text-color: rgba(0, 0, 0, 0.51);\n  --f7-message-header-text-color: rgba(0, 0, 0, 0.51);\n  --f7-message-footer-text-color: rgba(0, 0, 0, 0.51);\n  --f7-message-name-text-color: rgba(0, 0, 0, 0.51);\n}\n.aurora {\n  --f7-messages-title-font-size: 12px;\n  --f7-message-avatar-size: 24px;\n  --f7-message-margin: 10px;\n  --f7-message-bubble-min-height: 28px;\n  --f7-message-bubble-font-size: 13px;\n  --f7-message-bubble-line-height: 1.4;\n  --f7-message-bubble-border-radius: 14px;\n  --f7-message-bubble-padding-vertical: 5px;\n  --f7-message-bubble-padding-horizontal: 10px;\n  --f7-message-typing-indicator-opacity: 0.5;\n  --f7-messages-title-text-color: rgba(0, 0, 0, 0.51);\n  --f7-message-header-text-color: rgba(0, 0, 0, 0.51);\n  --f7-message-footer-text-color: rgba(0, 0, 0, 0.51);\n  --f7-message-name-text-color: rgba(0, 0, 0, 0.51);\n}\n.messages-content,\n.messages {\n  background: var(--f7-messages-content-bg-color);\n}\n.messages {\n  display: flex;\n  flex-direction: column;\n  min-height: 100%;\n  position: relative;\n  z-index: 1;\n}\n.messages-title,\n.message {\n  margin-top: var(--f7-message-margin);\n}\n.messages-title:last-child,\n.message:last-child {\n  margin-bottom: var(--f7-message-margin);\n}\n.messages-title {\n  text-align: center;\n  width: 100%;\n  line-height: 1;\n  color: var(--f7-messages-title-text-color);\n  font-size: var(--f7-messages-title-font-size);\n  font-weight: var(--f7-messages-title-font-weight);\n}\n.message {\n  max-width: 70%;\n  box-sizing: border-box;\n  display: flex;\n  align-items: flex-end;\n  position: relative;\n  z-index: 1;\n  transform: translate3d(0, 0, 0);\n}\n.message-avatar {\n  border-radius: var(--f7-message-avatar-border-radius);\n  position: relative;\n  background-size: cover;\n  align-self: flex-end;\n  flex-shrink: 0;\n  width: var(--f7-message-avatar-size);\n  height: var(--f7-message-avatar-size);\n}\n.message-content {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n}\n.message-header,\n.message-footer,\n.message-name {\n  line-height: 1;\n}\n.message-header {\n  color: var(--f7-message-header-text-color);\n  font-size: var(--f7-message-header-font-size);\n}\n.message-footer {\n  color: var(--f7-message-footer-text-color);\n  font-size: var(--f7-message-footer-font-size);\n  margin-bottom: -1em;\n}\n.message-name {\n  color: var(--f7-message-name-text-color);\n  font-size: var(--f7-message-name-font-size);\n  font-weight: var(--f7-message-name-font-weight);\n}\n.message-bubble {\n  box-sizing: border-box;\n  word-break: break-word;\n  display: flex;\n  flex-direction: column;\n  position: relative;\n  line-height: var(--f7-message-bubble-line-height);\n  font-size: var(--f7-message-bubble-font-size);\n  border-radius: var(--f7-message-bubble-border-radius);\n  padding: var(--f7-message-bubble-padding-vertical) var(--f7-message-bubble-padding-horizontal);\n  min-height: var(--f7-message-bubble-min-height);\n}\n.message-image img {\n  display: block;\n  max-width: 100%;\n  height: auto;\n  width: auto;\n}\n.message-text-header,\n.message-text-footer {\n  line-height: 1;\n}\n.message-text-header {\n  color: var(--f7-message-text-header-text-color);\n  opacity: var(--f7-message-text-header-opacity);\n  font-size: var(--f7-message-text-header-font-size);\n}\n.message-text-footer {\n  color: var(--f7-message-text-footer-text-color);\n  opacity: var(--f7-message-text-footer-opacity);\n  font-size: var(--f7-message-text-footer-font-size);\n}\n.message-text {\n  text-align: left;\n}\n.message-sent {\n  text-align: right;\n  flex-direction: row-reverse;\n  align-self: flex-end;\n}\n.message-sent .message-bubble {\n  color: var(--f7-message-sent-text-color);\n  background: var(--f7-message-sent-bg-color, var(--f7-theme-color));\n}\n.message-sent .message-content {\n  align-items: flex-end;\n}\n.message-sent.message-tail .message-bubble {\n  border-radius: var(--f7-message-bubble-border-radius) var(--f7-message-bubble-border-radius) 0 var(--f7-message-bubble-border-radius);\n}\n.message-received {\n  flex-direction: row;\n}\n.message-received .message-bubble {\n  color: var(--f7-message-received-text-color);\n  background: var(--f7-message-received-bg-color);\n}\n.message-received .message-content {\n  align-items: flex-start;\n}\n.message-received.message-tail .message-bubble {\n  border-radius: var(--f7-message-bubble-border-radius) var(--f7-message-bubble-border-radius) var(--f7-message-bubble-border-radius) 0;\n}\n.message:not(.message-last) .message-avatar {\n  opacity: 0;\n}\n.message:not(.message-first) .message-name {\n  display: none;\n}\n.message.message-same-name .message-name {\n  display: none;\n}\n.message.message-same-header .message-header {\n  display: none;\n}\n.message.message-same-footer .message-footer {\n  display: none;\n}\n.message-appear-from-bottom {\n  animation: message-appear-from-bottom 300ms;\n}\n.message-appear-from-top {\n  animation: message-appear-from-top 300ms;\n}\n.message-typing-indicator {\n  display: inline-block;\n  font-size: 0;\n  vertical-align: middle;\n}\n.message-typing-indicator > div {\n  display: inline-block;\n  position: relative;\n  background: var(--f7-message-typing-indicator-bg-color);\n  opacity: var(--f7-message-typing-indicator-opacity);\n  vertical-align: middle;\n  border-radius: 50%;\n}\n@keyframes message-appear-from-bottom {\n  from {\n    transform: translate3d(0, 100%, 0);\n  }\n  to {\n    transform: translate3d(0, 0, 0);\n  }\n}\n@keyframes message-appear-from-top {\n  from {\n    transform: translate3d(0, -100%, 0);\n  }\n  to {\n    transform: translate3d(0, 0, 0);\n  }\n}\n.ios .messages-title b,\n.ios .message-header b,\n.ios .message-footer b,\n.ios .message-name b {\n  font-weight: 600;\n}\n.ios .message-header,\n.ios .message-name {\n  margin-bottom: 3px;\n}\n.ios .message-footer {\n  margin-top: 3px;\n}\n.ios .message-bubble {\n  min-width: 48px;\n}\n.ios .message-image {\n  margin: var(--f7-message-bubble-padding-vertical) calc(-1 * var(--f7-message-bubble-padding-horizontal));\n}\n.ios .message-image:first-child {\n  margin-top: calc(-1 * var(--f7-message-bubble-padding-vertical));\n}\n.ios .message-image:first-child img {\n  border-top-left-radius: var(--f7-message-bubble-border-radius);\n  border-top-right-radius: var(--f7-message-bubble-border-radius);\n}\n.ios .message-image:last-child {\n  margin-bottom: calc(-1 * var(--f7-message-bubble-padding-vertical));\n}\n.ios .message-image:last-child img {\n  border-bottom-left-radius: var(--f7-message-bubble-border-radius);\n  border-bottom-right-radius: var(--f7-message-bubble-border-radius);\n}\n.ios .message-text-header {\n  margin-bottom: 3px;\n}\n.ios .message-text-footer {\n  margin-top: 3px;\n}\n.ios .message-received {\n  margin-left: calc(10px + var(--f7-safe-area-left));\n}\n.ios .message-received .message-header,\n.ios .message-received .message-footer,\n.ios .message-received .message-name {\n  margin-left: var(--f7-message-bubble-padding-horizontal);\n}\n.ios .message-received .message-bubble {\n  padding-left: calc(var(--f7-message-bubble-padding-horizontal) + 6px);\n  -webkit-mask-box-image: url(\"data:image/svg+xml;charset=utf-8,<svg height='35' viewBox='0 0 96 70' width='48' xmlns='http://www.w3.org/2000/svg'><path d='m96 35c1 7-5 37-42 35-37 2-43-28-42-35-1-7 5-37 42-35 37-2 43 28 42 35z'/></svg>\") 50% 42% 46% 56%;\n}\n.ios .message-received .message-image {\n  margin-left: calc(-1 * (var(--f7-message-bubble-padding-horizontal) + 6px));\n}\n.ios .message-received.message-tail:not(.message-typing) .message-bubble {\n  -webkit-mask-box-image: url(\"data:image/svg+xml;charset=utf-8,<svg height='35' viewBox='0 0 96 70' width='48' xmlns='http://www.w3.org/2000/svg'><path d='m96 35c1 7-5 37-42 35-37 2-43-28-42-35-1-7 5-37 42-35 37-2 43 28 42 35z'/><path d='m0 70c6-2 12-10 12-19v-16l14 27s-8 8-26 8z'/></svg>\") 50% 42% 46% 56%;\n}\n.ios .message-received.message-tail:not(.message-typing) .message-bubble .message-image:last-child img {\n  border-bottom-left-radius: 0px;\n}\n.ios .message-sent {\n  margin-right: calc(10px + var(--f7-safe-area-right));\n}\n.ios .message-sent .message-header,\n.ios .message-sent .message-footer,\n.ios .message-sent .message-name {\n  margin-right: var(--f7-message-bubble-padding-horizontal);\n}\n.ios .message-sent .message-bubble {\n  padding-right: calc(var(--f7-message-bubble-padding-horizontal) + 6px);\n  -webkit-mask-box-image: url(\"data:image/svg+xml;charset=utf-8,<svg height='35' viewBox='0 0 96 70' width='48' xmlns='http://www.w3.org/2000/svg'><path d='m84 35c1 7-5 37-42 35-37 2-43-28-42-35-1-7 5-37 42-35 37-2 43 28 42 35z'/></svg>\") 50% 56% 46% 42%;\n}\n.ios .message-sent .message-image {\n  margin-right: calc(-1 * (var(--f7-message-bubble-padding-horizontal) + 6px));\n}\n.ios .message-sent.message-tail .message-bubble {\n  -webkit-mask-box-image: url(\"data:image/svg+xml;charset=utf-8,<svg height='35' viewBox='0 0 96 70' width='48' xmlns='http://www.w3.org/2000/svg'><path d='m84 35c1 7-5 37-42 35-37 2-43-28-42-35-1-7 5-37 42-35 37-2 43 28 42 35z'/><path d='m96 70c-6-2-12-10-12-19v-16l-14 27s8 8 26 8z'/></svg>\") 50% 56% 46% 42%;\n}\n.ios .message-sent.message-tail .message-bubble .message-image:last-child img {\n  border-bottom-right-radius: 0px;\n}\n.ios .message + .message:not(.message-first) {\n  margin-top: 1px;\n}\n.ios .message-received.message-typing .message-content:after,\n.ios .message-received.message-typing .message-content:before {\n  content: '';\n  position: absolute;\n  background: var(--f7-message-received-bg-color);\n  border-radius: 50%;\n}\n.ios .message-received.message-typing .message-content:after {\n  width: 11px;\n  height: 11px;\n  left: 4px;\n  bottom: 0px;\n}\n.ios .message-received.message-typing .message-content:before {\n  width: 6px;\n  height: 6px;\n  left: -1px;\n  bottom: -4px;\n}\n.ios .message-typing-indicator > div {\n  width: 9px;\n  height: 9px;\n}\n.ios .message-typing-indicator > div + div {\n  margin-left: 4px;\n}\n.ios .message-typing-indicator > div:nth-child(1) {\n  animation: ios-message-typing-indicator 900ms infinite;\n}\n.ios .message-typing-indicator > div:nth-child(2) {\n  animation: ios-message-typing-indicator 900ms 150ms infinite;\n}\n.ios .message-typing-indicator > div:nth-child(3) {\n  animation: ios-message-typing-indicator 900ms 300ms infinite;\n}\n@keyframes ios-message-typing-indicator {\n  0% {\n    opacity: 0.35;\n  }\n  25% {\n    opacity: 0.2;\n  }\n  50% {\n    opacity: 0.2;\n  }\n}\n.md .messages-title b,\n.md .message-header b,\n.md .message-footer b,\n.md .message-name b {\n  font-weight: 500;\n}\n.md .message-header,\n.md .message-name {\n  margin-bottom: 2px;\n}\n.md .message-footer {\n  margin-top: 2px;\n}\n.md .message-text-header {\n  margin-bottom: 4px;\n}\n.md .message-text-footer {\n  margin-top: 4px;\n}\n.md .message-received.message-tail .message-bubble:before,\n.md .message-sent.message-tail .message-bubble:before {\n  position: absolute;\n  content: '';\n  bottom: 0;\n  width: 0;\n  height: 0;\n}\n.md .message-received {\n  margin-left: calc(8px + var(--f7-safe-area-left));\n}\n.md .message-received .message-avatar + .message-content {\n  margin-left: var(--f7-message-bubble-padding-horizontal);\n}\n.md .message-received.message-tail .message-bubble:before {\n  border-left: 8px solid transparent;\n  border-right: 0 solid transparent;\n  border-bottom: 8px solid var(--f7-message-received-bg-color);\n  right: 100%;\n}\n.md .message-sent {\n  margin-right: calc(8px + var(--f7-safe-area-right));\n}\n.md .message-sent .message-avatar + .message-content {\n  margin-right: var(--f7-message-bubble-padding-horizontal);\n}\n.md .message-sent.message-tail .message-bubble:before {\n  border-left: 0 solid transparent;\n  border-right: 8px solid transparent;\n  border-bottom: 8px solid var(--f7-message-sent-bg-color, var(--f7-theme-color));\n  left: 100%;\n}\n.md .message + .message:not(.message-first) {\n  margin-top: 8px;\n}\n.md .message-typing-indicator > div {\n  width: 6px;\n  height: 6px;\n}\n.md .message-typing-indicator > div + div {\n  margin-left: 6px;\n}\n.md .message-typing-indicator > div:nth-child(1) {\n  animation: md-message-typing-indicator 900ms infinite;\n}\n.md .message-typing-indicator > div:nth-child(2) {\n  animation: md-message-typing-indicator 900ms 150ms infinite;\n}\n.md .message-typing-indicator > div:nth-child(3) {\n  animation: md-message-typing-indicator 900ms 300ms infinite;\n}\n@keyframes md-message-typing-indicator {\n  0% {\n    transform: translateY(0%);\n  }\n  25% {\n    transform: translateY(-5px);\n  }\n  50% {\n    transform: translateY(0%);\n  }\n}\n.aurora .messages-title b,\n.aurora .message-header b,\n.aurora .message-footer b,\n.aurora .message-name b {\n  font-weight: 500;\n}\n.aurora .message-header,\n.aurora .message-name {\n  margin-bottom: 2px;\n}\n.aurora .message-footer {\n  margin-top: 2px;\n}\n.aurora .message-text-header {\n  margin-bottom: 2px;\n}\n.aurora .message-text-footer {\n  margin-top: 2px;\n}\n.aurora .message-received.message-tail .message-bubble:before,\n.aurora .message-sent.message-tail .message-bubble:before {\n  position: absolute;\n  content: '';\n  bottom: 0;\n  width: 0;\n  height: 0;\n}\n.aurora .message-image {\n  margin: var(--f7-message-bubble-padding-vertical) calc(-1 * var(--f7-message-bubble-padding-horizontal) + 4px);\n}\n.aurora .message-image:first-child {\n  margin-top: calc(-1 * var(--f7-message-bubble-padding-vertical) + 4px);\n}\n.aurora .message-image:first-child img {\n  border-top-left-radius: var(--f7-message-bubble-border-radius);\n  border-top-right-radius: var(--f7-message-bubble-border-radius);\n}\n.aurora .message-image:last-child {\n  margin-bottom: calc(-1 * var(--f7-message-bubble-padding-vertical) + 4px);\n}\n.aurora .message-image:last-child img {\n  border-bottom-left-radius: var(--f7-message-bubble-border-radius);\n  border-bottom-right-radius: var(--f7-message-bubble-border-radius);\n}\n.aurora .message-received {\n  margin-left: calc(16px + var(--f7-safe-area-left));\n}\n.aurora .message-received .message-avatar + .message-content {\n  margin-left: 5px;\n}\n.aurora .message-received .message-header,\n.aurora .message-received .message-footer,\n.aurora .message-received .message-name {\n  margin-left: var(--f7-message-bubble-padding-horizontal);\n}\n.aurora .message-received.message-tail .message-bubble:before {\n  border-left: 6px solid transparent;\n  border-right: 0 solid transparent;\n  border-bottom: 6px solid var(--f7-message-received-bg-color);\n  right: 100%;\n  transform: translate(2px, 0px) rotate(-15deg);\n  transform-origin: right bottom;\n}\n.aurora .message-sent {\n  margin-right: calc(16px + var(--f7-safe-area-right));\n}\n.aurora .message-sent .message-avatar + .message-content {\n  margin-right: 5px;\n}\n.aurora .message-sent .message-header,\n.aurora .message-sent .message-footer,\n.aurora .message-sent .message-name {\n  margin-right: var(--f7-message-bubble-padding-horizontal);\n}\n.aurora .message-sent.message-tail .message-bubble:before {\n  border-left: 0 solid transparent;\n  border-right: 6px solid transparent;\n  border-bottom: 6px solid var(--f7-message-sent-bg-color, var(--f7-theme-color));\n  left: 100%;\n  transform: translate(-2px, 0px) rotate(15deg);\n  transform-origin: left bottom;\n}\n.aurora .message + .message:not(.message-first) {\n  margin-top: 5px;\n}\n.aurora .message-typing-indicator > div {\n  width: 6px;\n  height: 6px;\n}\n.aurora .message-typing-indicator > div + div {\n  margin-left: 4px;\n}\n.aurora .message-typing-indicator > div:nth-child(1) {\n  animation: aurora-message-typing-indicator 900ms infinite;\n}\n.aurora .message-typing-indicator > div:nth-child(2) {\n  animation: aurora-message-typing-indicator 900ms 150ms infinite;\n}\n.aurora .message-typing-indicator > div:nth-child(3) {\n  animation: aurora-message-typing-indicator 900ms 300ms infinite;\n}\n@keyframes aurora-message-typing-indicator {\n  0% {\n    transform: translateY(0%);\n  }\n  50% {\n    transform: translateY(-5px);\n  }\n  100% {\n    transform: translateY(0%);\n  }\n}\n/* === Messagebar === */\n:root {\n  --f7-messagebar-shadow-image: none;\n  --f7-messagebar-textarea-bg-color: transparent;\n  --f7-messagebar-attachments-height: 155px;\n  --f7-messagebar-attachment-height: 155px;\n  --f7-messagebar-attachment-landscape-height: 120px;\n  --f7-messagebar-sheet-height: 252px;\n  --f7-messagebar-sheet-landscape-height: 192px;\n  /*\n  --f7-messagebar-inner-padding-left: var(--f7-toolbar-inner-padding-left);\n  --f7-messagebar-inner-padding-right: var(--f7-toolbar-inner-padding-right);\n  */\n  --f7-messagebar-bg-color: #fff;\n  --f7-messagebar-bg-color-rgb: 255, 255, 255;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-messagebar-bg-color: var(--f7-bars-bg-color);\n  --f7-messagebar-bg-color-rgb: var(--f7-bars-bg-color-rgb);\n}\n.ios {\n  --f7-messagebar-height: 44px;\n  --f7-messagebar-font-size: 17px;\n  /*\n  --f7-messagebar-link-color: var(--f7-theme-color);\n  */\n  --f7-messagebar-border-color: transparent;\n  --f7-messagebar-textarea-border-radius: 17px;\n  --f7-messagebar-textarea-padding: 6px 16px;\n  --f7-messagebar-textarea-height: 34px;\n  --f7-messagebar-textarea-font-size: 17px;\n  --f7-messagebar-textarea-line-height: 20px;\n  --f7-messagebar-sheet-bg-color: #d1d5da;\n  --f7-messagebar-attachment-border-radius: 12px;\n  --f7-messagebar-textarea-text-color: #000;\n  --f7-messagebar-textarea-border: 1px solid #c8c8cd;\n  --f7-messagebar-attachments-border-color: #c8c8cd;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-messagebar-textarea-text-color: #fff;\n  --f7-messagebar-textarea-border: 1px solid var(--f7-bars-border-color);\n  --f7-messagebar-attachments-border-color: var(--f7-bars-border-color);\n}\n.md {\n  --f7-messagebar-height: 48px;\n  --f7-messagebar-font-size: 16px;\n  --f7-messagebar-textarea-border-radius: 0px;\n  --f7-messagebar-textarea-padding: 5px 8px;\n  --f7-messagebar-textarea-height: 32px;\n  --f7-messagebar-textarea-font-size: 16px;\n  --f7-messagebar-textarea-line-height: 22px;\n  --f7-messagebar-textarea-border: 1px solid transparent;\n  --f7-messagebar-sheet-bg-color: #fff;\n  --f7-messagebar-attachment-border-radius: 4px;\n  --f7-messagebar-link-color: #333;\n  --f7-messagebar-border-color: #d1d1d1;\n  --f7-messagebar-textarea-text-color: #333;\n  --f7-messagebar-attachments-border-color: #ddd;\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-messagebar-border-color: transparent;\n  --f7-messagebar-link-color: rgba(255, 255, 255, 0.87);\n  --f7-messagebar-textarea-text-color: rgba(255, 255, 255, 0.87);\n  --f7-messagebar-attachments-border-color: rgba(255, 255, 255, 0.2);\n}\n.aurora {\n  --f7-messagebar-height: 38px;\n  --f7-messagebar-font-size: 14px;\n  /*\n  --f7-messagebar-link-color: var(--f7-theme-color);\n  */\n  --f7-messagebar-border-color: transparent;\n  --f7-messagebar-textarea-border-radius: 12px;\n  --f7-messagebar-textarea-padding: 3px 10px;\n  --f7-messagebar-textarea-height: 24px;\n  --f7-messagebar-textarea-font-size: 13px;\n  --f7-messagebar-textarea-line-height: 16px;\n  --f7-messagebar-sheet-bg-color: #fff;\n  --f7-messagebar-attachment-border-radius: 12px;\n  --f7-messagebar-textarea-text-color: #000;\n  --f7-messagebar-textarea-border: 1px solid #c8c8cd;\n  --f7-messagebar-attachments-border-color: #c8c8cd;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-messagebar-textarea-text-color: #fff;\n  --f7-messagebar-textarea-border: 1px solid var(--f7-bars-border-color);\n  --f7-messagebar-attachments-border-color: var(--f7-bars-border-color);\n}\n.messagebar {\n  transform: translate3d(0, 0, 0);\n  background: var(--f7-messagebar-bg-color);\n  height: auto;\n  min-height: var(--f7-messagebar-height);\n  font-size: var(--f7-messagebar-font-size);\n  padding-bottom: var(--f7-safe-area-bottom);\n  bottom: 0;\n}\n.messagebar:before {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-messagebar-border-color);\n  display: block;\n  z-index: 15;\n  top: 0;\n  right: auto;\n  bottom: auto;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 0%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\n.messagebar:after {\n  content: '';\n  position: absolute;\n  right: 0;\n  width: 100%;\n  bottom: 100%;\n  height: 8px;\n  top: auto;\n  pointer-events: none;\n  background: var(--f7-messagebar-shadow-image);\n  transform: translate3d(0, 0, 0);\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-bars .messagebar {\n    background-color: rgba(var(--f7-messagebar-bg-color-rgb), var(--f7-bars-translucent-opacity));\n    -webkit-backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n            backdrop-filter: saturate(180%) blur(var(--f7-bars-translucent-blur));\n  }\n}\n.messagebar.no-hairline:before,\n.messagebar.no-border:before {\n  display: none !important;\n}\n.messagebar.no-shadow:after,\n.messagebar.toolbar-hidden:after {\n  display: none !important;\n}\n.messagebar .toolbar-inner {\n  top: auto;\n  position: relative;\n  height: auto;\n  bottom: auto;\n  padding-left: calc(var(--f7-messagebar-inner-padding-left, var(--f7-toolbar-inner-padding-left)) + var(--f7-safe-area-left));\n  padding-right: calc(var(--f7-messagebar-inner-padding-right, var(--f7-toolbar-inner-padding-right)) + var(--f7-safe-area-right));\n}\n.messagebar.messagebar-sheet-visible > .toolbar-inner {\n  bottom: 0;\n}\n.messagebar .messagebar-area {\n  width: 100%;\n  flex-shrink: 1;\n  overflow: hidden;\n  position: relative;\n}\n.messagebar textarea {\n  width: 100%;\n  flex-shrink: 1;\n  background-color: var(--f7-messagebar-textarea-bg-color);\n  border-radius: var(--f7-messagebar-textarea-border-radius);\n  padding: var(--f7-messagebar-textarea-padding);\n  height: var(--f7-messagebar-textarea-height);\n  color: var(--f7-messagebar-textarea-text-color);\n  font-size: var(--f7-messagebar-textarea-font-size);\n  line-height: var(--f7-messagebar-textarea-line-height);\n  border: var(--f7-messagebar-textarea-border);\n}\n.messagebar a.link {\n  align-self: flex-end;\n  flex-shrink: 0;\n  color: var(--f7-messagebar-link-color, var(--f7-theme-color));\n}\n.messagebar-attachments {\n  width: 100%;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  font-size: 0;\n  white-space: nowrap;\n  box-sizing: border-box;\n  position: relative;\n}\n.messagebar:not(.messagebar-attachments-visible) .messagebar-attachments {\n  display: none;\n}\n.messagebar-attachment {\n  background-size: cover;\n  background-position: center;\n  background-repeat: no-repeat;\n  display: inline-block;\n  vertical-align: middle;\n  white-space: normal;\n  height: var(--f7-messagebar-attachment-height);\n  position: relative;\n  border-radius: var(--f7-messagebar-attachment-border-radius);\n}\n@media (orientation: landscape) {\n  .messagebar-attachment {\n    height: var(--f7-messagebar-attachment-landscape-height);\n  }\n}\n.messagebar-attachment img {\n  display: block;\n  width: auto;\n  height: 100%;\n  border-radius: var(--f7-messagebar-attachment-border-radius);\n}\n.messagebar-attachment + .messagebar-attachment {\n  margin-left: 8px;\n}\n.messagebar-sheet {\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  display: flex;\n  flex-wrap: wrap;\n  flex-direction: column;\n  align-content: flex-start;\n  height: var(--f7-messagebar-sheet-height);\n  background-color: var(--f7-messagebar-sheet-bg-color);\n  padding-left: var(--f7-safe-area-left);\n  padding-right: var(--f7-safe-area-right);\n}\n@media (orientation: landscape) {\n  .messagebar-sheet {\n    height: var(--f7-messagebar-sheet-landscape-height);\n  }\n}\n.messagebar-sheet-image,\n.messagebar-sheet-item {\n  box-sizing: border-box;\n  flex-shrink: 0;\n  margin-top: 1px;\n  position: relative;\n  overflow: hidden;\n  height: calc((var(--f7-messagebar-sheet-height) - 2px) / 2);\n  width: calc((var(--f7-messagebar-sheet-height) - 2px) / 2);\n  margin-left: 1px;\n}\n@media (orientation: landscape) {\n  .messagebar-sheet-image,\n  .messagebar-sheet-item {\n    width: calc((var(--f7-messagebar-sheet-landscape-height) - 2px) / 2);\n    height: calc((var(--f7-messagebar-sheet-landscape-height) - 2px) / 2);\n  }\n}\n.messagebar-sheet-image .icon-checkbox,\n.messagebar-sheet-item .icon-checkbox,\n.messagebar-sheet-image .icon-radio,\n.messagebar-sheet-item .icon-radio {\n  position: absolute;\n  right: 8px;\n  bottom: 8px;\n}\n.messagebar-sheet-image {\n  background-size: cover;\n  background-position: center;\n  background-repeat: no-repeat;\n}\n.messagebar-attachment-delete {\n  display: block;\n  position: absolute;\n  border-radius: 50%;\n  box-sizing: border-box;\n  cursor: pointer;\n  box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.2);\n}\n.messagebar-attachment-delete:after,\n.messagebar-attachment-delete:before {\n  position: absolute;\n  content: '';\n  left: 50%;\n  top: 50%;\n}\n.messagebar-attachment-delete:after {\n  transform: rotate(45deg);\n}\n.messagebar-attachment-delete:before {\n  transform: rotate(-45deg);\n}\n.messagebar:not(.messagebar-sheet-visible) .messagebar-sheet {\n  display: none;\n}\n.messagebar ~ * {\n  --f7-page-toolbar-bottom-offset: var(--f7-messagebar-height);\n}\n.ios .messagebar a.link.icon-only:first-child {\n  margin-left: -8px;\n}\n.ios .messagebar a.link.icon-only:last-child {\n  margin-right: -8px;\n}\n.ios .messagebar a.link:not(.icon-only) + .messagebar-area {\n  margin-left: 8px;\n}\n.ios .messagebar .messagebar-area + a.link:not(.icon-only) {\n  margin-left: 8px;\n}\n.ios .messagebar-area {\n  margin-top: 5px;\n  margin-bottom: 5px;\n}\n.ios .messagebar-attachments {\n  padding: 5px;\n  border-radius: var(--f7-messagebar-textarea-border-radius) var(--f7-messagebar-textarea-border-radius) 0 0;\n  border: 1px solid var(--f7-messagebar-attachments-border-color);\n  border-bottom: none;\n}\n.ios .messagebar-attachments-visible .messagebar-attachments + textarea {\n  border-radius: 0 0 var(--f7-messagebar-textarea-border-radius) var(--f7-messagebar-textarea-border-radius);\n}\n.ios .messagebar-attachment {\n  font-size: 14px;\n}\n.ios .messagebar-attachment-delete {\n  right: 5px;\n  top: 5px;\n  width: 20px;\n  height: 20px;\n  background: #7d7e80;\n  border: 2px solid #fff;\n}\n.ios .messagebar-attachment-delete:after,\n.ios .messagebar-attachment-delete:before {\n  width: 10px;\n  height: 2px;\n  background: #fff;\n  margin-left: -5px;\n  margin-top: -1px;\n}\n.md .messagebar-attachments {\n  padding: 8px;\n  border-bottom: 1px solid var(--f7-messagebar-attachments-border-color);\n}\n.md .messagebar-area {\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\n.md .messagebar-sheet-image .icon-checkbox,\n.md .messagebar-sheet-item .icon-checkbox {\n  border-color: #fff;\n  background: rgba(255, 255, 255, 0.25);\n  box-shadow: 0px 0px 10px rgba(0, 0, 0, 0.5);\n}\n.md .messagebar-attachment-delete {\n  right: 8px;\n  top: 8px;\n  width: 24px;\n  height: 24px;\n  background-color: var(--f7-theme-color);\n  border-radius: 4px;\n}\n.md .messagebar-attachment-delete:after,\n.md .messagebar-attachment-delete:before {\n  width: 14px;\n  height: 2px;\n  background: #fff;\n  margin-left: -7px;\n  margin-top: -1px;\n}\n.aurora .messagebar a.link + .messagebar-area {\n  margin-left: 5px;\n}\n.aurora .messagebar .messagebar-area + a.link {\n  margin-left: 5px;\n}\n.aurora .messagebar-area {\n  margin-top: 5px;\n  margin-bottom: 5px;\n}\n.aurora .messagebar-sheet-image .icon-checkbox,\n.aurora .messagebar-sheet-item .icon-checkbox {\n  background: rgba(255, 255, 255, 0.25);\n}\n.aurora .messagebar-attachments {\n  padding: 5px;\n  border-radius: var(--f7-messagebar-textarea-border-radius) var(--f7-messagebar-textarea-border-radius) 0 0;\n  border: 1px solid var(--f7-messagebar-attachments-border-color);\n  border-bottom: none;\n}\n.aurora .messagebar-attachments-visible .messagebar-attachments + textarea {\n  border-radius: 0 0 var(--f7-messagebar-textarea-border-radius) var(--f7-messagebar-textarea-border-radius);\n}\n.aurora .messagebar-attachment {\n  font-size: 14px;\n}\n.aurora .messagebar-attachment-delete {\n  right: 5px;\n  top: 5px;\n  width: 14px;\n  height: 14px;\n  background: #808080;\n}\n.aurora .messagebar-attachment-delete:after,\n.aurora .messagebar-attachment-delete:before {\n  width: 8px;\n  height: 1px;\n  background: #fff;\n  margin-left: -4px;\n  margin-top: -1px;\n}\n/* === Swiper === */\n@font-face {\n  font-family: 'swiper-icons';\n  src: url(\"data:application/font-woff;charset=utf-8;base64, d09GRgABAAAAAAZgABAAAAAADAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABGRlRNAAAGRAAAABoAAAAci6qHkUdERUYAAAWgAAAAIwAAACQAYABXR1BPUwAABhQAAAAuAAAANuAY7+xHU1VCAAAFxAAAAFAAAABm2fPczU9TLzIAAAHcAAAASgAAAGBP9V5RY21hcAAAAkQAAACIAAABYt6F0cBjdnQgAAACzAAAAAQAAAAEABEBRGdhc3AAAAWYAAAACAAAAAj//wADZ2x5ZgAAAywAAADMAAAD2MHtryVoZWFkAAABbAAAADAAAAA2E2+eoWhoZWEAAAGcAAAAHwAAACQC9gDzaG10eAAAAigAAAAZAAAArgJkABFsb2NhAAAC0AAAAFoAAABaFQAUGG1heHAAAAG8AAAAHwAAACAAcABAbmFtZQAAA/gAAAE5AAACXvFdBwlwb3N0AAAFNAAAAGIAAACE5s74hXjaY2BkYGAAYpf5Hu/j+W2+MnAzMYDAzaX6QjD6/4//Bxj5GA8AuRwMYGkAPywL13jaY2BkYGA88P8Agx4j+/8fQDYfA1AEBWgDAIB2BOoAeNpjYGRgYNBh4GdgYgABEMnIABJzYNADCQAACWgAsQB42mNgYfzCOIGBlYGB0YcxjYGBwR1Kf2WQZGhhYGBiYGVmgAFGBiQQkOaawtDAoMBQxXjg/wEGPcYDDA4wNUA2CCgwsAAAO4EL6gAAeNpj2M0gyAACqxgGNWBkZ2D4/wMA+xkDdgAAAHjaY2BgYGaAYBkGRgYQiAHyGMF8FgYHIM3DwMHABGQrMOgyWDLEM1T9/w8UBfEMgLzE////P/5//f/V/xv+r4eaAAeMbAxwIUYmIMHEgKYAYjUcsDAwsLKxc3BycfPw8jEQA/gZBASFhEVExcQlJKWkZWTl5BUUlZRVVNXUNTQZBgMAAMR+E+gAEQFEAAAAKgAqACoANAA+AEgAUgBcAGYAcAB6AIQAjgCYAKIArAC2AMAAygDUAN4A6ADyAPwBBgEQARoBJAEuATgBQgFMAVYBYAFqAXQBfgGIAZIBnAGmAbIBzgHsAAB42u2NMQ6CUAyGW568x9AneYYgm4MJbhKFaExIOAVX8ApewSt4Bic4AfeAid3VOBixDxfPYEza5O+Xfi04YADggiUIULCuEJK8VhO4bSvpdnktHI5QCYtdi2sl8ZnXaHlqUrNKzdKcT8cjlq+rwZSvIVczNiezsfnP/uznmfPFBNODM2K7MTQ45YEAZqGP81AmGGcF3iPqOop0r1SPTaTbVkfUe4HXj97wYE+yNwWYxwWu4v1ugWHgo3S1XdZEVqWM7ET0cfnLGxWfkgR42o2PvWrDMBSFj/IHLaF0zKjRgdiVMwScNRAoWUoH78Y2icB/yIY09An6AH2Bdu/UB+yxopYshQiEvnvu0dURgDt8QeC8PDw7Fpji3fEA4z/PEJ6YOB5hKh4dj3EvXhxPqH/SKUY3rJ7srZ4FZnh1PMAtPhwP6fl2PMJMPDgeQ4rY8YT6Gzao0eAEA409DuggmTnFnOcSCiEiLMgxCiTI6Cq5DZUd3Qmp10vO0LaLTd2cjN4fOumlc7lUYbSQcZFkutRG7g6JKZKy0RmdLY680CDnEJ+UMkpFFe1RN7nxdVpXrC4aTtnaurOnYercZg2YVmLN/d/gczfEimrE/fs/bOuq29Zmn8tloORaXgZgGa78yO9/cnXm2BpaGvq25Dv9S4E9+5SIc9PqupJKhYFSSl47+Qcr1mYNAAAAeNptw0cKwkAAAMDZJA8Q7OUJvkLsPfZ6zFVERPy8qHh2YER+3i/BP83vIBLLySsoKimrqKqpa2hp6+jq6RsYGhmbmJqZSy0sraxtbO3sHRydnEMU4uR6yx7JJXveP7WrDycAAAAAAAH//wACeNpjYGRgYOABYhkgZgJCZgZNBkYGLQZtIJsFLMYAAAw3ALgAeNolizEKgDAQBCchRbC2sFER0YD6qVQiBCv/H9ezGI6Z5XBAw8CBK/m5iQQVauVbXLnOrMZv2oLdKFa8Pjuru2hJzGabmOSLzNMzvutpB3N42mNgZGBg4GKQYzBhYMxJLMlj4GBgAYow/P/PAJJhLM6sSoWKfWCAAwDAjgbRAAB42mNgYGBkAIIbCZo5IPrmUn0hGA0AO8EFTQAA\") format(\"woff\");\n  font-weight: 400;\n  font-style: normal;\n}\n:root {\n  --swiper-theme-color: #007aff;\n}\n.swiper-container {\n  margin-left: auto;\n  margin-right: auto;\n  position: relative;\n  overflow: hidden;\n  list-style: none;\n  padding: 0;\n  /* Fix of Webkit flickering */\n  z-index: 1;\n}\n.swiper-container-vertical > .swiper-wrapper {\n  flex-direction: column;\n}\n.swiper-wrapper {\n  position: relative;\n  width: 100%;\n  height: 100%;\n  z-index: 1;\n  display: flex;\n  transition-property: transform;\n  box-sizing: content-box;\n}\n.swiper-container-android .swiper-slide,\n.swiper-wrapper {\n  transform: translate3d(0px, 0, 0);\n}\n.swiper-container-multirow > .swiper-wrapper {\n  flex-wrap: wrap;\n}\n.swiper-container-multirow-column > .swiper-wrapper {\n  flex-wrap: wrap;\n  flex-direction: column;\n}\n.swiper-container-free-mode > .swiper-wrapper {\n  transition-timing-function: ease-out;\n  margin: 0 auto;\n}\n.swiper-slide {\n  flex-shrink: 0;\n  width: 100%;\n  height: 100%;\n  position: relative;\n  transition-property: transform;\n}\n.swiper-slide-invisible-blank {\n  visibility: hidden;\n}\n/* Auto Height */\n.swiper-container-autoheight,\n.swiper-container-autoheight .swiper-slide {\n  height: auto;\n}\n.swiper-container-autoheight .swiper-wrapper {\n  align-items: flex-start;\n  transition-property: transform, height;\n}\n/* 3D Effects */\n.swiper-container-3d {\n  perspective: 1200px;\n}\n.swiper-container-3d .swiper-wrapper,\n.swiper-container-3d .swiper-slide,\n.swiper-container-3d .swiper-slide-shadow-left,\n.swiper-container-3d .swiper-slide-shadow-right,\n.swiper-container-3d .swiper-slide-shadow-top,\n.swiper-container-3d .swiper-slide-shadow-bottom,\n.swiper-container-3d .swiper-cube-shadow {\n  transform-style: preserve-3d;\n}\n.swiper-container-3d .swiper-slide-shadow-left,\n.swiper-container-3d .swiper-slide-shadow-right,\n.swiper-container-3d .swiper-slide-shadow-top,\n.swiper-container-3d .swiper-slide-shadow-bottom {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  pointer-events: none;\n  z-index: 10;\n}\n.swiper-container-3d .swiper-slide-shadow-left {\n  background-image: linear-gradient(to left, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\n.swiper-container-3d .swiper-slide-shadow-right {\n  background-image: linear-gradient(to right, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\n.swiper-container-3d .swiper-slide-shadow-top {\n  background-image: linear-gradient(to top, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\n.swiper-container-3d .swiper-slide-shadow-bottom {\n  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0));\n}\n/* CSS Mode */\n.swiper-container-css-mode > .swiper-wrapper {\n  overflow: auto;\n  scrollbar-width: none;\n  /* For Firefox */\n  -ms-overflow-style: none;\n  /* For Internet Explorer and Edge */\n}\n.swiper-container-css-mode > .swiper-wrapper::-webkit-scrollbar {\n  display: none;\n}\n.swiper-container-css-mode > .swiper-wrapper > .swiper-slide {\n  scroll-snap-align: start start;\n}\n.swiper-container-horizontal.swiper-container-css-mode > .swiper-wrapper {\n  scroll-snap-type: x mandatory;\n}\n.swiper-container-vertical.swiper-container-css-mode > .swiper-wrapper {\n  scroll-snap-type: y mandatory;\n}\n/* a11y */\n.swiper-container .swiper-notification {\n  position: absolute;\n  left: 0;\n  top: 0;\n  pointer-events: none;\n  opacity: 0;\n  z-index: -1000;\n}\n.swiper-container-cube {\n  overflow: visible;\n}\n.swiper-container-cube .swiper-slide {\n  pointer-events: none;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  z-index: 1;\n  visibility: hidden;\n  transform-origin: 0 0;\n  width: 100%;\n  height: 100%;\n}\n.swiper-container-cube .swiper-slide .swiper-slide {\n  pointer-events: none;\n}\n.swiper-container-cube.swiper-container-rtl .swiper-slide {\n  transform-origin: 100% 0;\n}\n.swiper-container-cube .swiper-slide-active,\n.swiper-container-cube .swiper-slide-active .swiper-slide-active {\n  pointer-events: auto;\n}\n.swiper-container-cube .swiper-slide-active,\n.swiper-container-cube .swiper-slide-next,\n.swiper-container-cube .swiper-slide-prev,\n.swiper-container-cube .swiper-slide-next + .swiper-slide {\n  pointer-events: auto;\n  visibility: visible;\n}\n.swiper-container-cube .swiper-slide-shadow-top,\n.swiper-container-cube .swiper-slide-shadow-bottom,\n.swiper-container-cube .swiper-slide-shadow-left,\n.swiper-container-cube .swiper-slide-shadow-right {\n  z-index: 0;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n.swiper-container-cube .swiper-cube-shadow {\n  position: absolute;\n  left: 0;\n  bottom: 0px;\n  width: 100%;\n  height: 100%;\n  background: #000;\n  opacity: 0.6;\n  -webkit-filter: blur(50px);\n  filter: blur(50px);\n  z-index: 0;\n}\n.swiper-container-fade.swiper-container-free-mode .swiper-slide {\n  transition-timing-function: ease-out;\n}\n.swiper-container-fade .swiper-slide {\n  pointer-events: none;\n  transition-property: opacity;\n}\n.swiper-container-fade .swiper-slide .swiper-slide {\n  pointer-events: none;\n}\n.swiper-container-fade .swiper-slide-active,\n.swiper-container-fade .swiper-slide-active .swiper-slide-active {\n  pointer-events: auto;\n}\n.swiper-container-flip {\n  overflow: visible;\n}\n.swiper-container-flip .swiper-slide {\n  pointer-events: none;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n  z-index: 1;\n}\n.swiper-container-flip .swiper-slide .swiper-slide {\n  pointer-events: none;\n}\n.swiper-container-flip .swiper-slide-active,\n.swiper-container-flip .swiper-slide-active .swiper-slide-active {\n  pointer-events: auto;\n}\n.swiper-container-flip .swiper-slide-shadow-top,\n.swiper-container-flip .swiper-slide-shadow-bottom,\n.swiper-container-flip .swiper-slide-shadow-left,\n.swiper-container-flip .swiper-slide-shadow-right {\n  z-index: 0;\n  -webkit-backface-visibility: hidden;\n          backface-visibility: hidden;\n}\n/* Preloader */\n:root {\n  /*\n  --swiper-preloader-color: var(--swiper-theme-color);\n  */\n}\n.swiper-lazy-preloader {\n  width: 42px;\n  height: 42px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: -21px;\n  margin-top: -21px;\n  z-index: 10;\n  transform-origin: 50%;\n  animation: swiper-preloader-spin 1s infinite linear;\n  box-sizing: border-box;\n  border: 4px solid var(--swiper-preloader-color, var(--swiper-theme-color));\n  border-radius: 50%;\n  border-top-color: transparent;\n}\n.swiper-lazy-preloader-white {\n  --swiper-preloader-color: #fff;\n}\n.swiper-lazy-preloader-black {\n  --swiper-preloader-color: #000;\n}\n@keyframes swiper-preloader-spin {\n  100% {\n    transform: rotate(360deg);\n  }\n}\n:root {\n  --swiper-navigation-size: 44px;\n  /*\n  --swiper-navigation-color: var(--swiper-theme-color);\n  */\n}\n.swiper-button-prev,\n.swiper-button-next {\n  position: absolute;\n  top: 50%;\n  width: calc(var(--swiper-navigation-size) / 44 * 27);\n  height: var(--swiper-navigation-size);\n  margin-top: calc(-1 * var(--swiper-navigation-size) / 2);\n  z-index: 10;\n  cursor: pointer;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  color: var(--swiper-navigation-color, var(--swiper-theme-color));\n}\n.swiper-button-prev.swiper-button-disabled,\n.swiper-button-next.swiper-button-disabled {\n  opacity: 0.35;\n  cursor: auto;\n  pointer-events: none;\n}\n.swiper-button-prev:after,\n.swiper-button-next:after {\n  font-family: swiper-icons;\n  font-size: var(--swiper-navigation-size);\n  text-transform: none !important;\n  letter-spacing: 0;\n  text-transform: none;\n  font-variant: initial;\n  line-height: 1;\n}\n.swiper-button-prev,\n.swiper-container-rtl .swiper-button-next {\n  left: 10px;\n  right: auto;\n}\n.swiper-button-prev:after,\n.swiper-container-rtl .swiper-button-next:after {\n  content: 'prev';\n}\n.swiper-button-next,\n.swiper-container-rtl .swiper-button-prev {\n  right: 10px;\n  left: auto;\n}\n.swiper-button-next:after,\n.swiper-container-rtl .swiper-button-prev:after {\n  content: 'next';\n}\n.swiper-button-lock {\n  display: none;\n}\n:root {\n  /*\n  --swiper-pagination-color: var(--swiper-theme-color);\n  */\n}\n.swiper-pagination {\n  position: absolute;\n  text-align: center;\n  transition: 300ms opacity;\n  transform: translate3d(0, 0, 0);\n  z-index: 10;\n}\n.swiper-pagination.swiper-pagination-hidden {\n  opacity: 0;\n}\n/* Common Styles */\n.swiper-pagination-fraction,\n.swiper-pagination-custom,\n.swiper-container-horizontal > .swiper-pagination-bullets {\n  bottom: 10px;\n  left: 0;\n  width: 100%;\n}\n/* Bullets */\n.swiper-pagination-bullets-dynamic {\n  overflow: hidden;\n  font-size: 0;\n}\n.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {\n  transform: scale(0.33);\n  position: relative;\n}\n.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active {\n  transform: scale(1);\n}\n.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-main {\n  transform: scale(1);\n}\n.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev {\n  transform: scale(0.66);\n}\n.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-prev-prev {\n  transform: scale(0.33);\n}\n.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next {\n  transform: scale(0.66);\n}\n.swiper-pagination-bullets-dynamic .swiper-pagination-bullet-active-next-next {\n  transform: scale(0.33);\n}\n.swiper-pagination-bullet {\n  width: 8px;\n  height: 8px;\n  display: inline-block;\n  border-radius: 100%;\n  background: #000;\n  opacity: 0.2;\n}\nbutton.swiper-pagination-bullet {\n  border: none;\n  margin: 0;\n  padding: 0;\n  box-shadow: none;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n}\n.swiper-pagination-clickable .swiper-pagination-bullet {\n  cursor: pointer;\n}\n.swiper-pagination-bullet-active {\n  opacity: 1;\n  background: var(--swiper-pagination-color, var(--swiper-theme-color));\n}\n.swiper-container-vertical > .swiper-pagination-bullets {\n  right: 10px;\n  top: 50%;\n  transform: translate3d(0px, -50%, 0);\n}\n.swiper-container-vertical > .swiper-pagination-bullets .swiper-pagination-bullet {\n  margin: 6px 0;\n  display: block;\n}\n.swiper-container-vertical > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic {\n  top: 50%;\n  transform: translateY(-50%);\n  width: 8px;\n}\n.swiper-container-vertical > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {\n  display: inline-block;\n  transition: 200ms transform, 200ms top;\n}\n.swiper-container-horizontal > .swiper-pagination-bullets .swiper-pagination-bullet {\n  margin: 0 4px;\n}\n.swiper-container-horizontal > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic {\n  left: 50%;\n  transform: translateX(-50%);\n  white-space: nowrap;\n}\n.swiper-container-horizontal > .swiper-pagination-bullets.swiper-pagination-bullets-dynamic .swiper-pagination-bullet {\n  transition: 200ms transform, 200ms left;\n}\n.swiper-container-horizontal.swiper-container-rtl > .swiper-pagination-bullets-dynamic .swiper-pagination-bullet {\n  transition: 200ms transform, 200ms right;\n}\n/* Progress */\n.swiper-pagination-progressbar {\n  background: rgba(0, 0, 0, 0.25);\n  position: absolute;\n}\n.swiper-pagination-progressbar .swiper-pagination-progressbar-fill {\n  background: var(--swiper-pagination-color, var(--swiper-theme-color));\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  transform: scale(0);\n  transform-origin: left top;\n}\n.swiper-container-rtl .swiper-pagination-progressbar .swiper-pagination-progressbar-fill {\n  transform-origin: right top;\n}\n.swiper-container-horizontal > .swiper-pagination-progressbar,\n.swiper-container-vertical > .swiper-pagination-progressbar.swiper-pagination-progressbar-opposite {\n  width: 100%;\n  height: 4px;\n  left: 0;\n  top: 0;\n}\n.swiper-container-vertical > .swiper-pagination-progressbar,\n.swiper-container-horizontal > .swiper-pagination-progressbar.swiper-pagination-progressbar-opposite {\n  width: 4px;\n  height: 100%;\n  left: 0;\n  top: 0;\n}\n.swiper-pagination-lock {\n  display: none;\n}\n/* Scrollbar */\n.swiper-scrollbar {\n  border-radius: 10px;\n  position: relative;\n  -ms-touch-action: none;\n  background: rgba(0, 0, 0, 0.1);\n}\n.swiper-container-horizontal > .swiper-scrollbar {\n  position: absolute;\n  left: 1%;\n  bottom: 3px;\n  z-index: 50;\n  height: 5px;\n  width: 98%;\n}\n.swiper-container-vertical > .swiper-scrollbar {\n  position: absolute;\n  right: 3px;\n  top: 1%;\n  z-index: 50;\n  width: 5px;\n  height: 98%;\n}\n.swiper-scrollbar-drag {\n  height: 100%;\n  width: 100%;\n  position: relative;\n  background: rgba(0, 0, 0, 0.5);\n  border-radius: 10px;\n  left: 0;\n  top: 0;\n}\n.swiper-scrollbar-cursor-drag {\n  cursor: move;\n}\n.swiper-scrollbar-lock {\n  display: none;\n}\n.swiper-zoom-container {\n  width: 100%;\n  height: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  text-align: center;\n}\n.swiper-zoom-container > img,\n.swiper-zoom-container > svg,\n.swiper-zoom-container > canvas {\n  max-width: 100%;\n  max-height: 100%;\n  object-fit: contain;\n}\n.swiper-slide-zoomed {\n  cursor: move;\n}\n:root {\n  --swiper-theme-color: var(--f7-theme-color);\n}\n/* === Photo Browser === */\n:root {\n  --f7-photobrowser-bg-color: #fff;\n  --f7-photobrowser-bars-bg-image: none;\n  /*\n  --f7-photobrowser-bars-bg-color: rgba(var(--f7-bars-bg-color-rgb), 0.95);\n  --f7-photobrowser-bars-text-color: var(--f7-bars-text-color);\n  --f7-photobrowser-bars-link-color: var(--f7-bars-link-color);\n  */\n  --f7-photobrowser-caption-font-size: 14px;\n  --f7-photobrowser-caption-light-text-color: #000;\n  --f7-photobrowser-caption-light-bg-color: rgba(255, 255, 255, 0.8);\n  --f7-photobrowser-caption-dark-text-color: #fff;\n  --f7-photobrowser-caption-dark-bg-color: rgba(0, 0, 0, 0.8);\n  --f7-photobrowser-exposed-bg-color: #000;\n  --f7-photobrowser-dark-bg-color: #000;\n  --f7-photobrowser-dark-bars-bg-color: rgba(27, 27, 27, 0.8);\n  --f7-photobrowser-dark-bars-text-color: #fff;\n  --f7-photobrowser-dark-bars-link-color: #fff;\n}\n.photo-browser {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  z-index: 400;\n}\n.photo-browser-standalone.modal-in {\n  transition-duration: 0ms;\n  animation: photo-browser-in 400ms;\n}\n.photo-browser-standalone.modal-out {\n  transition-duration: 0ms;\n  animation: photo-browser-out 400ms !important;\n}\n.photo-browser-standalone.modal-out.swipe-close-to-bottom,\n.photo-browser-standalone.modal-out.swipe-close-to-top {\n  animation: none !important;\n}\n.photo-browser-standalone.photo-browser-transitioning {\n  transition: 400ms;\n  transition-property: transform;\n  animation: none !important;\n}\n.photo-browser-popup.modal-out.swipe-close-to-bottom,\n.photo-browser-popup.modal-out.swipe-close-to-top {\n  transition-duration: 300ms;\n}\n.photo-browser-popup.modal-out.swipe-close-to-bottom {\n  transform: translate3d(0, 100%, 0);\n}\n.photo-browser-popup.modal-out.swipe-close-to-top {\n  transform: translate3d(0, -100vh, 0);\n}\n.photo-browser-page {\n  background: none;\n}\n.photo-browser-page .toolbar {\n  transform: none;\n}\n.photo-browser-popup {\n  background: none;\n}\n.photo-browser-of {\n  margin: 0 5px;\n}\n.photo-browser-captions {\n  pointer-events: none;\n  position: absolute;\n  left: 0;\n  width: 100%;\n  bottom: var(--f7-safe-area-bottom);\n  z-index: 10;\n  opacity: 1;\n  transition: 400ms;\n}\n.photo-browser-captions.photo-browser-captions-exposed {\n  opacity: 0;\n}\n.toolbar ~ .photo-browser-captions {\n  bottom: calc(var(--f7-toolbar-height) + var(--f7-safe-area-bottom));\n  transform: translate3d(0, 0px, 0);\n}\n.toolbar ~ .photo-browser-captions.photo-browser-captions-exposed {\n  transform: translate3d(0, 0px, 0);\n}\n.photo-browser-caption {\n  box-sizing: border-box;\n  transition: 300ms;\n  position: absolute;\n  bottom: 0;\n  left: 0;\n  opacity: 0;\n  padding: 4px 5px;\n  width: 100%;\n  text-align: center;\n  font-size: var(--f7-photobrowser-caption-font-size);\n}\n.photo-browser-caption:empty {\n  display: none;\n}\n.photo-browser-caption.photo-browser-caption-active {\n  opacity: 1;\n}\n.photo-browser-captions-light .photo-browser-caption {\n  color: var(--f7-photobrowser-caption-light-text-color);\n  background: var(--f7-photobrowser-caption-light-bg-color);\n}\n.photo-browser-captions-dark .photo-browser-caption {\n  color: var(--f7-photobrowser-caption-dark-text-color);\n  background: var(--f7-photobrowser-caption-dark-bg-color);\n}\n.photo-browser-swiper-container {\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  background: var(--f7-photobrowser-bg-color);\n  transition: 400ms;\n  transition-property: background-color;\n}\n.photo-browser-prev.swiper-button-disabled,\n.photo-browser-next.swiper-button-disabled {\n  opacity: 0.3;\n  pointer-events: none;\n}\n.photo-browser-slide {\n  width: 100%;\n  height: 100%;\n  position: relative;\n  overflow: hidden;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-shrink: 0;\n  box-sizing: border-box;\n}\n.photo-browser-slide span.swiper-zoom-container {\n  display: none;\n}\n.photo-browser-slide img {\n  width: auto;\n  height: auto;\n  max-width: 100%;\n  max-height: 100%;\n  display: none;\n}\n.photo-browser-slide.swiper-slide-active span.swiper-zoom-container,\n.photo-browser-slide.swiper-slide-next span.swiper-zoom-container,\n.photo-browser-slide.swiper-slide-prev span.swiper-zoom-container {\n  display: flex;\n}\n.photo-browser-slide.swiper-slide-active img,\n.photo-browser-slide.swiper-slide-next img,\n.photo-browser-slide.swiper-slide-prev img {\n  display: inline;\n}\n.photo-browser-slide.swiper-slide-active.photo-browser-slide-lazy .preloader,\n.photo-browser-slide.swiper-slide-next.photo-browser-slide-lazy .preloader,\n.photo-browser-slide.swiper-slide-prev.photo-browser-slide-lazy .preloader {\n  display: block;\n}\n.photo-browser-slide iframe {\n  width: 100%;\n  height: 100%;\n}\n.photo-browser-slide .preloader {\n  display: none;\n  position: absolute;\n  width: 42px;\n  height: 42px;\n  margin-left: -21px;\n  margin-top: -21px;\n  left: 50%;\n  top: 50%;\n}\n.photo-browser-page .navbar-bg,\n.navbar-photo-browser .navbar-bg,\n.photo-browser-page .toolbar {\n  background-color: var(--f7-photobrowser-bars-bg-color, rgba(var(--f7-bars-bg-color-rgb), 0.95));\n  background-image: var(--f7-photobrowser-bars-bg-image);\n}\n.photo-browser-page .navbar,\n.photo-browser-page .toolbar {\n  transition: 400ms;\n  color: var(--f7-photobrowser-bars-text-color, var(--f7-bars-text-color));\n}\n.photo-browser-page .navbar a,\n.photo-browser-page .toolbar a {\n  color: var(--f7-photobrowser-bars-link-color, var(--f7-bars-link-color, var(--f7-theme-color)));\n}\n.photo-browser-exposed .navbar,\n.photo-browser-exposed .toolbar {\n  opacity: 0;\n  visibility: hidden;\n  pointer-events: none;\n}\n.photo-browser-exposed .toolbar ~ .photo-browser-captions {\n  transform: translate3d(0, var(--f7-toolbar-height), 0);\n}\n.photo-browser-exposed .photo-browser-swiper-container {\n  background: var(--f7-photobrowser-exposed-bg-color);\n}\n.photo-browser-exposed .photo-browser-caption {\n  color: var(--f7-photobrowser-caption-dark-text-color);\n  background: var(--f7-photobrowser-caption-dark-bg-color);\n}\n.view.with-photo-browser-page-exposed .navbar {\n  opacity: 0;\n  pointer-events: none;\n}\n.photo-browser-page-dark .navbar-bg,\n.navbar-photo-browser-dark .navbar-bg,\n.photo-browser-page-dark .toolbar {\n  background: var(--f7-photobrowser-dark-bars-bg-color);\n}\n.photo-browser-page-dark .navbar-bg:before,\n.navbar-photo-browser-dark .navbar-bg:before,\n.photo-browser-page-dark .toolbar:before,\n.photo-browser-page-dark .navbar-bg:after,\n.navbar-photo-browser-dark .navbar-bg:after,\n.photo-browser-page-dark .toolbar:after {\n  display: none !important;\n}\n.navbar-photo-browser-dark,\n.photo-browser-dark .navbar,\n.photo-browser-dark .toolbar,\n.photo-browser-dark-page .navbar,\n.photo-browser-dark-page .toolbar {\n  --f7-touch-ripple-color: var(--f7-touch-ripple-white);\n  --f7-link-highlight-color: var(--f7-link-highlight-white);\n  color: var(--f7-photobrowser-dark-bars-text-color);\n}\n.navbar-photo-browser-dark a,\n.photo-browser-dark .navbar a,\n.photo-browser-dark .toolbar a,\n.photo-browser-dark-page .navbar a,\n.photo-browser-dark-page .toolbar a {\n  color: var(--f7-photobrowser-dark-bars-link-color);\n}\n.photo-browser-dark .photo-browser-swiper-container,\n.photo-browser-page-dark .photo-browser-swiper-container {\n  background: var(--f7-photobrowser-dark-bg-color);\n}\n@keyframes photo-browser-in {\n  0% {\n    transform: translate3d(0, 0, 0) scale(0.5);\n    opacity: 0;\n  }\n  50% {\n    transform: translate3d(0, 0, 0) scale(1.05);\n    opacity: 1;\n  }\n  100% {\n    transform: translate3d(0, 0, 0) scale(1);\n    opacity: 1;\n  }\n}\n@keyframes photo-browser-out {\n  0% {\n    transform: translate3d(0, 0, 0) scale(1);\n    opacity: 1;\n  }\n  50% {\n    transform: translate3d(0, 0, 0) scale(1.05);\n    opacity: 1;\n  }\n  100% {\n    transform: translate3d(0, 0, 0) scale(0.5);\n    opacity: 0;\n  }\n}\n/* === Notifications === */\n:root {\n  --f7-notification-max-width: 568px;\n  --f7-notification-subtitle-text-transform: none;\n  --f7-notification-subtitle-line-height: 1.35;\n  --f7-notification-text-text-transform: none;\n  --f7-notification-text-font-weight: 400;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-notification-subtitle-color: #fff;\n}\n.ios {\n  --f7-notification-margin: 8px;\n  --f7-notification-padding: 10px;\n  --f7-notification-border-radius: 12px;\n  --f7-notification-box-shadow: 0px 5px 25px -10px rgba(0, 0, 0, 0.7);\n  --f7-notification-icon-size: 20px;\n  --f7-notification-title-font-size: 13px;\n  --f7-notification-title-text-transform: uppercase;\n  --f7-notification-title-line-height: 1.4;\n  --f7-notification-title-font-weight: 400;\n  --f7-notification-title-letter-spacing: 0.02em;\n  --f7-notification-title-right-font-size: 13px;\n  --f7-notification-subtitle-font-size: 15px;\n  --f7-notification-subtitle-font-weight: 600;\n  --f7-notification-text-font-size: 15px;\n  --f7-notification-text-line-height: 1.2;\n  --f7-notification-bg-color: rgba(250, 250, 250, 0.95);\n  --f7-notification-bg-color-rgb: 255, 255, 255;\n  --f7-notification-title-color: #000;\n  --f7-notification-title-right-color: rgba(0, 0, 0, 0.45);\n  --f7-notification-subtitle-color: #000;\n  --f7-notification-text-color: #000;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-notification-bg-color: rgba(30, 30, 30, 0.95);\n  --f7-notification-bg-color-rgb: 30, 30, 30;\n  --f7-notification-title-color: #fff;\n  --f7-notification-text-color: #fff;\n  --f7-notification-title-right-color: rgba(255, 255, 255, 0.55);\n}\n.md {\n  --f7-notification-margin: 0px;\n  --f7-notification-padding: 16px;\n  --f7-notification-border-radius: 0px;\n  --f7-notification-box-shadow: 0 2px 4px rgba(0, 0, 0, 0.22), 0 1px 2px rgba(0, 0, 0, 0.24);\n  --f7-notification-icon-size: 16px;\n  --f7-notification-title-color: var(--f7-theme-color);\n  --f7-notification-title-font-size: 12px;\n  --f7-notification-title-text-transform: none;\n  --f7-notification-title-line-height: 1;\n  --f7-notification-title-font-weight: 400;\n  --f7-notification-title-right-font-size: 12px;\n  --f7-notification-subtitle-font-size: 14px;\n  --f7-notification-subtitle-font-weight: 400;\n  --f7-notification-text-font-size: 14px;\n  --f7-notification-text-line-height: 1.35;\n  --f7-notification-bg-color: #fff;\n  --f7-notification-title-right-color: rgba(0, 0, 0, 0.54);\n  --f7-notification-subtitle-color: #212121;\n  --f7-notification-text-color: rgba(0, 0, 0, 0.54);\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-notification-bg-color: #242424;\n  --f7-notification-title-right-color: rgba(255, 255, 255, 0.54);\n  --f7-notification-text-color: rgba(255, 255, 255, 0.54);\n}\n.aurora {\n  --f7-notification-margin: 10px;\n  --f7-notification-padding: 10px;\n  --f7-notification-border-radius: 4px;\n  --f7-notification-box-shadow: 0px 5px 25px -10px rgba(0, 0, 0, 0.7);\n  --f7-notification-icon-size: 18px;\n  --f7-notification-title-font-size: 13px;\n  --f7-notification-title-text-transform: uppercase;\n  --f7-notification-title-line-height: 1.4;\n  --f7-notification-title-font-weight: 500;\n  --f7-notification-title-letter-spacing: 0.02em;\n  --f7-notification-title-right-font-size: 13px;\n  --f7-notification-subtitle-font-size: 12px;\n  --f7-notification-subtitle-font-weight: 600;\n  --f7-notification-text-font-size: 12px;\n  --f7-notification-text-line-height: 1.2;\n  --f7-notification-bg-color: #fff;\n  --f7-notification-title-color: #000;\n  --f7-notification-title-right-color: rgba(255, 255, 255, 0.6);\n  --f7-notification-subtitle-color: #000;\n  --f7-notification-text-color: #000;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-notification-bg-color: #242424;\n  --f7-notification-title-color: #fff;\n  --f7-notification-text-color: #fff;\n  --f7-notification-title-right-color: rgba(255, 255, 255, 0.54);\n}\n.notification {\n  --f7-link-highlight-color: var(--f7-link-highlight-black);\n  --f7-touch-ripple-color: var(--f7-touch-ripple-black);\n  position: absolute;\n  left: var(--f7-notification-margin);\n  top: var(--f7-notification-margin);\n  width: calc(100% - var(--f7-notification-margin) * 2);\n  z-index: 20000;\n  font-size: 14px;\n  margin: 0;\n  border: none;\n  display: none;\n  box-sizing: border-box;\n  transition-property: transform;\n  direction: ltr;\n  max-width: var(--f7-notification-max-width);\n  padding: var(--f7-notification-padding);\n  border-radius: var(--f7-notification-border-radius);\n  box-shadow: var(--f7-notification-box-shadow);\n  background: var(--f7-notification-bg-color);\n  margin-top: var(--f7-safe-area-top);\n}\n@supports ((-webkit-backdrop-filter: blur(20px)) or (backdrop-filter: blur(20px))) {\n  .ios-translucent-modals .notification {\n    background-color: rgba(var(--f7-notification-bg-color-rgb), 0.8);\n    -webkit-backdrop-filter: saturate(180%) blur(20px);\n            backdrop-filter: saturate(180%) blur(20px);\n  }\n}\n@media (min-width: 568px) {\n  .notification {\n    left: 50%;\n    width: var(--f7-notification-max-width);\n    margin-left: calc(-1 * var(--f7-notification-max-width) / 2);\n  }\n}\n.notification-title {\n  color: var(--f7-notification-title-color, var(--f7-theme-color));\n  font-size: var(--f7-notification-title-font-size);\n  text-transform: var(--f7-notification-title-text-transform);\n  line-height: var(--f7-notification-title-line-height);\n  font-weight: var(--f7-notification-title-font-weight);\n  letter-spacing: var(--f7-notification-title-letter-spacing);\n}\n.notification-subtitle {\n  color: var(--f7-notification-subtitle-color);\n  font-size: var(--f7-notification-subtitle-font-size);\n  text-transform: var(--f7-notification-subtitle-text-transform);\n  line-height: var(--f7-notification-subtitle-line-height);\n  font-weight: var(--f7-notification-subtitle-font-weight);\n}\n.notification-text {\n  color: var(--f7-notification-text-color);\n  font-size: var(--f7-notification-text-font-size);\n  text-transform: var(--f7-notification-text-text-transform);\n  line-height: var(--f7-notification-text-line-height);\n  font-weight: var(--f7-notification-text-font-weight);\n}\n.notification-title-right-text {\n  color: var(--f7-notification-title-right-color);\n  font-size: var(--f7-notification-title-right-font-size);\n}\n.notification-icon {\n  font-size: 0;\n  line-height: var(--f7-notification-icon-size);\n}\n.notification-icon i,\n.notification-icon {\n  width: var(--f7-notification-icon-size) !important;\n  height: var(--f7-notification-icon-size) !important;\n}\n.notification-icon i {\n  font-size: var(--f7-notification-icon-size);\n}\n.notification-icon img {\n  height: var(--f7-notification-icon-size);\n}\n.notification-header {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n.notification-close-button {\n  margin-left: auto;\n  cursor: pointer;\n  position: relative;\n}\n.notification-close-button:after {\n  font-family: 'framework7-core-icons';\n  font-weight: normal;\n  font-style: normal;\n  line-height: 1;\n  letter-spacing: normal;\n  text-transform: none;\n  white-space: nowrap;\n  word-wrap: normal;\n  direction: ltr;\n  -webkit-font-smoothing: antialiased;\n  text-rendering: optimizeLegibility;\n  -moz-osx-font-smoothing: grayscale;\n  font-feature-settings: \"liga\";\n  display: block;\n  width: 100%;\n  height: 100%;\n  font-size: 20px;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  text-align: center;\n}\n.ios .notification {\n  transition-duration: 450ms;\n  transform: translate3d(0%, -200%, 0);\n}\n.ios .notification.modal-in {\n  transform: translate3d(0%, 0%, 0);\n  opacity: 1;\n}\n.ios .notification.modal-out {\n  transform: translate3d(0%, -200%, 0);\n}\n.ios .notification-icon {\n  margin-right: 8px;\n}\n.ios .notification-header + .notification-content {\n  margin-top: 10px;\n}\n.ios .notification-title-right-text {\n  margin-right: 6px;\n  margin-left: auto;\n}\n.ios .notification-title-right-text + .notification-close-button {\n  margin-left: 10px;\n}\n.ios .notification-close-button {\n  font-size: 14px;\n  width: 20px;\n  height: 20px;\n  opacity: 0.3;\n  transition-duration: 300ms;\n}\n.ios .notification-close-button.active-state {\n  transition-duration: 0ms;\n  opacity: 0.1;\n}\n.ios .notification-close-button:after {\n  color: #000;\n  content: 'notification_close_ios';\n  font-size: 0.65em;\n  line-height: 44px;\n  width: 44px;\n  height: 44px;\n  margin-left: -22px;\n  margin-top: -22px;\n}\n.ios .theme-dark .notification-close-button:after,\n.ios.theme-dark .notification-close-button:after {\n  color: #fff;\n}\n.md .notification {\n  transform: translate3d(0, -150%, 0);\n}\n.md .notification.modal-in {\n  transition-duration: 0ms;\n  animation: notification-md-in 400ms ease-out;\n  transform: translate3d(0, 0%, 0);\n}\n.md .notification.modal-in.notification-transitioning {\n  transition-duration: 200ms;\n}\n.md .notification.modal-out {\n  animation: none;\n  transition-duration: 200ms;\n  transition-timing-function: ease-in;\n  transform: translate3d(0, -150%, 0);\n}\n.md .notification-icon {\n  margin-right: 8px;\n}\n.md .notification-subtitle + .notification-text {\n  margin-top: 2px;\n}\n.md .notification-header + .notification-content {\n  margin-top: 6px;\n}\n.md .notification-title-right-text {\n  margin-left: 4px;\n}\n.md .notification-title-right-text:before {\n  content: '';\n  width: 3px;\n  height: 3px;\n  border-radius: 50%;\n  display: inline-block;\n  vertical-align: middle;\n  margin-right: 4px;\n  background: var(--f7-notification-title-right-color);\n}\n.md .notification-close-button {\n  width: 16px;\n  height: 16px;\n  transition-duration: 300ms;\n}\n.md .notification-close-button:before {\n  content: '';\n  width: 152%;\n  height: 152%;\n  position: absolute;\n  left: -26%;\n  top: -26%;\n  background-image: radial-gradient(circle at center, var(--f7-link-highlight-color) 66%, rgba(255, 255, 255, 0) 66%);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 100% 100%;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 600ms;\n}\n.md .notification-close-button.active-state:before {\n  opacity: 1;\n  transition-duration: 150ms;\n}\n.md .notification-close-button:before,\n.md .notification-close-button:after {\n  width: 48px;\n  height: 48px;\n  left: 50%;\n  top: 50%;\n  margin-left: -24px;\n  margin-top: -24px;\n}\n.md .notification-close-button:after {\n  color: #737373;\n  content: 'delete_md';\n  line-height: 48px;\n  font-size: 14px;\n}\n@keyframes notification-md-in {\n  0% {\n    transform: translate3d(0, -150%, 0);\n  }\n  50% {\n    transform: translate3d(0, 10%, 0);\n  }\n  100% {\n    transform: translate3d(0, 0%, 0);\n  }\n}\n.aurora .notification {\n  transition-duration: 450ms;\n  transform: translate3d(0%, -200%, 0);\n}\n.aurora .notification.modal-in {\n  transform: translate3d(0%, 0%, 0);\n  opacity: 1;\n}\n.aurora .notification.modal-out {\n  transform: translate3d(0%, -200%, 0);\n}\n.aurora .notification-icon {\n  margin-right: 10px;\n}\n.aurora .notification-header + .notification-content {\n  margin-top: 10px;\n}\n.aurora .notification-title-right-text {\n  margin-right: 0px;\n  margin-left: auto;\n}\n.aurora .notification-title-right-text + .notification-close-button {\n  margin-left: 10px;\n}\n.aurora .notification-close-button {\n  font-size: 14px;\n  width: 16px;\n  height: 16px;\n  opacity: 0.4;\n  transition-duration: 300ms;\n}\n.aurora .notification-close-button.active-state {\n  transition-duration: 0ms;\n  opacity: 0.6;\n}\n.aurora .notification-close-button:after {\n  color: #000;\n  content: 'notification_close_ios';\n  font-size: 0.5em;\n  line-height: 38px;\n  width: 38px;\n  height: 38px;\n  margin-left: -19px;\n  margin-top: -19px;\n}\n.aurora .theme-dark .notification-close-button:after,\n.aurora.theme-dark .notification-close-button:after {\n  color: #fff;\n}\n/* === Autocomplete === */\n:root {\n  --f7-autocomplete-dropdown-placeholder-color: #a9a9a9;\n  --f7-autocomplete-dropdown-preloader-size: 20px;\n  /*\n  --f7-autocomplete-dropdown-selected-bg-color: rgba(var(--f7-theme-color-rgb), 0.2);\n  */\n  --f7-autocomplete-dropdown-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-autocomplete-dropdown-bg-color: #1c1c1d;\n}\n.ios {\n  --f7-autocomplete-dropdown-box-shadow: 0px 3px 3px rgba(0, 0, 0, 0.2);\n  --f7-autocomplete-dropdown-text-matching-font-weight: 600;\n  --f7-autocomplete-dropdown-font-size: var(--f7-list-font-size);\n  --f7-autocomplete-dropdown-text-color: #000;\n  --f7-autocomplete-dropdown-text-matching-color: #000;\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-autocomplete-dropdown-text-color: #fff;\n  --f7-autocomplete-dropdown-text-matching-color: #fff;\n}\n.md {\n  --f7-autocomplete-dropdown-box-shadow: 0 2px 2px rgba(0, 0, 0, 0.25);\n  --f7-autocomplete-dropdown-text-matching-font-weight: 400;\n  --f7-autocomplete-dropdown-font-size: var(--f7-list-font-size);\n  --f7-autocomplete-dropdown-text-color: rgba(0, 0, 0, 0.54);\n  --f7-autocomplete-dropdown-text-matching-color: #212121;\n}\n.md .theme-dark,\n.md.theme-dark {\n  --f7-autocomplete-dropdown-text-color: rgba(255, 255, 255, 0.54);\n  --f7-autocomplete-dropdown-text-matching-color: rgba(255, 255, 255, 0.87);\n}\n.aurora {\n  --f7-autocomplete-dropdown-box-shadow: 0px 1px 2px rgba(0, 0, 0, 0.2);\n  --f7-autocomplete-dropdown-text-matching-font-weight: 700;\n  --f7-autocomplete-dropdown-font-size: 13px;\n  --f7-autocomplete-dropdown-text-color: #000;\n  --f7-autocomplete-dropdown-text-matching-color: #000;\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-autocomplete-dropdown-text-color: #fff;\n  --f7-autocomplete-dropdown-text-matching-color: #fff;\n}\n.autocomplete-page .autocomplete-found {\n  display: block;\n}\n.autocomplete-page .autocomplete-not-found {\n  display: none;\n}\n.autocomplete-page .autocomplete-values {\n  display: block;\n}\n.autocomplete-page .list ul:empty {\n  display: none;\n}\n.autocomplete-preloader:not(.autocomplete-preloader-visible) {\n  visibility: hidden;\n}\n.autocomplete-preloader:not(.autocomplete-preloader-visible),\n.autocomplete-preloader:not(.autocomplete-preloader-visible) * {\n  animation: none;\n}\n.autocomplete-dropdown {\n  background: var(--f7-autocomplete-dropdown-bg-color);\n  box-shadow: var(--f7-autocomplete-dropdown-box-shadow);\n  box-sizing: border-box;\n  position: absolute;\n  z-index: 500;\n  width: 100%;\n  left: 0;\n}\n.autocomplete-dropdown .autocomplete-dropdown-inner {\n  position: relative;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  height: 100%;\n  z-index: 1;\n}\n.autocomplete-dropdown .autocomplete-preloader {\n  display: none;\n  position: absolute;\n  bottom: 100%;\n  width: var(--f7-autocomplete-dropdown-preloader-size);\n  height: var(--f7-autocomplete-dropdown-preloader-size);\n}\n.autocomplete-dropdown .autocomplete-preloader-visible {\n  display: block;\n}\n.autocomplete-dropdown .autocomplete-dropdown-placeholder {\n  color: var(--f7-autocomplete-dropdown-placeholder-color);\n}\n.autocomplete-dropdown .list {\n  margin: 0;\n  color: var(--f7-autocomplete-dropdown-text-color);\n  font-size: var(--f7-autocomplete-dropdown-font-size);\n}\n.autocomplete-dropdown .list b {\n  color: var(--f7-autocomplete-dropdown-text-matching-color);\n  font-weight: var(--f7-autocomplete-dropdown-text-matching-font-weight);\n}\n.autocomplete-dropdown .list ul {\n  background: none !important;\n}\n.autocomplete-dropdown .list ul:before,\n.autocomplete-dropdown .list ul:after {\n  display: none !important;\n}\n.autocomplete-dropdown .autocomplete-dropdown-selected {\n  background: var(--f7-autocomplete-dropdown-selected-bg-color, rgba(var(--f7-theme-color-rgb), 0.2));\n}\n.searchbar-input-wrap .autocomplete-dropdown {\n  background-color: var(--f7-searchbar-input-bg-color, var(--f7-searchbar-bg-color));\n  border-radius: var(--f7-searchbar-input-border-radius);\n}\n.searchbar-input-wrap .autocomplete-dropdown .autocomplete-dropdown-placeholder {\n  color: var(--f7-searchbar-placeholder-color);\n}\n.searchbar-input-wrap .autocomplete-dropdown li:last-child {\n  border-radius: 0 0 var(--f7-searchbar-input-border-radius) var(--f7-searchbar-input-border-radius);\n  position: relative;\n  overflow: hidden;\n}\n.searchbar-input-wrap .autocomplete-dropdown .item-content {\n  padding-left: var(--f7-searchbar-input-padding-horizontal);\n}\n.list .item-content-dropdown-expanded .item-title.item-label {\n  width: 0;\n  flex-shrink: 10;\n  overflow: hidden;\n}\n.list .item-content-dropdown-expanded .item-title.item-label + .item-input-wrap {\n  margin-left: 0;\n}\n.list .item-content-dropdown-expanded .item-input-wrap {\n  width: 100%;\n}\n.ios .autocomplete-dropdown .autocomplete-preloader {\n  right: 16px;\n  margin-bottom: 12px;\n}\n.ios .searchbar-input-wrap .autocomplete-dropdown {\n  margin-top: calc(-1 * var(--f7-searchbar-input-height));\n  top: 100%;\n  z-index: 20;\n}\n.ios .searchbar-input-wrap .autocomplete-dropdown .autocomplete-dropdown-inner {\n  padding-top: var(--f7-searchbar-input-height);\n}\n.md .autocomplete-page .navbar .autocomplete-preloader {\n  margin-right: 8px;\n}\n.md .autocomplete-popup .navbar .autocomplete-preloader {\n  margin-left: 8px;\n  margin-right: 16px;\n}\n.md .autocomplete-dropdown .autocomplete-preloader {\n  right: 16px;\n  margin-bottom: 8px;\n}\n.md .autocomplete-dropdown .autocomplete-preloader .preloader-inner-gap,\n.md .autocomplete-dropdown .autocomplete-preloader .preloader-inner-half-circle {\n  border-width: 3px;\n}\n.aurora .autocomplete-dropdown .autocomplete-preloader {\n  right: 16px;\n  margin-bottom: 2px;\n}\n.aurora .searchbar-input-wrap .autocomplete-dropdown {\n  margin-top: calc(-1 * var(--f7-searchbar-input-height));\n  top: 100%;\n  z-index: 20;\n}\n.aurora .searchbar-input-wrap .autocomplete-dropdown .autocomplete-dropdown-inner {\n  padding-top: var(--f7-searchbar-input-height);\n}\n/* === Tooltip === */\n:root {\n  --f7-tooltip-bg-color: rgba(0, 0, 0, 0.87);\n  --f7-tooltip-text-color: #fff;\n  --f7-tooltip-border-radius: 4px;\n  --f7-tooltip-padding: 8px 16px;\n  --f7-tooltip-font-size: 14px;\n  --f7-tooltip-font-weight: 500;\n  --f7-tooltip-desktop-padding: 6px 8px;\n  --f7-tooltip-desktop-font-size: 12px;\n}\n.tooltip {\n  position: absolute;\n  z-index: 20000;\n  background: var(--f7-tooltip-bg-color);\n  border-radius: var(--f7-tooltip-border-radius);\n  padding: var(--f7-tooltip-padding);\n  color: var(--f7-tooltip-text-color);\n  font-size: var(--f7-tooltip-font-size);\n  font-weight: var(--f7-tooltip-font-weight);\n  box-sizing: border-box;\n  line-height: 1.2;\n  opacity: 0;\n  transform: scale(0.9);\n  transition-duration: 150ms;\n  transition-property: opacity, transform;\n  z-index: 99000;\n}\n.tooltip.tooltip-in {\n  transform: scale(1);\n  opacity: 1;\n}\n.tooltip.tooltip-out {\n  opacity: 0;\n  transform: scale(1);\n}\n.device-desktop .tooltip {\n  font-size: var(--f7-tooltip-desktop-font-size);\n  padding: var(--f7-tooltip-desktop-padding);\n}\n/* === Gauge === */\n.gauge {\n  position: relative;\n  text-align: center;\n  margin-left: auto;\n  margin-right: auto;\n  display: inline-block;\n}\n.gauge-svg,\n.gauge svg {\n  max-width: 100%;\n  height: auto;\n}\n.gauge-svg circle,\n.gauge svg circle,\n.gauge-svg path,\n.gauge svg path {\n  transition-duration: 400ms;\n}\n/* === Skeleton === */\n:root {\n  --f7-skeleton-color: #ccc;\n}\n.theme-dark {\n  --f7-skeleton-color: #515151;\n}\n.skeleton-text {\n  font-family: 'framework7-skeleton' !important;\n}\n.skeleton-text,\n.skeleton-text * {\n  color: var(--f7-skeleton-color) !important;\n  font-weight: normal !important;\n  font-style: normal !important;\n  letter-spacing: -0.015em !important;\n}\n.skeleton-block {\n  height: 1em;\n  background: var(--f7-skeleton-color) !important;\n  width: 100%;\n}\n.skeleton-effect-fade {\n  animation: skeleton-effect-fade 1s infinite;\n}\n.skeleton-effect-blink {\n  -webkit-mask-image: linear-gradient(to right, transparent 0%, black 25%, black 75%, transparent 100%);\n  mask-image: linear-gradient(to right, transparent 0%, black 25%, black 75%, transparent 100%);\n  -webkit-mask-size: 200% 100%;\n  mask-size: 200% 100%;\n  -webkit-mask-repeat: repeat;\n  mask-repeat: repeat;\n  -webkit-mask-position: 50% top;\n  mask-position: 50% top;\n  animation: skeleton-effect-blink 1s infinite;\n}\n.skeleton-effect-pulse {\n  animation: skeleton-effect-pulse 1s infinite;\n}\n@keyframes skeleton-effect-fade {\n  0% {\n    opacity: 1;\n  }\n  50% {\n    opacity: 0.2;\n  }\n  100% {\n    opacity: 1;\n  }\n}\n@keyframes skeleton-effect-blink {\n  0% {\n    -webkit-mask-position: 50% top;\n    mask-position: 50% top;\n  }\n  100% {\n    -webkit-mask-position: -150% top;\n    mask-position: -150% top;\n  }\n}\n@keyframes skeleton-effect-pulse {\n  0% {\n    transform: scale(1);\n  }\n  40% {\n    transform: scale(1);\n  }\n  50% {\n    transform: scale(0.975);\n  }\n  100% {\n    transform: scale(1);\n  }\n}\n/* === Menu === */\n:root {\n  --f7-menu-text-color: #fff;\n  --f7-menu-font-size: 16px;\n  --f7-menu-font-weight: 500;\n  --f7-menu-line-height: 1.2;\n  --f7-menu-bg-color: rgba(0, 0, 0, 0.9);\n  --f7-menu-item-pressed-bg-color: rgba(20, 20, 20, 0.9);\n  --f7-menu-item-padding-horizontal: 12px;\n  --f7-menu-item-spacing: 6px;\n  --f7-menu-item-height: 40px;\n  --f7-menu-item-dropdown-icon-color: rgba(255, 255, 255, 0.4);\n  --f7-menu-item-border-radius: 8px;\n  /*\n  --f7-menu-dropdown-pressed-bg-color: var(--f7-theme-color);\n  */\n  --f7-menu-dropdown-item-height: 28px;\n  --f7-menu-dropdown-divider-color: rgba(255, 255, 255, 0.2);\n  --f7-menu-dropdown-padding-vertical: 6px;\n  /*\n  --f7-menu-dropdown-border-radius: var(--f7-menu-item-border-radius);\n  */\n}\n.aurora {\n  --f7-menu-font-size: 13px;\n  --f7-menu-item-height: 28px;\n  --f7-menu-dropdown-item-height: 24px;\n  --f7-menu-item-border-radius: 5px;\n  --f7-menu-item-padding-horizontal: 10px;\n}\n.menu {\n  z-index: 1000;\n  position: relative;\n  transform: translate3d(0, 0, 0);\n  --f7-touch-ripple-color: var(--f7-touch-ripple-white);\n}\n.menu-inner {\n  display: flex;\n  justify-content: flex-start;\n  align-items: flex-start;\n  padding-left: var(--f7-menu-item-spacing);\n  padding-right: var(--f7-menu-item-spacing);\n}\n.menu-inner:after {\n  content: '';\n  width: var(--f7-menu-item-spacing);\n  height: 100%;\n  flex-shrink: 0;\n}\n.menu-item {\n  height: var(--f7-menu-item-height);\n  min-width: var(--f7-menu-item-height);\n  flex-shrink: 0;\n  background: var(--f7-menu-bg-color);\n  color: var(--f7-menu-text-color);\n  border-radius: var(--f7-menu-item-border-radius);\n  position: relative;\n  box-sizing: border-box;\n  font-size: var(--f7-menu-font-size);\n  font-weight: var(--f7-menu-font-weight);\n  cursor: pointer;\n  margin-left: var(--f7-menu-item-spacing);\n}\n.menu-item:first-child {\n  margin-left: 0;\n}\n.menu-item.active-state:not(.menu-item-dropdown-opened) {\n  background-color: rgba(0, 0, 0, 0.7);\n}\n.menu-item.icon-only {\n  padding-left: 0;\n  padding-right: 0;\n}\n.menu-item-content {\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  padding: 0 var(--f7-menu-item-padding-horizontal);\n  height: 100%;\n  box-sizing: border-box;\n  width: 100%;\n  overflow: hidden;\n  border-radius: var(--f7-menu-item-border-radius);\n  position: relative;\n}\n.menu-item-content.icon-only,\n.icon-only .menu-item-content {\n  padding-left: 0;\n  padding-right: 0;\n}\n.menu-item-dropdown .menu-item-content:after {\n  content: '';\n  position: absolute;\n  width: 20px;\n  height: 2px;\n  left: 50%;\n  transform: translateX(-50%);\n  bottom: 4px;\n  background: var(--f7-menu-item-dropdown-icon-color);\n  border-radius: 4px;\n}\n.menu-dropdown {\n  opacity: 0;\n  visibility: hidden;\n  pointer-events: none;\n  cursor: auto;\n  height: 10px;\n  background: var(--f7-menu-bg-color);\n  position: relative;\n}\n.menu-dropdown-content {\n  position: absolute;\n  top: 100%;\n  border-radius: var(--f7-menu-dropdown-border-radius, var(--f7-menu-item-border-radius));\n  padding-top: var(--f7-menu-dropdown-padding-vertical);\n  padding-bottom: var(--f7-menu-dropdown-padding-vertical);\n  box-sizing: border-box;\n  background: var(--f7-menu-bg-color);\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n  min-width: calc(100% + 24px);\n}\n.menu-dropdown-link,\n.menu-dropdown-item {\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n  padding-left: var(--f7-menu-item-padding-horizontal);\n  padding-right: var(--f7-menu-item-padding-horizontal);\n  min-height: var(--f7-menu-dropdown-item-height);\n  line-height: var(--f7-menu-line-height);\n  font-size: var(--f7-menu-font-size);\n  color: var(--f7-menu-text-color);\n  font-weight: var(--f7-menu-font-weight);\n  white-space: nowrap;\n  min-width: 100px;\n}\n.menu-dropdown-link i,\n.menu-dropdown-item i,\n.menu-dropdown-link i.icon,\n.menu-dropdown-item i.icon,\n.menu-dropdown-link i.f7-icons,\n.menu-dropdown-item i.f7-icons,\n.menu-dropdown-link i.material-icons,\n.menu-dropdown-item i.material-icons {\n  font-size: 20px;\n}\n.menu-dropdown-link.active-state {\n  background: var(--f7-menu-dropdown-pressed-bg-color, var(--f7-theme-color));\n  color: var(--f7-menu-text-color);\n}\n.menu-dropdown-divider {\n  height: 1px;\n  margin-top: 2px;\n  margin-bottom: 2px;\n  background: var(--f7-menu-dropdown-divider-color);\n}\n.menu-item-dropdown-opened {\n  border-bottom-left-radius: 0px;\n  border-bottom-right-radius: 0px;\n}\n.menu-item-dropdown-opened .menu-item-content:after {\n  opacity: 0;\n}\n.menu-item-dropdown-opened .menu-dropdown {\n  opacity: 1;\n  visibility: visible;\n  pointer-events: auto;\n}\n.menu-item-dropdown-left .menu-dropdown:after,\n.menu-item-dropdown-center .menu-dropdown:after,\n.menu-dropdown-left:after,\n.menu-dropdown-center:after {\n  content: '';\n  position: absolute;\n  left: 100%;\n  bottom: 0;\n  width: var(--f7-menu-item-border-radius);\n  height: var(--f7-menu-item-border-radius);\n  background-image: radial-gradient(ellipse at 100% 0%, transparent 0%, transparent 70%, var(--f7-menu-bg-color) 72%);\n}\n.menu-item-dropdown-right .menu-dropdown:before,\n.menu-item-dropdown-center .menu-dropdown:before,\n.menu-dropdown-right:before,\n.menu-dropdown-center:before {\n  content: '';\n  position: absolute;\n  right: 100%;\n  bottom: 0;\n  width: var(--f7-menu-item-border-radius);\n  height: var(--f7-menu-item-border-radius);\n  background-image: radial-gradient(ellipse at 0% 0%, transparent 0%, transparent 70%, var(--f7-menu-bg-color) 72%);\n}\n.menu-item-dropdown-left .menu-dropdown-content,\n.menu-dropdown-left .menu-dropdown-content {\n  left: 0;\n  border-top-left-radius: 0px;\n}\n.menu-item-dropdown-right .menu-dropdown-content,\n.menu-dropdown-right .menu-dropdown-content {\n  right: 0;\n  border-top-right-radius: 0px;\n}\n.menu-item-dropdown-center .menu-dropdown-content,\n.menu-dropdown-center .menu-dropdown-content {\n  left: 50%;\n  min-width: calc(100% + 24px + 24px);\n  transform: translateX(-50%);\n}\n/* === Color Picker === */\n:root {\n  --f7-color-picker-popover-width: 350px;\n  --f7-color-picker-slider-size: 6px;\n  --f7-color-picker-slider-knob-size: 16px;\n  --f7-color-picker-bar-size: 50px;\n  --f7-color-picker-bar-min-height: 260px;\n  --f7-color-picker-value-width: 64px;\n  --f7-color-picker-value-height: 32px;\n  --f7-color-picker-value-font-size: 16px;\n  --f7-color-picker-value-border-radius: 4px;\n  --f7-color-picker-hex-value-width: 84px;\n  --f7-color-picker-label-font-size: 14px;\n  --f7-color-picker-label-width: 10px;\n  --f7-color-picker-label-height: 14px;\n  --f7-color-picker-sb-spectrum-height: 260px;\n  --f7-color-picker-sb-spectrum-handle-size: 16px;\n  --f7-color-picker-wheel-width: 330px;\n  --f7-color-picker-palette-value-width: 36px;\n  --f7-color-picker-palette-value-height: 36px;\n  --f7-color-picker-initial-current-color-height: 40px;\n  --f7-color-picker-initial-current-color-border-radius: 4px;\n  --f7-color-picker-sheet-bg-color: #fff;\n  --f7-color-picker-popup-bg-color: #fff;\n  --f7-color-picker-value-bg-color: rgba(0, 0, 0, 0.05);\n  --f7-color-picker-group-bg-color: rgba(0, 0, 0, 0.05);\n  --f7-color-picker-group-value-bg-color: #fff;\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-color-picker-sheet-bg-color: #121212;\n  --f7-color-picker-popup-bg-color: #121212;\n  --f7-color-picker-value-bg-color: rgba(255, 255, 255, 0.1);\n  --f7-color-picker-group-bg-color: #000;\n  --f7-color-picker-group-value-bg-color: rgba(255, 255, 255, 0.12);\n}\n.color-picker {\n  overflow: hidden;\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n}\n.color-picker.color-picker-inline,\n.color-picker-popover .color-picker,\n.color-picker-popup .color-picker {\n  position: relative;\n}\n.color-picker-sheet-modal {\n  background: var(--f7-color-picker-sheet-bg-color);\n}\n.color-picker-sheet-modal:before {\n  z-index: 600;\n}\n.color-picker-sheet-modal .sheet-modal-inner {\n  margin-bottom: var(--f7-safe-area-bottom);\n}\n.color-picker-popup .page {\n  background: var(--f7-color-picker-popup-bg-color);\n}\n.color-picker-popup .page-content {\n  padding-bottom: var(--f7-safe-area-bottom);\n}\n.color-picker-popover .color-picker,\n.color-picker-popup .color-picker,\n.color-picker-page .color-picker {\n  height: 100%;\n}\n.color-picker-popover .color-picker .toolbar,\n.color-picker-popup .color-picker .toolbar,\n.color-picker-page .color-picker .toolbar {\n  position: absolute;\n}\n.color-picker-popover {\n  width: var(--f7-color-picker-popover-width);\n  max-width: 90vw;\n  max-height: 80vh;\n}\n.color-picker-popover .color-picker {\n  max-height: 80vh;\n}\n.color-picker-popover .toolbar-top {\n  border-top-left-radius: var(--f7-popover-border-radius);\n  border-top-right-radius: var(--f7-popover-border-radius);\n}\n.color-picker-popover .color-picker-module-palette {\n  overflow: hidden;\n  flex-shrink: 0;\n}\n.color-picker-popover .color-picker-module-palette:first-child {\n  border-top-left-radius: var(--f7-popover-border-radius);\n  border-top-right-radius: var(--f7-popover-border-radius);\n}\n.color-picker-popover .color-picker-module-palette:last-child {\n  border-bottom-left-radius: var(--f7-popover-border-radius);\n  border-bottom-right-radius: var(--f7-popover-border-radius);\n}\n.color-picker-popover .color-picker-module-palette:first-child:last-child {\n  border-radius: var(--f7-popover-border-radius);\n}\n.color-picker-popover .toolbar ~ .page-content .color-picker-module-palette:first-child {\n  border-top-left-radius: 0;\n  border-top-right-radius: 0;\n}\n.color-picker-popup .page-content,\n.color-picker-popover .page-content,\n.color-picker-sheet-modal .page-content,\n.color-picker-page .page-content {\n  display: flex;\n  justify-content: flex-start;\n  align-items: stretch;\n  flex-direction: column;\n  overflow-x: hidden;\n}\n.color-picker-module {\n  margin-top: 5px;\n}\n.color-picker-module:last-child {\n  margin-bottom: 5px;\n}\n.color-picker-module-sb-spectrum,\n.color-picker-module-hs-spectrum {\n  margin-left: 10px;\n  margin-right: 10px;\n}\n.color-picker-module-sb-spectrum:first-child,\n.color-picker-module-hs-spectrum:first-child {\n  margin-top: 10px;\n}\n.color-picker-module-sb-spectrum .color-picker-sb-spectrum,\n.color-picker-module-hs-spectrum .color-picker-sb-spectrum,\n.color-picker-module-sb-spectrum .color-picker-hs-spectrum,\n.color-picker-module-hs-spectrum .color-picker-hs-spectrum {\n  border-radius: 4px;\n  height: var(--f7-color-picker-sb-spectrum-height);\n}\n.color-picker-sb-spectrum {\n  background-color: #000;\n  background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0) 0%, #000 100%), linear-gradient(to left, rgba(255, 255, 255, 0) 0%, #fff 100%);\n  position: relative;\n}\n.color-picker-hs-spectrum {\n  position: relative;\n  background-image: linear-gradient(to right, hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(0, 100%, 50%));\n}\n.color-picker-hs-spectrum:after {\n  content: '';\n  position: absolute;\n  left: 0;\n  top: 0;\n  width: 100%;\n  height: 100%;\n  background-image: linear-gradient(to bottom, rgba(255, 255, 255, 0), #ffffff);\n}\n.color-picker-sb-spectrum-handle,\n.color-picker-hs-spectrum-handle {\n  width: 4px;\n  height: 4px;\n  position: absolute;\n  left: -2px;\n  top: -2px;\n  z-index: 1;\n}\n.color-picker-sb-spectrum-handle:after,\n.color-picker-hs-spectrum-handle:after {\n  background-color: inherit;\n  content: '';\n  position: absolute;\n  width: var(--f7-color-picker-sb-spectrum-handle-size);\n  height: var(--f7-color-picker-sb-spectrum-handle-size);\n  border: 1px solid #fff;\n  border-radius: 50%;\n  box-shadow: 0px 0px 2px rgba(0, 0, 0, 0.5);\n  box-sizing: border-box;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  transition: 150ms;\n  transition-property: transform;\n  transform-origin: center;\n}\n.color-picker-sb-spectrum-handle.color-picker-sb-spectrum-handle-pressed:after,\n.color-picker-hs-spectrum-handle.color-picker-sb-spectrum-handle-pressed:after,\n.color-picker-sb-spectrum-handle.color-picker-hs-spectrum-handle-pressed:after,\n.color-picker-hs-spectrum-handle.color-picker-hs-spectrum-handle-pressed:after {\n  transform: scale(1.5) translate(-33.333%, -33.333%);\n}\n.color-picker-module-wheel {\n  margin-left: 10px;\n  margin-right: 10px;\n}\n.color-picker-wheel {\n  position: relative;\n  width: var(--f7-color-picker-wheel-width);\n  max-width: 100%;\n  height: auto;\n  font-size: 0;\n  margin-left: auto;\n  margin-right: auto;\n}\n.color-picker-wheel svg {\n  width: 100%;\n  height: auto;\n}\n.color-picker-wheel .color-picker-wheel-handle {\n  width: calc(100% / 6);\n  height: calc(100% / 6);\n  position: absolute;\n  box-sizing: border-box;\n  border: 2px solid #fff;\n  box-shadow: 0px 0px 5px rgba(0, 0, 0, 0.5);\n  background: red;\n  border-radius: 50%;\n  left: 0;\n  top: 0;\n}\n.color-picker-wheel .color-picker-sb-spectrum {\n  width: 45%;\n  height: 45%;\n  left: 50%;\n  top: 50%;\n  transform: translate3d(-50%, -50%, 0);\n  position: absolute;\n}\n.color-picker-slider-wrap {\n  display: flex;\n  align-items: center;\n  margin-bottom: 2px;\n}\n.color-picker-slider-wrap + .color-picker-slider-wrap {\n  margin-top: 5px;\n}\n.color-picker-hex-wrap {\n  justify-content: space-between;\n  display: flex;\n  align-items: center;\n}\n.color-picker-slider-label,\n.color-picker-hex-label {\n  font-size: var(--f7-color-picker-label-font-size);\n  width: var(--f7-color-picker-label-size);\n  flex-shrink: 0;\n  margin-right: 12px;\n}\n.color-picker-hex-label {\n  width: auto;\n}\n.color-picker-bar-value,\n.color-picker-slider-value,\n.color-picker-hex-value {\n  width: var(--f7-color-picker-value-width);\n  height: var(--f7-color-picker-value-height);\n  background: var(--f7-color-picker-value-bg-color);\n  border-radius: var(--f7-color-picker-value-border-radius);\n  text-align: center;\n  font-size: var(--f7-color-picker-value-font-size);\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-shrink: 0;\n  margin-left: 10px;\n}\n.color-picker-bar-value input,\n.color-picker-slider-value input,\n.color-picker-hex-value input {\n  width: 100%;\n  height: 100%;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border: none;\n  outline: 0;\n  background: transparent;\n  color: inherit;\n  font-family: inherit;\n  font-size: inherit;\n  text-align: center;\n  display: block;\n  border-radius: 4px;\n}\n.color-picker-bar-value input::-webkit-inner-spin-button,\n.color-picker-slider-value input::-webkit-inner-spin-button,\n.color-picker-hex-value input::-webkit-inner-spin-button,\n.color-picker-bar-value input::-webkit-outer-spin-button,\n.color-picker-slider-value input::-webkit-outer-spin-button,\n.color-picker-hex-value input::-webkit-outer-spin-button {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  margin: 0;\n  display: none;\n}\n.color-picker-hex-value {\n  width: var(--f7-color-picker-hex-value-width);\n}\n.color-picker-hex-value:first-child {\n  margin-left: auto;\n}\n.color-picker-slider {\n  --f7-range-bar-active-bg-color: transparent;\n  --f7-range-bar-size: var(--f7-color-picker-slider-size);\n  --f7-range-bar-border-radius: var(--f7-color-picker-slider-size);\n  --f7-range-knob-size: var(--f7-color-picker-slider-knob-size);\n  --f7-range-knob-box-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);\n}\n.color-picker-slider .range-knob {\n  transition-duration: 200ms;\n  transition-property: transform;\n}\n.color-picker-slider .range-knob:after {\n  width: 30px;\n  height: 30px;\n  margin-left: -16px;\n  margin-top: -16px;\n}\n.color-picker-slider .range-knob-active-state .range-knob {\n  transform: scale(1.5);\n}\n.md .color-picker-slider.range-slider-min:not(.range-slider-dual) .range-knob {\n  background: var(--f7-range-knob-color) !important;\n  border: none;\n}\n.color-picker-module-rgb-bars {\n  display: flex;\n  justify-content: space-around;\n  justify-content: space-evenly;\n  align-items: stretch;\n  height: 100%;\n  min-height: var(--f7-color-picker-bar-min-height);\n  padding-bottom: 10px;\n  padding-top: 10px;\n  box-sizing: border-box;\n}\n.color-picker-bar-wrap {\n  display: flex;\n  align-items: center;\n  flex-direction: column-reverse;\n}\n.color-picker-bar {\n  --f7-range-bar-active-bg-color: transparent;\n  --f7-range-bar-size: var(--f7-color-picker-bar-size);\n  --f7-range-bar-border-radius: 2px;\n  --f7-range-knob-size: 6px;\n  --f7-range-knob-box-shadow: 0 0px 3px rgba(0, 0, 0, 0.3);\n  --f7-range-knob-color: #fff;\n}\n.color-picker-bar .range-knob {\n  transition-duration: 0ms;\n  transition-property: transform;\n  border-radius: 3px;\n}\n.color-picker-bar .range-knob-wrap {\n  height: 6px;\n  width: calc(var(--f7-color-picker-bar-size) - 4px);\n  margin-left: calc(-0.5 * (var(--f7-color-picker-bar-size) - 4px));\n}\n.color-picker-bar .range-knob-active-state .range-knob {\n  transform: scale(1);\n}\n.md .color-picker-bar.range-slider-min:not(.range-slider-dual) .range-knob {\n  background: var(--f7-range-knob-color) !important;\n  border: none;\n}\n.color-picker-bar-label {\n  font-size: var(--f7-color-picker-label-size);\n  margin-top: 12px;\n  line-height: 1;\n  height: var(--f7-color-picker-label-height);\n  flex-shrink: 0;\n}\n.color-picker-bar-value {\n  margin-left: 0;\n  margin-bottom: 10px;\n}\n.color-picker-slider-alpha {\n  --f7-range-knob-color: #fff;\n}\n.color-picker-slider-alpha .range-bar {\n  background-image: linear-gradient(to right, rgba(0, 0, 0, 0), #000), linear-gradient(to right, rgba(255, 255, 255, 0.2) 50%, rgba(0, 0, 0, 0.2) 50%), linear-gradient(to left, rgba(255, 255, 255, 0.2) 50%, rgba(0, 0, 0, 0.2) 50%);\n  background-size: 100% 100%, 6px 3px, 6px 3px;\n  background-position: 0 0, 0px 3px, 0 0;\n  background-repeat: repeat-y, repeat-x, repeat-x;\n}\n.color-picker-slider-hue .range-bar {\n  background-image: linear-gradient(to right, hsl(0, 100%, 50%), hsl(60, 100%, 50%), hsl(120, 100%, 50%), hsl(180, 100%, 50%), hsl(240, 100%, 50%), hsl(300, 100%, 50%), hsl(0, 100%, 50%));\n}\n.color-picker-slider-brightness .range-bar {\n  background-image: linear-gradient(to right, #000, #fff);\n}\n.color-picker-module-palette {\n  margin-top: 16px;\n}\n.color-picker-module-palette:first-child {\n  margin-top: 0;\n}\n.color-picker-module-palette:last-child {\n  margin-bottom: 0;\n}\n.color-picker-module-palette:first-child:last-child {\n  margin: 0;\n}\n.color-picker-palette {\n  display: flex;\n  flex-wrap: wrap;\n}\n.color-picker-palette-row {\n  width: 100%;\n  display: flex;\n  flex-wrap: nowrap;\n}\n.color-picker-palette-row .color-picker-palette-value {\n  width: 100%;\n}\n.color-picker-palette-value {\n  width: var(--f7-color-picker-palette-value-width);\n  height: var(--f7-color-picker-palette-value-height);\n  cursor: pointer;\n}\n.color-picker-module-initial-current-colors,\n.color-picker-module-current-color {\n  margin-left: 10px;\n  margin-right: 10px;\n  border-radius: var(--f7-color-picker-initial-current-color-border-radius);\n  overflow: hidden;\n  flex-shrink: 0;\n}\n.color-picker-initial-color,\n.color-picker-current-color {\n  height: var(--f7-color-picker-initial-current-color-height);\n}\n.color-picker-initial-current-colors {\n  display: flex;\n}\n.color-picker-initial-current-colors .color-picker-initial-color,\n.color-picker-initial-current-colors .color-picker-current-color {\n  width: 50%;\n}\n.color-picker-module-rgb-sliders,\n.color-picker-module-hsb-sliders,\n.color-picker-module-alpha-slider,\n.color-picker-module-hue-slider,\n.color-picker-module-brightness-slider,\n.color-picker-module-hex {\n  margin-left: 10px;\n  margin-right: 10px;\n}\n.color-picker-grouped-modules .color-picker-module-rgb-sliders,\n.color-picker-grouped-modules .color-picker-module-hsb-sliders,\n.color-picker-grouped-modules .color-picker-module-alpha-slider,\n.color-picker-grouped-modules .color-picker-module-hue-slider,\n.color-picker-grouped-modules .color-picker-module-brightness-slider,\n.color-picker-grouped-modules .color-picker-module-hex {\n  background: var(--f7-color-picker-group-bg-color);\n  padding: 5px;\n  border-radius: 4px;\n  margin-top: 16px;\n  margin-left: 5px;\n  margin-right: 5px;\n}\n.color-picker-grouped-modules .color-picker-module-rgb-sliders:last-child,\n.color-picker-grouped-modules .color-picker-module-hsb-sliders:last-child,\n.color-picker-grouped-modules .color-picker-module-alpha-slider:last-child,\n.color-picker-grouped-modules .color-picker-module-hue-slider:last-child,\n.color-picker-grouped-modules .color-picker-module-brightness-slider:last-child,\n.color-picker-grouped-modules .color-picker-module-hex:last-child {\n  margin-bottom: 16px;\n}\n.color-picker-grouped-modules .color-picker-slider-value,\n.color-picker-grouped-modules .color-picker-hex-value {\n  background: var(--f7-color-picker-group-value-bg-color);\n}\n.color-picker-grouped-modules .color-picker-slider-label,\n.color-picker-grouped-modules .color-picker-hex-label {\n  margin-left: 5px;\n}\n.color-picker-grouped-modules .color-picker-module-rgb-sliders .range-slider:first-child,\n.color-picker-grouped-modules .color-picker-module-hsb-sliders .range-slider:first-child,\n.color-picker-grouped-modules .color-picker-module-alpha-slider .range-slider:first-child,\n.color-picker-grouped-modules .color-picker-module-hue-slider .range-slider:first-child,\n.color-picker-grouped-modules .color-picker-module-brightness-slider .range-slider:first-child {\n  margin-left: 5px;\n}\n.color-picker-grouped-modules .color-picker-module-rgb-sliders .range-slider:last-child,\n.color-picker-grouped-modules .color-picker-module-hsb-sliders .range-slider:last-child,\n.color-picker-grouped-modules .color-picker-module-alpha-slider .range-slider:last-child,\n.color-picker-grouped-modules .color-picker-module-hue-slider .range-slider:last-child,\n.color-picker-grouped-modules .color-picker-module-brightness-slider .range-slider:last-child {\n  margin-right: 5px;\n}\n/* === Treeview === */\n:root {\n  --f7-treeview-item-padding-left: 16px;\n  --f7-treeview-item-padding-right: 16px;\n  --f7-treeview-toggle-size: 24px;\n  --f7-treeview-children-offset: 29px;\n  --f7-treeview-label-font-weight: 400;\n  --f7-treeview-label-text-color: inherit;\n  /*\n  --f7-treeview-selectable-selected-bg-color: rgba(var(--f7-theme-color-rgb), 0.2);\n  */\n  --f7-treeview-toggle-color: rgba(0, 0, 0, 0.5);\n  --f7-treeview-toggle-hover-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-treeview-toggle-pressed-bg-color: rgba(0, 0, 0, 0.15);\n  --f7-treeview-icon-color: rgba(0, 0, 0, 0.5);\n  --f7-treeview-selectable-hover-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-treeview-link-hover-bg-color: rgba(0, 0, 0, 0.1);\n  --f7-treeview-link-pressed-bg-color: rgba(0, 0, 0, 0.15);\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-treeview-toggle-color: rgba(255, 255, 255, 0.5);\n  --f7-treeview-toggle-hover-bg-color: rgba(255, 255, 255, 0.03);\n  --f7-treeview-toggle-pressed-bg-color: rgba(255, 255, 255, 0.1);\n  --f7-treeview-icon-color: rgba(255, 255, 255, 0.75);\n  --f7-treeview-selectable-hover-bg-color: rgba(255, 255, 255, 0.03);\n  --f7-treeview-link-hover-bg-color: rgba(255, 255, 255, 0.03);\n  --f7-treeview-link-pressed-bg-color: rgba(255, 255, 255, 0.11);\n}\n.ios {\n  --f7-treeview-item-height: 34px;\n  --f7-treeview-label-font-size: 17px;\n  --f7-treeview-icon-size: 24px;\n}\n.md {\n  --f7-treeview-item-height: 34px;\n  --f7-treeview-label-font-size: 16px;\n  --f7-treeview-icon-size: 24px;\n}\n.aurora {\n  --f7-treeview-item-height: 28px;\n  --f7-treeview-label-font-size: 14px;\n  --f7-treeview-icon-size: 20px;\n}\n.treeview-item-root {\n  padding-left: var(--f7-treeview-item-padding-left);\n  padding-right: var(--f7-treeview-item-padding-right);\n  height: var(--f7-treeview-item-height);\n  display: flex;\n  align-items: center;\n  justify-content: flex-start;\n}\n.treeview-item-content {\n  display: flex;\n  justify-content: flex-start;\n  align-items: center;\n}\n.treeview-item-content > i,\n.treeview-item-content > .f7-icons,\n.treeview-item-content > .material-icons {\n  font-size: var(--f7-treeview-icon-size);\n  color: var(--f7-treeview-icon-color);\n}\n.treeview-item-content:first-child {\n  margin-left: calc(var(--f7-treeview-toggle-size) + 5px);\n}\n.treeview-item-content > * + * {\n  margin-left: 5px;\n}\n.treeview-item-label {\n  font-size: var(--f7-treeview-label-font-size);\n  font-weight: var(--f7-treeview-label-font-weight);\n  color: var(--f7-treeview-label-text-color);\n}\n.treeview-toggle {\n  width: var(--f7-treeview-toggle-size);\n  height: var(--f7-treeview-toggle-size);\n  cursor: pointer;\n  border-radius: 4px;\n  background-color: rgba(0, 0, 0, 0);\n  transition-duration: 200ms;\n  position: relative;\n  margin-right: 5px;\n}\n.treeview-toggle.active-state {\n  background-color: var(--f7-treeview-toggle-pressed-bg-color);\n}\n.treeview-toggle:after {\n  transition-duration: 200ms;\n  content: '';\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  width: 0;\n  height: 0;\n  border-top: 5px solid transparent;\n  border-bottom: 5px solid transparent;\n  transform: translate(-50%, -50%);\n  border-left: 6px solid var(--f7-treeview-toggle-color);\n}\n.treeview-toggle-hidden {\n  opacity: 0;\n  pointer-events: none;\n  visibility: hidden;\n}\n.treeview-preloader {\n  --f7-preloader-size: var(--f7-treeview-toggle-size);\n  margin-right: calc(-1 * var(--f7-treeview-toggle-size));\n}\n.treeview-item-children {\n  display: none;\n}\n.treeview-item-opened > .treeview-item-children {\n  display: block;\n}\n.treeview-item-opened > .treeview-item-root .treeview-toggle:after {\n  transform: translate(-50%, -50%) rotate(90deg);\n}\na.treeview-item-root {\n  color: var(--f7-treeview-label-text-color);\n}\n.treeview-item-selectable > .treeview-item-root,\n.treeview-item-selectable.treeview-item-root {\n  cursor: pointer;\n  transition-duration: 150ms;\n}\na.treeview-item-root {\n  transition-duration: 150ms;\n}\na.treeview-item-root.active-state {\n  background: var(--f7-treeview-link-pressed-bg-color);\n}\n.treeview-item-toggle > .treeview-item-root,\n.treeview-item-toggle.treeview-item-root {\n  cursor: pointer;\n}\n.treeview-item-selected > .treeview-item-root,\n.treeview-item-selected.treeview-item-root {\n  background: var(--f7-treeview-selectable-selected-bg-color, rgba(var(--f7-theme-color-rgb), 0.2));\n}\n.treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 1);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 2);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 3);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 4);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 5);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 6);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 7);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 8);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 9);\n}\n.treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item .treeview-item-root {\n  padding-left: calc(var(--f7-treeview-item-padding-left) + var(--f7-treeview-children-offset) * 10);\n}\n.aurora .treeview-toggle:hover {\n  background-color: var(--f7-treeview-toggle-hover-bg-color);\n}\n.aurora .treeview-toggle.active-state {\n  background-color: var(--f7-treeview-toggle-pressed-bg-color);\n}\n.aurora .treeview-item-selectable > .treeview-item-root:hover,\n.aurora .treeview-item-selectable.treeview-item-root:hover {\n  background: var(--f7-treeview-selectable-hover-bg-color);\n}\n.aurora a.treeview-item-root:hover {\n  background: var(--f7-treeview-link-hover-bg-color);\n}\n.aurora a.treeview-item-root.active-state {\n  background: var(--f7-treeview-link-pressed-bg-color);\n}\n.aurora .treeview-item-selected > .treeview-item-root:hover,\n.aurora .treeview-item-selected.treeview-item-root:hover {\n  background: var(--f7-treeview-selectable-selected-bg-color, rgba(var(--f7-theme-color-rgb), 0.2));\n}\n/* === Stepper === */\n:root {\n  --f7-text-editor-font-size: inherit;\n  --f7-text-editor-font-weight: inherit;\n  --f7-text-editor-border-width: 1px;\n  --f7-text-editor-height: 250px;\n  --f7-text-editor-margin: 16px;\n  --f7-text-editor-padding: 8px;\n  --f7-text-editor-button-bg-color: transparent;\n  --f7-text-editor-button-size: 28px;\n  --f7-text-editor-button-icon-size: 20px;\n  --f7-text-editor-button-margin: 2px;\n  --f7-text-editor-button-border-radius: 2px;\n  --f7-text-editor-text-color: #000;\n  --f7-text-editor-bg-color: #fff;\n  --f7-text-editor-border-color: rgba(0, 0, 0, 0.1);\n  --f7-text-editor-toolbar-bg-color: #fff;\n  --f7-text-editor-button-text-color: #333;\n  --f7-text-editor-button-divider-color: rgba(0, 0, 0, 0.15);\n  --f7-text-editor-placeholder-color: rgba(0, 0, 0, 0.35);\n}\n:root .theme-dark,\n:root.theme-dark {\n  --f7-text-editor-bg-color: #121212;\n  --f7-text-editor-border-color: rgba(255, 255, 255, 0.1);\n  --f7-text-editor-toolbar-bg-color: #202020;\n  --f7-text-editor-text-color: #fff;\n  --f7-text-editor-placeholder-color: rgba(255, 255, 255, 0.35);\n  --f7-text-editor-button-text-color: #fff;\n  --f7-text-editor-button-divider-color: rgba(255, 255, 255, 0.15);\n}\n.ios {\n  --f7-text-editor-toolbar-padding: 6px;\n  --f7-text-editor-toolbar-border-color: rgba(0, 0, 0, 0.25);\n}\n.ios .theme-dark,\n.ios.theme-dark {\n  --f7-text-editor-toolbar-bg-color: #121212;\n  --f7-text-editor-toolbar-border-color: rgba(255, 255, 255, 0.1);\n}\n.md {\n  --f7-text-editor-toolbar-padding: 8px;\n  --f7-text-editor-toolbar-box-shadow: 0px 2px 3px -1px rgba(0, 0, 0, 0.25);\n}\n.aurora {\n  --f7-text-editor-toolbar-padding: 3px;\n  --f7-text-editor-toolbar-border-color: rgba(0, 0, 0, 0.25);\n}\n.aurora .theme-dark,\n.aurora.theme-dark {\n  --f7-text-editor-toolbar-border-color: rgba(255, 255, 255, 0.1);\n}\n.text-editor {\n  margin: var(--f7-text-editor-margin);\n  background-color: var(--f7-text-editor-bg-color);\n  display: block;\n  position: relative;\n  border: var(--f7-text-editor-border-width) solid var(--f7-text-editor-border-color);\n  display: flex;\n  flex-direction: column;\n  align-items: stretch;\n  height: var(--f7-text-editor-height);\n  box-sizing: border-box;\n}\n.text-editor.text-editor-resizable {\n  height: auto;\n}\n.text-editor-toolbar {\n  display: flex;\n  flex-wrap: wrap;\n  background: var(--f7-text-editor-toolbar-bg-color);\n  z-index: 100;\n  position: relative;\n  position: -webkit-sticky;\n  position: sticky;\n  left: 0;\n  top: 0;\n  padding: var(--f7-text-editor-toolbar-padding);\n  flex-shrink: 0;\n  box-shadow: var(--f7-text-editor-toolbar-box-shadow);\n  box-sizing: border-box;\n}\n.text-editor-toolbar:after {\n  content: '';\n  position: absolute;\n  background-color: var(--f7-text-editor-toolbar-border-color);\n  display: block;\n  z-index: 15;\n  top: auto;\n  right: auto;\n  bottom: 0;\n  left: 0;\n  height: 1px;\n  width: 100%;\n  transform-origin: 50% 100%;\n  transform: scaleY(calc(1 / var(--f7-device-pixel-ratio)));\n}\nbutton.text-editor-button {\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border: none;\n  padding: 0;\n  margin: 0;\n  outline: 0;\n  font-family: inherit;\n  background: transparent;\n  cursor: pointer;\n  box-shadow: none;\n  border-radius: var(--f7-text-editor-button-border-radius);\n  position: relative;\n  z-index: 1;\n  display: flex;\n  width: auto;\n  overflow: hidden;\n  width: var(--f7-text-editor-button-size);\n  height: var(--f7-text-editor-button-size);\n  align-items: center;\n  justify-content: center;\n  margin: var(--f7-text-editor-button-margin);\n  box-sizing: border-box;\n  color: var(--f7-text-editor-button-text-color);\n  background-color: var(--f7-text-editor-button-bg-color);\n  flex-shrink: 0;\n}\nbutton.text-editor-button i {\n  font-size: var(--f7-text-editor-button-icon-size);\n  font-style: normal;\n}\nbutton.text-editor-button i sup,\nbutton.text-editor-button i sub {\n  font-size: 60%;\n}\n.text-editor-button-divider {\n  width: 1px;\n  background: var(--f7-text-editor-button-divider-color);\n  margin: 0 2px;\n  flex-shrink: 0;\n}\n.text-editor-content {\n  -webkit-user-modify: read-write;\n  -webkit-appearance: none;\n     -moz-appearance: none;\n          appearance: none;\n  border: none;\n  outline: 0;\n  height: 100%;\n  -webkit-user-select: text;\n     -moz-user-select: text;\n          user-select: text;\n  padding: var(--f7-text-editor-padding);\n  overflow: auto;\n  flex-shrink: 10;\n  box-sizing: border-box;\n  color: var(--f7-text-editor-text-color);\n  font-size: var(--f7-text-editor-font-size);\n  font-weight: var(--f7-text-editor-font-weight);\n}\n.text-editor-content .text-editor-placeholder {\n  pointer-events: none;\n  color: var(--f7-text-editor-placeholder-color);\n}\n.text-editor-content img {\n  max-width: 100%;\n}\n.text-editor-content a {\n  pointer-events: none;\n}\n.text-editor-popover {\n  z-index: 12500;\n  width: auto;\n  max-width: 80vw;\n}\n.text-editor-popover .popover-inner {\n  display: flex;\n  flex-wrap: wrap;\n  padding: 3px;\n}\n.text-editor-keyboard-toolbar {\n  position: absolute;\n  z-index: 6000;\n  --f7-safe-area-bottom: 0px;\n}\n.text-editor-keyboard-toolbar .toolbar-inner {\n  justify-content: flex-start !important;\n  overflow: auto;\n  -webkit-overflow-scrolling: touch;\n}\n.text-editor-keyboard-toolbar .toolbar-inner::-webkit-scrollbar {\n  display: none;\n}\n.text-editor-keyboard-toolbar .toolbar-inner .text-editor-button-divider {\n  height: 100%;\n}\n.item-input .text-editor {\n  border: none;\n  margin: 0;\n  background-color: var(--f7-input-bg-color, transparent);\n}\n.item-input .text-editor-content {\n  padding-top: var(--f7-textarea-padding-vertical);\n  padding-bottom: var(--f7-textarea-padding-vertical);\n  padding-left: var(--f7-input-padding-left);\n  padding-right: var(--f7-input-padding-right);\n  color: var(--f7-input-text-color);\n  font-size: var(--f7-input-font-size);\n}\n.item-input .text-editor-toolbar {\n  box-shadow: none;\n}\n.item-input .text-editor-toolbar:after {\n  display: none !important;\n}\n.item-input-outline .text-editor-content {\n  border-radius: var(--f7-input-outline-border-radius);\n  padding-left: var(--f7-input-outline-padding-horizontal);\n  padding-right: var(--f7-input-outline-padding-horizontal);\n}\n.ios button.text-editor-button {\n  transition: opacity 300ms;\n}\n.ios button.text-editor-button.active-state {\n  opacity: 0.3;\n  transition-duration: 0ms;\n}\n.md button.text-editor-button:before {\n  content: '';\n  width: 152%;\n  height: 152%;\n  position: absolute;\n  left: -26%;\n  top: -26%;\n  background-image: radial-gradient(circle at center, var(--f7-link-highlight-color) 66%, rgba(255, 255, 255, 0) 66%);\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: 100% 100%;\n  opacity: 0;\n  pointer-events: none;\n  transition-duration: 600ms;\n}\n.md button.text-editor-button.active-state:before {\n  opacity: 1;\n  transition-duration: 150ms;\n}\n.md .text-editor-keyboard-toolbar .toolbar-inner {\n  padding-left: 8px;\n  padding-right: 8px;\n}\n.aurora button.text-editor-button {\n  transition: opacity 300ms;\n}\n.aurora button.text-editor-button.active-state {\n  opacity: 0.3;\n  transition-duration: 0ms;\n}\n/* === Elevation === */\n:root {\n  --f7-elevation-0: 0px 0px 0px 0px rgba(0, 0, 0, 0);\n  --f7-elevation-1: 0px 2px 1px -1px rgba(0, 0, 0, 0.2),\n    0px 1px 1px 0px rgba(0, 0, 0, 0.14),\n    0px 1px 3px 0px rgba(0, 0, 0, 0.12);\n  --f7-elevation-2: 0px 3px 1px -2px rgba(0, 0, 0, 0.2),\n    0px 2px 2px 0px rgba(0, 0, 0, 0.14),\n    0px 1px 5px 0px rgba(0, 0, 0, 0.12);\n  --f7-elevation-3: 0px 3px 3px -2px rgba(0, 0, 0, 0.2),\n    0px 3px 4px 0px rgba(0, 0, 0, 0.14),\n    0px 1px 8px 0px rgba(0, 0, 0, 0.12);\n  --f7-elevation-4: 0px 2px 4px -1px rgba(0, 0, 0, 0.2),\n    0px 4px 5px 0px rgba(0, 0, 0, 0.14),\n    0px 1px 10px 0px rgba(0, 0, 0, 0.12);\n  --f7-elevation-5: 0px 3px 5px -1px rgba(0, 0, 0, 0.2),\n    0px 5px 8px 0px rgba(0, 0, 0, 0.14),\n    0px 1px 14px 0px rgba(0, 0, 0, 0.12);\n  --f7-elevation-6: 0px 3px 5px -1px rgba(0, 0, 0, 0.2),\n    0px 6px 10px 0px rgba(0, 0, 0, 0.14),\n    0px 1px 18px 0px rgba(0, 0, 0, 0.12);\n  --f7-elevation-7: 0px 4px 5px -2px rgba(0, 0, 0, 0.2),\n    0px 7px 10px 1px rgba(0, 0, 0, 0.14),\n    0px 2px 16px 1px rgba(0, 0, 0, 0.12);\n  --f7-elevation-8: 0px 5px 5px -3px rgba(0, 0, 0, 0.2),\n    0px 8px 10px 1px rgba(0, 0, 0, 0.14),\n    0px 3px 14px 2px rgba(0, 0, 0, 0.12);\n  --f7-elevation-9: 0px 5px 6px -3px rgba(0, 0, 0, 0.2),\n    0px 9px 12px 1px rgba(0, 0, 0, 0.14),\n    0px 3px 16px 2px rgba(0, 0, 0, 0.12);\n  --f7-elevation-10: 0px 6px 6px -3px rgba(0, 0, 0, 0.2),\n    0px 10px 14px 1px rgba(0, 0, 0, 0.14),\n    0px 4px 18px 3px rgba(0, 0, 0, 0.12);\n  --f7-elevation-11: 0px 6px 7px -4px rgba(0, 0, 0, 0.2),\n    0px 11px 15px 1px rgba(0, 0, 0, 0.14),\n    0px 4px 20px 3px rgba(0, 0, 0, 0.12);\n  --f7-elevation-12: 0px 7px 8px -4px rgba(0, 0, 0, 0.2),\n    0px 12px 17px 2px rgba(0, 0, 0, 0.14),\n    0px 5px 22px 4px rgba(0, 0, 0, 0.12);\n  --f7-elevation-13: 0px 7px 8px -4px rgba(0, 0, 0, 0.2),\n    0px 13px 19px 2px rgba(0, 0, 0, 0.14),\n    0px 5px 24px 4px rgba(0, 0, 0, 0.12);\n  --f7-elevation-14: 0px 7px 9px -4px rgba(0, 0, 0, 0.2),\n    0px 14px 21px 2px rgba(0, 0, 0, 0.14),\n    0px 5px 26px 4px rgba(0, 0, 0, 0.12);\n  --f7-elevation-15: 0px 8px 9px -5px rgba(0, 0, 0, 0.2),\n    0px 15px 22px 2px rgba(0, 0, 0, 0.14),\n    0px 6px 28px 5px rgba(0, 0, 0, 0.12);\n  --f7-elevation-16: 0px 8px 10px -5px rgba(0, 0, 0, 0.2),\n    0px 16px 24px 2px rgba(0, 0, 0, 0.14),\n    0px 6px 30px 5px rgba(0, 0, 0, 0.12);\n  --f7-elevation-17: 0px 8px 11px -5px rgba(0, 0, 0, 0.2),\n    0px 17px 26px 2px rgba(0, 0, 0, 0.14),\n    0px 6px 32px 5px rgba(0, 0, 0, 0.12);\n  --f7-elevation-18: 0px 9px 11px -5px rgba(0, 0, 0, 0.2),\n    0px 18px 28px 2px rgba(0, 0, 0, 0.14),\n    0px 7px 34px 6px rgba(0, 0, 0, 0.12);\n  --f7-elevation-19: 0px 9px 12px -6px rgba(0, 0, 0, 0.2),\n    0px 19px 29px 2px rgba(0, 0, 0, 0.14),\n    0px 7px 36px 6px rgba(0, 0, 0, 0.12);\n  --f7-elevation-20: 0px 10px 13px -6px rgba(0, 0, 0, 0.2),\n    0px 20px 31px 3px rgba(0, 0, 0, 0.14),\n    0px 8px 38px 7px rgba(0, 0, 0, 0.12);\n  --f7-elevation-21: 0px 10px 13px -6px rgba(0, 0, 0, 0.2),\n    0px 21px 33px 3px rgba(0, 0, 0, 0.14),\n    0px 8px 40px 7px rgba(0, 0, 0, 0.12);\n  --f7-elevation-22: 0px 10px 14px -6px rgba(0, 0, 0, 0.2),\n    0px 22px 35px 3px rgba(0, 0, 0, 0.14),\n    0px 8px 42px 7px rgba(0, 0, 0, 0.12);\n  --f7-elevation-23: 0px 11px 14px -7px rgba(0, 0, 0, 0.2),\n    0px 23px 36px 3px rgba(0, 0, 0, 0.14),\n    0px 9px 44px 8px rgba(0, 0, 0, 0.12);\n  --f7-elevation-24: 0px 11px 15px -7px rgba(0, 0, 0, 0.2),\n    0px 24px 38px 3px rgba(0, 0, 0, 0.14),\n    0px 9px 46px 8px rgba(0, 0, 0, 0.12);\n}\n.elevation-0 {\n  box-shadow: var(--f7-elevation-0) !important;\n}\n.elevation-1 {\n  box-shadow: var(--f7-elevation-1) !important;\n}\n.elevation-2 {\n  box-shadow: var(--f7-elevation-2) !important;\n}\n.elevation-3 {\n  box-shadow: var(--f7-elevation-3) !important;\n}\n.elevation-4 {\n  box-shadow: var(--f7-elevation-4) !important;\n}\n.elevation-5 {\n  box-shadow: var(--f7-elevation-5) !important;\n}\n.elevation-6 {\n  box-shadow: var(--f7-elevation-6) !important;\n}\n.elevation-7 {\n  box-shadow: var(--f7-elevation-7) !important;\n}\n.elevation-8 {\n  box-shadow: var(--f7-elevation-8) !important;\n}\n.elevation-9 {\n  box-shadow: var(--f7-elevation-9) !important;\n}\n.elevation-10 {\n  box-shadow: var(--f7-elevation-10) !important;\n}\n.elevation-11 {\n  box-shadow: var(--f7-elevation-11) !important;\n}\n.elevation-12 {\n  box-shadow: var(--f7-elevation-12) !important;\n}\n.elevation-13 {\n  box-shadow: var(--f7-elevation-13) !important;\n}\n.elevation-14 {\n  box-shadow: var(--f7-elevation-14) !important;\n}\n.elevation-15 {\n  box-shadow: var(--f7-elevation-15) !important;\n}\n.elevation-16 {\n  box-shadow: var(--f7-elevation-16) !important;\n}\n.elevation-17 {\n  box-shadow: var(--f7-elevation-17) !important;\n}\n.elevation-18 {\n  box-shadow: var(--f7-elevation-18) !important;\n}\n.elevation-19 {\n  box-shadow: var(--f7-elevation-19) !important;\n}\n.elevation-20 {\n  box-shadow: var(--f7-elevation-20) !important;\n}\n.elevation-21 {\n  box-shadow: var(--f7-elevation-21) !important;\n}\n.elevation-22 {\n  box-shadow: var(--f7-elevation-22) !important;\n}\n.elevation-23 {\n  box-shadow: var(--f7-elevation-23) !important;\n}\n.elevation-24 {\n  box-shadow: var(--f7-elevation-24) !important;\n}\n.device-desktop .elevation-hover-0:hover {\n  box-shadow: var(--f7-elevation-0) !important;\n}\n.device-desktop .elevation-hover-1:hover {\n  box-shadow: var(--f7-elevation-1) !important;\n}\n.device-desktop .elevation-hover-2:hover {\n  box-shadow: var(--f7-elevation-2) !important;\n}\n.device-desktop .elevation-hover-3:hover {\n  box-shadow: var(--f7-elevation-3) !important;\n}\n.device-desktop .elevation-hover-4:hover {\n  box-shadow: var(--f7-elevation-4) !important;\n}\n.device-desktop .elevation-hover-5:hover {\n  box-shadow: var(--f7-elevation-5) !important;\n}\n.device-desktop .elevation-hover-6:hover {\n  box-shadow: var(--f7-elevation-6) !important;\n}\n.device-desktop .elevation-hover-7:hover {\n  box-shadow: var(--f7-elevation-7) !important;\n}\n.device-desktop .elevation-hover-8:hover {\n  box-shadow: var(--f7-elevation-8) !important;\n}\n.device-desktop .elevation-hover-9:hover {\n  box-shadow: var(--f7-elevation-9) !important;\n}\n.device-desktop .elevation-hover-10:hover {\n  box-shadow: var(--f7-elevation-10) !important;\n}\n.device-desktop .elevation-hover-11:hover {\n  box-shadow: var(--f7-elevation-11) !important;\n}\n.device-desktop .elevation-hover-12:hover {\n  box-shadow: var(--f7-elevation-12) !important;\n}\n.device-desktop .elevation-hover-13:hover {\n  box-shadow: var(--f7-elevation-13) !important;\n}\n.device-desktop .elevation-hover-14:hover {\n  box-shadow: var(--f7-elevation-14) !important;\n}\n.device-desktop .elevation-hover-15:hover {\n  box-shadow: var(--f7-elevation-15) !important;\n}\n.device-desktop .elevation-hover-16:hover {\n  box-shadow: var(--f7-elevation-16) !important;\n}\n.device-desktop .elevation-hover-17:hover {\n  box-shadow: var(--f7-elevation-17) !important;\n}\n.device-desktop .elevation-hover-18:hover {\n  box-shadow: var(--f7-elevation-18) !important;\n}\n.device-desktop .elevation-hover-19:hover {\n  box-shadow: var(--f7-elevation-19) !important;\n}\n.device-desktop .elevation-hover-20:hover {\n  box-shadow: var(--f7-elevation-20) !important;\n}\n.device-desktop .elevation-hover-21:hover {\n  box-shadow: var(--f7-elevation-21) !important;\n}\n.device-desktop .elevation-hover-22:hover {\n  box-shadow: var(--f7-elevation-22) !important;\n}\n.device-desktop .elevation-hover-23:hover {\n  box-shadow: var(--f7-elevation-23) !important;\n}\n.device-desktop .elevation-hover-24:hover {\n  box-shadow: var(--f7-elevation-24) !important;\n}\n.active-state.elevation-pressed-0,\n.device-desktop .active-state.elevation-pressed-0 {\n  box-shadow: var(--f7-elevation-0) !important;\n}\n.active-state.elevation-pressed-1,\n.device-desktop .active-state.elevation-pressed-1 {\n  box-shadow: var(--f7-elevation-1) !important;\n}\n.active-state.elevation-pressed-2,\n.device-desktop .active-state.elevation-pressed-2 {\n  box-shadow: var(--f7-elevation-2) !important;\n}\n.active-state.elevation-pressed-3,\n.device-desktop .active-state.elevation-pressed-3 {\n  box-shadow: var(--f7-elevation-3) !important;\n}\n.active-state.elevation-pressed-4,\n.device-desktop .active-state.elevation-pressed-4 {\n  box-shadow: var(--f7-elevation-4) !important;\n}\n.active-state.elevation-pressed-5,\n.device-desktop .active-state.elevation-pressed-5 {\n  box-shadow: var(--f7-elevation-5) !important;\n}\n.active-state.elevation-pressed-6,\n.device-desktop .active-state.elevation-pressed-6 {\n  box-shadow: var(--f7-elevation-6) !important;\n}\n.active-state.elevation-pressed-7,\n.device-desktop .active-state.elevation-pressed-7 {\n  box-shadow: var(--f7-elevation-7) !important;\n}\n.active-state.elevation-pressed-8,\n.device-desktop .active-state.elevation-pressed-8 {\n  box-shadow: var(--f7-elevation-8) !important;\n}\n.active-state.elevation-pressed-9,\n.device-desktop .active-state.elevation-pressed-9 {\n  box-shadow: var(--f7-elevation-9) !important;\n}\n.active-state.elevation-pressed-10,\n.device-desktop .active-state.elevation-pressed-10 {\n  box-shadow: var(--f7-elevation-10) !important;\n}\n.active-state.elevation-pressed-11,\n.device-desktop .active-state.elevation-pressed-11 {\n  box-shadow: var(--f7-elevation-11) !important;\n}\n.active-state.elevation-pressed-12,\n.device-desktop .active-state.elevation-pressed-12 {\n  box-shadow: var(--f7-elevation-12) !important;\n}\n.active-state.elevation-pressed-13,\n.device-desktop .active-state.elevation-pressed-13 {\n  box-shadow: var(--f7-elevation-13) !important;\n}\n.active-state.elevation-pressed-14,\n.device-desktop .active-state.elevation-pressed-14 {\n  box-shadow: var(--f7-elevation-14) !important;\n}\n.active-state.elevation-pressed-15,\n.device-desktop .active-state.elevation-pressed-15 {\n  box-shadow: var(--f7-elevation-15) !important;\n}\n.active-state.elevation-pressed-16,\n.device-desktop .active-state.elevation-pressed-16 {\n  box-shadow: var(--f7-elevation-16) !important;\n}\n.active-state.elevation-pressed-17,\n.device-desktop .active-state.elevation-pressed-17 {\n  box-shadow: var(--f7-elevation-17) !important;\n}\n.active-state.elevation-pressed-18,\n.device-desktop .active-state.elevation-pressed-18 {\n  box-shadow: var(--f7-elevation-18) !important;\n}\n.active-state.elevation-pressed-19,\n.device-desktop .active-state.elevation-pressed-19 {\n  box-shadow: var(--f7-elevation-19) !important;\n}\n.active-state.elevation-pressed-20,\n.device-desktop .active-state.elevation-pressed-20 {\n  box-shadow: var(--f7-elevation-20) !important;\n}\n.active-state.elevation-pressed-21,\n.device-desktop .active-state.elevation-pressed-21 {\n  box-shadow: var(--f7-elevation-21) !important;\n}\n.active-state.elevation-pressed-22,\n.device-desktop .active-state.elevation-pressed-22 {\n  box-shadow: var(--f7-elevation-22) !important;\n}\n.active-state.elevation-pressed-23,\n.device-desktop .active-state.elevation-pressed-23 {\n  box-shadow: var(--f7-elevation-23) !important;\n}\n.active-state.elevation-pressed-24,\n.device-desktop .active-state.elevation-pressed-24 {\n  box-shadow: var(--f7-elevation-24) !important;\n}\n.elevation-transition-100 {\n  transition-duration: 100ms;\n  transition-property: box-shadow;\n}\n.elevation-transition,\n.elevation-transition-200 {\n  transition-duration: 200ms;\n  transition-property: box-shadow;\n}\n.elevation-transition-300 {\n  transition-duration: 300ms;\n  transition-property: box-shadow;\n}\n.elevation-transition-400 {\n  transition-duration: 400ms;\n  transition-property: box-shadow;\n}\n.elevation-transition-500 {\n  transition-duration: 500ms;\n  transition-property: box-shadow;\n}\n/* === Typography === */\n:root {\n  --f7-typography-padding: 16px;\n  --f7-typography-margin: 16px;\n}\n.display-flex {\n  display: flex !important;\n}\n.display-block {\n  display: block !important;\n}\n.display-inline-flex {\n  display: inline-flex !important;\n}\n.display-inline-block {\n  display: inline-block !important;\n}\n.display-inline {\n  display: inline !important;\n}\n.display-none {\n  display: none !important;\n}\n.flex-shrink-0 {\n  flex-shrink: 0 !important;\n}\n.flex-shrink-1 {\n  flex-shrink: 1 !important;\n}\n.flex-shrink-2 {\n  flex-shrink: 2 !important;\n}\n.flex-shrink-3 {\n  flex-shrink: 3 !important;\n}\n.flex-shrink-4 {\n  flex-shrink: 4 !important;\n}\n.flex-shrink-5 {\n  flex-shrink: 5 !important;\n}\n.flex-shrink-6 {\n  flex-shrink: 6 !important;\n}\n.flex-shrink-7 {\n  flex-shrink: 7 !important;\n}\n.flex-shrink-8 {\n  flex-shrink: 8 !important;\n}\n.flex-shrink-9 {\n  flex-shrink: 9 !important;\n}\n.flex-shrink-10 {\n  flex-shrink: 10 !important;\n}\n.flex-direction-row {\n  flex-direction: row !important;\n}\n.flex-direction-row-reverse {\n  flex-direction: row-reverse !important;\n}\n.flex-direction-column {\n  flex-direction: column !important;\n}\n.flex-direction-column-reverse {\n  flex-direction: column-reverse !important;\n}\n.justify-content-flex-start {\n  justify-content: flex-start !important;\n}\n.justify-content-center {\n  justify-content: center !important;\n}\n.justify-content-flex-end {\n  justify-content: flex-end !important;\n}\n.justify-content-space-between {\n  justify-content: space-between !important;\n}\n.justify-content-space-around {\n  justify-content: space-around !important;\n}\n.justify-content-space-evenly {\n  justify-content: space-evenly !important;\n}\n.justify-content-stretch {\n  justify-content: stretch !important;\n}\n.justify-content-start {\n  justify-content: start !important;\n}\n.justify-content-end {\n  justify-content: end !important;\n}\n.justify-content-left {\n  justify-content: left !important;\n}\n.justify-content-right {\n  justify-content: right !important;\n}\n.align-content-flex-start {\n  align-content: flex-start !important;\n}\n.align-content-flex-end {\n  align-content: flex-end !important;\n}\n.align-content-center {\n  align-content: center !important;\n}\n.align-content-space-between {\n  align-content: space-between !important;\n}\n.align-content-space-around {\n  align-content: space-around !important;\n}\n.align-content-stretch {\n  align-content: stretch !important;\n}\n.align-items-baseline {\n  align-items: baseline !important;\n}\n.align-items-flex-start {\n  align-items: flex-start !important;\n}\n.align-items-flex-end {\n  align-items: flex-end !important;\n}\n.align-items-center {\n  align-items: center !important;\n}\n.align-items-stretch {\n  align-items: stretch !important;\n}\n.align-self-flex-start {\n  align-self: flex-start !important;\n}\n.align-self-flex-end {\n  align-self: flex-end !important;\n}\n.align-self-center {\n  align-self: center !important;\n}\n.align-self-stretch {\n  align-self: stretch !important;\n}\n.text-align-left {\n  text-align: left !important;\n}\n.text-align-center {\n  text-align: center !important;\n}\n.text-align-right {\n  text-align: right !important;\n}\n.text-align-justify {\n  text-align: justify !important;\n}\n.float-left {\n  float: left !important;\n}\n.float-right {\n  float: right !important;\n}\n.float-none {\n  float: none !important;\n}\n.vertical-align-bottom {\n  vertical-align: bottom !important;\n}\n.vertical-align-middle {\n  vertical-align: middle !important;\n}\n.vertical-align-top {\n  vertical-align: top !important;\n}\n.no-padding {\n  padding: 0 !important;\n}\n.no-padding-left {\n  padding-left: 0 !important;\n}\n.no-padding-right {\n  padding-right: 0 !important;\n}\n.no-padding-horizontal {\n  padding-left: 0 !important;\n  padding-right: 0 !important;\n}\n.no-padding-top {\n  padding-top: 0 !important;\n}\n.no-padding-bottom {\n  padding-bottom: 0 !important;\n}\n.no-padding-vertical {\n  padding-top: 0 !important;\n  padding-bottom: 0 !important;\n}\n.no-margin {\n  margin: 0 !important;\n}\n.no-margin-left {\n  margin-left: 0 !important;\n}\n.no-margin-right {\n  margin-right: 0 !important;\n}\n.no-margin-horizontal {\n  margin-left: 0 !important;\n  margin-right: 0 !important;\n}\n.no-margin-top {\n  margin-top: 0 !important;\n}\n.no-margin-bottom {\n  margin-bottom: 0 !important;\n}\n.no-margin-vertical {\n  margin-top: 0 !important;\n  margin-bottom: 0 !important;\n}\n.width-auto {\n  width: auto !important;\n}\n.width-100 {\n  width: 100% !important;\n}\n.padding {\n  padding: var(--f7-typography-padding) !important;\n}\n.padding-half {\n  padding: calc(var(--f7-typography-padding) / 2) !important;\n}\n.padding-top {\n  padding-top: var(--f7-typography-padding) !important;\n}\n.padding-top-half {\n  padding-top: calc(var(--f7-typography-padding) / 2) !important;\n}\n.padding-bottom {\n  padding-bottom: var(--f7-typography-padding) !important;\n}\n.padding-bottom-half {\n  padding-bottom: calc(var(--f7-typography-padding) / 2) !important;\n}\n.padding-left {\n  padding-left: var(--f7-typography-padding) !important;\n}\n.padding-left-half {\n  padding-left: calc(var(--f7-typography-padding) / 2) !important;\n}\n.padding-right {\n  padding-right: var(--f7-typography-padding) !important;\n}\n.padding-right-half {\n  padding-right: calc(var(--f7-typography-padding) / 2) !important;\n}\n.padding-vertical {\n  padding-top: var(--f7-typography-padding) !important;\n  padding-bottom: var(--f7-typography-padding) !important;\n}\n.padding-vertical-half {\n  padding-top: calc(var(--f7-typography-padding) / 2) !important;\n  padding-bottom: calc(var(--f7-typography-padding) / 2) !important;\n}\n.padding-horizontal {\n  padding-left: var(--f7-typography-padding) !important;\n  padding-right: var(--f7-typography-padding) !important;\n}\n.padding-horizontal-half {\n  padding-left: calc(var(--f7-typography-padding) / 2) !important;\n  padding-right: calc(var(--f7-typography-padding) / 2) !important;\n}\n.margin {\n  margin: var(--f7-typography-margin) !important;\n}\n.margin-half {\n  margin: calc(var(--f7-typography-margin) / 2) !important;\n}\n.margin-top {\n  margin-top: var(--f7-typography-margin) !important;\n}\n.margin-top-half {\n  margin-top: calc(var(--f7-typography-margin) / 2) !important;\n}\n.margin-bottom {\n  margin-bottom: var(--f7-typography-margin) !important;\n}\n.margin-bottom-half {\n  margin-bottom: calc(var(--f7-typography-margin) / 2) !important;\n}\n.margin-left {\n  margin-left: var(--f7-typography-margin) !important;\n}\n.margin-left-half {\n  margin-left: calc(var(--f7-typography-margin) / 2) !important;\n}\n.margin-right {\n  margin-right: var(--f7-typography-margin) !important;\n}\n.margin-right-half {\n  margin-right: calc(var(--f7-typography-margin) / 2) !important;\n}\n.margin-vertical {\n  margin-top: var(--f7-typography-margin) !important;\n  margin-bottom: var(--f7-typography-margin) !important;\n}\n.margin-vertical-half {\n  margin-top: calc(var(--f7-typography-margin) / 2) !important;\n  margin-bottom: calc(var(--f7-typography-margin) / 2) !important;\n}\n.margin-horizontal {\n  margin-left: var(--f7-typography-margin) !important;\n  margin-right: var(--f7-typography-margin) !important;\n}\n.margin-horizontal-half {\n  margin-left: calc(var(--f7-typography-margin) / 2) !important;\n  margin-right: calc(var(--f7-typography-margin) / 2) !important;\n}\n[class*=\"text-color-\"] {\n  color: var(--f7-theme-color-text-color) !important;\n}\n[class*=\"bg-color-\"] {\n  background-color: var(--f7-theme-color-bg-color) !important;\n}\n[class*=\"border-color-\"] {\n  border-color: var(--f7-theme-color-border-color) !important;\n}\niframe#viAd {\n  z-index: 12900 !important;\n  background: #000 !important;\n}\n.vi-overlay {\n  background: rgba(0, 0, 0, 0.85);\n  z-index: 13100;\n  position: absolute;\n  left: 0%;\n  top: 0%;\n  width: 100%;\n  height: 100%;\n  border-radius: 3px;\n  display: flex;\n  justify-content: center;\n  flex-direction: column;\n  align-items: center;\n  align-content: center;\n  text-align: center;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n@supports ((-webkit-backdrop-filter: blur(10px)) or (backdrop-filter: blur(10px))) {\n  .vi-overlay {\n    background: rgba(0, 0, 0, 0.65);\n    -webkit-backdrop-filter: blur(10px);\n            backdrop-filter: blur(10px);\n  }\n}\n.vi-overlay .vi-overlay-text {\n  text-align: center;\n  color: #fff;\n  max-width: 80%;\n}\n.vi-overlay .vi-overlay-text + .vi-overlay-play-button {\n  margin-top: 15px;\n}\n.vi-overlay .vi-overlay-play-button {\n  width: 44px;\n  height: 44px;\n  border-radius: 50%;\n  border: 2px solid #fff;\n  position: relative;\n}\n.vi-overlay .vi-overlay-play-button.active-state {\n  opacity: 0.55;\n}\n.vi-overlay .vi-overlay-play-button:before {\n  content: '';\n  width: 0;\n  height: 0;\n  border-top: 8px solid transparent;\n  border-bottom: 8px solid transparent;\n  border-left: 14px solid #fff;\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  margin-left: 2px;\n  transform: translate(-50%, -50%);\n}\n";
  styleInject(css_248z);

  /* src/pages/stories.svelte generated by Svelte v3.21.0 */

  const file$l = "src/pages/stories.svelte";

  function get_each_context$2(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[5] = list[i];
  	child_ctx[7] = i;
  	return child_ctx;
  }

  // (29:2) {:else}
  function create_else_block$5(ctx) {
  	let div0;
  	let t;
  	let div1;
  	let current;

  	const preloader = new Preloader$2({
  			props: { color: "multi" },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			div0 = element("div");
  			t = space();
  			div1 = element("div");
  			create_component(preloader.$$.fragment);
  			attr_dev(div0, "class", "preloader-backdrop");
  			add_location(div0, file$l, 29, 4, 866);
  			attr_dev(div1, "class", "preloader-modal");
  			add_location(div1, file$l, 30, 6, 911);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div0, anchor);
  			insert_dev(target, t, anchor);
  			insert_dev(target, div1, anchor);
  			mount_component(preloader, div1, null);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(preloader.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(preloader.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div0);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(div1);
  			destroy_component(preloader);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$5.name,
  		type: "else",
  		source: "(29:2) {:else}",
  		ctx
  	});

  	return block;
  }

  // (5:2) {#if items}
  function create_if_block$c(ctx) {
  	let current;

  	const list = new List({
  			props: {
  				accordionList: true,
  				$$slots: { default: [create_default_slot_1$3] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(list.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(list, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const list_changes = {};

  			if (dirty & /*$$scope, items*/ 257) {
  				list_changes.$$scope = { dirty, ctx };
  			}

  			list.$set(list_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(list.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(list.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(list, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$c.name,
  		type: "if",
  		source: "(5:2) {#if items}",
  		ctx
  	});

  	return block;
  }

  // (9:6) <i slot="media">
  function create_media_slot(ctx) {
  	let i;
  	let t_value = /*i*/ ctx[7] + 1 + "";
  	let t;

  	const block = {
  		c: function create() {
  			i = element("i");
  			t = text$1(t_value);
  			attr_dev(i, "slot", "media");
  			add_location(i, file$l, 8, 6, 226);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, i, anchor);
  			append_dev(i, t);
  		},
  		p: noop,
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(i);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_media_slot.name,
  		type: "slot",
  		source: "(9:6) <i slot=\\\"media\\\">",
  		ctx
  	});

  	return block;
  }

  // (10:6) <span slot="footer">
  function create_footer_slot(ctx) {
  	let span;
  	let t0_value = pluralize(/*item*/ ctx[5].points, "point") + "";
  	let t0;
  	let t1;
  	let t2_value = /*item*/ ctx[5].user + "";
  	let t2;
  	let t3;
  	let t4_value = /*item*/ ctx[5].time_ago + "";
  	let t4;

  	const block = {
  		c: function create() {
  			span = element("span");
  			t0 = text$1(t0_value);
  			t1 = text$1(" by ");
  			t2 = text$1(t2_value);
  			t3 = space();
  			t4 = text$1(t4_value);
  			attr_dev(span, "slot", "footer");
  			add_location(span, file$l, 9, 6, 260);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, span, anchor);
  			append_dev(span, t0);
  			append_dev(span, t1);
  			append_dev(span, t2);
  			append_dev(span, t3);
  			append_dev(span, t4);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*items*/ 1 && t0_value !== (t0_value = pluralize(/*item*/ ctx[5].points, "point") + "")) set_data_dev(t0, t0_value);
  			if (dirty & /*items*/ 1 && t2_value !== (t2_value = /*item*/ ctx[5].user + "")) set_data_dev(t2, t2_value);
  			if (dirty & /*items*/ 1 && t4_value !== (t4_value = /*item*/ ctx[5].time_ago + "")) set_data_dev(t4, t4_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(span);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_footer_slot.name,
  		type: "slot",
  		source: "(10:6) <span slot=\\\"footer\\\">",
  		ctx
  	});

  	return block;
  }

  // (16:8) <Button>
  function create_default_slot_9$1(ctx) {
  	let a;
  	let t;
  	let a_href_value;

  	const block = {
  		c: function create() {
  			a = element("a");
  			t = text$1("Visit Site");
  			attr_dev(a, "href", a_href_value = /*item*/ ctx[5].url);
  			attr_dev(a, "class", "external");
  			add_location(a, file$l, 15, 16, 433);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, a, anchor);
  			append_dev(a, t);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*items*/ 1 && a_href_value !== (a_href_value = /*item*/ ctx[5].url)) {
  				attr_dev(a, "href", a_href_value);
  			}
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(a);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_9$1.name,
  		type: "slot",
  		source: "(16:8) <Button>",
  		ctx
  	});

  	return block;
  }

  // (15:6) <Col>
  function create_default_slot_8$1(ctx) {
  	let current;

  	const button = new Button({
  			props: {
  				$$slots: { default: [create_default_slot_9$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(button.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(button, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const button_changes = {};

  			if (dirty & /*$$scope, items*/ 257) {
  				button_changes.$$scope = { dirty, ctx };
  			}

  			button.$set(button_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(button.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(button.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(button, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_8$1.name,
  		type: "slot",
  		source: "(15:6) <Col>",
  		ctx
  	});

  	return block;
  }

  // (19:16) {#if item.comments_count}
  function create_if_block_1$a(ctx) {
  	let current;

  	const link = new Link({
  			props: {
  				href: "/item/" + /*item*/ ctx[5].id,
  				routeProps: { item: /*item*/ ctx[5] },
  				$$slots: { default: [create_default_slot_7$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(link.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(link, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const link_changes = {};
  			if (dirty & /*items*/ 1) link_changes.href = "/item/" + /*item*/ ctx[5].id;
  			if (dirty & /*items*/ 1) link_changes.routeProps = { item: /*item*/ ctx[5] };

  			if (dirty & /*$$scope, items*/ 257) {
  				link_changes.$$scope = { dirty, ctx };
  			}

  			link.$set(link_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(link.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(link.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(link, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block_1$a.name,
  		type: "if",
  		source: "(19:16) {#if item.comments_count}",
  		ctx
  	});

  	return block;
  }

  // (20:10) <Link href="/item/{item.id}" routeProps={{item}}>
  function create_default_slot_7$1(ctx) {
  	let t_value = pluralize(/*item*/ ctx[5].comments_count, "comment") + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*items*/ 1 && t_value !== (t_value = pluralize(/*item*/ ctx[5].comments_count, "comment") + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_7$1.name,
  		type: "slot",
  		source: "(20:10) <Link href=\\\"/item/{item.id}\\\" routeProps={{item}}>",
  		ctx
  	});

  	return block;
  }

  // (19:8) <Button>
  function create_default_slot_6$1(ctx) {
  	let if_block_anchor;
  	let current;
  	let if_block = /*item*/ ctx[5].comments_count && create_if_block_1$a(ctx);

  	const block = {
  		c: function create() {
  			if (if_block) if_block.c();
  			if_block_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			if (if_block) if_block.m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (/*item*/ ctx[5].comments_count) {
  				if (if_block) {
  					if_block.p(ctx, dirty);

  					if (dirty & /*items*/ 1) {
  						transition_in(if_block, 1);
  					}
  				} else {
  					if_block = create_if_block_1$a(ctx);
  					if_block.c();
  					transition_in(if_block, 1);
  					if_block.m(if_block_anchor.parentNode, if_block_anchor);
  				}
  			} else if (if_block) {
  				group_outros();

  				transition_out(if_block, 1, 1, () => {
  					if_block = null;
  				});

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (if_block) if_block.d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_6$1.name,
  		type: "slot",
  		source: "(19:8) <Button>",
  		ctx
  	});

  	return block;
  }

  // (18:6) <Col>
  function create_default_slot_5$1(ctx) {
  	let current;

  	const button = new Button({
  			props: {
  				$$slots: { default: [create_default_slot_6$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(button.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(button, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const button_changes = {};

  			if (dirty & /*$$scope, items*/ 257) {
  				button_changes.$$scope = { dirty, ctx };
  			}

  			button.$set(button_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(button.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(button.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(button, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_5$1.name,
  		type: "slot",
  		source: "(18:6) <Col>",
  		ctx
  	});

  	return block;
  }

  // (14:6) <Row>
  function create_default_slot_4$1(ctx) {
  	let t;
  	let current;

  	const col0 = new Col({
  			props: {
  				$$slots: { default: [create_default_slot_8$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const col1 = new Col({
  			props: {
  				$$slots: { default: [create_default_slot_5$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(col0.$$.fragment);
  			t = space();
  			create_component(col1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(col0, target, anchor);
  			insert_dev(target, t, anchor);
  			mount_component(col1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const col0_changes = {};

  			if (dirty & /*$$scope, items*/ 257) {
  				col0_changes.$$scope = { dirty, ctx };
  			}

  			col0.$set(col0_changes);
  			const col1_changes = {};

  			if (dirty & /*$$scope, items*/ 257) {
  				col1_changes.$$scope = { dirty, ctx };
  			}

  			col1.$set(col1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(col0.$$.fragment, local);
  			transition_in(col1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(col0.$$.fragment, local);
  			transition_out(col1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(col0, detaching);
  			if (detaching) detach_dev(t);
  			destroy_component(col1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_4$1.name,
  		type: "slot",
  		source: "(14:6) <Row>",
  		ctx
  	});

  	return block;
  }

  // (13:6) <AccordionContent>
  function create_default_slot_3$1(ctx) {
  	let current;

  	const row = new Row({
  			props: {
  				$$slots: { default: [create_default_slot_4$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(row.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(row, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const row_changes = {};

  			if (dirty & /*$$scope, items*/ 257) {
  				row_changes.$$scope = { dirty, ctx };
  			}

  			row.$set(row_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(row.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(row.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(row, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_3$1.name,
  		type: "slot",
  		source: "(13:6) <AccordionContent>",
  		ctx
  	});

  	return block;
  }

  // (8:4) <ListItem title={item.title} accordionItem>
  function create_default_slot_2$3(ctx) {
  	let t0;
  	let t1;
  	let current;

  	const accordioncontent = new Accordion_content({
  			props: {
  				$$slots: { default: [create_default_slot_3$1] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			t0 = space();
  			t1 = space();
  			create_component(accordioncontent.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t0, anchor);
  			insert_dev(target, t1, anchor);
  			mount_component(accordioncontent, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const accordioncontent_changes = {};

  			if (dirty & /*$$scope, items*/ 257) {
  				accordioncontent_changes.$$scope = { dirty, ctx };
  			}

  			accordioncontent.$set(accordioncontent_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(accordioncontent.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(accordioncontent.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(t1);
  			destroy_component(accordioncontent, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_2$3.name,
  		type: "slot",
  		source: "(8:4) <ListItem title={item.title} accordionItem>",
  		ctx
  	});

  	return block;
  }

  // (7:3) {#each items as item, i}
  function create_each_block$2(ctx) {
  	let current;

  	const listitem = new List_item({
  			props: {
  				title: /*item*/ ctx[5].title,
  				accordionItem: true,
  				$$slots: {
  					default: [create_default_slot_2$3],
  					footer: [create_footer_slot],
  					media: [create_media_slot]
  				},
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(listitem.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(listitem, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const listitem_changes = {};
  			if (dirty & /*items*/ 1) listitem_changes.title = /*item*/ ctx[5].title;

  			if (dirty & /*$$scope, items*/ 257) {
  				listitem_changes.$$scope = { dirty, ctx };
  			}

  			listitem.$set(listitem_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(listitem.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(listitem.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(listitem, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$2.name,
  		type: "each",
  		source: "(7:3) {#each items as item, i}",
  		ctx
  	});

  	return block;
  }

  // (6:2) <List accordionList>
  function create_default_slot_1$3(ctx) {
  	let t;
  	let current;
  	let each_value = /*items*/ ctx[0];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$2(get_each_context$2(ctx, each_value, i));
  	}

  	const out = i => transition_out(each_blocks[i], 1, 1, () => {
  		each_blocks[i] = null;
  	});

  	const listitem = new List_item({
  			props: { title: "Load More ..." },
  			$$inline: true
  		});

  	listitem.$on("click", /*NextPage*/ ctx[1]);

  	const block = {
  		c: function create() {
  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			t = space();
  			create_component(listitem.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(target, anchor);
  			}

  			insert_dev(target, t, anchor);
  			mount_component(listitem, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*items, pluralize*/ 1) {
  				each_value = /*items*/ ctx[0];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$2(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  						transition_in(each_blocks[i], 1);
  					} else {
  						each_blocks[i] = create_each_block$2(child_ctx);
  						each_blocks[i].c();
  						transition_in(each_blocks[i], 1);
  						each_blocks[i].m(t.parentNode, t);
  					}
  				}

  				group_outros();

  				for (i = each_value.length; i < each_blocks.length; i += 1) {
  					out(i);
  				}

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			for (let i = 0; i < each_value.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			transition_in(listitem.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			each_blocks = each_blocks.filter(Boolean);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			transition_out(listitem.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_each(each_blocks, detaching);
  			if (detaching) detach_dev(t);
  			destroy_component(listitem, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1$3.name,
  		type: "slot",
  		source: "(6:2) <List accordionList>",
  		ctx
  	});

  	return block;
  }

  // (1:0) <Page name="stories">
  function create_default_slot$4(ctx) {
  	let t;
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;

  	const navbar = new Navbar$2({
  			props: { large: true, title: "HackerNews7" },
  			$$inline: true
  		});

  	const if_block_creators = [create_if_block$c, create_else_block$5];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*items*/ ctx[0]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			create_component(navbar.$$.fragment);
  			t = space();
  			if_block.c();
  			if_block_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			mount_component(navbar, target, anchor);
  			insert_dev(target, t, anchor);
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navbar.$$.fragment, local);
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navbar.$$.fragment, local);
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(navbar, detaching);
  			if (detaching) detach_dev(t);
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$4.name,
  		type: "slot",
  		source: "(1:0) <Page name=\\\"stories\\\">",
  		ctx
  	});

  	return block;
  }

  function create_fragment$l(ctx) {
  	let current;

  	const page_1 = new Page({
  			props: {
  				name: "stories",
  				$$slots: { default: [create_default_slot$4] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(page_1.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(page_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const page_1_changes = {};

  			if (dirty & /*$$scope, items*/ 257) {
  				page_1_changes.$$scope = { dirty, ctx };
  			}

  			page_1.$set(page_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(page_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(page_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(page_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$l.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function pluralize(prop, text) {
  	return `${prop} ${prop < 2 ? text : text + "s"}`;
  }

  function instance$k($$self, $$props, $$invalidate) {
  	let page = 1;
  	let items;
  	let currentItem;

  	async function getStories(page) {
  		const res = await fetch(`https://node-hnapi.herokuapp.com/news?page=${page}`);
  		const data = await res.json();
  		$$invalidate(0, items = items ? items.concat(data) : data);
  	}

  	function NextPage() {
  		$$invalidate(2, page += 1);
  	}

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Stories> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Stories", $$slots, []);

  	$$self.$capture_state = () => ({
  		Page,
  		Navbar: Navbar$2,
  		List,
  		ListItem: List_item,
  		AccordionContent: Accordion_content,
  		Row,
  		Col,
  		Button,
  		Preloader: Preloader$2,
  		Link,
  		page,
  		items,
  		currentItem,
  		getStories,
  		pluralize,
  		NextPage
  	});

  	$$self.$inject_state = $$props => {
  		if ("page" in $$props) $$invalidate(2, page = $$props.page);
  		if ("items" in $$props) $$invalidate(0, items = $$props.items);
  		if ("currentItem" in $$props) currentItem = $$props.currentItem;
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*page*/ 4) {
  			 getStories(page);
  		}
  	};

  	return [items, NextPage];
  }

  class Stories extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$k, create_fragment$l, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Stories",
  			options,
  			id: create_fragment$l.name
  		});
  	}
  }

  /* src/components/Comment.svelte generated by Svelte v3.21.0 */
  const file$m = "src/components/Comment.svelte";

  function get_each_context$3(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[1] = list[i];
  	return child_ctx;
  }

  // (2:4) <BlockHeader>
  function create_default_slot_1$4(ctx) {
  	let t0_value = /*comment*/ ctx[0].user + "";
  	let t0;
  	let t1;
  	let t2_value = /*comment*/ ctx[0].time_ago + "";
  	let t2;

  	const block = {
  		c: function create() {
  			t0 = text$1(t0_value);
  			t1 = space();
  			t2 = text$1(t2_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t0, anchor);
  			insert_dev(target, t1, anchor);
  			insert_dev(target, t2, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*comment*/ 1 && t0_value !== (t0_value = /*comment*/ ctx[0].user + "")) set_data_dev(t0, t0_value);
  			if (dirty & /*comment*/ 1 && t2_value !== (t2_value = /*comment*/ ctx[0].time_ago + "")) set_data_dev(t2, t2_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(t1);
  			if (detaching) detach_dev(t2);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1$4.name,
  		type: "slot",
  		source: "(2:4) <BlockHeader>",
  		ctx
  	});

  	return block;
  }

  // (6:1) {#each comment.comments as child}
  function create_each_block$3(ctx) {
  	let current;

  	const comment_1 = new Comment({
  			props: { comment: /*child*/ ctx[1] },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(comment_1.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(comment_1, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const comment_1_changes = {};
  			if (dirty & /*comment*/ 1) comment_1_changes.comment = /*child*/ ctx[1];
  			comment_1.$set(comment_1_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(comment_1.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(comment_1.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(comment_1, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$3.name,
  		type: "each",
  		source: "(6:1) {#each comment.comments as child}",
  		ctx
  	});

  	return block;
  }

  // (1:0) <Block strong>
  function create_default_slot$5(ctx) {
  	let t0;
  	let p;
  	let raw_value = /*comment*/ ctx[0].content + "";
  	let t1;
  	let each_1_anchor;
  	let current;

  	const blockheader = new Block_header({
  			props: {
  				$$slots: { default: [create_default_slot_1$4] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	let each_value = /*comment*/ ctx[0].comments;
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$3(get_each_context$3(ctx, each_value, i));
  	}

  	const out = i => transition_out(each_blocks[i], 1, 1, () => {
  		each_blocks[i] = null;
  	});

  	const block = {
  		c: function create() {
  			create_component(blockheader.$$.fragment);
  			t0 = space();
  			p = element("p");
  			t1 = space();

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			each_1_anchor = empty$1();
  			attr_dev(p, "class", "svelte-1nek4fi");
  			add_location(p, file$m, 3, 1, 82);
  		},
  		m: function mount(target, anchor) {
  			mount_component(blockheader, target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, p, anchor);
  			p.innerHTML = raw_value;
  			insert_dev(target, t1, anchor);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(target, anchor);
  			}

  			insert_dev(target, each_1_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const blockheader_changes = {};

  			if (dirty & /*$$scope, comment*/ 17) {
  				blockheader_changes.$$scope = { dirty, ctx };
  			}

  			blockheader.$set(blockheader_changes);
  			if ((!current || dirty & /*comment*/ 1) && raw_value !== (raw_value = /*comment*/ ctx[0].content + "")) p.innerHTML = raw_value;
  			if (dirty & /*comment*/ 1) {
  				each_value = /*comment*/ ctx[0].comments;
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$3(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  						transition_in(each_blocks[i], 1);
  					} else {
  						each_blocks[i] = create_each_block$3(child_ctx);
  						each_blocks[i].c();
  						transition_in(each_blocks[i], 1);
  						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
  					}
  				}

  				group_outros();

  				for (i = each_value.length; i < each_blocks.length; i += 1) {
  					out(i);
  				}

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(blockheader.$$.fragment, local);

  			for (let i = 0; i < each_value.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(blockheader.$$.fragment, local);
  			each_blocks = each_blocks.filter(Boolean);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(blockheader, detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(p);
  			if (detaching) detach_dev(t1);
  			destroy_each(each_blocks, detaching);
  			if (detaching) detach_dev(each_1_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$5.name,
  		type: "slot",
  		source: "(1:0) <Block strong>",
  		ctx
  	});

  	return block;
  }

  function create_fragment$m(ctx) {
  	let current;

  	const block = new Block({
  			props: {
  				strong: true,
  				$$slots: { default: [create_default_slot$5] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block_1 = {
  		c: function create() {
  			create_component(block.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(block, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const block_changes = {};

  			if (dirty & /*$$scope, comment*/ 17) {
  				block_changes.$$scope = { dirty, ctx };
  			}

  			block.$set(block_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(block.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(block.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(block, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block: block_1,
  		id: create_fragment$m.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block_1;
  }

  function instance$l($$self, $$props, $$invalidate) {
  	let { comment } = $$props;
  	const writable_props = ["comment"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Comment> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Comment", $$slots, []);

  	$$self.$set = $$props => {
  		if ("comment" in $$props) $$invalidate(0, comment = $$props.comment);
  	};

  	$$self.$capture_state = () => ({ Block, BlockHeader: Block_header, comment });

  	$$self.$inject_state = $$props => {
  		if ("comment" in $$props) $$invalidate(0, comment = $$props.comment);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [comment];
  }

  class Comment extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$l, create_fragment$m, safe_not_equal, { comment: 0 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Comment",
  			options,
  			id: create_fragment$m.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*comment*/ ctx[0] === undefined && !("comment" in props)) {
  			console.warn("<Comment> was created without expected prop 'comment'");
  		}
  	}

  	get comment() {
  		throw new Error("<Comment>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set comment(value) {
  		throw new Error("<Comment>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  /* src/pages/story.svelte generated by Svelte v3.21.0 */
  const file$n = "src/pages/story.svelte";

  function get_each_context$4(ctx, list, i) {
  	const child_ctx = ctx.slice();
  	child_ctx[3] = list[i];
  	return child_ctx;
  }

  // (6:2) <Link href={item.url} external>
  function create_default_slot_1$5(ctx) {
  	let t_value = /*item*/ ctx[0].domain + "";
  	let t;

  	const block = {
  		c: function create() {
  			t = text$1(t_value);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, t, anchor);
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*item*/ 1 && t_value !== (t_value = /*item*/ ctx[0].domain + "")) set_data_dev(t, t_value);
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(t);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot_1$5.name,
  		type: "slot",
  		source: "(6:2) <Link href={item.url} external>",
  		ctx
  	});

  	return block;
  }

  // (12:2) {:else}
  function create_else_block$6(ctx) {
  	let div0;
  	let t;
  	let div1;
  	let current;

  	const preloader = new Preloader$2({
  			props: { color: "multi" },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			div0 = element("div");
  			t = space();
  			div1 = element("div");
  			create_component(preloader.$$.fragment);
  			attr_dev(div0, "class", "preloader-backdrop");
  			add_location(div0, file$n, 12, 4, 365);
  			attr_dev(div1, "class", "preloader-modal");
  			add_location(div1, file$n, 13, 6, 410);
  		},
  		m: function mount(target, anchor) {
  			insert_dev(target, div0, anchor);
  			insert_dev(target, t, anchor);
  			insert_dev(target, div1, anchor);
  			mount_component(preloader, div1, null);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(preloader.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(preloader.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			if (detaching) detach_dev(div0);
  			if (detaching) detach_dev(t);
  			if (detaching) detach_dev(div1);
  			destroy_component(preloader);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_else_block$6.name,
  		type: "else",
  		source: "(12:2) {:else}",
  		ctx
  	});

  	return block;
  }

  // (8:2) {#if comments}
  function create_if_block$d(ctx) {
  	let each_1_anchor;
  	let current;
  	let each_value = /*comments*/ ctx[1];
  	validate_each_argument(each_value);
  	let each_blocks = [];

  	for (let i = 0; i < each_value.length; i += 1) {
  		each_blocks[i] = create_each_block$4(get_each_context$4(ctx, each_value, i));
  	}

  	const out = i => transition_out(each_blocks[i], 1, 1, () => {
  		each_blocks[i] = null;
  	});

  	const block = {
  		c: function create() {
  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].c();
  			}

  			each_1_anchor = empty$1();
  		},
  		m: function mount(target, anchor) {
  			for (let i = 0; i < each_blocks.length; i += 1) {
  				each_blocks[i].m(target, anchor);
  			}

  			insert_dev(target, each_1_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			if (dirty & /*comments*/ 2) {
  				each_value = /*comments*/ ctx[1];
  				validate_each_argument(each_value);
  				let i;

  				for (i = 0; i < each_value.length; i += 1) {
  					const child_ctx = get_each_context$4(ctx, each_value, i);

  					if (each_blocks[i]) {
  						each_blocks[i].p(child_ctx, dirty);
  						transition_in(each_blocks[i], 1);
  					} else {
  						each_blocks[i] = create_each_block$4(child_ctx);
  						each_blocks[i].c();
  						transition_in(each_blocks[i], 1);
  						each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
  					}
  				}

  				group_outros();

  				for (i = each_value.length; i < each_blocks.length; i += 1) {
  					out(i);
  				}

  				check_outros();
  			}
  		},
  		i: function intro(local) {
  			if (current) return;

  			for (let i = 0; i < each_value.length; i += 1) {
  				transition_in(each_blocks[i]);
  			}

  			current = true;
  		},
  		o: function outro(local) {
  			each_blocks = each_blocks.filter(Boolean);

  			for (let i = 0; i < each_blocks.length; i += 1) {
  				transition_out(each_blocks[i]);
  			}

  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_each(each_blocks, detaching);
  			if (detaching) detach_dev(each_1_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_if_block$d.name,
  		type: "if",
  		source: "(8:2) {#if comments}",
  		ctx
  	});

  	return block;
  }

  // (9:2) {#each comments as comment}
  function create_each_block$4(ctx) {
  	let current;

  	const comment = new Comment({
  			props: { comment: /*comment*/ ctx[3] },
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(comment.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(comment, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const comment_changes = {};
  			if (dirty & /*comments*/ 2) comment_changes.comment = /*comment*/ ctx[3];
  			comment.$set(comment_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(comment.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(comment.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(comment, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_each_block$4.name,
  		type: "each",
  		source: "(9:2) {#each comments as comment}",
  		ctx
  	});

  	return block;
  }

  // (1:0) <Page name="story">
  function create_default_slot$6(ctx) {
  	let t0;
  	let p0;
  	let t1_value = /*item*/ ctx[0].title + "";
  	let t1;
  	let t2;
  	let t3;
  	let p1;
  	let t4_value = pluralize$1(/*item*/ ctx[0].points, "point") + "";
  	let t4;
  	let t5;
  	let t6_value = /*item*/ ctx[0].user + "";
  	let t6;
  	let t7;
  	let t8_value = /*item*/ ctx[0].time_ago + "";
  	let t8;
  	let t9;
  	let current_block_type_index;
  	let if_block;
  	let if_block_anchor;
  	let current;

  	const navbar = new Navbar$2({
  			props: {
  				large: true,
  				title: /*item*/ ctx[0].title,
  				backLink: "Back"
  			},
  			$$inline: true
  		});

  	const link = new Link({
  			props: {
  				href: /*item*/ ctx[0].url,
  				external: true,
  				$$slots: { default: [create_default_slot_1$5] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const if_block_creators = [create_if_block$d, create_else_block$6];
  	const if_blocks = [];

  	function select_block_type(ctx, dirty) {
  		if (/*comments*/ ctx[1]) return 0;
  		return 1;
  	}

  	current_block_type_index = select_block_type(ctx);
  	if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);

  	const block = {
  		c: function create() {
  			create_component(navbar.$$.fragment);
  			t0 = space();
  			p0 = element("p");
  			t1 = text$1(t1_value);
  			t2 = space();
  			create_component(link.$$.fragment);
  			t3 = space();
  			p1 = element("p");
  			t4 = text$1(t4_value);
  			t5 = text$1(" by ");
  			t6 = text$1(t6_value);
  			t7 = text$1(", ");
  			t8 = text$1(t8_value);
  			t9 = space();
  			if_block.c();
  			if_block_anchor = empty$1();
  			add_location(p0, file$n, 4, 2, 121);
  			add_location(p1, file$n, 6, 2, 197);
  		},
  		m: function mount(target, anchor) {
  			mount_component(navbar, target, anchor);
  			insert_dev(target, t0, anchor);
  			insert_dev(target, p0, anchor);
  			append_dev(p0, t1);
  			insert_dev(target, t2, anchor);
  			mount_component(link, target, anchor);
  			insert_dev(target, t3, anchor);
  			insert_dev(target, p1, anchor);
  			append_dev(p1, t4);
  			append_dev(p1, t5);
  			append_dev(p1, t6);
  			append_dev(p1, t7);
  			append_dev(p1, t8);
  			insert_dev(target, t9, anchor);
  			if_blocks[current_block_type_index].m(target, anchor);
  			insert_dev(target, if_block_anchor, anchor);
  			current = true;
  		},
  		p: function update(ctx, dirty) {
  			const navbar_changes = {};
  			if (dirty & /*item*/ 1) navbar_changes.title = /*item*/ ctx[0].title;
  			navbar.$set(navbar_changes);
  			if ((!current || dirty & /*item*/ 1) && t1_value !== (t1_value = /*item*/ ctx[0].title + "")) set_data_dev(t1, t1_value);
  			const link_changes = {};
  			if (dirty & /*item*/ 1) link_changes.href = /*item*/ ctx[0].url;

  			if (dirty & /*$$scope, item*/ 65) {
  				link_changes.$$scope = { dirty, ctx };
  			}

  			link.$set(link_changes);
  			if ((!current || dirty & /*item*/ 1) && t4_value !== (t4_value = pluralize$1(/*item*/ ctx[0].points, "point") + "")) set_data_dev(t4, t4_value);
  			if ((!current || dirty & /*item*/ 1) && t6_value !== (t6_value = /*item*/ ctx[0].user + "")) set_data_dev(t6, t6_value);
  			if ((!current || dirty & /*item*/ 1) && t8_value !== (t8_value = /*item*/ ctx[0].time_ago + "")) set_data_dev(t8, t8_value);
  			let previous_block_index = current_block_type_index;
  			current_block_type_index = select_block_type(ctx);

  			if (current_block_type_index === previous_block_index) {
  				if_blocks[current_block_type_index].p(ctx, dirty);
  			} else {
  				group_outros();

  				transition_out(if_blocks[previous_block_index], 1, 1, () => {
  					if_blocks[previous_block_index] = null;
  				});

  				check_outros();
  				if_block = if_blocks[current_block_type_index];

  				if (!if_block) {
  					if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  					if_block.c();
  				}

  				transition_in(if_block, 1);
  				if_block.m(if_block_anchor.parentNode, if_block_anchor);
  			}
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(navbar.$$.fragment, local);
  			transition_in(link.$$.fragment, local);
  			transition_in(if_block);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(navbar.$$.fragment, local);
  			transition_out(link.$$.fragment, local);
  			transition_out(if_block);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(navbar, detaching);
  			if (detaching) detach_dev(t0);
  			if (detaching) detach_dev(p0);
  			if (detaching) detach_dev(t2);
  			destroy_component(link, detaching);
  			if (detaching) detach_dev(t3);
  			if (detaching) detach_dev(p1);
  			if (detaching) detach_dev(t9);
  			if_blocks[current_block_type_index].d(detaching);
  			if (detaching) detach_dev(if_block_anchor);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$6.name,
  		type: "slot",
  		source: "(1:0) <Page name=\\\"story\\\">",
  		ctx
  	});

  	return block;
  }

  function create_fragment$n(ctx) {
  	let current;

  	const page = new Page({
  			props: {
  				name: "story",
  				$$slots: { default: [create_default_slot$6] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(page.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(page, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const page_changes = {};

  			if (dirty & /*$$scope, comments, item*/ 67) {
  				page_changes.$$scope = { dirty, ctx };
  			}

  			page.$set(page_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(page.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(page.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(page, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$n.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function pluralize$1(prop, text) {
  	return `${prop} ${prop < 2 ? text : text + "s"}`;
  }

  function instance$m($$self, $$props, $$invalidate) {
  	let { item } = $$props;
  	let comments;

  	async function getStory(id) {
  		const res = await fetch(`https://node-hnapi.herokuapp.com/item/${id}`);
  		const data = await res.json();
  		$$invalidate(1, comments = comments ? [] : data.comments);
  	}

  	const writable_props = ["item"];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<Story> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("Story", $$slots, []);

  	$$self.$set = $$props => {
  		if ("item" in $$props) $$invalidate(0, item = $$props.item);
  	};

  	$$self.$capture_state = () => ({
  		Page,
  		Navbar: Navbar$2,
  		Link,
  		Block,
  		BlockHeader: Block_header,
  		Preloader: Preloader$2,
  		Comment,
  		item,
  		comments,
  		getStory,
  		pluralize: pluralize$1
  	});

  	$$self.$inject_state = $$props => {
  		if ("item" in $$props) $$invalidate(0, item = $$props.item);
  		if ("comments" in $$props) $$invalidate(1, comments = $$props.comments);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	$$self.$$.update = () => {
  		if ($$self.$$.dirty & /*item*/ 1) {
  			 getStory(item.id);
  		}
  	};

  	return [item, comments];
  }

  class Story extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$m, create_fragment$n, safe_not_equal, { item: 0 });

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "Story",
  			options,
  			id: create_fragment$n.name
  		});

  		const { ctx } = this.$$;
  		const props = options.props || {};

  		if (/*item*/ ctx[0] === undefined && !("item" in props)) {
  			console.warn("<Story> was created without expected prop 'item'");
  		}
  	}

  	get item() {
  		throw new Error("<Story>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}

  	set item(value) {
  		throw new Error("<Story>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  	}
  }

  var routes = [
    {
      path: '/',
      component: Stories,
    },
    {
      path: '/item/:id',
      component: Story
    }
  ];

  /* src/App.svelte generated by Svelte v3.21.0 */

  // (1:0) <App params={ f7params }>
  function create_default_slot$7(ctx) {
  	let current;

  	const view = new View$2({
  			props: {
  				main: true,
  				class: "safe-areas",
  				url: "/"
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(view.$$.fragment);
  		},
  		m: function mount(target, anchor) {
  			mount_component(view, target, anchor);
  			current = true;
  		},
  		p: noop,
  		i: function intro(local) {
  			if (current) return;
  			transition_in(view.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(view.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(view, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_default_slot$7.name,
  		type: "slot",
  		source: "(1:0) <App params={ f7params }>",
  		ctx
  	});

  	return block;
  }

  function create_fragment$o(ctx) {
  	let current;

  	const app = new App({
  			props: {
  				params: /*f7params*/ ctx[0],
  				$$slots: { default: [create_default_slot$7] },
  				$$scope: { ctx }
  			},
  			$$inline: true
  		});

  	const block = {
  		c: function create() {
  			create_component(app.$$.fragment);
  		},
  		l: function claim(nodes) {
  			throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
  		},
  		m: function mount(target, anchor) {
  			mount_component(app, target, anchor);
  			current = true;
  		},
  		p: function update(ctx, [dirty]) {
  			const app_changes = {};

  			if (dirty & /*$$scope*/ 2) {
  				app_changes.$$scope = { dirty, ctx };
  			}

  			app.$set(app_changes);
  		},
  		i: function intro(local) {
  			if (current) return;
  			transition_in(app.$$.fragment, local);
  			current = true;
  		},
  		o: function outro(local) {
  			transition_out(app.$$.fragment, local);
  			current = false;
  		},
  		d: function destroy(detaching) {
  			destroy_component(app, detaching);
  		}
  	};

  	dispatch_dev("SvelteRegisterBlock", {
  		block,
  		id: create_fragment$o.name,
  		type: "component",
  		source: "",
  		ctx
  	});

  	return block;
  }

  function instance$n($$self, $$props, $$invalidate) {
  	let f7params = {
  		name: "stock", // App name
  		theme: "auto", // Automatic theme detection
  		autoDarkTheme: true, // Automatic Dark Theme
  		routes, // App routes
  		
  	};

  	if (window.navigator.standalone) {
  		document.body.classList.add("standalone");
  	}

  	const writable_props = [];

  	Object.keys($$props).forEach(key => {
  		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$") console.warn(`<App> was created with unknown prop '${key}'`);
  	});

  	let { $$slots = {}, $$scope } = $$props;
  	validate_slots("App", $$slots, []);
  	$$self.$capture_state = () => ({ App, View: View$2, routes, f7params });

  	$$self.$inject_state = $$props => {
  		if ("f7params" in $$props) $$invalidate(0, f7params = $$props.f7params);
  	};

  	if ($$props && "$$inject" in $$props) {
  		$$self.$inject_state($$props.$$inject);
  	}

  	return [f7params];
  }

  class App_1 extends SvelteComponentDev {
  	constructor(options) {
  		super(options);
  		init(this, options, instance$n, create_fragment$o, safe_not_equal, {});

  		dispatch_dev("SvelteRegisterComponent", {
  			component: this,
  			tagName: "App_1",
  			options,
  			id: create_fragment$o.name
  		});
  	}
  }

  // Import Framework7

  // Init F7 Svelte Plugin
  Framework7.use(Plugin);

  var app = new App_1({
  	target: document.body
  });

  return app;

}());
//# sourceMappingURL=bundle.js.map
